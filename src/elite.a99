       copy "equates.a99"                                  ; 
       copy "macros.a99"                                   ; 
* ******************************************************************************
* 
* ELITE GAME SOURCE
* 
* Elite was written by Ian Bell and David Braben and is copyright Acornsoft 1984
* 
* The code on this site is identical to the source discs released on Ian Bell's
* personal website at http://www.elitehomepage.org/ (it's just been reformatted
* to be more readable)
* 
* The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
* in the documentation are entirely my fault
* 
* The terminology and notations used in this commentary are explained at
* https://elite.bbcelite.com/terminology
* 
* The deep dive articles referred to in this commentary can be found at
* https://elite.bbcelite.com/deep_dives
* 
* ------------------------------------------------------------------------------
* 
* This source file produces the following binary files:
* 
* * ELTA.bin
* * ELTB.bin
* * ELTC.bin
* * ELTD.bin
* * ELTE.bin
* * ELTF.bin
* * ELTG.bin
* * PYTHON.bin
* * SHIPS.bin
* * WORDS9.bin
* 
* ******************************************************************************




* ******************************************************************************
* 
* Configuration variables
* 
* ******************************************************************************

ZERO_PAGE.:
       equ >0000

STACK.:
       equ >0100

CODE.:                                                     ; The address where the code will be run
       equ >0F40

LOAD.:                                                     ; The address where the code will be loaded
       equ >1128

T.:                                                        ; Current commander data and stardust data blocks
       equ >0300

CODE_WORDS.:                                               ; The address where the text data will be run
       equ >0400

LOAD_WORDS.:                                               ; The address where the text data will be loaded
       equ >1100

Q.:                                                        ; Set Q% to TRUE to max out the default commander, FALSE
       equ _MAX_COMMANDER
                                                           ; for the standard default commander

NOST:                                                      ; The number of stardust particles in normal space (this
       equ 18
                                                           ; goes down to 3 in witchspace)

NOSH:                                                      ; The maximum number of ships in our local bubble of
       equ 12
                                                           ; universe

NTY:                                                       ; The number of different ship types
       equ 13

COPS:                                                      ; Ship type for a Viper
       equ 2

THG:                                                       ; Ship type for a Thargoid
       equ 6

CYL:                                                       ; Ship type for a Cobra Mk III (trader)
       equ 7

SST:                                                       ; Ship type for the space station
       equ 8

MSL:                                                       ; Ship type for a missile
       equ 9

AST:                                                       ; Ship type for an asteroid
       equ 10

OIL:                                                       ; Ship type for a cargo canister
       equ 11

TGL:                                                       ; Ship type for a Thargon
       equ 12

ESC:                                                       ; Ship type for an escape pod
       equ 13

POW:                                                       ; Pulse laser power
       equ 15

NI.:                                                       ; The number of bytes in each ship's data block (as
       equ 36
                                                           ; stored in INWK and K%)

VSCAN:                                                     ; Defines the split position in the split-screen mode
       equ 57

X:                                                         ; The centre x-coordinate of the 256 x 192 space view
       equ 128

Y:                                                         ; The centre y-coordinate of the 256 x 192 space view
       equ 96

f0_:                                                       ; Internal key number for red key f0 (Launch, Front)
       equ >20

f1_:                                                       ; Internal key number for red key f1 (Buy Cargo, Rear)
       equ >71

f2_:                                                       ; Internal key number for red key f2 (Sell Cargo, Left)
       equ >72

f3_:                                                       ; Internal key number for red key f3 (Equip Ship, Right)
       equ >73

f4_:                                                       ; Internal key number for red key f4 (Long-range Chart)
       equ >14

f5_:                                                       ; Internal key number for red key f5 (Short-range Chart)
       equ >74

f6_:                                                       ; Internal key number for red key f6 (Data on System)
       equ >75

f7_:                                                       ; Internal key number for red key f7 (Market Price)
       equ >16

f8_:                                                       ; Internal key number for red key f8 (Status Mode)
       equ >76

f9_:                                                       ; Internal key number for red key f9 (Inventory)
       equ >77

RE:                                                        ; The obfuscation byte used to hide the recursive tokens
       equ >23
                                                           ; table from crackers viewing the binary code

VIA:                                                       ; Memory-mapped space for accessing internal hardware,
       equ >FE00
                                                           ; such as the video ULA, 6845 CRTC and 6522 VIAs (also
                                                           ; known as SHEILA)

OSBYTE:                                                    ; The address for the OSBYTE routine, which is used
       equ >FFF4
                                                           ; three times in the main game code

OSWORD:                                                    ; The address for the OSWORD routine, which is used
       equ >FFF1
                                                           ; twice in the main game code

OSFILE:                                                    ; The address for the OSFILE routine, which is used
       equ >FFDD
                                                           ; once in the main game code

* ******************************************************************************
* 
* Name: ZP
* Type: Workspace
* Address: &0000 to &00B0
* Category: Workspaces
* Summary: Lots of important variables are stored in the zero page workspace
* as it is quicker and more space-efficient to access memory here
* 
* ******************************************************************************

       aorg ZERO_PAGE.

ZP:
       bss 0                                               ; The start of the zero page workspace

RAND:
       bss 4                                               ; Four 8-bit seeds for the random number generation
                                                           ; system implemented in the DORND routine

TRTB.:
       bss 2                                               ; Contains the address of the keyboard translation
                                                           ; table, which is used to translate internal key
                                                           ; numbers to ASCII

T1:
       bss 1                                               ; Temporary storage, used in a number of places

SC:
       bss 1                                               ; Screen address (low byte)
                                                           ; 
                                                           ; Elite draws on-screen by poking bytes directly into
                                                           ; screen memory, and SC(1 0) is typically set to the
                                                           ; address of the character block containing the pixel
                                                           ; we want to draw (see the deep dives on "Drawing
                                                           ; monochrome pixels in mode 4" and "Drawing colour
                                                           ; pixels in mode 5" for more details)

SCH:
       bss 1                                               ; Screen address (high byte)

XX16:
       bss 18                                              ; Temporary storage for a block of values, used in a
                                                           ; number of places

P:
       bss 3                                               ; Temporary storage, used in a number of places

XX0:
       bss 2                                               ; Temporary storage, used to store the address of a ship
                                                           ; blueprint. For example, it is used when we add a new
                                                           ; ship to the local bubble in routine NWSHP, and it
                                                           ; contains the address of the current ship's blueprint
                                                           ; as we loop through all the nearby ships in the main
                                                           ; flight loop

INF:
       bss 2                                               ; Temporary storage, typically used for storing the
                                                           ; address of a ship's data block, so it can be copied
                                                           ; to and from the internal workspace at INWK

V:
       bss 2                                               ; Temporary storage, typically used for storing an
                                                           ; address pointer

XX:
       bss 2                                               ; Temporary storage, typically used for storing a 16-bit
                                                           ; x-coordinate

YY:
       bss 2                                               ; Temporary storage, typically used for storing a 16-bit
                                                           ; y-coordinate

SUNX:
       bss 2                                               ; The 16-bit x-coordinate of the vertical centre axis
                                                           ; of the sun (which might be off-screen)

BETA:
       bss 1                                               ; The current pitch angle beta, which is reduced from
                                                           ; JSTY to a sign-magnitude value between -8 and +8
                                                           ; 
                                                           ; This describes how fast we are pitching our ship, and
                                                           ; determines how fast the universe pitches around us
                                                           ; 
                                                           ; The sign bit is also stored in BET2, while the
                                                           ; opposite sign is stored in BET2+1

BET1:
       bss 1                                               ; The magnitude of the pitch angle beta, i.e. |beta|,
                                                           ; which is a positive value between 0 and 8

XC:
       bss 1                                               ; The x-coordinate of the text cursor (i.e. the text
                                                           ; column), which can be from 0 to 32
                                                           ; 
                                                           ; A value of 0 denotes the leftmost column and 32 the
                                                           ; rightmost column, but because the top part of the
                                                           ; screen (the space view) has a white border that
                                                           ; clashes with columns 0 and 32, text is only shown
                                                           ; in columns 1-31

YC:
       bss 1                                               ; The y-coordinate of the text cursor (i.e. the text
                                                           ; row), which can be from 0 to 23
                                                           ; 
                                                           ; The screen actually has 31 character rows if you
                                                           ; include the dashboard, but the text printing routines
                                                           ; only work on the top part (the space view), so the
                                                           ; text cursor only goes up to a maximum of 23, the row
                                                           ; just before the screen splits
                                                           ; 
                                                           ; A value of 0 denotes the top row, but because the
                                                           ; top part of the screen has a white border that clashes
                                                           ; with row 0, text is always shown at row 1 or greater

QQ22:
       bss 2                                               ; The two hyperspace countdown counters
                                                           ; 
                                                           ; Before a hyperspace jump, both QQ22 and QQ22+1 are
                                                           ; set to 15
                                                           ; 
                                                           ; QQ22 is an internal counter that counts down by 1
                                                           ; each time TT102 is called, which happens every
                                                           ; iteration of the main game loop. When it reaches
                                                           ; zero, the on-screen counter in QQ22+1 gets
                                                           ; decremented, and QQ22 gets set to 5 and the countdown
                                                           ; continues (so the first tick of the hyperspace counter
                                                           ; takes 15 iterations to happen, but subsequent ticks
                                                           ; take 5 iterations each)
                                                           ; 
                                                           ; QQ22+1 contains the number that's shown on-screen
                                                           ; during the countdown. It counts down from 15 to 1, and
                                                           ; when it hits 0, the hyperspace engines kick in

ECMA:
       bss 1                                               ; The E.C.M. countdown timer, which determines whether
                                                           ; an E.C.M. system is currently operating:
                                                           ; 
                                                           ; * 0 = E.C.M. is off
                                                           ; 
                                                           ; * Non-zero = E.C.M. is on and is counting down
                                                           ; 
                                                           ; The counter starts at 32 when an E.C.M. is activated,
                                                           ; either by us or by an opponent, and it decreases by 1
                                                           ; in each iteration of the main flight loop until it
                                                           ; reaches zero, at which point the E.C.M. switches off.
                                                           ; Only one E.C.M. can be active at any one time, so
                                                           ; there is only one counter

XX15:
       bss 0                                               ; Temporary storage, typically used for storing screen
                                                           ; coordinates in line-drawing routines
                                                           ; 
                                                           ; There are six bytes of storage, from XX15 TO XX15+5.
                                                           ; The first four bytes have the following aliases:
                                                           ; 
                                                           ; X1 = XX15
                                                           ; Y1 = XX15+1
                                                           ; X2 = XX15+2
                                                           ; Y2 = XX15+3
                                                           ; 
                                                           ; These are typically used for describing lines in terms
                                                           ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
                                                           ; 
                                                           ; The last two bytes of XX15 do not have aliases

X1:
       bss 1                                               ; Temporary storage, typically used for x-coordinates in
                                                           ; line-drawing routines

Y1:
       bss 1                                               ; Temporary storage, typically used for y-coordinates in
                                                           ; line-drawing routines

X2:
       bss 1                                               ; Temporary storage, typically used for x-coordinates in
                                                           ; line-drawing routines

Y2:
       bss 1                                               ; Temporary storage, typically used for y-coordinates in
                                                           ; line-drawing routines

       bss 2                                               ; The last two bytes of the XX15 block

XX12:
       bss 6                                               ; Temporary storage for a block of values, used in a
                                                           ; number of places

K:
       bss 4                                               ; Temporary storage, used in a number of places

KL:
       bss 1                                               ; The following bytes implement a key logger that
                                                           ; enables Elite to scan for concurrent key presses of
                                                           ; the primary flight keys, plus a secondary flight key
                                                           ; 
                                                           ; See the deep dive on "The key logger" for more details
                                                           ; 
                                                           ; If a key is being pressed that is not in the keyboard
                                                           ; table at KYTB, it can be stored here (as seen in
                                                           ; routine DK4, for example)

KY1:
       bss 1                                               ; "?" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY2:
       bss 1                                               ; Space is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY3:
       bss 1                                               ; "<" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY4:
       bss 1                                               ; ">" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY5:
       bss 1                                               ; "X" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY6:
       bss 1                                               ; "S" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY7:
       bss 1                                               ; "A" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes
                                                           ; 
                                                           ; This is also set when the joystick fire button has
                                                           ; been pressed

KY12:
       bss 1                                               ; TAB is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY13:
       bss 1                                               ; ESCAPE is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY14:
       bss 1                                               ; "T" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY15:
       bss 1                                               ; "U" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY16:
       bss 1                                               ; "M" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY17:
       bss 1                                               ; "E" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY18:
       bss 1                                               ; "J" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

KY19:
       bss 1                                               ; "C" is being pressed
                                                           ; 
                                                           ; * 0 = no
                                                           ; 
                                                           ; * Non-zero = yes

LAS:
       bss 1                                               ; Contains the laser power of the laser fitted to the
                                                           ; current space view (or 0 if there is no laser fitted
                                                           ; to the current view)
                                                           ; 
                                                           ; This gets set to bits 0-6 of the laser power byte from
                                                           ; the commander data block, which contains the laser's
                                                           ; power (bit 7 doesn't denote laser power, just whether
                                                           ; or not the laser pulses, so that is not stored here)

MSTG:
       bss 1                                               ; The current missile lock target
                                                           ; 
                                                           ; * &FF = no target
                                                           ; 
                                                           ; * 1-12 = the slot number of the ship that our
                                                           ; missile is locked onto

XX1:
       bss 0                                               ; This is an alias for INWK that is used in the main
                                                           ; ship-drawing routine at LL9

INWK:
       bss 33                                              ; The zero-page internal workspace for the current ship
                                                           ; data block
                                                           ; 
                                                           ; As operations on zero page locations are faster and
                                                           ; have smaller opcodes than operations on the rest of
                                                           ; the addressable memory, Elite tends to store oft-used
                                                           ; data here. A lot of the routines in Elite need to
                                                           ; access and manipulate ship data, so to make this an
                                                           ; efficient exercise, the ship data is first copied from
                                                           ; the ship data blocks at K% into INWK (or, when new
                                                           ; ships are spawned, from the blueprints at XX21). See
                                                           ; the deep dive on "Ship data blocks" for details of
                                                           ; what each of the bytes in the INWK data block
                                                           ; represents

XX19:
       bss NI. - 33                                        ; XX19(1 0) shares its location with INWK(34 33), which
                                                           ; contains the address of the ship line heap

LSP:
       bss 1                                               ; The ball line heap pointer, which contains the number
                                                           ; of the first free byte after the end of the LSX2 and
                                                           ; LSY2 heaps (see the deep dive on "The ball line heap"
                                                           ; for details)

QQ15:
       bss 6                                               ; The three 16-bit seeds for the selected system, i.e.
                                                           ; the one in the crosshairs in the Short-range Chart
                                                           ; 
                                                           ; See the deep dives on "Galaxy and system seeds" and
                                                           ; "Twisting the system seeds" for more details

K5:
       bss 0                                               ; Temporary storage used to store segment coordinates
                                                           ; across successive calls to BLINE, the ball line
                                                           ; routine

XX18:
       bss 0                                               ; Temporary storage used to store coordinates in the
                                                           ; LL9 ship-drawing routine

QQ17:
       bss 1                                               ; Contains a number of flags that affect how text tokens
                                                           ; are printed, particularly capitalisation:
                                                           ; 
                                                           ; * If all bits are set (255) then text printing is
                                                           ; disabled
                                                           ; 
                                                           ; * Bit 7: 0 = ALL CAPS
                                                           ; 1 = Sentence Case, bit 6 determines the
                                                           ; case of the next letter to print
                                                           ; 
                                                           ; * Bit 6: 0 = print the next letter in upper case
                                                           ; 1 = print the next letter in lower case
                                                           ; 
                                                           ; * Bits 0-5: If any of bits 0-5 are set, print in
                                                           ; lower case
                                                           ; 
                                                           ; So:
                                                           ; 
                                                           ; * QQ17 = 0 means case is set to ALL CAPS
                                                           ; 
                                                           ; * QQ17 = %10000000 means Sentence Case, currently
                                                           ; printing upper case
                                                           ; 
                                                           ; * QQ17 = %11000000 means Sentence Case, currently
                                                           ; printing lower case
                                                           ; 
                                                           ; * QQ17 = %11111111 means printing is disabled

QQ19:
       bss 3                                               ; Temporary storage, used in a number of places

K6:
       bss 5                                               ; Temporary storage, typically used for storing
                                                           ; coordinates during vector calculations

ALP1:
       bss 1                                               ; Magnitude of the roll angle alpha, i.e. |alpha|,
                                                           ; which is a positive value between 0 and 31

ALP2:
       bss 2                                               ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
                                                           ; 
                                                           ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA

BET2:
       bss 2                                               ; Bit 7 of BET2 = sign of the pitch angle in BETA
                                                           ; 
                                                           ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA

DELTA:
       bss 1                                               ; Our current speed, in the range 1-40

DELT4:
       bss 2                                               ; Our current speed * 64 as a 16-bit value
                                                           ; 
                                                           ; This is stored as DELT4(1 0), so the high byte in
                                                           ; DELT4+1 therefore contains our current speed / 4

U:
       bss 1                                               ; Temporary storage, used in a number of places

Q:
       bss 1                                               ; Temporary storage, used in a number of places

R:
       bss 1                                               ; Temporary storage, used in a number of places

S:
       bss 1                                               ; Temporary storage, used in a number of places

XSAV:
       bss 1                                               ; Temporary storage for saving the value of the X
                                                           ; register, used in a number of places

YSAV:
       bss 1                                               ; Temporary storage for saving the value of the Y
                                                           ; register, used in a number of places

XX17:
       bss 1                                               ; Temporary storage, used in BPRNT to store the number
                                                           ; of characters to print, and as the edge counter in the
                                                           ; main ship-drawing routine

QQ11:
       bss 1                                               ; The type of the current view:
                                                           ; 
                                                           ; 0   = Space view
                                                           ; 1   = Title screen
                                                           ; Get commander name ("@", save/load commander)
                                                           ; In-system jump just arrived ("J")
                                                           ; Data on System screen (red key f6)
                                                           ; Buy Cargo screen (red key f1)
                                                           ; Mis-jump just arrived (witchspace)
                                                           ; 4   = Sell Cargo screen (red key f2)
                                                           ; 6   = Death screen
                                                           ; 8   = Status Mode screen (red key f8)
                                                           ; Inventory screen (red key f9)
                                                           ; 16  = Market Price screen (red key f7)
                                                           ; 32  = Equip Ship screen (red key f3)
                                                           ; 64  = Long-range Chart (red key f4)
                                                           ; 128 = Short-range Chart (red key f5)
                                                           ; 
                                                           ; This value is typically set by calling routine TT66

ZZ:
       bss 1                                               ; Temporary storage, typically used for distance values

XX13:
       bss 1                                               ; Temporary storage, typically used in the line-drawing
                                                           ; routines

MCNT:
       bss 1                                               ; The main loop counter
                                                           ; 
                                                           ; This counter determines how often certain actions are
                                                           ; performed within the main loop. See the deep dive on
                                                           ; "Scheduling tasks with the main loop counter" for more
                                                           ; details

DL:
       bss 1                                               ; Vertical sync flag
                                                           ; 
                                                           ; DL gets set to 30 every time we reach vertical sync on
                                                           ; the video system, which happens 50 times a second
                                                           ; (50Hz). The WSCAN routine uses this to pause until the
                                                           ; vertical sync, by setting DL to 0 and then monitoring
                                                           ; its value until it changes to 30

TYPE:
       bss 1                                               ; The current ship type
                                                           ; 
                                                           ; This is where we store the current ship type for when
                                                           ; we are iterating through the ships in the local bubble
                                                           ; as part of the main flight loop. See the table at XX21
                                                           ; for information about ship types

JSTX:
       bss 1                                               ; Our current roll rate
                                                           ; 
                                                           ; This value is shown in the dashboard's RL indicator,
                                                           ; and determines the rate at which we are rolling
                                                           ; 
                                                           ; The value ranges from 1 to 255 with 128 as the centre
                                                           ; point, so 1 means roll is decreasing at the maximum
                                                           ; rate, 128 means roll is not changing, and 255 means
                                                           ; roll is increasing at the maximum rate
                                                           ; 
                                                           ; This value is updated by "<" and ">" key presses, or
                                                           ; if joysticks are enabled, from the joystick. If
                                                           ; keyboard damping is enabled (which it is by default),
                                                           ; the value is slowly moved towards the centre value of
                                                           ; 128 (no roll) if there are no key presses or joystick
                                                           ; movement

JSTY:
       bss 1                                               ; Our current pitch rate
                                                           ; 
                                                           ; This value is shown in the dashboard's DC indicator,
                                                           ; and determines the rate at which we are pitching
                                                           ; 
                                                           ; The value ranges from 1 to 255 with 128 as the centre
                                                           ; point, so 1 means pitch is decreasing at the maximum
                                                           ; rate, 128 means pitch is not changing, and 255 means
                                                           ; pitch is increasing at the maximum rate
                                                           ; 
                                                           ; This value is updated by "S" and "X" key presses, or
                                                           ; if joysticks are enabled, from the joystick. If
                                                           ; keyboard damping is enabled (which it is by default),
                                                           ; the value is slowly moved towards the centre value of
                                                           ; 128 (no pitch) if there are no key presses or joystick
                                                           ; movement

ALPHA:
       bss 1                                               ; The current roll angle alpha, which is reduced from
                                                           ; JSTX to a sign-magnitude value between -31 and +31
                                                           ; 
                                                           ; This describes how fast we are rolling our ship, and
                                                           ; determines how fast the universe rolls around us
                                                           ; 
                                                           ; The sign bit is also stored in ALP2, while the
                                                           ; opposite sign is stored in ALP2+1

QQ12:
       bss 1                                               ; Our "docked" status
                                                           ; 
                                                           ; * 0 = we are not docked
                                                           ; 
                                                           ; * &FF = we are docked

TGT:
       bss 1                                               ; Temporary storage, typically used as a target value
                                                           ; for counters when drawing explosion clouds and partial
                                                           ; circles

SWAP:
       bss 1                                               ; Temporary storage, used to store a flag that records
                                                           ; whether or not we had to swap a line's start and end
                                                           ; coordinates around when clipping the line in routine
                                                           ; LL145 (the flag is used in places like BLINE to swap
                                                           ; them back)

COL:
       bss 1                                               ; Temporary storage, used to store colour information
                                                           ; when drawing pixels in the dashboard

FLAG:
       bss 1                                               ; A flag that's used to define whether this is the first
                                                           ; call to the ball line routine in BLINE, so it knows
                                                           ; whether to wait for the second call before storing
                                                           ; segment data in the ball line heap

CNT:
       bss 1                                               ; Temporary storage, typically used for storing the
                                                           ; number of iterations required when looping

CNT2:
       bss 1                                               ; Temporary storage, used in the planet-drawing routine
                                                           ; to store the segment number where the arc of a partial
                                                           ; circle should start

STP:
       bss 1                                               ; The step size for drawing circles
                                                           ; 
                                                           ; Circles in Elite are split up into 64 points, and the
                                                           ; step size determines how many points to skip with each
                                                           ; straight-line segment, so the smaller the step size,
                                                           ; the smoother the circle. The values used are:
                                                           ; 
                                                           ; * 2 for big planets and the circles on the charts
                                                           ; * 4 for medium planets and the launch tunnel
                                                           ; * 8 for small planets and the hyperspace tunnel
                                                           ; 
                                                           ; As the step size increases we move from smoother
                                                           ; circles at the top to more polygonal at the bottom.
                                                           ; See the CIRCLE2 routine for more details

XX4:
       bss 1                                               ; Temporary storage, used in a number of places

XX20:
       bss 1                                               ; Temporary storage, used in a number of places

XX14:
       bss 1                                               ; This byte appears to be unused

RAT:
       bss 1                                               ; Used to store different signs depending on the current
                                                           ; space view, for use in calculating stardust movement

RAT2:
       bss 1                                               ; Temporary storage, used to store the pitch and roll
                                                           ; signs when moving objects and stardust

K2:
       bss 4                                               ; Temporary storage, used in a number of places

* RM: At &00B0 = 176

       aorg >00D1

T:
       bss 1                                               ; Temporary storage, used in a number of places

K3:
       bss 0                                               ; Temporary storage, used in a number of places

XX2:
       bss 14                                              ; Temporary storage, used to store the visibility of the
                                                           ; ship's faces during the ship-drawing routine at LL9

K4:
       bss 2                                               ; Temporary storage, used in a number of places


* ******************************************************************************
* 
* Name: XX3
* Type: Workspace
* Address: &0100 to the top of the descending stack
* Category: Workspaces
* Summary: Temporary storage space for complex calculations
* 
* ------------------------------------------------------------------------------
* 
* Used as heap space for storing temporary data during calculations. Shared with
* the descending 6502 stack, which works down from &01FF.
* 
* ******************************************************************************

       aorg STACK.

XX3:
       bss 256                                             ; Temporary storage, typically used for storing tables
                                                           ; of values such as screen coordinates or ship data

* ******************************************************************************
* 
* Name: T%
* Type: Workspace
* Address: &0300 to &035F
* Category: Workspaces
* Summary: Current commander data and stardust data blocks
* 
* ------------------------------------------------------------------------------
* 
* Contains the current commander data (NT% bytes at location TP), and the
* stardust data blocks (NOST bytes at location SX)
* 
* ******************************************************************************

       aorg T.

       bss 0                                               ; The start of the T% workspace

TP:
       bss 1                                               ; The current mission status, which is always 0 for the
                                                           ; cassette version of Elite as there are no missions

QQ0:
       bss 1                                               ; The current system's galactic x-coordinate (0-256)

QQ1:
       bss 1                                               ; The current system's galactic y-coordinate (0-256)

QQ21:
       bss 6                                               ; The three 16-bit seeds for the current galaxy
                                                           ; 
                                                           ; These seeds define system 0 in the current galaxy, so
                                                           ; they can be used as a starting point to generate all
                                                           ; 256 systems in the galaxy
                                                           ; 
                                                           ; Using a galactic hyperdrive rotates each byte to the
                                                           ; left (rolling each byte within itself) to get the
                                                           ; seeds for the next galaxy, so after eight galactic
                                                           ; jumps, the seeds roll around to the first galaxy again
                                                           ; 
                                                           ; See the deep dives on "Galaxy and system seeds" and
                                                           ; "Twisting the system seeds" for more details

CASH:
       bss 4                                               ; Our current cash pot
                                                           ; 
                                                           ; The cash stash is stored as a 32-bit unsigned integer,
                                                           ; with the most significant byte in CASH and the least
                                                           ; significant in CASH+3. This is big-endian, which is
                                                           ; the opposite way round to most of the numbers used in
                                                           ; Elite - to use our notation for multi-byte numbers,
                                                           ; the amount of cash is CASH(0 1 2 3)

QQ14:
       bss 1                                               ; Our current fuel level (0-70)
                                                           ; 
                                                           ; The fuel level is stored as the number of light years
                                                           ; multiplied by 10, so QQ14 = 1 represents 0.1 light
                                                           ; years, and the maximum possible value is 70, for 7.0
                                                           ; light years

COK:
       bss 1                                               ; Flags used to generate the competition code
                                                           ; 
                                                           ; See the deep dive on "The competition code" for
                                                           ; details of these flags and how they are used in
                                                           ; generating and decoding the competition code

GCNT:
       bss 1                                               ; The number of the current galaxy (0-7)
                                                           ; 
                                                           ; When this is displayed in-game, 1 is added to the
                                                           ; number, so we start in galaxy 1 in-game, but it's
                                                           ; stored as galaxy 0 internally
                                                           ; 
                                                           ; The galaxy number increases by one every time a
                                                           ; galactic hyperdrive is used, and wraps back around to
                                                           ; the start after eight galaxies

LASER:
       bss 4                                               ; The specifications of the lasers fitted to each of the
                                                           ; four space views:
                                                           ; 
                                                           ; * Byte #0 = front view
                                                           ; * Byte #1 = rear view
                                                           ; * Byte #2 = left view
                                                           ; * Byte #3 = right view
                                                           ; 
                                                           ; For each of the views:
                                                           ; 
                                                           ; * 0 = no laser is fitted to this view
                                                           ; 
                                                           ; * Non-zero = a laser is fitted to this view, with
                                                           ; the following specification:
                                                           ; 
                                                           ; * Bits 0-6 contain the laser's power
                                                           ; 
                                                           ; * Bit 7 determines whether or not the laser pulses
                                                           ; (0 = pulse laser) or is always on (1 = beam
                                                           ; laser)

       bss 2                                               ; These bytes appear to be unused (they were originally
                                                           ; used for up/down lasers, but they were dropped)

CRGO:
       bss 1                                               ; Our ship's cargo capacity
                                                           ; 
                                                           ; * 22 = standard cargo bay of 20 tonnes
                                                           ; 
                                                           ; * 37 = large cargo bay of 35 tonnes
                                                           ; 
                                                           ; The value is two greater than the actual capacity to
                                                           ; make the maths in tnpr slightly more efficient

QQ20:
       bss 17                                              ; The contents of our cargo hold
                                                           ; 
                                                           ; The amount of market item X that we have in our hold
                                                           ; can be found in the X-th byte of QQ20. For example:
                                                           ; 
                                                           ; * QQ20 contains the amount of food (item 0)
                                                           ; 
                                                           ; * QQ20+7 contains the amount of computers (item 7)
                                                           ; 
                                                           ; See QQ23 for a list of market item numbers and their
                                                           ; storage units

ECM:
       bss 1                                               ; E.C.M. system
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * &FF = fitted

BST:
       bss 1                                               ; Fuel scoops (BST stands for "barrel status")
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * &FF = fitted

BOMB:
       bss 1                                               ; Energy bomb
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * &7F = fitted

ENGY:
       bss 1                                               ; Energy unit
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * Non-zero = fitted
                                                           ; 
                                                           ; The actual value determines the refresh rate of our
                                                           ; energy banks, as they refresh by ENGY+1 each time (so
                                                           ; our ship's energy level goes up by 2 each time if we
                                                           ; have an energy unit fitted, otherwise it goes up by 1)

DKCMP:
       bss 1                                               ; Docking computer
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * &FF = fitted

GHYP:
       bss 1                                               ; Galactic hyperdrive
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * &FF = fitted

ESCP:
       bss 1                                               ; Escape pod
                                                           ; 
                                                           ; * 0 = not fitted
                                                           ; 
                                                           ; * &FF = fitted

       bss 4                                               ; These bytes appear to be unused

NOMSL:
       bss 1                                               ; The number of missiles we have fitted (0-4)

FIST:
       bss 1                                               ; Our legal status (FIST stands for "fugitive/innocent
                                                           ; status"):
                                                           ; 
                                                           ; * 0 = Clean
                                                           ; 
                                                           ; * 1-49 = Offender
                                                           ; 
                                                           ; * 50+ = Fugitive
                                                           ; 
                                                           ; You get 64 points if you kill a cop, so that's a fast
                                                           ; ticket to fugitive status

AVL:
       bss 17                                              ; Market availability in the current system
                                                           ; 
                                                           ; The available amount of market item X is stored in
                                                           ; the X-th byte of AVL, so for example:
                                                           ; 
                                                           ; * AVL contains the amount of food (item 0)
                                                           ; 
                                                           ; * AVL+7 contains the amount of computers (item 7)
                                                           ; 
                                                           ; See QQ23 for a list of market item numbers and their
                                                           ; storage units, and the deep dive on "Market item
                                                           ; prices and availability" for details of the algorithm
                                                           ; used for calculating each item's availability

QQ26:
       bss 1                                               ; A random value used to randomise market data
                                                           ; 
                                                           ; This value is set to a new random number for each
                                                           ; change of system, so we can add a random factor into
                                                           ; the calculations for market prices (for details of how
                                                           ; this is used, see the deep dive on "Market prices")

TALLY:
       bss 2                                               ; Our combat rank
                                                           ; 
                                                           ; The combat rank is stored as the number of kills, in a
                                                           ; 16-bit number TALLY(1 0) - so the high byte is in
                                                           ; TALLY+1 and the low byte in TALLY
                                                           ; 
                                                           ; If the high byte in TALLY+1 is 0 then we have between
                                                           ; 0 and 255 kills, so our rank is Harmless, Mostly
                                                           ; Harmless, Poor, Average or Above Average, according to
                                                           ; the value of the low byte in TALLY:
                                                           ; 
                                                           ; Harmless        = %00000000 to %00000011 = 0 to 3
                                                           ; Mostly Harmless = %00000100 to %00000111 = 4 to 7
                                                           ; Poor            = %00001000 to %00001111 = 8 to 15
                                                           ; Average         = %00010000 to %00011111 = 16 to 31
                                                           ; Above Average   = %00100000 to %11111111 = 32 to 255
                                                           ; 
                                                           ; If the high byte in TALLY+1 is non-zero then we are
                                                           ; Competent, Dangerous, Deadly or Elite, according to
                                                           ; the high byte in TALLY+1:
                                                           ; 
                                                           ; Competent       = 1           = 256 to 511 kills
                                                           ; Dangerous       = 2 to 9      = 512 to 2559 kills
                                                           ; Deadly          = 10 to 24    = 2560 to 6399 kills
                                                           ; Elite           = 25 and up   = 6400 kills and up
                                                           ; 
                                                           ; You can see the rating calculation in the STATUS
                                                           ; subroutine

SVC:
       bss 1                                               ; The save count
                                                           ; 
                                                           ; When a new commander is created, the save count gets
                                                           ; set to 128. This value gets halved each time the
                                                           ; commander file is saved, but it is otherwise unused.
                                                           ; It is presumably part of the security system for the
                                                           ; competition, possibly another flag to catch out
                                                           ; entries with manually altered commander files

       bss 2                                               ; The commander file checksum
                                                           ; 
                                                           ; These two bytes are reserved for the commander file
                                                           ; checksum, so when the current commander block is
                                                           ; copied from here to the last saved commander block at
                                                           ; NA%, CHK and CHK2 get overwritten

NT.:                                                       ; This sets the variable NT% to the size of the current
       equ SVC + 2 - TP
                                                           ; commander data block, which starts at TP and ends at
                                                           ; SVC+2 (inclusive)

SX:
       bss NOST + 1                                        ; This is where we store the x_hi coordinates for all
                                                           ; the stardust particles

SXL:
       bss NOST + 1                                        ; This is where we store the x_lo coordinates for all
                                                           ; the stardust particles


* ******************************************************************************
* 
* ELITE RECURSIVE TEXT TOKEN FILE
* 
* Produces the binary file WORDS9.bin that gets loaded by elite-loader.asm.
* 
* The recursive token table is loaded at &1100 and is moved down to &0400 as
* part of elite-loader.asm, so it ends up at &0400 to &07FF.
* 
* ******************************************************************************

       aorg CODE_WORDS.

* ******************************************************************************
* 
* Name: CHAR
* Type: Macro
* Category: Text
* Summary: Macro definition for characters in the recursive token table
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used when building the recursive token table:
* 
* CHAR 'x'            Insert ASCII character "x"
* 
* To include an apostrophe, use a backtick character, as in CHAR '`'.
* 
* See the deep dive on "Printing text tokens" for details on how characters are
* stored in the recursive token table.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* 'x'                 The character to insert into the table
* 
* ******************************************************************************

       ; CHAR x

       ; IF x = '`'                    ;                   
       ; EQUB 39 EOR RE                ;                   
       ; ELSE                          ;                   
       ; EQUB x EOR RE                 ;                   
       ; ENDIF                         ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: TWOK
* Type: Macro
* Category: Text
* Summary: Macro definition for two-letter tokens in the token table
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used when building the recursive token table:
* 
* TWOK 'x', 'y'       Insert two-letter token "xy"
* 
* See the deep dive on "Printing text tokens" for details on how two-letter
* tokens are stored in the recursive token table.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* 'x'                 The first letter of the two-letter token to insert into
* the table
* 
* 'y'                 The second letter of the two-letter token to insert into
* the table
* 
* ******************************************************************************

       ; TWOK t, k

       ; IF t = 'A' AND k = 'L' : EQUB 128 EOR RE : ENDIF ;                   
       ; IF t = 'L' AND k = 'E' : EQUB 129 EOR RE : ENDIF ;                   
       ; IF t = 'X' AND k = 'E' : EQUB 130 EOR RE : ENDIF ;                   
       ; IF t = 'G' AND k = 'E' : EQUB 131 EOR RE : ENDIF ;                   
       ; IF t = 'Z' AND k = 'A' : EQUB 132 EOR RE : ENDIF ;                   
       ; IF t = 'C' AND k = 'E' : EQUB 133 EOR RE : ENDIF ;                   
       ; IF t = 'B' AND k = 'I' : EQUB 134 EOR RE : ENDIF ;                   
       ; IF t = 'S' AND k = 'O' : EQUB 135 EOR RE : ENDIF ;                   
       ; IF t = 'U' AND k = 'S' : EQUB 136 EOR RE : ENDIF ;                   
       ; IF t = 'E' AND k = 'S' : EQUB 137 EOR RE : ENDIF ;                   
       ; IF t = 'A' AND k = 'R' : EQUB 138 EOR RE : ENDIF ;                   
       ; IF t = 'M' AND k = 'A' : EQUB 139 EOR RE : ENDIF ;                   
       ; IF t = 'I' AND k = 'N' : EQUB 140 EOR RE : ENDIF ;                   
       ; IF t = 'D' AND k = 'I' : EQUB 141 EOR RE : ENDIF ;                   
       ; IF t = 'R' AND k = 'E' : EQUB 142 EOR RE : ENDIF ;                   
       ; IF t = 'A' AND k = '?' : EQUB 143 EOR RE : ENDIF ;                   
       ; IF t = 'E' AND k = 'R' : EQUB 144 EOR RE : ENDIF ;                   
       ; IF t = 'A' AND k = 'T' : EQUB 145 EOR RE : ENDIF ;                   
       ; IF t = 'E' AND k = 'N' : EQUB 146 EOR RE : ENDIF ;                   
       ; IF t = 'B' AND k = 'E' : EQUB 147 EOR RE : ENDIF ;                   
       ; IF t = 'R' AND k = 'A' : EQUB 148 EOR RE : ENDIF ;                   
       ; IF t = 'L' AND k = 'A' : EQUB 149 EOR RE : ENDIF ;                   
       ; IF t = 'V' AND k = 'E' : EQUB 150 EOR RE : ENDIF ;                   
       ; IF t = 'T' AND k = 'I' : EQUB 151 EOR RE : ENDIF ;                   
       ; IF t = 'E' AND k = 'D' : EQUB 152 EOR RE : ENDIF ;                   
       ; IF t = 'O' AND k = 'R' : EQUB 153 EOR RE : ENDIF ;                   
       ; IF t = 'Q' AND k = 'U' : EQUB 154 EOR RE : ENDIF ;                   
       ; IF t = 'A' AND k = 'N' : EQUB 155 EOR RE : ENDIF ;                   
       ; IF t = 'T' AND k = 'E' : EQUB 156 EOR RE : ENDIF ;                   
       ; IF t = 'I' AND k = 'S' : EQUB 157 EOR RE : ENDIF ;                   
       ; IF t = 'R' AND k = 'I' : EQUB 158 EOR RE : ENDIF ;                   
       ; IF t = 'O' AND k = 'N' : EQUB 159 EOR RE : ENDIF ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: CONT
* Type: Macro
* Category: Text
* Summary: Macro definition for control codes in the recursive token table
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used when building the recursive token table:
* 
* CONT n              Insert control code token {n}
* 
* See the deep dive on "Printing text tokens" for details on how characters are
* stored in the recursive token table.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* n                   The control code to insert into the table
* 
* ******************************************************************************

       ; CONT n

       ; EQUB n EOR RE                 ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: RTOK
* Type: Macro
* Category: Text
* Summary: Macro definition for recursive tokens in the recursive token table
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used when building the recursive token table:
* 
* RTOK n              Insert recursive token [n]
* 
* * Tokens 0-95 get stored as n + 160
* 
* * Tokens 128-145 get stored as n - 114
* 
* * Tokens 96-127 get stored as n
* 
* See the deep dive on "Printing text tokens" for details on how recursive
* tokens are stored in the recursive token table.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* n                   The number of the recursive token to insert into the
* table, in the range 0 to 145
* 
* ******************************************************************************

       ; RTOK n

       ; IF n >= 0 AND n <= 95         ;                   
       ; t = n + 160                   ;                   
       ; ELIF n >= 128                 ;                   
       ; t = n - 114                   ;                   
       ; ELSE                          ;                   
       ; t = n                         ;                   
       ; ENDIF                         ;                   

       ; EQUB t EOR RE                 ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: QQ18
* Type: Variable
* Category: Text
* Summary: The recursive token table for tokens 0-148
* Deep dive: Printing text tokens
* 
* ******************************************************************************

QQ18:
       .rtok 111                                           ; Token 0:      "FUEL SCOOPS ON {beep}"
       .rtok 131                                           ; 
       .cont 7                                             ; Encoded as:   "[111][131]{7}"
       byte >00

       .char ' '                                           ; Token 1:      " CHART"
       .char 'c'                                           ; 
       .char 'h'                                           ; Encoded as:   " CH<138>T"
       .twok 'a', 'r'
       .char 't'
       byte >00

       .char 'g'                                           ; Token 2:      "GOVERNMENT"
       .char 'o'                                           ; 
       .twok 'v', 'e'                                      ; Encoded as:   "GO<150>RNM<146>T"
       .char 'r'
       .char 'n'
       .char 'm'
       .twok 'e', 'n'
       .char 't'
       byte >00

       .char 'd'                                           ; Token 3:      "DATA ON {selected system name}"
       .twok 'a', 't'                                      ; 
       .char 'a'                                           ; Encoded as:   "D<145>A[131]{3}"
       .rtok 131
       .cont 3
       byte >00

       .twok 'i', 'n'                                      ; Token 4:      "INVENTORY{crlf}
       .twok 'v', 'e'                                      ; "
       .char 'n'                                           ; 
       .char 't'                                           ; Encoded as:   "<140><150>NT<153>Y{13}"
       .twok 'o', 'r'
       .char 'y'
       .cont 13
       byte >00

       .char 's'                                           ; Token 5:      "SYSTEM"
       .char 'y'                                           ; 
       .char 's'                                           ; Encoded as:   "SYS<156>M"
       .twok 't', 'e'
       .char 'm'
       byte >00

       .char 'p'                                           ; Token 6:      "PRICE"
       .twok 'r', 'i'                                      ; 
       .twok 'c', 'e'                                      ; Encoded as:   "P<158><133>"
       byte >00

       .cont 2                                             ; Token 7:      "{current system name} MARKET PRICES"
       .char ' '                                           ; 
       .twok 'm', 'a'                                      ; Encoded as:   "{2} <139>RKET [6]S"
       .char 'r'
       .char 'k'
       .char 'e'
       .char 't'
       .char ' '
       .rtok 6
       .char 's'
       byte >00

       .twok 'i', 'n'                                      ; Token 8:      "INDUSTRIAL"
       .char 'd'                                           ; 
       .twok 'u', 's'                                      ; Encoded as:   "<140>D<136>T<158><128>"
       .char 't'
       .twok 'r', 'i'
       .twok 'a', 'l'
       byte >00

       .char 'a'                                           ; Token 9:      "AGRICULTURAL"
       .char 'g'                                           ; 
       .twok 'r', 'i'                                      ; Encoded as:   "AG<158>CULTU<148>L"
       .char 'c'
       .char 'u'
       .char 'l'
       .char 't'
       .char 'u'
       .twok 'r', 'a'
       .char 'l'
       byte >00

       .twok 'r', 'i'                                      ; Token 10:     "RICH "
       .char 'c'                                           ; 
       .char 'h'                                           ; Encoded as:   "<158>CH "
       .char ' '
       byte >00

       .char 'a'                                           ; Token 11:     "AVERAGE "
       .twok 'v', 'e'                                      ; 
       .twok 'r', 'a'                                      ; Encoded as:   "A<150><148><131> "
       .twok 'g', 'e'
       .char ' '
       byte >00

       .char 'p'                                           ; Token 12:     "POOR "
       .char 'o'                                           ; 
       .twok 'o', 'r'                                      ; Encoded as:   "PO<153> "
       .char ' '
       byte >00

       .twok 'm', 'a'                                      ; Token 13:     "MAINLY "
       .twok 'i', 'n'                                      ; 
       .char 'l'                                           ; Encoded as:   "<139><140>LY "
       .char 'y'
       .char ' '
       byte >00

       .char 'u'                                           ; Token 14:     "UNIT"
       .char 'n'                                           ; 
       .char 'i'                                           ; Encoded as:   "UNIT"
       .char 't'
       byte >00

       .char 'v'                                           ; Token 15:     "VIEW "
       .char 'i'                                           ; 
       .char 'e'                                           ; Encoded as:   "VIEW "
       .char 'w'
       .char ' '
       byte >00

       .twok 'q', 'u'                                      ; Token 16:     "QUANTITY"
       .twok 'a', 'n'                                      ; 
       .twok 't', 'i'                                      ; Encoded as:   "<154><155><151>TY"
       .char 't'
       .char 'y'
       byte >00

       .twok 'a', 'n'                                      ; Token 17:     "ANARCHY"
       .twok 'a', 'r'                                      ; 
       .char 'c'                                           ; Encoded as:   "<155><138>CHY"
       .char 'h'
       .char 'y'
       byte >00

       .char 'f'                                           ; Token 18:     "FEUDAL"
       .char 'e'                                           ; 
       .char 'u'                                           ; Encoded as:   "FEUD<128>"
       .char 'd'
       .twok 'a', 'l'
       byte >00

       .char 'm'                                           ; Token 19:     "MULTI-GOVERNMENT"
       .char 'u'                                           ; 
       .char 'l'                                           ; Encoded as:   "MUL<151>-[2]"
       .twok 't', 'i'
       .char '-'
       .rtok 2
       byte >00

       .twok 'd', 'i'                                      ; Token 20:     "DICTATORSHIP"
       .char 'c'                                           ; 
       .char 't'                                           ; Encoded as:   "<141>CT<145><153>[25]"
       .twok 'a', 't'
       .twok 'o', 'r'
       .rtok 25
       byte >00

       .rtok 91                                            ; Token 21:     "COMMUNIST"
       .char 'm'                                           ; 
       .char 'u'                                           ; Encoded as:   "[91]MUN<157>T"
       .char 'n'
       .twok 'i', 's'
       .char 't'
       byte >00

       .char 'c'                                           ; Token 22:     "CONFEDERACY"
       .twok 'o', 'n'                                      ; 
       .char 'f'                                           ; Encoded as:   "C<159>F<152><144>ACY"
       .twok 'e', 'd'
       .twok 'e', 'r'
       .char 'a'
       .char 'c'
       .char 'y'
       byte >00

       .char 'd'                                           ; Token 23:     "DEMOCRACY"
       .char 'e'                                           ; 
       .char 'm'                                           ; Encoded as:   "DEMOC<148>CY"
       .char 'o'
       .char 'c'
       .twok 'r', 'a'
       .char 'c'
       .char 'y'
       byte >00

       .char 'c'                                           ; Token 24:     "CORPORATE STATE"
       .twok 'o', 'r'                                      ; 
       .char 'p'                                           ; Encoded as:   "C<153>P<153><145>E [43]<145>E"
       .twok 'o', 'r'
       .twok 'a', 't'
       .char 'e'
       .char ' '
       .rtok 43
       .twok 'a', 't'
       .char 'e'
       byte >00

       .char 's'                                           ; Token 25:     "SHIP"
       .char 'h'                                           ; 
       .char 'i'                                           ; Encoded as:   "SHIP"
       .char 'p'
       byte >00

       .char 'p'                                           ; Token 26:     "PRODUCT"
       .char 'r'                                           ; 
       .char 'o'                                           ; Encoded as:   "PRODUCT"
       .char 'd'
       .char 'u'
       .char 'c'
       .char 't'
       byte >00

       .char ' '                                           ; Token 27:     " LASER"
       .twok 'l', 'a'                                      ; 
       .char 's'                                           ; Encoded as:   " <149>S<144>"
       .twok 'e', 'r'
       byte >00

       .char 'h'                                           ; Token 28:     "HUMAN COLONIAL"
       .char 'u'                                           ; 
       .char 'm'                                           ; Encoded as:   "HUM<155> COL<159>I<128>"
       .twok 'a', 'n'
       .char ' '
       .char 'c'
       .char 'o'
       .char 'l'
       .twok 'o', 'n'
       .char 'i'
       .twok 'a', 'l'
       byte >00

       .char 'h'                                           ; Token 29:     "HYPERSPACE "
       .char 'y'                                           ; 
       .char 'p'                                           ; Encoded as:   "HYP<144>SPA<133> "
       .twok 'e', 'r'
       .char 's'
       .char 'p'
       .char 'a'
       .twok 'c', 'e'
       .char ' '
       byte >00

       .char 's'                                           ; Token 30:     "SHORT RANGE CHART"
       .char 'h'                                           ; 
       .twok 'o', 'r'                                      ; Encoded as:   "SH<153>T [42][1]"
       .char 't'
       .char ' '
       .rtok 42
       .rtok 1
       byte >00

       .twok 'd', 'i'                                      ; Token 31:     "DISTANCE"
       .rtok 43                                            ; 
       .twok 'a', 'n'                                      ; Encoded as:   "<141>[43]<155><133>"
       .twok 'c', 'e'
       byte >00

       .char 'p'                                           ; Token 32:     "POPULATION"
       .char 'o'                                           ; 
       .char 'p'                                           ; Encoded as:   "POPUL<145>I<159>"
       .char 'u'
       .char 'l'
       .twok 'a', 't'
       .char 'i'
       .twok 'o', 'n'
       byte >00

       .char 'g'                                           ; Token 33:     "GROSS PRODUCTIVITY"
       .char 'r'                                           ; 
       .char 'o'                                           ; Encoded as:   "GROSS [26]IVITY"
       .char 's'
       .char 's'
       .char ' '
       .rtok 26
       .char 'i'
       .char 'v'
       .char 'i'
       .char 't'
       .char 'y'
       byte >00

       .char 'e'                                           ; Token 34:     "ECONOMY"
       .char 'c'                                           ; 
       .twok 'o', 'n'                                      ; Encoded as:   "EC<159>OMY"
       .char 'o'
       .char 'm'
       .char 'y'
       byte >00

       .char ' '                                           ; Token 35:     " LIGHT YEARS"
       .char 'l'                                           ; 
       .char 'i'                                           ; Encoded as:   " LIGHT YE<138>S"
       .char 'g'
       .char 'h'
       .char 't'
       .char ' '
       .char 'y'
       .char 'e'
       .twok 'a', 'r'
       .char 's'
       byte >00

       .twok 't', 'e'                                      ; Token 36:     "TECH.LEVEL"
       .char 'c'                                           ; 
       .char 'h'                                           ; Encoded as:   "<156>CH.<129><150>L"
       .char '.'
       .twok 'l', 'e'
       .twok 'v', 'e'
       .char 'l'
       byte >00

       .char 'c'                                           ; Token 37:     "CASH"
       .char 'a'                                           ; 
       .char 's'                                           ; Encoded as:   "CASH"
       .char 'h'
       byte >00

       .char ' '                                           ; Token 38:     " BILLION"
       .twok 'b', 'i'                                      ; 
       .rtok 118                                           ; Encoded as:   " <134>[118]I<159>"
       .char 'i'
       .twok 'o', 'n'
       byte >00

       .rtok 122                                           ; Token 39:     "GALACTIC CHART{galaxy number}"
       .rtok 1                                             ; 
       .cont 1                                             ; Encoded as:   "[122][1]{1}"
       byte >00

       .char 't'                                           ; Token 40:     "TARGET LOST"
       .twok 'a', 'r'                                      ; 
       .twok 'g', 'e'                                      ; Encoded as:   "T<138><131>T LO[43]"
       .char 't'
       .char ' '
       .char 'l'
       .char 'o'
       .rtok 43
       byte >00

       .rtok 106                                           ; Token 41:     "MISSILE JAMMED"
       .char ' '                                           ; 
       .char 'j'                                           ; Encoded as:   "[106] JAMM<152>"
       .char 'a'
       .char 'm'
       .char 'm'
       .twok 'e', 'd'
       byte >00

       .char 'r'                                           ; Token 42:     "RANGE"
       .twok 'a', 'n'                                      ; 
       .twok 'g', 'e'                                      ; Encoded as:   "R<155><131>"
       byte >00

       .char 's'                                           ; Token 43:     "ST"
       .char 't'                                           ; 
       byte >00                                                      ; Encoded as:   "ST"

       .rtok 16                                            ; Token 44:     "QUANTITY OF "
       .char ' '                                           ; 
       .char 'o'                                           ; Encoded as:   "[16] OF "
       .char 'f'
       .char ' '
       byte >00

       .char 's'                                           ; Token 45:     "SELL"
       .char 'e'                                           ; 
       .rtok 118                                           ; Encoded as:   "SE[118]"
       byte >00

       .char ' '                                           ; Token 46:     " CARGO{sentence case}"
       .char 'c'                                           ; 
       .twok 'a', 'r'                                      ; Encoded as:   " C<138>GO{6}"
       .char 'g'
       .char 'o'
       .cont 6
       byte >00

       .char 'e'                                           ; Token 47:     "EQUIP"
       .twok 'q', 'u'                                      ; 
       .char 'i'                                           ; Encoded as:   "E<154>IP"
       .char 'p'
       byte >00

       .char 'f'                                           ; Token 48:     "FOOD"
       .char 'o'                                           ; 
       .char 'o'                                           ; Encoded as:   "FOOD"
       .char 'd'
       byte >00

       .twok 't', 'e'                                      ; Token 49:     "TEXTILES"
       .char 'x'                                           ; 
       .twok 't', 'i'                                      ; Encoded as:   "<156>X<151>L<137>"
       .char 'l'
       .twok 'e', 's'
       byte >00

       .twok 'r', 'a'                                      ; Token 50:     "RADIOACTIVES"
       .twok 'd', 'i'                                      ; 
       .char 'o'                                           ; Encoded as:   "<148><141>OAC<151><150>S"
       .char 'a'
       .char 'c'
       .twok 't', 'i'
       .twok 'v', 'e'
       .char 's'
       byte >00

       .char 's'                                           ; Token 51:     "SLAVES"
       .twok 'l', 'a'                                      ; 
       .twok 'v', 'e'                                      ; Encoded as:   "S<149><150>S"
       .char 's'
       byte >00

       .char 'l'                                           ; Token 52:     "LIQUOR/WINES"
       .char 'i'                                           ; 
       .twok 'q', 'u'                                      ; Encoded as:   "LI<154><153>/W<140><137>"
       .twok 'o', 'r'
       .char '/'
       .char 'w'
       .twok 'i', 'n'
       .twok 'e', 's'
       byte >00

       .char 'l'                                           ; Token 53:     "LUXURIES"
       .char 'u'                                           ; 
       .char 'x'                                           ; Encoded as:   "LUXU<158><137>"
       .char 'u'
       .twok 'r', 'i'
       .twok 'e', 's'
       byte >00

       .char 'n'                                           ; Token 54:     "NARCOTICS"
       .twok 'a', 'r'                                      ; 
       .char 'c'                                           ; Encoded as:   "N<138>CO<151>CS"
       .char 'o'
       .twok 't', 'i'
       .char 'c'
       .char 's'
       byte >00

       .rtok 91                                            ; Token 55:     "COMPUTERS"
       .char 'p'                                           ; 
       .char 'u'                                           ; Encoded as:   "[91]PUT<144>S"
       .char 't'
       .twok 'e', 'r'
       .char 's'
       byte >00

       .twok 'm', 'a'                                      ; Token 56:     "MACHINERY"
       .char 'c'                                           ; 
       .char 'h'                                           ; Encoded as:   "<139>CH<140><144>Y"
       .twok 'i', 'n'
       .twok 'e', 'r'
       .char 'y'
       byte >00

       .rtok 117                                           ; Token 57:     "ALLOYS"
       .char 'o'                                           ; 
       .char 'y'                                           ; Encoded as:   "[117]OYS"
       .char 's'
       byte >00

       .char 'f'                                           ; Token 58:     "FIREARMS"
       .char 'i'                                           ; 
       .twok 'r', 'e'                                      ; Encoded as:   "FI<142><138>MS"
       .twok 'a', 'r'
       .char 'm'
       .char 's'
       byte >00

       .char 'f'                                           ; Token 59:     "FURS"
       .char 'u'                                           ; 
       .char 'r'                                           ; Encoded as:   "FURS"
       .char 's'
       byte >00

       .char 'm'                                           ; Token 60:     "MINERALS"
       .twok 'i', 'n'                                      ; 
       .twok 'e', 'r'                                      ; Encoded as:   "M<140><144><128>S"
       .twok 'a', 'l'
       .char 's'
       byte >00

       .char 'g'                                           ; Token 61:     "GOLD"
       .char 'o'                                           ; 
       .char 'l'                                           ; Encoded as:   "GOLD"
       .char 'd'
       byte >00

       .char 'p'                                           ; Token 62:     "PLATINUM"
       .char 'l'                                           ; 
       .twok 'a', 't'                                      ; Encoded as:   "PL<145><140>UM"
       .twok 'i', 'n'
       .char 'u'
       .char 'm'
       byte >00

       .twok 'g', 'e'                                      ; Token 63:     "GEM-STONES"
       .char 'm'                                           ; 
       .char '-'                                           ; Encoded as:   "<131>M-[43]<159><137>"
       .rtok 43
       .twok 'o', 'n'
       .twok 'e', 's'
       byte >00

       .twok 'a', 'l'                                      ; Token 64:     "ALIEN ITEMS"
       .char 'i'                                           ; 
       .twok 'e', 'n'                                      ; Encoded as:   "<128>I<146> [127]S"
       .char ' '
       .rtok 127
       .char 's'
       byte >00

       .char '('                                           ; Token 65:     "(Y/N)?"
       .char 'y'                                           ; 
       .char '/'                                           ; Encoded as:   "(Y/N)?"
       .char 'n'
       .char ')'
       .char '?'
       byte >00

       .char ' '                                           ; Token 66:     " CR"
       .char 'c'                                           ; 
       .char 'r'                                           ; Encoded as:   " CR"
       byte >00

       .char 'l'                                           ; Token 67:     "LARGE"
       .twok 'a', 'r'                                      ; 
       .twok 'g', 'e'                                      ; Encoded as:   "L<138><131>"
       byte >00

       .char 'f'                                           ; Token 68:     "FIERCE"
       .char 'i'                                           ; 
       .twok 'e', 'r'                                      ; Encoded as:   "FI<144><133>"
       .twok 'c', 'e'
       byte >00

       .char 's'                                           ; Token 69:     "SMALL"
       .twok 'm', 'a'                                      ; 
       .rtok 118                                           ; Encoded as:   "S<139>[118]"
       byte >00

       .char 'g'                                           ; Token 70:     "GREEN"
       .twok 'r', 'e'                                      ; 
       .twok 'e', 'n'                                      ; Encoded as:   "G<142><146>"
       byte >00

       .char 'r'                                           ; Token 71:     "RED"
       .twok 'e', 'd'                                      ; 
       byte >00                                                      ; Encoded as:   "R<152>"

       .char 'y'                                           ; Token 72:     "YELLOW"
       .char 'e'                                           ; 
       .rtok 118                                           ; Encoded as:   "YE[118]OW"
       .char 'o'
       .char 'w'
       byte >00

       .char 'b'                                           ; Token 73:     "BLUE"
       .char 'l'                                           ; 
       .char 'u'                                           ; Encoded as:   "BLUE"
       .char 'e'
       byte >00

       .char 'b'                                           ; Token 74:     "BLACK"
       .twok 'l', 'a'                                      ; 
       .char 'c'                                           ; Encoded as:   "B<149>CK"
       .char 'k'
       byte >00

       .rtok 136                                           ; Token 75:     "HARMLESS"
       byte >00                                                      ; 
                                                                     ; Encoded as:   "[136]"

       .char 's'                                           ; Token 76:     "SLIMY"
       .char 'l'                                           ; 
       .char 'i'                                           ; Encoded as:   "SLIMY"
       .char 'm'
       .char 'y'
       byte >00

       .char 'b'                                           ; Token 77:     "BUG-EYED"
       .char 'u'                                           ; 
       .char 'g'                                           ; Encoded as:   "BUG-EY<152>"
       .char '-'
       .char 'e'
       .char 'y'
       .twok 'e', 'd'
       byte >00

       .char 'h'                                           ; Token 78:     "HORNED"
       .twok 'o', 'r'                                      ; 
       .char 'n'                                           ; Encoded as:   "H<153>N<152>"
       .twok 'e', 'd'
       byte >00

       .char 'b'                                           ; Token 79:     "BONY"
       .twok 'o', 'n'                                      ; 
       .char 'y'                                           ; Encoded as:   "B<159>Y"
       byte >00

       .char 'f'                                           ; Token 80:     "FAT"
       .twok 'a', 't'                                      ; 
       byte >00                                                      ; Encoded as:   "F<145>"

       .char 'f'                                           ; Token 81:     "FURRY"
       .char 'u'                                           ; 
       .char 'r'                                           ; Encoded as:   "FURRY"
       .char 'r'
       .char 'y'
       byte >00

       .char 'r'                                           ; Token 82:     "RODENT"
       .char 'o'                                           ; 
       .char 'd'                                           ; Encoded as:   "ROD<146>T"
       .twok 'e', 'n'
       .char 't'
       byte >00

       .char 'f'                                           ; Token 83:     "FROG"
       .char 'r'                                           ; 
       .char 'o'                                           ; Encoded as:   "FROG"
       .char 'g'
       byte >00

       .char 'l'                                           ; Token 84:     "LIZARD"
       .char 'i'                                           ; 
       .twok 'z', 'a'                                      ; Encoded as:   "LI<132>RD"
       .char 'r'
       .char 'd'
       byte >00

       .char 'l'                                           ; Token 85:     "LOBSTER"
       .char 'o'                                           ; 
       .char 'b'                                           ; Encoded as:   "LOB[43]<144>"
       .rtok 43
       .twok 'e', 'r'
       byte >00

       .twok 'b', 'i'                                      ; Token 86:     "BIRD"
       .char 'r'                                           ; 
       .char 'd'                                           ; Encoded as:   "<134>RD"
       byte >00

       .char 'h'                                           ; Token 87:     "HUMANOID"
       .char 'u'                                           ; 
       .char 'm'                                           ; Encoded as:   "HUM<155>OID"
       .twok 'a', 'n'
       .char 'o'
       .char 'i'
       .char 'd'
       byte >00

       .char 'f'                                           ; Token 88:     "FELINE"
       .char 'e'                                           ; 
       .char 'l'                                           ; Encoded as:   "FEL<140>E"
       .twok 'i', 'n'
       .char 'e'
       byte >00

       .twok 'i', 'n'                                      ; Token 89:     "INSECT"
       .char 's'                                           ; 
       .char 'e'                                           ; Encoded as:   "<140>SECT"
       .char 'c'
       .char 't'
       byte >00

       .rtok 11                                            ; Token 90:     "AVERAGE RADIUS"
       .twok 'r', 'a'                                      ; 
       .twok 'd', 'i'                                      ; Encoded as:   "[11]<148><141><136>"
       .twok 'u', 's'
       byte >00

       .char 'c'                                           ; Token 91:     "COM"
       .char 'o'                                           ; 
       .char 'm'                                           ; Encoded as:   "COM"
       byte >00

       .rtok 91                                            ; Token 92:     "COMMANDER"
       .char 'm'                                           ; 
       .twok 'a', 'n'                                      ; Encoded as:   "[91]M<155>D<144>"
       .char 'd'
       .twok 'e', 'r'
       byte >00

       .char ' '                                           ; Token 93:     " DESTROYED"
       .char 'd'                                           ; 
       .twok 'e', 's'                                      ; Encoded as:   " D<137>TROY<152>"
       .char 't'
       .char 'r'
       .char 'o'
       .char 'y'
       .twok 'e', 'd'
       byte >00

       .char 'b'                                           ; Token 94:     "BY D.BRABEN & I.BELL"
       .char 'y'                                           ; 
       .char ' '                                           ; Encoded as:   "BY D.B<148><147>N & I.<147>[118]"
       .char 'd'
       .char '.'
       .char 'b'
       .twok 'r', 'a'
       .twok 'b', 'e'
       .char 'n'
       .char ' '
       .char '&'
       .char ' '
       .char 'i'
       .char '.'
       .twok 'b', 'e'
       .rtok 118
       byte >00

       .rtok 14                                            ; Token 95:     "UNIT  QUANTITY{crlf}
       .char ' '                                           ; PRODUCT   UNIT PRICE FOR SALE{crlf}
       .char ' '                                           ; {lf}"
       .rtok 16                                            ; 
       .cont 13                                            ; Encoded as:   "[14]  [16]{13} [26]   [14] [6] F<153>
       .char ' '                                           ; SA<129>{13}{10}"
       .rtok 26
       .char ' '
       .char ' '
       .char ' '
       .rtok 14
       .char ' '
       .rtok 6
       .char ' '
       .char 'f'
       .twok 'o', 'r'
       .char ' '
       .char 's'
       .char 'a'
       .twok 'l', 'e'
       .cont 13
       .cont 10
       byte >00

       .char 'f'                                           ; Token 96:     "FRONT"
       .char 'r'                                           ; 
       .twok 'o', 'n'                                      ; Encoded as:   "FR<159>T"
       .char 't'
       byte >00

       .twok 'r', 'e'                                      ; Token 97:     "REAR"
       .twok 'a', 'r'                                      ; 
       byte >00                                                      ; Encoded as:   "<142><138>"

       .twok 'l', 'e'                                      ; Token 98:     "LEFT"
       .char 'f'                                           ; 
       .char 't'                                           ; Encoded as:   "<129>FT"
       byte >00

       .twok 'r', 'i'                                      ; Token 99:     "RIGHT"
       .char 'g'                                           ; 
       .char 'h'                                           ; Encoded as:   "<158>GHT"
       .char 't'
       byte >00

       .rtok 121                                           ; Token 100:    "ENERGY LOW{beep}"
       .char 'l'                                           ; 
       .char 'o'                                           ; Encoded as:   "[121]LOW{7}"
       .char 'w'
       .cont 7
       byte >00

       .rtok 99                                            ; Token 101:    "RIGHT ON COMMANDER!"
       .rtok 131                                           ; 
       .rtok 92                                            ; Encoded as:   "[99][131][92]!"
       .char '!'
       byte >00

       .char 'e'                                           ; Token 102:    "EXTRA "
       .char 'x'                                           ; 
       .char 't'                                           ; Encoded as:   "EXT<148> "
       .twok 'r', 'a'
       .char ' '
       byte >00

       .char 'p'                                           ; Token 103:    "PULSE LASER"
       .char 'u'                                           ; 
       .char 'l'                                           ; Encoded as:   "PULSE[27]"
       .char 's'
       .char 'e'
       .rtok 27
       byte >00

       .twok 'b', 'e'                                      ; Token 104:    "BEAM LASER"
       .char 'a'                                           ; 
       .char 'm'                                           ; Encoded as:   "<147>AM[27]"
       .rtok 27
       byte >00

       .char 'f'                                           ; Token 105:    "FUEL"
       .char 'u'                                           ; 
       .char 'e'                                           ; Encoded as:   "FUEL"
       .char 'l'
       byte >00

       .char 'm'                                           ; Token 106:    "MISSILE"
       .twok 'i', 's'                                      ; 
       .char 's'                                           ; Encoded as:   "M<157>SI<129>"
       .char 'i'
       .twok 'l', 'e'
       byte >00

       .rtok 67                                            ; Token 107:    "LARGE CARGO{sentence case} BAY"
       .rtok 46                                            ; 
       .char ' '                                           ; Encoded as:   "[67][46] BAY"
       .char 'b'
       .char 'a'
       .char 'y'
       byte >00

       .char 'e'                                           ; Token 108:    "E.C.M.SYSTEM"
       .char '.'                                           ; 
       .char 'c'                                           ; Encoded as:   "E.C.M.[5]"
       .char '.'
       .char 'm'
       .char '.'
       .rtok 5
       byte >00

       .rtok 102                                           ; Token 109:    "EXTRA PULSE LASERS"
       .rtok 103                                           ; 
       .char 's'                                           ; Encoded as:   "[102][103]S"
       byte >00

       .rtok 102                                           ; Token 110:    "EXTRA BEAM LASERS"
       .rtok 104                                           ; 
       .char 's'                                           ; Encoded as:   "[102][104]S"
       byte >00

       .rtok 105                                           ; Token 111:    "FUEL SCOOPS"
       .char ' '                                           ; 
       .char 's'                                           ; Encoded as:   "[105] SCOOPS"
       .char 'c'
       .char 'o'
       .char 'o'
       .char 'p'
       .char 's'
       byte >00

       .twok 'e', 's'                                      ; Token 112:    "ESCAPE POD"
       .char 'c'                                           ; 
       .char 'a'                                           ; Encoded as:   "<137>CAPE POD"
       .char 'p'
       .char 'e'
       .char ' '
       .char 'p'
       .char 'o'
       .char 'd'
       byte >00

       .rtok 121                                           ; Token 113:    "ENERGY BOMB"
       .char 'b'                                           ; 
       .char 'o'                                           ; Encoded as:   "[121]BOMB"
       .char 'm'
       .char 'b'
       byte >00

       .rtok 121                                           ; Token 114:    "ENERGY UNIT"
       .rtok 14                                            ; 
       byte >00                                                      ; Encoded as:   "[121][14]"

       .rtok 124                                           ; Token 115:    "DOCKING COMPUTERS"
       .twok 'i', 'n'                                      ; 
       .char 'g'                                           ; Encoded as:   "[124]<140>G [55]"
       .char ' '
       .rtok 55
       byte >00

       .rtok 122                                           ; Token 116:    "GALACTIC HYPERSPACE "
       .char ' '                                           ; 
       .rtok 29                                            ; Encoded as:   "[122] [29]"
       byte >00

       .char 'a'                                           ; Token 117:    "ALL"
       .rtok 118                                           ; 
       byte >00                                                      ; Encoded as:   "A[118]"

       .char 'l'                                           ; Token 118:    "LL"
       .char 'l'                                           ; 
       byte >00                                                      ; Encoded as:   "LL"

       .rtok 37                                            ; Token 119:    "CASH:{cash} CR{crlf}
       .char ':'                                           ; "
       .cont 0                                             ; 
       byte >00                                                      ; Encoded as:   "[37]:{0}"

       .twok 'i', 'n'                                      ; Token 120:    "INCOMING MISSILE"
       .rtok 91                                            ; 
       .twok 'i', 'n'                                      ; Encoded as:   "<140>[91]<140>G [106]"
       .char 'g'
       .char ' '
       .rtok 106
       byte >00

       .twok 'e', 'n'                                      ; Token 121:    "ENERGY "
       .twok 'e', 'r'                                      ; 
       .char 'g'                                           ; Encoded as:   "<146><144>GY "
       .char 'y'
       .char ' '
       byte >00

       .char 'g'                                           ; Token 122:    "GALACTIC"
       .char 'a'                                           ; 
       .twok 'l', 'a'                                      ; Encoded as:   "GA<149>C<151>C"
       .char 'c'
       .twok 't', 'i'
       .char 'c'
       byte >00

       .cont 13                                            ; Token 123:    "{crlf}
       .rtok 92                                            ; COMMANDER'S NAME? "
       .char '`'                                           ; 
       .char 's'                                           ; Encoded as:   "{13}[92]'S NAME? "
       .char ' '
       .char 'n'
       .char 'a'
       .char 'm'
       .char 'e'
       .char '?'
       .char ' '
       byte >00

       .char 'd'                                           ; Token 124:    "DOCK"
       .char 'o'                                           ; 
       .char 'c'                                           ; Encoded as:   "DOCK"
       .char 'k'
       byte >00

       .cont 5                                             ; Token 125:    "FUEL: {fuel level} LIGHT YEARS{crlf}
       .twok 'l', 'e'                                      ; CASH:{cash} CR{crlf}
       .char 'g'                                           ; LEGAL STATUS:"
       .twok 'a', 'l'                                      ; 
       .char ' '                                           ; Encoded as:   "{5}<129>G<128> [43]<145><136>:"
       .rtok 43
       .twok 'a', 't'
       .twok 'u', 's'
       .char ':'
       byte >00

       .rtok 92                                            ; Token 126:    "COMMANDER {commander name}{crlf}
       .char ' '                                           ; {crlf}
       .cont 4                                             ; {crlf}
       .cont 13                                            ; {sentence case}PRESENT SYSTEM{tab to
       .cont 13                                            ; column 21}:{current system name}{crlf}
       .cont 13                                            ; HYPERSPACE SYSTEM{tab to column 21}:
       .cont 6                                             ; {selected system name}{crlf}
       .rtok 145                                           ; CONDITION{tab to column 21}:"
       .char ' '                                           ; 
       .rtok 5                                             ; Encoded as:   "[92] {4}{13}{13}{13}{6}[145] [5]{9}{2}
       .cont 9                                             ; {13}[29][5]{9}{3}{13}C<159><141><151>
       .cont 2                                             ; <159>{9}"
       .cont 13
       .rtok 29
       .rtok 5
       .cont 9
       .cont 3
       .cont 13
       .char 'c'
       .twok 'o', 'n'
       .twok 'd', 'i'
       .twok 't', 'i'
       .twok 'o', 'n'
       .cont 9
       byte >00

       .char 'i'                                           ; Token 127:    "ITEM"
       .twok 't', 'e'                                      ; 
       .char 'm'                                           ; Encoded as:   "I<156>M"
       byte >00

       .char ' '                                           ; Token 128:    "  LOAD NEW COMMANDER (Y/N)?{crlf}
       .char ' '                                           ; {crlf}
       .char 'l'                                           ; "
       .char 'o'                                           ; 
       .char 'a'                                           ; Encoded as:   "  LOAD NEW [92] [65]{13}{13}"
       .char 'd'
       .char ' '
       .char 'n'
       .char 'e'
       .char 'w'
       .char ' '
       .rtok 92
       .char ' '
       .rtok 65
       .cont 13
       .cont 13
       byte >00

       .cont 6                                             ; Token 129:    "{sentence case}DOCKED"
       .rtok 124                                           ; 
       .twok 'e', 'd'                                      ; Encoded as:   "{6}[124]<152>"
       byte >00

       .twok 'r', 'a'                                      ; Token 130:    "RATING:"
       .twok 't', 'i'                                      ; 
       .char 'n'                                           ; Encoded as:   "<148><151>NG:"
       .char 'g'
       .char ':'
       byte >00

       .char ' '                                           ; Token 131:    " ON "
       .twok 'o', 'n'                                      ; 
       .char ' '                                           ; Encoded as:   " <159> "
       byte >00

       .cont 13                                            ; Token 132:    "{crlf}
       .cont 8                                             ; {all caps}EQUIPMENT: {sentence case}"
       .rtok 47                                            ; 
       .char 'm'                                           ; Encoded as:   "{13}{8}[47]M<146>T:{6}"
       .twok 'e', 'n'
       .char 't'
       .char ':'
       .cont 6
       byte >00

       .char 'c'                                           ; Token 133:    "CLEAN"
       .twok 'l', 'e'                                      ; 
       .twok 'a', 'n'                                      ; Encoded as:   "C<129><155>"
       byte >00

       .char 'o'                                           ; Token 134:    "OFFENDER"
       .char 'f'                                           ; 
       .char 'f'                                           ; Encoded as:   "OFF<146>D<144>"
       .twok 'e', 'n'
       .char 'd'
       .twok 'e', 'r'
       byte >00

       .char 'f'                                           ; Token 135:    "FUGITIVE"
       .char 'u'                                           ; 
       .char 'g'                                           ; Encoded as:   "FUGI<151><150>"
       .char 'i'
       .twok 't', 'i'
       .twok 'v', 'e'
       byte >00

       .char 'h'                                           ; Token 136:    "HARMLESS"
       .twok 'a', 'r'                                      ; 
       .char 'm'                                           ; Encoded as:   "H<138>M<129>SS"
       .twok 'l', 'e'
       .char 's'
       .char 's'
       byte >00

       .char 'm'                                           ; Token 137:    "MOSTLY HARMLESS"
       .char 'o'                                           ; 
       .rtok 43                                            ; Encoded as:   "MO[43]LY [136]"
       .char 'l'
       .char 'y'
       .char ' '
       .rtok 136
       byte >00

       .rtok 12                                            ; Token 138:    "POOR "
       byte >00                                                      ; 
                                                                     ; Encoded as:   "[12]"

       .rtok 11                                            ; Token 139:    "AVERAGE "
       byte >00                                                      ; 
                                                                     ; Encoded as:   "[11]"

       .char 'a'                                           ; Token 140:    "ABOVE AVERAGE "
       .char 'b'                                           ; 
       .char 'o'                                           ; Encoded as:   "ABO<150> [11]"
       .twok 'v', 'e'
       .char ' '
       .rtok 11
       byte >00

       .rtok 91                                            ; Token 141:    "COMPETENT"
       .char 'p'                                           ; 
       .char 'e'                                           ; Encoded as:   "[91]PET<146>T"
       .char 't'
       .twok 'e', 'n'
       .char 't'
       byte >00

       .char 'd'                                           ; Token 142:    "DANGEROUS"
       .twok 'a', 'n'                                      ; 
       .twok 'g', 'e'                                      ; Encoded as:   "D<155><131>RO<136>"
       .char 'r'
       .char 'o'
       .twok 'u', 's'
       byte >00

       .char 'd'                                           ; Token 143:    "DEADLY"
       .char 'e'                                           ; 
       .char 'a'                                           ; Encoded as:   "DEADLY"
       .char 'd'
       .char 'l'
       .char 'y'
       byte >00

       .char '-'                                           ; Token 144:    "---- E L I T E ----"
       .char '-'                                           ; 
       .char '-'                                           ; Encoded as:   "---- E L I T E ----"
       .char '-'
       .char ' '
       .char 'e'
       .char ' '
       .char 'l'
       .char ' '
       .char 'i'
       .char ' '
       .char 't'
       .char ' '
       .char 'e'
       .char ' '
       .char '-'
       .char '-'
       .char '-'
       .char '-'
       byte >00

       .char 'p'                                           ; Token 145:    "PRESENT"
       .twok 'r', 'e'                                      ; 
       .char 's'                                           ; Encoded as:   "P<142>S<146>T"
       .twok 'e', 'n'
       .char 't'
       byte >00

       .cont 8                                             ; Token 146:    "{all caps}GAME OVER"
       .char 'g'                                           ; 
       .char 'a'                                           ; Encoded as:   "{8}GAME O<150>R"
       .char 'm'
       .char 'e'
       .char ' '
       .char 'o'
       .twok 'v', 'e'
       .char 'r'
       byte >00

       .char 'p'                                           ; Token 147:    "PRESS FIRE OR SPACE,COMMANDER.{crlf}
       .char 'r'                                           ; {crlf}
       .twok 'e', 's'                                      ; "
       .char 's'                                           ; 
       .char ' '                                           ; Encoded as:   "PR<137>S FI<142> <153> SPA<133>,[92].
       .char 'f'                                           ; {13}{13}"
       .char 'i'
       .twok 'r', 'e'
       .char ' '
       .twok 'o', 'r'
       .char ' '
       .char 's'
       .char 'p'
       .char 'a'
       .twok 'c', 'e'
       .char ','
       .rtok 92
       .char '.'
       .cont 13
       .cont 13
       byte >00

       .char '('                                           ; Token 148:    "(C) ACORNSOFT 1984"
       .char 'c'                                           ; 
       .char ')'                                           ; Encoded as:   "(C) AC<153>N<135>FT 1984"
       .char ' '
       .char 'a'
       .char 'c'
       .twok 'o', 'r'
       .char 'n'
       .twok 's', 'o'
       .char 'f'
       .char 't'
       .char ' '
       .char '1'
       .char '9'
       .char '8'
       .char '4'
       byte >00

* ******************************************************************************
* 
* Save WORDS9.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* Name: K%
* Type: Workspace
* Address: &0900 to &0AAF
* Category: Workspaces
* Summary: Ship data blocks and ship line heaps
* Deep dive: Ship data blocks
* The local bubble of universe
* 
* ------------------------------------------------------------------------------
* 
* Contains ship data for all the ships, planets, suns and space stations in our
* local bubble of universe, along with their corresponding ship line heaps.
* 
* The blocks are pointed to by the lookup table at location UNIV. The first 432
* bytes of the K% workspace hold ship data on up to 12 ships, with 36 (NI%)
* bytes per ship, and the ship line heap grows downwards from WP at the end of
* the K% workspace.
* 
* See the deep dive on "Ship data blocks" for details on ship data blocks, and
* the deep dive on "The local bubble of universe" for details of how Elite
* stores the local universe in K%, FRIN and UNIV.
* 
* ******************************************************************************

       aorg >0900

K.:
       bss NOSH * NI.                                      ; Ship data blocks and ship line heap

* ******************************************************************************
* 
* Name: WP
* Type: Workspace
* Address: &0D40 to &0F33
* Category: Workspaces
* Summary: Ship slots, variables
* 
* ******************************************************************************

       aorg >0D40

WP:
       bss 0                                               ; The start of the WP workspace

FRIN:
       bss NOSH + 1                                        ; Slots for the ships in the local bubble of universe
                                                           ; 
                                                           ; There are #NOSH + 1 slots, but the ship-spawning
                                                           ; routine at NWSHP only populates #NOSH of them, so
                                                           ; there are 13 slots but only 12 are used for ships
                                                           ; (the last slot is effectively used as a null
                                                           ; terminator when shuffling the slots down in the
                                                           ; KILLSHP routine)
                                                           ; 
                                                           ; See the deep dive on "The local bubble of universe"
                                                           ; for details of how Elite stores the local universe in
                                                           ; FRIN, UNIV and K%

CABTMP:
       bss 0                                               ; Cabin temperature
                                                           ; 
                                                           ; The ambient cabin temperature in deep space is 30,
                                                           ; which is displayed as one notch on the dashboard bar
                                                           ; 
                                                           ; We get higher temperatures closer to the sun
                                                           ; 
                                                           ; CABTMP shares a location with MANY, but that's OK as
                                                           ; MANY+0 would contain the number of ships of type 0,
                                                           ; and as there is no ship type 0 (they start at 1), the
                                                           ; byte at MANY+0 is not used for storing a ship type
                                                           ; and can be used for the cabin temperature instead

MANY:
       bss SST                                             ; The number of ships of each type in the local bubble
                                                           ; of universe
                                                           ; 
                                                           ; The number of ships of type X in the local bubble is
                                                           ; stored at MANY+X
                                                           ; 
                                                           ; See the deep dive on "Ship blueprints" for a list of
                                                           ; ship types

SSPR:
       bss NTY + 1 - SST                                   ; "Space station present" flag
                                                           ; 
                                                           ; * Non-zero if we are inside the space station's safe
                                                           ; zone
                                                           ; 
                                                           ; * 0 if we aren't (in which case we can show the sun)
                                                           ; 
                                                           ; This flag is at MANY+SST, which is no coincidence, as
                                                           ; MANY+SST is a count of how many space stations there
                                                           ; are in our local bubble, which is the same as saying
                                                           ; "space station present"

ECMP:
       bss 1                                               ; Our E.C.M. status
                                                           ; 
                                                           ; * 0 = E.C.M. is off
                                                           ; 
                                                           ; * Non-zero = E.C.M. is on

MJ:
       bss 1                                               ; Are we in witchspace (i.e. have we mis-jumped)?
                                                           ; 
                                                           ; * 0 = no, we are in normal space
                                                           ; 
                                                           ; * &FF = yes, we are in witchspace

LAS2:
       bss 1                                               ; Laser power for the current laser
                                                           ; 
                                                           ; * Bits 0-6 contain the laser power of the current
                                                           ; space view
                                                           ; 
                                                           ; * Bit 7 denotes whether or not the laser pulses:
                                                           ; 
                                                           ; * 0 = pulsing laser
                                                           ; 
                                                           ; * 1 = beam laser (i.e. always on)

MSAR:
       bss 1                                               ; The targeting state of our leftmost missile
                                                           ; 
                                                           ; * 0 = missile is not looking for a target, or it
                                                           ; already has a target lock (indicator is not
                                                           ; yellow/white)
                                                           ; 
                                                           ; * Non-zero = missile is currently looking for a
                                                           ; target (indicator is yellow/white)

VIEW:
       bss 1                                               ; The number of the current space view
                                                           ; 
                                                           ; * 0 = front
                                                           ; * 1 = rear
                                                           ; * 2 = left
                                                           ; * 3 = right

LASCT:
       bss 1                                               ; The laser pulse count for the current laser
                                                           ; 
                                                           ; This is a counter that defines the gap between the
                                                           ; pulses of a pulse laser. It is set as follows:
                                                           ; 
                                                           ; * 0 for a beam laser
                                                           ; 
                                                           ; * 10 for a pulse laser
                                                           ; 
                                                           ; It gets decremented every vertical sync (in the LINSCN
                                                           ; routine, which is called 50 times a second) and is set
                                                           ; to a non-zero value for pulse lasers only
                                                           ; 
                                                           ; The laser only fires when the value of LASCT hits
                                                           ; zero, so for pulse lasers with a value of 10, that
                                                           ; means the laser fires once every 10 vertical syncs (or
                                                           ; 5 times a second)
                                                           ; 
                                                           ; In comparison, beam lasers fire continuously as the
                                                           ; value of LASCT is always 0

GNTMP:
       bss 1                                               ; Laser temperature (or "gun temperature")
                                                           ; 
                                                           ; If the laser temperature exceeds 242 then the laser
                                                           ; overheats and cannot be fired again until it has
                                                           ; cooled down

HFX:
       bss 1                                               ; A flag that toggles the hyperspace colour effect
                                                           ; 
                                                           ; * 0 = no colour effect
                                                           ; 
                                                           ; * Non-zero = hyperspace colour effect enabled
                                                           ; 
                                                           ; When HFX is set to 1, the mode 4 screen that makes
                                                           ; up the top part of the display is temporarily switched
                                                           ; to mode 5 (the same screen mode as the dashboard),
                                                           ; which has the effect of blurring and colouring the
                                                           ; hyperspace rings in the top part of the screen. The
                                                           ; code to do this is in the LINSCN routine, which is
                                                           ; called as part of the screen mode routine at IRQ1.
                                                           ; It's in LINSCN that HFX is checked, and if it is
                                                           ; non-zero, the top part of the screen is not switched
                                                           ; to mode 4, thus leaving the top part of the screen in
                                                           ; the more colourful mode 5

EV:
       bss 1                                               ; The "extra vessels" spawning counter
                                                           ; 
                                                           ; This counter is set to 0 on arrival in a system and
                                                           ; following an in-system jump, and is bumped up when we
                                                           ; spawn bounty hunters or pirates (i.e. "extra vessels")
                                                           ; 
                                                           ; It decreases by 1 each time we consider spawning more
                                                           ; "extra vessels" in part 4 of the main game loop, so
                                                           ; increasing the value of EV has the effect of delaying
                                                           ; the spawning of more vessels
                                                           ; 
                                                           ; In other words, this counter stops bounty hunters and
                                                           ; pirates from continually appearing, and ensures that
                                                           ; there's a delay between spawnings

DLY:
       bss 1                                               ; In-flight message delay
                                                           ; 
                                                           ; This counter is used to keep an in-flight message up
                                                           ; for a specified time before it gets removed. The value
                                                           ; in DLY is decremented each time we start another
                                                           ; iteration of the main game loop at TT100

de_:
       bss 1                                               ; Equipment destruction flag
                                                           ; 
                                                           ; * Bit 1 denotes whether or not the in-flight message
                                                           ; about to be shown by the MESS routine is about
                                                           ; destroyed equipment:
                                                           ; 
                                                           ; * 0 = the message is shown normally
                                                           ; 
                                                           ; * 1 = the string " DESTROYED" gets added to the
                                                           ; end of the message

LSX:
       bss 0                                               ; LSX is an alias that points to the first byte of the
                                                           ; sun line heap at LSO
                                                           ; 
                                                           ; * &FF indicates the sun line heap is empty
                                                           ; 
                                                           ; * Otherwise the LSO heap contains the line data for
                                                           ; the sun

LSO:
       bss 192                                             ; The ship line heap for the space station (see NWSPS)
                                                           ; and the sun line heap (see SUN)
                                                           ; 
                                                           ; The spaces can be shared as our local bubble of
                                                           ; universe can support either the sun or a space
                                                           ; station, but not both

LSX2:
       bss 78                                              ; The ball line heap for storing x-coordinates (see the
                                                           ; deep dive on "The ball line heap" for details)

LSY2:
       bss 78                                              ; The ball line heap for storing y-coordinates (see the
                                                           ; deep dive on "The ball line heap" for details)

SY:
       bss NOST + 1                                        ; This is where we store the y_hi coordinates for all
                                                           ; the stardust particles

SYL:
       bss NOST + 1                                        ; This is where we store the y_lo coordinates for all
                                                           ; the stardust particles

SZ:
       bss NOST + 1                                        ; This is where we store the z_hi coordinates for all
                                                           ; the stardust particles

SZL:
       bss NOST + 1                                        ; This is where we store the z_lo coordinates for all
                                                           ; the stardust particles

XSAV2:
       bss 1                                               ; Temporary storage, used for storing the value of the X
                                                           ; register in the TT26 routine

YSAV2:
       bss 1                                               ; Temporary storage, used for storing the value of the Y
                                                           ; register in the TT26 routine

MCH:
       bss 1                                               ; The text token number of the in-flight message that is
                                                           ; currently being shown, and which will be removed by
                                                           ; the me2 routine when the counter in DLY reaches zero

FSH:
       bss 1                                               ; Forward shield status
                                                           ; 
                                                           ; * 0 = empty
                                                           ; 
                                                           ; * &FF = full

ASH:
       bss 1                                               ; Aft shield status
                                                           ; 
                                                           ; * 0 = empty
                                                           ; 
                                                           ; * &FF = full

ENERGY:
       bss 1                                               ; Energy bank status
                                                           ; 
                                                           ; * 0 = empty
                                                           ; 
                                                           ; * &FF = full

LASX:
       bss 1                                               ; The x-coordinate of the tip of the laser line

LASY:
       bss 1                                               ; The y-coordinate of the tip of the laser line

COMX:
       bss 1                                               ; The x-coordinate of the compass dot

COMY:
       bss 1                                               ; The y-coordinate of the compass dot

QQ24:
       bss 1                                               ; Temporary storage, used to store the current market
                                                           ; item's price in routine TT151

QQ25:
       bss 1                                               ; Temporary storage, used to store the current market
                                                           ; item's availability in routine TT151

QQ28:
       bss 1                                               ; The current system's economy (0-7)
                                                           ; 
                                                           ; * 0 = Rich Industrial
                                                           ; * 1 = Average Industrial
                                                           ; * 2 = Poor Industrial
                                                           ; * 3 = Mainly Industrial
                                                           ; * 4 = Mainly Agricultural
                                                           ; * 5 = Rich Agricultural
                                                           ; * 6 = Average Agricultural
                                                           ; * 7 = Poor Agricultural
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; information on economies

QQ29:
       bss 1                                               ; Temporary storage, used in a number of places

gov_:
       bss 1                                               ; The current system's government type (0-7)
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for
                                                           ; details of the various government types

tek_:
       bss 1                                               ; The current system's tech level (0-14)
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; information on tech levels

SLSP:
       bss 2                                               ; The address of the bottom of the ship line heap
                                                           ; 
                                                           ; The ship line heap is a descending block of memory
                                                           ; that starts at WP and descends down to SLSP. It can be
                                                           ; extended downwards by the NWSHP routine when adding
                                                           ; new ships (and their associated ship line heaps), in
                                                           ; which case SLSP is lowered to provide more heap space,
                                                           ; assuming there is enough free memory to do so

XX24:
       bss 1                                               ; This byte appears to be unused

ALTIT:
       bss 1                                               ; Our altitude above the surface of the planet or sun
                                                           ; 
                                                           ; * 255 = we are a long way above the surface
                                                           ; 
                                                           ; * 1-254 = our altitude as the square root of:
                                                           ; 
                                                           ; x_hi^2 + y_hi^2 + z_hi^2 - 6^2
                                                           ; 
                                                           ; where our ship is at the origin, the centre of the
                                                           ; planet/sun is at (x_hi, y_hi, z_hi), and the
                                                           ; radius of the planet/sun is 6
                                                           ; 
                                                           ; * 0 = we have crashed into the surface

QQ2:
       bss 6                                               ; The three 16-bit seeds for the current system, i.e.
                                                           ; the one we are currently in
                                                           ; 
                                                           ; See the deep dives on "Galaxy and system seeds" and
                                                           ; "Twisting the system seeds" for more details

QQ3:
       bss 1                                               ; The selected system's economy (0-7)
                                                           ; 
                                                           ; * 0 = Rich Industrial
                                                           ; * 1 = Average Industrial
                                                           ; * 2 = Poor Industrial
                                                           ; * 3 = Mainly Industrial
                                                           ; * 4 = Mainly Agricultural
                                                           ; * 5 = Rich Agricultural
                                                           ; * 6 = Average Agricultural
                                                           ; * 7 = Poor Agricultural
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; information on economies

QQ4:
       bss 1                                               ; The selected system's government (0-7)
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; details of the various government types

QQ5:
       bss 1                                               ; The selected system's tech level (0-14)
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; information on tech levels

QQ6:
       bss 2                                               ; The selected system's population in billions * 10
                                                           ; (1-71), so the maximum population is 7.1 billion
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; details on population levels

QQ7:
       bss 2                                               ; The selected system's productivity in M CR (96-62480)
                                                           ; 
                                                           ; See the deep dive on "Generating system data" for more
                                                           ; details about productivity levels

QQ8:
       bss 2                                               ; The distance from the current system to the selected
                                                           ; system in light years * 10, stored as a 16-bit number
                                                           ; 
                                                           ; The distance will be 0 if the selected system is the
                                                           ; current system
                                                           ; 
                                                           ; The galaxy chart is 102.4 light years wide and 51.2
                                                           ; light years tall (see the intra-system distance
                                                           ; calculations in routine TT111 for details), which
                                                           ; equates to 1024 x 512 in terms of QQ8

QQ9:
       bss 1                                               ; The galactic x-coordinate of the crosshairs in the
                                                           ; galaxy chart (and, most of the time, the selected
                                                           ; system's galactic x-coordinate)

QQ10:
       bss 1                                               ; The galactic y-coordinate of the crosshairs in the
                                                           ; galaxy chart (and, most of the time, the selected
                                                           ; system's galactic y-coordinate)

NOSTM:
       bss 1                                               ; The number of stardust particles shown on screen,
                                                           ; which is 18 (#NOST) for normal space, and 3 for
                                                           ; witchspace


* ******************************************************************************
* 
* ELITE A FILE
* 
* Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
* 
* The main game code (ELITE A through G, plus the ship data) is loaded at &1128
* and is moved down to &0F40 as part of elite-loader.asm.
* 
* ******************************************************************************

       aorg CODE.

LOAD_A.:
       equ LOAD.

* ******************************************************************************
* 
* Name: S%
* Type: Workspace
* Address: &0F40 to &0F50
* Category: Workspaces
* Summary: Vector addresses, compass colour and configuration settings
* 
* ------------------------------------------------------------------------------
* 
* Contains addresses that are used by the loader to set up vectors, the current
* compass colour, and the game's configuration settings.
* 
* ******************************************************************************

S.:
       data >0000                                                    ; The entry point for the main game; once the main code
                                                                     ; has been loaded, decrypted and moved to the right
                                                                     ; place by elite-loader.asm, the game is started by a
                                                                     ; JMP (S%) instruction, which jumps to the main entry
                                                                     ; point at TT170 via this location

       data >0000                                                    ; WRCHV is set to point here by elite-loader.asm

       data >0000                                                    ; IRQ1V is set to point here by elite-loader.asm

       data >0000                                                    ; BRKV is set to point here by elite-loader.asm

COMC:
       bss 1                                               ; The colour of the dot on the compass
                                                           ; 
                                                           ; * &F0 = the object in the compass is in front of us,
                                                           ; so the dot is yellow/white
                                                           ; 
                                                           ; * &FF = the object in the compass is behind us, so
                                                           ; the dot is green/cyan

DNOIZ:
       bss 1                                               ; Sound on/off configuration setting
                                                           ; 
                                                           ; * 0 = sound is on (default)
                                                           ; 
                                                           ; * Non-zero = sound is off
                                                           ; 
                                                           ; Toggled by pressing "S" when paused, see the DK4
                                                           ; routine for details

DAMP:
       bss 1                                               ; Keyboard damping configuration setting
                                                           ; 
                                                           ; * 0 = damping is enabled (default)
                                                           ; 
                                                           ; * &FF = damping is disabled
                                                           ; 
                                                           ; Toggled by pressing CAPS LOCK when paused, see the
                                                           ; DKS3 routine for details

DJD:
       bss 1                                               ; Keyboard auto-recentre configuration setting
                                                           ; 
                                                           ; * 0 = auto-recentre is enabled (default)
                                                           ; 
                                                           ; * &FF = auto-recentre is disabled
                                                           ; 
                                                           ; Toggled by pressing "A" when paused, see the DKS3
                                                           ; routine for details

PATG:
       bss 1                                               ; Configuration setting to show the author names on the
                                                           ; start-up screen and enable manual hyperspace mis-jumps
                                                           ; 
                                                           ; * 0 = no author names or manual mis-jumps (default)
                                                           ; 
                                                           ; * &FF = show author names and allow manual mis-jumps
                                                           ; 
                                                           ; Toggled by pressing "X" when paused, see the DKS3
                                                           ; routine for details
                                                           ; 
                                                           ; This needs to be turned on for manual mis-jumps to be
                                                           ; possible. To do a manual mis-jump, first toggle the
                                                           ; author display by pausing the game (COPY) and pressing
                                                           ; "X", and during the next hyperspace, hold down CTRL to
                                                           ; force a mis-jump. See routine ee5 for the "AND PATG"
                                                           ; instruction that implements this logic

FLH:
       bss 1                                               ; Flashing console bars configuration setting
                                                           ; 
                                                           ; * 0 = static bars (default)
                                                           ; 
                                                           ; * &FF = flashing bars
                                                           ; 
                                                           ; Toggled by pressing "F" when paused, see the DKS3
                                                           ; routine for details

JSTGY:
       bss 1                                               ; Reverse joystick Y-channel configuration setting
                                                           ; 
                                                           ; * 0 = standard Y-channel (default)
                                                           ; 
                                                           ; * &FF = reversed Y-channel
                                                           ; 
                                                           ; Toggled by pressing "Y" when paused, see the DKS3
                                                           ; routine for details

JSTE:
       bss 1                                               ; Reverse both joystick channels configuration setting
                                                           ; 
                                                           ; * 0 = standard channels (default)
                                                           ; 
                                                           ; * &FF = reversed channels
                                                           ; 
                                                           ; Toggled by pressing "J" when paused, see the DKS3
                                                           ; routine for details

JSTK:
       bss 1                                               ; Keyboard or joystick configuration setting
                                                           ; 
                                                           ; * 0 = keyboard (default)
                                                           ; 
                                                           ; * &FF = joystick
                                                           ; 
                                                           ; Toggled by pressing "K" when paused, see the DKS3
                                                           ; routine for details

* ******************************************************************************
* 
* Name: Main flight loop (Part 1 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Seed the random number generator
* Deep dive: Program flow of the main game loop
* Generating random numbers
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Seed the random number generator
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* M%                  The entry point for the main flight loop
* 
* ******************************************************************************

M.:
       movb @K.,ra                     ; LDA K%            ; We want to seed the random number generator with a
                                                           ; pretty random number, so fetch the contents of K%,
                                                           ; which is the x_lo coordinate of the planet. This value
                                                           ; will be fairly unpredictable, so it's a pretty good
                                                           ; candidate

       movb ra,@RAND                   ; STA RAND          ; Store the seed in the first byte of the four-byte
                                                           ; random number seed that's stored in RAND

* ******************************************************************************
* 
* Name: Main flight loop (Part 2 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Calculate the alpha and beta angles from the current pitch and
* roll of our ship
* Deep dive: Program flow of the main game loop
* Pitching and rolling
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Calculate the alpha and beta angles from the current pitch and roll
* 
* Here we take the current rate of pitch and roll, as set by the joystick or
* keyboard, and convert them into alpha and beta angles that we can use in the
* matrix functions to rotate space around our ship. The alpha angle covers
* roll, while the beta angle covers pitch (there is no yaw in this version of
* Elite). The angles are in radians, which allows us to use the small angle
* approximation when moving objects in the sky (see the MVEIT routine for more
* on this). Also, the signs of the two angles are stored separately, in both
* the sign and the flipped sign, as this makes calculations easier.
* 
* ******************************************************************************

       movb @JSTX,rx                   ; LDX JSTX          ; Set X to the current rate of roll in JSTX

       .jsr @cntr_                     ; JSR cntr          ; Apply keyboard damping twice (if enabled) so the roll
       .jsr @cntr_                     ; JSR cntr          ; rate in X creeps towards the centre by 2

                                                           ; The roll rate in JSTX increases if we press ">" (and
                                                           ; the RL indicator on the dashboard goes to the right)
                                                           ; 
                                                           ; This rolls our ship to the right (clockwise), but we
                                                           ; actually implement this by rolling everything else
                                                           ; to the left (anti-clockwise), so a positive roll rate
                                                           ; in JSTX translates to a negative roll angle alpha

       movb rx,ra                      ; TXA               ; Set A and Y to the roll rate but with the sign bit
       .eoi (>80*256)                  ; EOR #%10000000    ; flipped (i.e. set them to the sign we want for alpha)
       movb ra,ry                      ; TAY               

       andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the roll rate and store
       movb ra,@ALP2                   ; STA ALP2          ; in ALP2 (so ALP2 contains the sign of the roll angle
                                                           ; alpha)

       movb rx,@JSTX                   ; STX JSTX          ; Update JSTX with the damped value that's still in X

       .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the roll rate and store
       movb ra,@ALP2+1                 ; STA ALP2+1        ; in ALP2+1 (so ALP2+1 contains the flipped sign of the
                                                           ; roll angle alpha)

       movb ry,ra                      ; TYA               ; Set A to the roll rate but with the sign bit flipped

       jgt  B01                        ; BPL B01           ; If the value of A is positive, skip the following
                                                           ; three instructions

       .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so change the sign of A using two's
       .clc                            ; CLC               ; complement so that A is now positive and contains
       .adi (>01*256)                  ; ADC #1            ; the absolute value of the roll rate, i.e. |JSTX|

B01:
       srl  ra,1                       ; LSR A             ; Divide the (positive) roll rate in A by 4
       srl  ra,1                       ; LSR A             

       ci   ra,>08*256                 ; CMP #8            ; If A >= 8, skip the following two instructions
       joc  B02                        ; BCS B02           

       srl  ra,1                       ; LSR A             ; A < 8, so halve A again

       .clc                            ; CLC               ; This instruction has no effect, as we only get here
                                                           ; if the C flag is clear (if it is set, we skip this
                                                           ; instruction)
B02:
       movb ra,@ALP1                   ; STA ALP1          ; Store A in ALP1, so we now have:
                                                           ; 
                                                           ; ALP1 = |JSTX| / 8    if |JSTX| < 32
                                                           ; 
                                                           ; ALP1 = |JSTX| / 4    if |JSTX| >= 32
                                                           ; 
                                                           ; This means that at lower roll rates, the roll angle is
                                                           ; reduced closer to zero than at higher roll rates,
                                                           ; which gives us finer control over the ship's roll at
                                                           ; lower roll rates
                                                           ; 
                                                           ; Because JSTX is in the range -127 to +127, ALP1 is
                                                           ; in the range 0 to 31

       socb @ALP2,ra                   ; ORA ALP2          ; Store A in ALPHA, but with the sign set to ALP2 (so
       movb ra,@ALPHA                  ; STA ALPHA         ; ALPHA has a different sign to the actual roll rate)

       movb @JSTY,rx                   ; LDX JSTY          ; Set X to the current rate of pitch in JSTY

       .jsr @cntr_                     ; JSR cntr          ; Apply keyboard damping so the pitch rate in X creeps
                                                           ; towards the centre by 1

       movb rx,ra                      ; TXA               ; Set A and Y to the pitch rate but with the sign bit
       .eoi (>80*256)                  ; EOR #%10000000    ; flipped
       movb ra,ry                      ; TAY               

       andi ra,>80*256                 ; AND #%10000000    ; Extract the flipped sign of the pitch rate into A

       movb rx,@JSTY                   ; STX JSTY          ; Update JSTY with the damped value that's still in X

       movb ra,@BET2+1                 ; STA BET2+1        ; Store the flipped sign of the pitch rate in BET2+1

       .eoi (>80*256)                  ; EOR #%10000000    ; Extract the correct sign of the pitch rate and store
       movb ra,@BET2                   ; STA BET2          ; it in BET2

       movb ry,ra                      ; TYA               ; Set A to the pitch rate but with the sign bit flipped

       jgt  B03                        ; BPL B03           ; If the value of A is positive, skip the following
                                                           ; instruction

       .eoi (>ff*256)                  ; EOR #%11111111    ; A is negative, so flip the bits

B03:
       .adi (>04*256)                  ; ADC #4            ; Add 4 to the (positive) pitch rate, so the maximum
                                                           ; value is now up to 131 (rather than 127)

       srl  ra,1                       ; LSR A             ; Divide the (positive) pitch rate in A by 16
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             

       ci   ra,>03*256                 ; CMP #3            ; If A >= 3, skip the following instruction
       joc  B04                        ; BCS B04           

       srl  ra,1                       ; LSR A             ; A < 3, so halve A again

B04:
       movb ra,@BET1                   ; STA BET1          ; Store A in BET1, so we now have:
                                                           ; 
                                                           ; BET1 = |JSTY| / 32    if |JSTY| < 48
                                                           ; 
                                                           ; BET1 = |JSTY| / 16    if |JSTY| >= 48
                                                           ; 
                                                           ; This means that at lower pitch rates, the pitch angle
                                                           ; is reduced closer to zero than at higher pitch rates,
                                                           ; which gives us finer control over the ship's pitch at
                                                           ; lower pitch rates
                                                           ; 
                                                           ; Because JSTY is in the range -131 to +131, BET1 is in
                                                           ; the range 0 to 8

       socb @BET2,ra                   ; ORA BET2          ; Store A in BETA, but with the sign set to BET2 (so
       movb ra,@BETA                   ; STA BETA          ; BETA has the same sign as the actual pitch rate)

* ******************************************************************************
* 
* Name: Main flight loop (Part 3 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Scan for flight keys and process the results
* Deep dive: Program flow of the main game loop
* The key logger
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Scan for flight keys and process the results
* 
* Flight keys are logged in the key logger at location KY1 onwards, with a
* non-zero value in the relevant location indicating a key press. See the deep
* dive on "The key logger" for more details.
* 
* The key presses that are processed are as follows:
* 
* * Space and "?" to speed up and slow down
* * "U", "T" and "M" to disarm, arm and fire missiles
* * TAB to fire an energy bomb
* * ESCAPE to launch an escape pod
* * "J" to initiate an in-system jump
* * "E" to deploy E.C.M. anti-missile countermeasures
* * "C" to use the docking computer
* * "A" to fire lasers
* 
* ******************************************************************************

       movb @KY2,ra                    ; LDA KY2           ; If Space is being pressed, keep going, otherwise jump
       jeq  MA17                       ; BEQ MA17          ; down to MA17 to skip the following

       movb @DELTA,ra                  ; LDA DELTA         ; The "go faster" key is being pressed, so first we
       ci   ra,>28*256                 ; CMP #40           ; fetch the current speed from DELTA into A, and if
       joc  MA17                       ; BCS MA17          ; A >= 40, we are already going at full pelt, so jump
                                                           ; down to MA17 to skip the following

       ab   rone,ra                    ; INC DELTA         ; We can go a bit faster, so increment the speed in
                                                           ; location DELTA

MA17:
       movb @KY1,ra                    ; LDA KY1           ; If "?" is being pressed, keep going, otherwise jump
       jeq  MA4                        ; BEQ MA4           ; down to MA4 to skip the following

       sb   rone,ra                    ; DEC DELTA         ; The "slow down" key is being pressed, so we decrement
                                                           ; the current ship speed in DELTA

       jne  MA4                        ; BNE MA4           ; If the speed is still greater than zero, jump to MA4

       ab   rone,ra                    ; INC DELTA         ; Otherwise we just braked a little too hard, so bump
                                                           ; the speed back up to the minimum value of 1

MA4:
       movb @KY15,ra                   ; LDA KY15          ; If "U" is being pressed and the number of missiles
       .and @NOMSL                     ; AND NOMSL         ; in NOMSL is non-zero, keep going, otherwise jump down
       jeq  MA20                       ; BEQ MA20          ; to MA20 to skip the following

       li   ry,>ee*256                 ; LDY #&EE          ; The "disarm missiles" key is being pressed, so call
       .jsr @ABORT                     ; JSR ABORT         ; ABORT to disarm the missile and update the missile
                                                           ; indicators on the dashboard to green/cyan (Y = &EE)

       li   ra,>28*256                 ; LDA #40           ; Call the NOISE routine with A = 40 to make a low,
       .jsr @NOISE                     ; JSR NOISE         ; long beep to indicate the missile is now disarmed

MA31:
       li   ra,>00*256                 ; LDA #0            ; Set MSAR to 0 to indicate that no missiles are
       movb ra,@MSAR                   ; STA MSAR          ; currently armed

MA20:
       movb @MSTG,ra                   ; LDA MSTG          ; If MSTG is positive (i.e. it does not have bit 7 set),
       jgt  MA25                       ; BPL MA25          ; then it indicates we already have a missile locked on
                                                           ; a target (in which case MSTG contains the ship number
                                                           ; of the target), so jump to MA25 to skip targeting. Or
                                                           ; to put it another way, if MSTG = &FF, which means
                                                           ; there is no current target lock, keep going

       movb @KY14,ra                   ; LDA KY14          ; If "T" is being pressed, keep going, otherwise jump
       jeq  MA25                       ; BEQ MA25          ; down to MA25 to skip the following

       movb @NOMSL,rx                  ; LDX NOMSL         ; If the number of missiles in NOMSL is zero, jump down
       jeq  MA25                       ; BEQ MA25          ; to MA25 to skip the following

       movb ra,@MSAR                   ; STA MSAR          ; The "target missile" key is being pressed and we have
                                                           ; at least one missile, so set MSAR = &FF to denote that
                                                           ; our missile is currently armed (we know A has the
                                                           ; value &FF, as we just loaded it from MSTG and checked
                                                           ; that it was negative)

       li   ry,>e0*256                 ; LDY #&E0          ; Change the leftmost missile indicator to yellow/white
       .jsr @MSBAR                     ; JSR MSBAR         ; on the missile bar (this call changes the leftmost
                                                           ; indicator because we set X to the number of missiles
                                                           ; in NOMSL above, and the indicators are numbered from
                                                           ; right to left, so X is the number of the leftmost
                                                           ; indicator)

MA25:
       movb @KY16,ra                   ; LDA KY16          ; If "M" is being pressed, keep going, otherwise jump
       jeq  MA24                       ; BEQ MA24          ; down to MA24 to skip the following

       movb @MSTG,ra                   ; LDA MSTG          ; If MSTG = &FF then there is no target lock, so jump to
       jlt  MA64                       ; BMI MA64          ; MA64 to skip the following (also skipping the checks
                                                           ; for TAB, ESCAPE, "J" and "E")

       .jsr @FRMIS                     ; JSR FRMIS         ; The "fire missile" key is being pressed and we have
                                                           ; a missile lock, so call the FRMIS routine to fire
                                                           ; the missile

MA24:
       movb @KY12,ra                   ; LDA KY12          ; If TAB is being pressed, keep going, otherwise jump
       jeq  MA76                       ; BEQ MA76          ; down to MA76 to skip the following

       .asl @BOMB                      ; ASL BOMB          ; The "energy bomb" key is being pressed, so double
                                                           ; the value in BOMB. If we have an energy bomb fitted,
                                                           ; BOMB will contain &7F (%01111111) before this shift
                                                           ; and will contain &FE (%11111110) after the shift; if
                                                           ; we don't have an energy bomb fitted, BOMB will still
                                                           ; contain 0. The bomb explosion is dealt with in the
                                                           ; MAL1 routine below - this just registers the fact that
                                                           ; we've set the bomb ticking

MA76:
       movb @KY13,ra                   ; LDA KY13          ; If ESCAPE is being pressed and we have an escape pod
       .and @ESCP                      ; AND ESCP          ; fitted, keep going, otherwise skip the next
       jeq  B05                        ; BEQ B05           ; instruction

       b    @ESCAPE                    ; JMP ESCAPE        ; The button is being pressed to launch an escape pod
                                                           ; and we have an escape pod fitted, so jump to ESCAPE to
                                                           ; launch it, and exit the main flight loop using a tail
                                                           ; call

B05:
       movb @KY18,ra                   ; LDA KY18          ; If "J" is being pressed, keep going, otherwise skip
       jeq  B06                        ; BEQ B06           ; the next instruction

       .jsr @WARP                      ; JSR WARP          ; Call the WARP routine to do an in-system jump

B06:
       movb @KY17,ra                   ; LDA KY17          ; If "E" is being pressed and we have an E.C.M. fitted,
       .and @ECM                       ; AND ECM           ; keep going, otherwise jump down to MA64 to skip the
       jeq  MA64                       ; BEQ MA64          ; following

       movb @ECMA,ra                   ; LDA ECMA          ; If ECMA is non-zero, that means an E.C.M. is already
       jne  MA64                       ; BNE MA64          ; operating and is counting down (this can be either
                                                           ; our E.C.M. or an opponent's), so jump down to MA64 to
                                                           ; skip the following (as we can't have two E.C.M.
                                                           ; systems operating at the same time)

       sb   rone,ra                    ; DEC ECMP          ; The E.C.M. button is being pressed and nobody else
                                                           ; is operating their E.C.M., so decrease the value of
                                                           ; ECMP to make it non-zero, to denote that our E.C.M.
                                                           ; is now on

       .jsr @ECBLB2                    ; JSR ECBLB2        ; Call ECBLB2 to light up the E.C.M. indicator bulb on
                                                           ; the dashboard, set the E.C.M. countdown timer to 32,
                                                           ; and start making the E.C.M. sound

MA64:
       movb @KY19,ra                   ; LDA KY19          ; If "C" is being pressed, and we have a docking
       .and @DKCMP                     ; AND DKCMP         ; computer fitted, and we are inside the space station's
       .and @SSPR                      ; AND SSPR          ; safe zone, keep going, otherwise jump down to MA68 to
       jeq  MA68                       ; BEQ MA68          ; skip the following

       movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
       jlt  MA68                       ; BMI MA68          ; from the ship data workspace at K%, which is reserved
                                                           ; for the sun or the space station (in this case it's
                                                           ; the latter as we are in the safe zone). If byte #32 is
                                                           ; negative, meaning the station is hostile, then jump
                                                           ; down to MA68 to skip the following (so we can't use
                                                           ; the docking computer to dock at a station that has
                                                           ; turned against us)

       b    @GOIN                      ; JMP GOIN          ; The Docking Computer button has been pressed and
                                                           ; we are allowed to dock at the station, so jump to
                                                           ; GOIN to dock (or "go in"), and exit the main flight
                                                           ; loop using a tail call

MA68:
       li   ra,>00*256                 ; LDA #0            ; Set LAS = 0, to switch the laser off while we do the
       movb ra,@LAS                    ; STA LAS           ; following logic

       movb ra,@DELT4                  ; STA DELT4         ; Take the 16-bit value (DELTA 0) - i.e. a two-byte
       movb @DELTA,ra                  ; LDA DELTA         ; number with DELTA as the high byte and 0 as the low
       srl  ra,1                       ; LSR A             ; byte - and divide it by 4, storing the 16-bit result
       .ror @DELT4                     ; ROR DELT4         ; in DELT4(1 0). This has the effect of storing the
       srl  ra,1                       ; LSR A             ; current speed * 64 in the 16-bit location DELT4(1 0)
       .ror @DELT4                     ; ROR DELT4         
       movb ra,@DELT4+1                ; STA DELT4+1       

       movb @LASCT,ra                  ; LDA LASCT         ; If LASCT is zero, keep going, otherwise the laser is
       jne  MA3                        ; BNE MA3           ; a pulse laser that is between pulses, so jump down to
                                                           ; MA3 to skip the following

       movb @KY7,ra                    ; LDA KY7           ; If "A" is being pressed, keep going, otherwise jump
       jeq  MA3                        ; BEQ MA3           ; down to MA3 to skip the following

       movb @GNTMP,ra                  ; LDA GNTMP         ; If the laser temperature >= 242 then the laser has
       ci   ra,>f2*256                 ; CMP #242          ; overheated, so jump down to MA3 to skip the following
       joc  MA3                        ; BCS MA3           

       movb @VIEW,rx                   ; LDX VIEW          ; If the current space view has a laser fitted (i.e. the
       movb @LASER(rx),ra              ; LDA LASER,X       ; laser power for this view is greater than zero), then
       jeq  MA3                        ; BEQ MA3           ; keep going, otherwise jump down to MA3 to skip the
                                                           ; following

                                                           ; If we get here, then the "fire" button is being
                                                           ; pressed, our laser hasn't overheated and isn't already
                                                           ; being fired, and we actually have a laser fitted to
                                                           ; the current space view, so it's time to hit me with
                                                           ; those laser beams

       .pha                            ; PHA               ; Store the current view's laser power on the stack

       andi ra,>7f*256                 ; AND #%01111111    ; Set LAS and LAS2 to bits 0-6 of the laser power
       movb ra,@LAS                    ; STA LAS           
       movb ra,@LAS2                   ; STA LAS2          

       li   ra,>00*256                 ; LDA #0            ; Call the NOISE routine with A = 0 to make the sound
       .jsr @NOISE                     ; JSR NOISE         ; of our laser firing

       .jsr @LASLI                     ; JSR LASLI         ; Call LASLI to draw the laser lines

       .pla                            ; PLA               ; Restore the current view's laser power into A

       jgt  ma1_                       ; BPL ma1           ; If the laser power has bit 7 set, then it's an "always
                                                           ; on" laser rather than a pulsing laser, so keep going,
                                                           ; otherwise jump down to ma1 to skip the following
                                                           ; instruction

       li   ra,>00*256                 ; LDA #0            ; This is an "always on" laser (i.e. a beam laser,
                                                           ; as this version of Elite doesn't have military
                                                           ; lasers), so set A = 0, which will be stored in LASCT
                                                           ; to denote that this is not a pulsing laser

ma1_:
       andi ra,>fa*256                 ; AND #%11111010    ; LASCT will be set to 0 for beam lasers, and to the
       movb ra,@LASCT                  ; STA LASCT         ; laser power AND %11111010 for pulse lasers, which
                                                           ; comes to 10 (as pulse lasers have a power of 15). See
                                                           ; MA23 below for more on laser pulsing and LASCT

* ******************************************************************************
* 
* Name: Main flight loop (Part 4 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Copy the ship's data block from K% to the
* zero-page workspace at INWK
* Deep dive: Program flow of the main game loop
* Ship data blocks
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Start looping through all the ships in the local bubble, and for each
* one:
* 
* * Copy the ship's data block from K% to INWK
* 
* * Set XX0 to point to the ship's blueprint (if this is a ship)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MAL1                Marks the beginning of the ship analysis loop, so we
* can jump back here from part 12 of the main flight loop
* to work our way through each ship in the local bubble.
* We also jump back here when a ship is removed from the
* bubble, so we can continue processing from the next ship
* 
* ******************************************************************************

MA3:
       li   rx,>00*256                 ; LDX #0            ; We're about to work our way through all the ships in
                                                           ; our local bubble of universe, so set a counter in X,
                                                           ; starting from 0, to refer to each ship slot in turn

MAL1:
       movb rx,@XSAV                   ; STX XSAV          ; Store the current slot number in XSAV

       movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the contents of this slot into A. If it is 0
       jne  B07                        ; BNE B07           ; then this slot is empty and we have no more ships to
       b    @MA18                      ; JMP MA18          ; process, so jump to MA18 below, otherwise A contains
                                                           ; the type of ship that's in this slot, so skip over the
                                                           ; JMP MA18 instruction and keep going

B07:
       movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE

       .jsr @GINF                      ; JSR GINF          ; Call GINF to fetch the address of the ship data block
                                                           ; for the ship in slot X and store it in INF. The data
                                                           ; block is in the K% workspace, which is where all the
                                                           ; ship data blocks are stored

                                                           ; Next we want to copy the ship data block from INF to
                                                           ; the zero-page workspace at INWK, so we can process it
                                                           ; more efficiently

       li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in each ship data block (and in
                                                           ; the INWK workspace, so we set a counter in Y so we can
                                                           ; loop through them

MAL2:
       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Load the Y-th byte of INF and store it in the Y-th
       movb ra,@INWK(ry)               ; STA INWK,Y        ; byte of INWK

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jgt  MAL2                       ; BPL MAL2          ; Loop back for the next byte until we have copied the
                                                           ; last byte from INF to INWK

       movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
       jlt  MA21                       ; BMI MA21          ; planet or sun, so jump down to MA21, as the next bit
                                                           ; sets up a pointer to the ship blueprint, and then
                                                           ; checks for energy bomb damage, and neither of these
                                                           ; apply to planets and suns

       .asla                           ; ASL A             ; Set Y = ship type * 2
       movb ra,ry                      ; TAY               

       movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
       movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
                                                           ; so this fetches the low byte of this particular ship
                                                           ; type's blueprint and stores it in XX0

       movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
       movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1

* ******************************************************************************
* 
* Name: Main flight loop (Part 5 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: If an energy bomb has been set off,
* potentially kill this ship
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * If an energy bomb has been set off and this ship can be killed, kill it
* and increase the kill tally
* 
* ******************************************************************************

       movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
       jgt  MA21                       ; BPL MA21          ; BOMB is now negative, so this skips to MA21 if our
                                                           ; energy bomb is not going off

       ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship in Y is the space station, jump to BA21
       jeq  MA21                       ; BEQ MA21          ; as energy bombs are useless against space stations

       movb @INWK+31,ra                ; LDA INWK+31       ; If the ship we are checking has bit 5 set in its ship
       andi ra,>20*256                 ; AND #%00100000    ; byte #31, then it is already exploding, so jump to
       jne  MA21                       ; BNE MA21          ; BA21 as ships can't explode more than once

       movb @INWK+31,ra                ; LDA INWK+31       ; The energy bomb is killing this ship, so set bit 7 of
       ori  ra,>80*256                 ; ORA #%10000000    ; the ship byte #31 to indicate that it has now been
       movb ra,@INWK+31                ; STA INWK+31       ; killed

       .jsr @EXNO2                     ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
                                                           ; ship (so increase the kill tally, make an explosion
                                                           ; sound and possibly display "RIGHT ON COMMANDER!")

* ******************************************************************************
* 
* Name: Main flight loop (Part 6 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Move the ship in space and copy the updated
* INWK data block back to K%
* Deep dive: Program flow of the main game loop
* Program flow of the ship-moving routine
* Ship data blocks
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * Move the ship in space
* 
* * Copy the updated ship's data block from INWK back to K%
* 
* ******************************************************************************

MA21:
       .jsr @MVEIT                     ; JSR MVEIT         ; Call MVEIT to move the ship we are processing in space

                                                           ; Now that we are done processing this ship, we need to
                                                           ; copy the ship data back from INWK to the correct place
                                                           ; in the K% workspace. We already set INF in part 4 to
                                                           ; point to the ship's data block in K%, so we can simply
                                                           ; do the reverse of the copy we did before, this time
                                                           ; copying from INWK to INF

       li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Set a counter in Y so we can loop through the NI%
                                                           ; bytes in the ship data block

MAL3:
       movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store it in the Y-th
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; byte of INF

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jgt  MAL3                       ; BPL MAL3          ; Loop back for the next byte, until we have copied the
                                                           ; last byte from INWK back to INF

* ******************************************************************************
* 
* Name: Main flight loop (Part 7 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Check whether we are docking, scooping or
* colliding with it
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * Check how close we are to this ship and work out if we are docking,
* scooping or colliding with it
* 
* ******************************************************************************

       movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the status of this ship from bits 5 (is ship
       andi ra,>a0*256                 ; AND #%10100000    ; exploding?) and bit 7 (has ship been killed?) from
                                                           ; ship byte #31 into A

       .jsr @MAS4                      ; JSR MAS4          ; Or this value with x_hi, y_hi and z_hi

       jne  MA65                       ; BNE MA65          ; If this value is non-zero, then either the ship is
                                                           ; far away (i.e. has a non-zero high byte in at least
                                                           ; one of the three axes), or it is already exploding,
                                                           ; or has been flagged as being killed - in which case
                                                           ; jump to MA65 to skip the following, as we can't dock
                                                           ; scoop or collide with it

       movb @INWK,ra                   ; LDA INWK          ; Set A = (x_lo OR y_lo OR z_lo), and if bit 7 of the
       socb @INWK+3,ra                 ; ORA INWK+3        ; result is set, the ship is still a fair distance
       socb @INWK+6,ra                 ; ORA INWK+6        ; away (further than 127 in at least one axis), so jump
       jlt  MA65                       ; BMI MA65          ; to MA65 to skip the following, as it's too far away to
                                                           ; dock, scoop or collide with

       movb @TYPE,rx                   ; LDX TYPE          ; If the current ship type is negative then it's either
       jlt  MA65                       ; BMI MA65          ; a planet or a sun, so jump down to MA65 to skip the
                                                           ; following, as we can't dock with it or scoop it

       ci   rx,(SST)*256               ; CPX #SST          ; If this ship is the space station, jump to ISDK to
       jeq  ISDK                       ; BEQ ISDK          ; check whether we are docking with it

       andi ra,>c0*256                 ; AND #%11000000    ; If bit 6 of (x_lo OR y_lo OR z_lo) is set, then the
       jne  MA65                       ; BNE MA65          ; ship is still a reasonable distance away (further than
                                                           ; 63 in at least one axis), so jump to MA65 to skip the
                                                           ; following, as it's too far away to dock, scoop or
                                                           ; collide with

       ci   rx,(MSL)*256               ; CPX #MSL          ; If this ship is a missile, jump down to MA65 to skip
       jeq  MA65                       ; BEQ MA65          ; the following, as we can't scoop or dock with a
                                                           ; missile, and it has its own dedicated collision
                                                           ; checks in the TACTICS routine

       ci   rx,(OIL)*256               ; CPX #OIL          ; If ship type >= OIL (i.e. it's a cargo canister,
       joc  B08                        ; BCS B08           ; Thargon or escape pod), skip the JMP instruction and
       b    @MA58                      ; JMP MA58          ; continue on, otherwise jump to MA58 to process a
                                                           ; potential collision

B08:
       movb @BST,ra                    ; LDA BST           ; If we have fuel scoops fitted then BST will be &FF,
                                                           ; otherwise it will be 0

       .and @INWK+5                    ; AND INWK+5        ; Ship byte #5 contains the y_sign of this ship, so a
                                                           ; negative value here means the canister is below us,
                                                           ; which means the result of the AND will be negative if
                                                           ; the canister is below us and we have a fuel scoop
                                                           ; fitted

       jgt  MA58                       ; BPL MA58          ; If the result is positive, then we either have no
                                                           ; scoop or the canister is above us, and in both cases
                                                           ; this means we can't scoop the item, so jump to MA58
                                                           ; to process a collision

* ******************************************************************************
* 
* Name: Main flight loop (Part 8 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Process us potentially scooping this item
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * Process us potentially scooping this item
* 
* ******************************************************************************

       li   ra,>03*256                 ; LDA #3            ; Set A to 3 to denote we may be scooping an escape pod

       ci   rx,(TGL)*256               ; CPX #TGL          ; If ship type < Thargon, i.e. it's a canister, jump
       jnc  oily_                      ; BCC oily          ; to oily to randomly decide the canister's contents

       jne  slvy2_                     ; BNE slvy2         ; If ship type <> Thargon, i.e. it's an escape pod,
                                                           ; jump to slvy2 with A set to 3, so we scoop up the
                                                           ; escape pod as slaves

       li   ra,>10*256                 ; LDA #16           ; Otherwise this is a Thargon, so jump to slvy2 with
       jne  slvy2_                     ; BNE slvy2         ; A set to 16, so we scoop up the Thargon as alien items
                                                           ; (this BNE is effectively a JMP as A will never be
                                                           ; zero)

oily_:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers and reduce A to a
       andi ra,>07*256                 ; AND #7            ; random number in the range 0-7

slvy2_:
                                                           ; By the time we get here, we are scooping, and A
                                                           ; contains the type of item we are scooping (a random
                                                           ; number 0-7 if we are scooping a cargo canister, 3 if
                                                           ; we are scooping an escape pod, or 16 if we are
                                                           ; scooping a Thargon). These numbers correspond to the
                                                           ; relevant market items (see QQ23 for a list), so a
                                                           ; cargo canister can contain anything from food to
                                                           ; computers, while escape pods contain slaves, and
                                                           ; Thargons become alien items when scooped
       movb ra,@QQ29                   ; STA QQ29          ; Call tnpr with the scooped cargo type stored in QQ29
       li   ra,>01*256                 ; LDA #1            ; and A set to 1, to work out whether we have room in
       .jsr @tnpr_                     ; JSR tnpr          ; the hold for the scooped item (A is preserved by this
                                                           ; call, and the C flag contains the result)

       li   ry,>4e*256                 ; LDY #78           ; This instruction has no effect, so presumably it used
                                                           ; to do something, but didn't get removed

       joc  MA59                       ; BCS MA59          ; If the C flag is set then we have no room in the hold
                                                           ; for the scooped item, so jump down to MA59 make a
                                                           ; sound to indicate failure, before destroying the
                                                           ; canister

       movb @QQ29,ry                   ; LDY QQ29          ; Scooping was successful, so set Y to the type of
                                                           ; item we just scooped, which we stored in QQ29 above

       .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Add A (which we set to 1 above) to the number of items
       movb ra,@QQ20(ry)               ; STA QQ20,Y        ; of type Y in the cargo hold, as we just successfully
                                                           ; scooped one canister of type Y

       movb ry,ra                      ; TYA               ; Print recursive token 48 + Y as an in-flight token,
       .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
       .jsr @MESS                      ; JSR MESS          ; ITEMS"), so this prints the scooped item's name

       b    @MA60                      ; JMP MA60          ; We are done scooping, so jump down to MA60 to set the
                                                           ; kill flag on the canister, as it no longer exists in
                                                           ; the local bubble

MA65:
       b    @MA26                      ; JMP MA26          ; If we get here, then the ship we are processing was
                                                           ; too far away to be scooped, docked or collided with,
                                                           ; so jump to MA26 to skip over the collision routines
                                                           ; and move on to missile targeting

* ******************************************************************************
* 
* Name: Main flight loop (Part 9 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: If it is a space station, check whether we
* are successfully docking with it
* Deep dive: Program flow of the main game loop
* Docking checks
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Process docking with a space station
* 
* For details on the various docking checks in this routine, see the deep dive
* on "Docking checks".
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* GOIN                We jump here from part 3 of the main flight loop if the
* docking computer is activated by pressing "C"
* 
* ******************************************************************************

ISDK:
       movb @K.+NI.+32,ra              ; LDA K%+NI%+32     ; 1. Fetch the AI counter (byte #32) of the second ship
       jlt  MA62                       ; BMI MA62          ; in the ship data workspace at K%, which is reserved
                                                           ; for the sun or the space station (in this case it's
                                                           ; the latter), and if it's negative, i.e. bit 7 is set,
                                                           ; meaning the station is hostile, jump down to MA62 to
                                                           ; fail docking (so trying to dock at a station that we
                                                           ; have annoyed does not end well)

       movb @INWK+14,ra                ; LDA INWK+14       ; 2. If nosev_z_hi < 214, jump down to MA62 to fail
       ci   ra,>d6*256                 ; CMP #214          ; docking, as the angle of approach is greater than 26
       jnc  MA62                       ; BCC MA62          ; degrees

       .jsr @SPS4                      ; JSR SPS4          ; Call SPS4 to get the vector to the space station
                                                           ; into XX15

       movb @XX15+2,ra                 ; LDA XX15+2        ; 3. Check the sign of the z-axis (bit 7 of XX15+2) and
       jlt  MA62                       ; BMI MA62          ; if it is negative, we are facing away from the
                                                           ; station, so jump to MA62 to fail docking

       ci   ra,>59*256                 ; CMP #89           ; 4. If z-axis < 89, jump to MA62 to fail docking, as
       jnc  MA62                       ; BCC MA62          ; we are not in the 22.0 degree safe cone of approach

       movb @INWK+16,ra                ; LDA INWK+16       ; 5. If |roofv_x_hi| < 80, jump to MA62 to fail docking,
       andi ra,>7f*256                 ; AND #%01111111    ; as the slot is more than 36.6 degrees from horizontal
       ci   ra,>50*256                 ; CMP #80           
       jnc  MA62                       ; BCC MA62          

GOIN:
                                                           ; If we arrive here, either the docking computer has
                                                           ; been activated, or we just docked successfully
       li   ra,>00*256                 ; LDA #0            ; Set the on-screen hyperspace counter to 0
       movb ra,@QQ22+1                 ; STA QQ22+1        

       li   ra,>08*256                 ; LDA #8            ; This instruction has no effect, so presumably it used
                                                           ; to do something, and didn't get removed

       .jsr @LAUN                      ; JSR LAUN          ; Show the space station launch tunnel

       .jsr @RES4                      ; JSR RES4          ; Reset the shields and energy banks, stardust and INWK
                                                           ; workspace

       b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
                                                           ; screen)

MA62:
                                                           ; If we arrive here, docking has just failed
       movb @DELTA,ra                  ; LDA DELTA         ; If the ship's speed is < 5, jump to MA67 to register
       ci   ra,>05*256                 ; CMP #5            ; some damage, but not a huge amount
       jnc  MA67                       ; BCC MA67          

       b    @DEATH                     ; JMP DEATH         ; Otherwise we have just crashed into the station, so
                                                           ; process our death

* ******************************************************************************
* 
* Name: Main flight loop (Part 10 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Remove if scooped, or process collisions
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * Remove scooped item after both successful and failed scooping attempts
* 
* * Process collisions
* 
* ******************************************************************************

MA59:
                                                           ; If we get here then scooping failed
       .jsr @EXNO3                     ; JSR EXNO3         ; Make the sound of the cargo canister being destroyed
                                                           ; and fall through into MA60 to remove the canister
                                                           ; from our local bubble

MA60:
                                                           ; If we get here then scooping was successful
       .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the scooped or destroyed item, to denote
       .sec                            ; SEC               ; that it has been killed and should be removed from
       .ror @INWK+31                   ; ROR INWK+31       ; the local bubble

MA61:
       jne  MA26                       ; BNE MA26          ; Jump to MA26 to skip over the collision routines and
                                                           ; to move on to missile targeting (this BNE is
                                                           ; effectively a JMP as A will never be zero)

MA67:
                                                           ; If we get here then we have collided with something,
                                                           ; but not fatally
       li   ra,>01*256                 ; LDA #1            ; Set the speed in DELTA to 1 (i.e. a sudden stop)
       movb ra,@DELTA                  ; STA DELTA         

       li   ra,>05*256                 ; LDA #5            ; Set the amount of damage in A to 5 (a small dent) and
       jne  MA63                       ; BNE MA63          ; jump down to MA63 to process the damage (this BNE is
                                                           ; effectively a JMP as A will never be zero)

MA58:
                                                           ; If we get here, we have collided with something in a
                                                           ; potentially fatal way
       .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the ship we just collided with, to
       .sec                            ; SEC               ; denote that it has been killed and should be removed
       .ror @INWK+31                   ; ROR INWK+31       ; from the local bubble

       movb @INWK+35,ra                ; LDA INWK+35       ; Load A with the energy level of the ship we just hit

       .sec                            ; SEC               ; Set the amount of damage in A to 128 + A / 2, so
       .rora                           ; ROR A             ; this is quite a big dent, and colliding with higher
                                                           ; energy ships will cause more damage

MA63:
       .jsr @OOPS                      ; JSR OOPS          ; The amount of damage is in A, so call OOPS to reduce
                                                           ; our shields, and if the shields are gone, there's a
                                                           ; chance of cargo loss or even death

       .jsr @EXNO3                     ; JSR EXNO3         ; Make the sound of colliding with the other ship and
                                                           ; fall through into MA26 to try targeting a missile

* ******************************************************************************
* 
* Name: Main flight loop (Part 11 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Process missile lock and firing our laser
* Deep dive: Program flow of the main game loop
* Flipping axes between space views
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * If this is not the front space view, flip the axes of the ship's
* coordinates in INWK
* 
* * Process missile lock
* 
* * Process our laser firing
* 
* ******************************************************************************

MA26:
       movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to MA15 to skip
       jne  MA15                       ; BNE MA15          ; missile and laser locking

       .jsr @PLUT                      ; JSR PLUT          ; Call PLUT to update the geometric axes in INWK to
                                                           ; match the view (front, rear, left, right)

       .jsr @HITCH                     ; JSR HITCH         ; Call HITCH to see if this ship is in the crosshairs,
       jnc  MA8                        ; BCC MA8           ; in which case the C flag will be set (so if there is
                                                           ; no missile or laser lock, we jump to MA8 to skip the
                                                           ; following)

       movb @MSAR,ra                   ; LDA MSAR          ; We have missile lock, so check whether the leftmost
       jeq  MA47                       ; BEQ MA47          ; missile is currently armed, and if not, jump to MA47
                                                           ; to process laser fire, as we can't lock an unarmed
                                                           ; missile

       .jsr @BEEP                      ; JSR BEEP          ; We have missile lock and an armed missile, so call
                                                           ; the BEEP subroutine to make a short, high beep

       movb @XSAV,rx                   ; LDX XSAV          ; Call ABORT2 to store the details of this missile
       li   ry,>0e*256                 ; LDY #&0E          ; lock, with the targeted ship's slot number in X
       .jsr @ABORT2                    ; JSR ABORT2        ; (which we stored in XSAV at the start of this ship's
                                                           ; loop at MAL1), and set the colour of the missile
                                                           ; indicator to the colour in Y (red = &0E)

MA47:
                                                           ; If we get here then the ship is in our sights, but
                                                           ; we didn't lock a missile, so let's see if we're
                                                           ; firing the laser
       movb @LAS,ra                    ; LDA LAS           ; If we are firing the laser then LAS will contain the
       jeq  MA8                        ; BEQ MA8           ; laser power (which we set in MA68 above), so if this
                                                           ; is zero, jump down to MA8 to skip the following

       li   rx,>0f*256                 ; LDX #15           ; We are firing our laser and the ship in INWK is in
       .jsr @EXNO                      ; JSR EXNO          ; the crosshairs, so call EXNO to make the sound of
                                                           ; us making a laser strike on another ship

       movb @INWK+35,ra                ; LDA INWK+35       ; Fetch the hit ship's energy from byte #35 and subtract
       .sec                            ; SEC               ; our current laser power, and if the result is greater
       .sbc @LAS,ra                    ; SBC LAS           ; than zero, the other ship has survived the hit, so
       joc  MA14                       ; BCS MA14          ; jump down to MA14 to make it angry

       movb @TYPE,ra                   ; LDA TYPE          ; Did we just hit the space station? If so, jump to
       ci   ra,(SST)*256               ; CMP #SST          ; MA14+2 to make the station hostile, skipping the
       jeq  MA14+2                     ; BEQ MA14+2        ; following as we can't destroy a space station

       movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 7 of the enemy ship's byte #31, to indicate
       ori  ra,>80*256                 ; ORA #%10000000    ; that it has been killed
       movb ra,@INWK+31                ; STA INWK+31       

       joc  MA8                        ; BCS MA8           ; If the enemy ship type is >= SST (i.e. missile,
                                                           ; asteroid, canister, Thargon or escape pod) then
                                                           ; jump down to MA8

       .jsr @DORND                     ; JSR DORND         ; Fetch a random number, and jump to oh if it is
       jgt  oh_                        ; BPL oh            ; positive (50% chance)

       li   ry,>00*256                 ; LDY #0            ; Fetch the first byte of the hit ship's blueprint,
       .and_ind_y_idx @XX0,ra          ; AND (XX0),Y       ; which determines the maximum number of bits of
                                                           ; debris shown when the ship is destroyed, and AND
                                                           ; with the random number we just fetched

       movb ra,@CNT                    ; STA CNT           ; Store the result in CNT, so CNT contains a random
                                                           ; number between 0 and the maximum number of bits of
                                                           ; debris that this ship will release when destroyed

um_:
       jeq  oh_                        ; BEQ oh            ; We're going to go round a loop using CNT as a counter
                                                           ; so this checks whether the counter is zero and jumps
                                                           ; to oh when it gets there (which might be straight
                                                           ; away)

       li   rx,(OIL)*256               ; LDX #OIL          ; Call SFS1 to spawn a cargo canister from the now
       li   ra,>00*256                 ; LDA #0            ; deceased parent ship, giving the spawned canister an
       .jsr @SFS1                      ; JSR SFS1          ; AI flag of 0 (no AI, no E.C.M., non-hostile)

       sb   rone,ra                    ; DEC CNT           ; Decrease the loop counter

       jgt  um_                        ; BPL um            ; Jump back up to um (this BPL is effectively a JMP as
                                                           ; CNT will never be negative)

oh_:
       .jsr @EXNO2                     ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
                                                           ; ship (so increase the kill tally, make an explosion
                                                           ; sound and so on)

MA14:
       movb ra,@INWK+35                ; STA INWK+35       ; Store the hit ship's updated energy in ship byte #35

       movb @TYPE,ra                   ; LDA TYPE          ; Call ANGRY to make this ship hostile, now that we
       .jsr @ANGRY                     ; JSR ANGRY         ; have hit it

* ******************************************************************************
* 
* Name: Main flight loop (Part 12 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: For each nearby ship: Draw the ship, remove if killed, loop back
* Deep dive: Program flow of the main game loop
* Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Continue looping through all the ships in the local bubble, and for each
* one:
* 
* * Draw the ship
* 
* * Process removal of killed ships
* 
* * Loop back up to MAL1 to move onto the next ship in the local bubble
* 
* ******************************************************************************

MA8:
       .jsr @LL9                       ; JSR LL9           ; Call LL9 to draw the ship we're processing on-screen

MA15:
       li   ry,>23*256                 ; LDY #35           ; Fetch the ship's energy from byte #35 and copy it to
       movb @INWK+35,ra                ; LDA INWK+35       ; byte #35 in INF (so the ship's data in K% gets
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; updated)

       movb @INWK+31,ra                ; LDA INWK+31       ; If bit 7 of the ship's byte #31 is clear, then the
       jgt  MAC1                       ; BPL MAC1          ; ship hasn't been killed by energy bomb, collision or
                                                           ; laser fire, so jump to MAC1 to skip the following

       andi ra,>20*256                 ; AND #%00100000    ; If bit 5 of the ship's byte #31 is clear then the
       jeq  NBOUN                      ; BEQ NBOUN         ; ship is no longer exploding, so jump to NBOUN to skip
                                                           ; the following

       movb @TYPE,ra                   ; LDA TYPE          ; If the ship we just destroyed was a cop, keep going,
       ci   ra,(COPS)*256              ; CMP #COPS         ; otherwise jump to q2 to skip the following
       jne  q2_                        ; BNE q2            

       movb @FIST,ra                   ; LDA FIST          ; We shot the sheriff, so update our FIST flag
       ori  ra,>40*256                 ; ORA #64           ; ("fugitive/innocent status") to at least 64, which
       movb ra,@FIST                   ; STA FIST          ; will instantly make us a fugitive

q2_:
       movb @DLY,ra                    ; LDA DLY           ; If we already have an in-flight message on-screen (in
       socb @MJ,ra                     ; ORA MJ            ; which case DLY > 0), or we are in witchspace (in
       jne  KS1S                       ; BNE KS1S          ; which case MJ > 0), jump to KS1S to skip showing an
                                                           ; on-screen bounty for this kill

       li   ry,>0a*256                 ; LDY #10           ; Fetch byte #10 of the ship's blueprint, which is the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the bounty awarded when this ship is
       jeq  KS1S                       ; BEQ KS1S          ; killed (in Cr * 10), and if it's zero jump to KS1S as
                                                           ; there is no on-screen bounty to display

       movb ra,rx                      ; TAX               ; Put the low byte of the bounty into X

       ab   rone,ry                    ; INY               ; Fetch byte #11 of the ship's blueprint, which is the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; high byte of the bounty awarded (in Cr * 10), and put
       movb ra,ry                      ; TAY               ; it into Y

       .jsr @MCASH                     ; JSR MCASH         ; Call MCASH to add (Y X) to the cash pot

       li   ra,>00*256                 ; LDA #0            ; Print control code 0 (current cash, right-aligned to
       .jsr @MESS                      ; JSR MESS          ; width 9, then " CR", newline) as an in-flight message

KS1S:
       b    @KS1                       ; JMP KS1           ; Process the killing of this ship (which removes this
                                                           ; ship from its slot and shuffles all the other ships
                                                           ; down to close up the gap)

NBOUN:
       equ  $
MAC1:
       movb @TYPE,ra                   ; LDA TYPE          ; If the ship we are processing is a planet or sun,
       jlt  MA27                       ; BMI MA27          ; jump to MA27 to skip the following two instructions

       .jsr @FAROF                     ; JSR FAROF         ; If the ship we are processing is a long way away (its
       jnc  KS1S                       ; BCC KS1S          ; distance in any one direction is > 224, jump to KS1S
                                                           ; to remove the ship from our local bubble, as it's just
                                                           ; left the building

MA27:
       li   ry,>1f*256                 ; LDY #31           ; Fetch the ship's explosion/killed state from byte #31
       movb @INWK+31,ra                ; LDA INWK+31       ; and copy it to byte #31 in INF (so the ship's data in
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; K% gets updated)

       movb @XSAV,rx                   ; LDX XSAV          ; We're done processing this ship, so fetch the ship's
                                                           ; slot number, which we saved in XSAV back at the start
                                                           ; of the loop

       ab   rone,rx                    ; INX               ; Increment the slot number to move on to the next slot

       b    @MAL1                      ; JMP MAL1          ; And jump back up to the beginning of the loop to get
                                                           ; the next ship in the local bubble for processing

* ******************************************************************************
* 
* Name: Main flight loop (Part 13 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Show energy bomb effect, charge shields and energy banks
* Deep dive: Program flow of the main game loop
* Scheduling tasks with the main loop counter
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Show energy bomb effect (if applicable)
* 
* * Charge shields and energy banks (every 7 iterations of the main loop)
* 
* ******************************************************************************

MA18:
       movb @BOMB,ra                   ; LDA BOMB          ; If we set off our energy bomb (see MA24 above), then
       jgt  MA77                       ; BPL MA77          ; BOMB is now negative, so this skips to MA21 if our
                                                           ; energy bomb is not going off

       .asl @BOMB                      ; ASL BOMB          ; We set off our energy bomb, so rotate BOMB to the
                                                           ; left by one place. BOMB was rotated left once already
                                                           ; during this iteration of the main loop, back at MA24,
                                                           ; so if this is the first pass it will already be
                                                           ; %11111110, and this will shift it to %11111100 - so
                                                           ; if we set off an energy bomb, it stays activated
                                                           ; (BOMB > 0) for four iterations of the main loop

       .jsr @WSCAN                     ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
                                                           ; screen gets drawn and the following palette change
                                                           ; won't kick in while the screen is still refreshing

       li   ra,>30*256                 ; LDA #%00110000    ; Set the palette byte at SHEILA &21 to map logical
       movb ra,@VIA+>21                ; STA VIA+&21       ; colour 0 to physical colour 7 (white), but with only
                                                           ; one mapping (rather than the 7 mappings required to
                                                           ; do the mapping properly). This makes the space screen
                                                           ; flash with black and white stripes. See p.382 of the
                                                           ; Advanced User Guide for details of why this single
                                                           ; palette change creates a special effect

MA77:
       movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 7,
       andi ra,>07*256                 ; AND #7            ; jumping to MA22 if it is non-zero (so the following
       jne  MA22                       ; BNE MA22          ; code only runs every 8 iterations of the main loop)

       movb @ENERGY,rx                 ; LDX ENERGY        ; Fetch our ship's energy levels and skip to b if bit 7
       jgt  b_                         ; BPL b             ; is not set, i.e. only charge the shields from the
                                                           ; energy banks if they are at more than 50% charge

       movb @ASH,rx                    ; LDX ASH           ; Call SHD to recharge our aft shield and update the
       .jsr @SHD                       ; JSR SHD           ; shield status in ASH
       movb rx,@ASH                    ; STX ASH           

       movb @FSH,rx                    ; LDX FSH           ; Call SHD to recharge our forward shield and update
       .jsr @SHD                       ; JSR SHD           ; the shield status in FSH
       movb rx,@FSH                    ; STX FSH           

b_:
       .sec                            ; SEC               ; Set A = ENERGY + ENGY + 1, so our ship's energy
       movb @ENGY,ra                   ; LDA ENGY          ; level goes up by 2 if we have an energy unit fitted,
       .adc @ENERGY,ra                 ; ADC ENERGY        ; otherwise it goes up by 1

       joc  B09                        ; BCS B09           ; If the value of A did not overflow (the maximum
       movb ra,@ENERGY                 ; STA ENERGY        ; energy level is &FF), then store A in ENERGY

* ******************************************************************************
* 
* Name: Main flight loop (Part 14 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Spawn a space station if we are close enough to the planet
* Deep dive: Program flow of the main game loop
* Scheduling tasks with the main loop counter
* Ship data blocks
* The space station safe zone
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Spawn a space station if we are close enough to the planet (every 32
* iterations of the main loop)
* 
* ******************************************************************************

B09:
       movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23S to skip
       jne  MA23S                      ; BNE MA23S         ; the following, as there are no space stations in
                                                           ; witchspace

       movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
       andi ra,>1f*256                 ; AND #31           ; jumping to MA93 if it is on-zero (so the following
       jne  MA93                       ; BNE MA93          ; code only runs every 32 iterations of the main loop)

       movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
       jne  MA23S                      ; BNE MA23S         ; MA23S to skip the following, as we already have a
                                                           ; space station and don't need another

       movb ra,ry                      ; TAY               ; Set Y = A = 0 (A is 0 as we didn't branch with the
                                                           ; previous BNE instruction)

       .jsr @MAS2                      ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
       jne  MA23S                      ; BNE MA23S         ; planet in any of the three axes, and if it's
                                                           ; non-zero, jump to MA23S to skip the following, as we
                                                           ; are too far from the planet to bump into a space
                                                           ; station

                                                           ; We now want to spawn a space station, so first we
                                                           ; need to set up a ship data block for the station in
                                                           ; INWK that we can then pass to NWSPS to add a new
                                                           ; station to our bubble of universe. We do this by
                                                           ; copying the planet data block from K% to INWK so we
                                                           ; can work on it, but we only need the first 29 bytes,
                                                           ; as we don't need to worry about bytes #29 to #35
                                                           ; for planets (as they don't have rotation counters,
                                                           ; AI, explosions, missiles, a ship line heap or energy
                                                           ; levels)

       li   rx,>1c*256                 ; LDX #28           ; So we set a counter in X to copy 29 bytes from K%+0
                                                           ; to K%+28

MAL4:
       movb @K.(rx),ra                 ; LDA K%,X          ; Load the X-th byte of K% and store in the X-th byte
       movb ra,@INWK(rx)               ; STA INWK,X        ; of the INWK workspace

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  MAL4                       ; BPL MAL4          ; Loop back for the next byte until we have copied the
                                                           ; first 28 bytes of K% to INWK

                                                           ; We now check the distance from our ship (at the
                                                           ; origin) towards the point where we will spawn the
                                                           ; space station if we are close enough
                                                           ; 
                                                           ; This point is calculated by starting at the planet's
                                                           ; centre and adding 2 * nosev, which takes us to a point
                                                           ; above the planet's surface, at an altitude that
                                                           ; matches the planet's radius
                                                           ; 
                                                           ; This point pitches and rolls around the planet as the
                                                           ; nosev vector rotates with the planet, and if our ship
                                                           ; is within a distance of (192 0) from this point in all
                                                           ; three axes, then we spawn the space station at this
                                                           ; point, with the station's slot facing towards the
                                                           ; planet, along the nosev vector
                                                           ; 
                                                           ; This works because in the following, we calculate the
                                                           ; station's coordinates one axis at a time, and store
                                                           ; the results in the INWK block, so by the time we have
                                                           ; calculated and checked all three, the ship data block
                                                           ; is set up with the correct spawning coordinates

       ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X as &FF)

       li   ry,>09*256                 ; LDY #9            ; Call MAS1 with X = 0, Y = 9 to do the following:
       .jsr @MAS1                      ; JSR MAS1          ; 
                                                           ; (x_sign x_hi x_lo) += (nosev_x_hi nosev_x_lo) * 2
                                                           ; 
                                                           ; A = |x_sign|

       jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
                                                           ; are too far from the planet in the x-direction to
                                                           ; bump into a space station

       li   rx,>03*256                 ; LDX #3            ; Call MAS1 with X = 3, Y = 11 to do the following:
       li   ry,>0b*256                 ; LDY #11           ; 
       .jsr @MAS1                      ; JSR MAS1          ; (y_sign y_hi y_lo) += (nosev_y_hi nosev_y_lo) * 2
                                                           ; 
                                                           ; A = |y_sign|

       jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
                                                           ; are too far from the planet in the y-direction to
                                                           ; bump into a space station

       li   rx,>06*256                 ; LDX #6            ; Call MAS1 with X = 6, Y = 13 to do the following:
       li   ry,>0d*256                 ; LDY #13           ; 
       .jsr @MAS1                      ; JSR MAS1          ; (z_sign z_hi z_lo) += (nosev_z_hi nosev_z_lo) * 2
                                                           ; 
                                                           ; A = |z_sign|

       jne  MA23S                      ; BNE MA23S         ; If A > 0, jump to MA23S to skip the following, as we
                                                           ; are too far from the planet in the z-direction to
                                                           ; bump into a space station

       li   ra,>c0*256                 ; LDA #192          ; Call FAROF2 to compare x_hi, y_hi and z_hi with 192,
       .jsr @FAROF2                    ; JSR FAROF2        ; which will set the C flag if all three are < 192, or
                                                           ; clear the C flag if any of them are >= 192

       jnc  MA23S                      ; BCC MA23S         ; Jump to MA23S if any one of x_hi, y_hi or z_hi are
                                                           ; >= 192 (i.e. they must all be < 192 for us to be near
                                                           ; enough to the planet to bump into a space station)

       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, skip the
       jne  B10                        ; BNE B10           ; following instruction (so we only remove the sun from
                                                           ; the screen if we are potentially looking at it)

       .jsr @WPLS                      ; JSR WPLS          ; Call WPLS to remove the sun from the screen, as we
                                                           ; can't have both the sun and the space station at the
                                                           ; same time

B10:
       .jsr @NWSPS                     ; JSR NWSPS         ; Add a new space station to our local bubble of
                                                           ; universe

MA23S:
       b    @MA23                      ; JMP MA23          ; Jump to MA23 to skip the following planet and sun
                                                           ; altitude checks

* ******************************************************************************
* 
* Name: Main flight loop (Part 15 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Perform altitude checks with the planet and sun and process fuel
* scooping if appropriate
* Deep dive: Program flow of the main game loop
* Scheduling tasks with the main loop counter
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Perform an altitude check with the planet (every 32 iterations of the main
* loop, on iteration 10 of each 32)
* 
* * Perform an altitude check with the sun and process fuel scooping (every
* 32 iterations of the main loop, on iteration 20 of each 32)
* 
* ******************************************************************************

MA22:
       movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace, jump down to MA23 to skip
       jne  MA23                       ; BNE MA23          ; the following, as there are no planets or suns to
                                                           ; bump into in witchspace

       movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 32,
       andi ra,>1f*256                 ; AND #31           ; which tells us the position of this loop in each block
                                                           ; of 32 iterations

MA93:
       ci   ra,>0a*256                 ; CMP #10           ; If this is the tenth iteration in this block of 32,
       jne  MA29                       ; BNE MA29          ; do the following, otherwise jump to MA29 to skip the
                                                           ; planet altitude check and move on to the sun distance
                                                           ; check

       li   ra,>32*256                 ; LDA #50           ; If our energy bank status in ENERGY is >= 50, skip
       cb   @ENERGY,ra                 ; CMP ENERGY        ; printing the following message (so the message is
       jnc  B11                        ; BCC B11           ; only shown if our energy is low)

       .asla                           ; ASL A             ; Print recursive token 100 ("ENERGY LOW{beep}") as an
       .jsr @MESS                      ; JSR MESS          ; in-flight message

B11:
       li   ry,>ff*256                 ; LDY #&FF          ; Set our altitude in ALTIT to &FF, the maximum
       movb ry,@ALTIT                  ; STY ALTIT         

       ab   rone,ry                    ; INY               ; Set Y = 0

       .jsr @m_                        ; JSR m             ; Call m to calculate the maximum distance to the
                                                           ; planet in any of the three axes, returned in A

       jne  MA23                       ; BNE MA23          ; If A > 0 then we are a fair distance away from the
                                                           ; planet in at least one axis, so jump to MA23 to skip
                                                           ; the rest of the altitude check

       .jsr @MAS3                      ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
                                                           ; we now know that A now contains the square of the
                                                           ; distance between our ship (at the origin) and the
                                                           ; centre of the planet at (x_hi, y_hi, z_hi)

       joc  MA23                       ; BCS MA23          ; If the C flag was set by MAS3, then the result
                                                           ; overflowed (was greater than &FF) and we are still a
                                                           ; fair distance from the planet, so jump to MA23 as we
                                                           ; haven't crashed into the planet

       .sbi (>24*256)                  ; SBC #36           ; Subtract 36 from x_hi^2 + y_hi^2 + z_hi^2
                                                           ; 
                                                           ; When we do the 3D Pythagoras calculation, we only use
                                                           ; the high bytes of the coordinates, so that's x_hi,
                                                           ; y_hi and z_hi and
                                                           ; 
                                                           ; The planet radius is (0 96 0), as defined in the
                                                           ; PLANET routine, so the high byte is 96
                                                           ; 
                                                           ; When we square the coordinates above and add them,
                                                           ; the result gets divided by 256 (otherwise the result
                                                           ; wouldn't fit into one byte), so if we do the same for
                                                           ; the planet's radius, we get:
                                                           ; 
                                                           ; 96 * 96 / 256 = 36
                                                           ; 
                                                           ; So for the planet, the equivalent figure to test the
                                                           ; sum of the _hi bytes against is 36, so A now contains
                                                           ; the high byte of our altitude above the planet
                                                           ; surface, squared

       jnc  MA28                       ; BCC MA28          ; If A < 0 then jump to MA28 as we have crashed into
                                                           ; the planet

       movb ra,@R                      ; STA R             ; We are getting close to the planet, so we need to
       .jsr @LL5                       ; JSR LL5           ; work out how close. We know from the above that A
                                                           ; contains our altitude squared, so we store A in R
                                                           ; and call LL5 to calculate:
                                                           ; 
                                                           ; Q = SQRT(R Q) = SQRT(A Q)
                                                           ; 
                                                           ; Interestingly, Q doesn't appear to be set to 0 for
                                                           ; this calculation, so presumably this doesn't make a
                                                           ; difference

       movb @Q,ra                      ; LDA Q             ; Store the result in ALTIT, our altitude
       movb ra,@ALTIT                  ; STA ALTIT         

       jne  MA23                       ; BNE MA23          ; If our altitude is non-zero then we haven't crashed,
                                                           ; so jump to MA23 to skip to the next section

MA28:
       b    @DEATH                     ; JMP DEATH         ; If we get here then we just crashed into the planet
                                                           ; or got too close to the sun, so jump to DEATH to start
                                                           ; the funeral preparations and return from the main
                                                           ; flight loop using a tail call

MA29:
       ci   ra,>14*256                 ; CMP #20           ; If this is the 20th iteration in this block of 32,
       jne  MA23                       ; BNE MA23          ; do the following, otherwise jump to MA23 to skip the
                                                           ; sun altitude check

       li   ra,>1e*256                 ; LDA #30           ; Set CABTMP to 30, the cabin temperature in deep space
       movb ra,@CABTMP                 ; STA CABTMP        ; (i.e. one notch on the dashboard bar)

       movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
       jne  MA23                       ; BNE MA23          ; MA23 to skip the following, as we can't have both the
                                                           ; sun and space station at the same time, so we clearly
                                                           ; can't be flying near the sun

       li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to NI%, which is the offset in K% for the sun's
                                                           ; data block, as the second block at K% is reserved for
                                                           ; the sun (or space station)

       .jsr @MAS2                      ; JSR MAS2          ; Call MAS2 to calculate the largest distance to the
       jne  MA23                       ; BNE MA23          ; sun in any of the three axes, and if it's non-zero,
                                                           ; jump to MA23 to skip the following, as we are too far
                                                           ; from the sun for scooping or temperature changes

       .jsr @MAS3                      ; JSR MAS3          ; Set A = x_hi^2 + y_hi^2 + z_hi^2, so using Pythagoras
                                                           ; we now know that A now contains the square of the
                                                           ; distance between our ship (at the origin) and the
                                                           ; heart of the sun at (x_hi, y_hi, z_hi)

       .eoi (>ff*256)                  ; EOR #%11111111    ; Invert A, so A is now small if we are far from the
                                                           ; sun and large if we are close to the sun, in the
                                                           ; range 0 = far away to &FF = extremely close, ouch,
                                                           ; hot, hot, hot!

       .adi (>1e*256)                  ; ADC #30           ; Add the minimum cabin temperature of 30, so we get
                                                           ; one of the following:
                                                           ; 
                                                           ; * If the C flag is clear, A contains the cabin
                                                           ; temperature, ranging from 30 to 255, that's hotter
                                                           ; the closer we are to the sun
                                                           ; 
                                                           ; * If the C flag is set, the addition has rolled over
                                                           ; and the cabin temperature is over 255

       movb ra,@CABTMP                 ; STA CABTMP        ; Store the updated cabin temperature

       joc  MA28                       ; BCS MA28          ; If the C flag is set then jump to MA28 to die, as
                                                           ; our temperature is off the scale

       ci   ra,>e0*256                 ; CMP #224          ; If the cabin temperature < 224 then jump to MA23 to
       jnc  MA23                       ; BCC MA23          ; skip fuel scooping, as we aren't close enough

       movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, jump to BA23 to
       jeq  MA23                       ; BEQ MA23          ; skip fuel scooping, as we can't scoop without fuel
                                                           ; scoops

       movb @DELT4+1,ra                ; LDA DELT4+1       ; We are now successfully fuel scooping, so it's time
       srl  ra,1                       ; LSR A             ; to work out how much fuel we're scooping. Fetch the
                                                           ; high byte of DELT4, which contains our current speed
                                                           ; divided by 4, and halve it to get our current speed
                                                           ; divided by 8 (so it's now a value between 1 and 5, as
                                                           ; our speed is normally between 1 and 40). This gives
                                                           ; us the amount of fuel that's being scooped in A, so
                                                           ; the faster we go, the more fuel we scoop, and because
                                                           ; the fuel levels are stored as 10 * the fuel in light
                                                           ; years, that means we just scooped between 0.1 and 0.5
                                                           ; light years of free fuel

       .adc @QQ14,ra                   ; ADC QQ14          ; Set A = A + the current fuel level * 10 (from QQ14)

       ci   ra,>46*256                 ; CMP #70           ; If A > 70 then set A = 70 (as 70 is the maximum fuel
       jnc  B12                        ; BCC B12           ; level, or 7.0 light years)
       li   ra,>46*256                 ; LDA #70           

B12:
       movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel level in QQ14

       li   ra,>a0*256                 ; LDA #160          ; Print recursive token 0 ("FUEL SCOOPS ON") as an
       .jsr @MESS                      ; JSR MESS          ; in-flight message

* ******************************************************************************
* 
* Name: Main flight loop (Part 16 of 16)
* Type: Subroutine
* Category: Main loop
* Summary: Process laser pulsing, E.C.M. energy drain, call stardust routine
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* The main flight loop covers most of the flight-specific aspects of Elite. This
* section covers the following:
* 
* * Process laser pulsing
* 
* * Process E.C.M. energy drain
* 
* * Jump to the stardust routine if we are in a space view
* 
* * Return from the main flight loop
* 
* ******************************************************************************

MA23:
       movb @LAS2,ra                   ; LDA LAS2          ; If the current view has no laser, jump to MA16 to skip
       jeq  MA16                       ; BEQ MA16          ; the following

       movb @LASCT,ra                  ; LDA LASCT         ; If LASCT >= 8, jump to MA16 to skip the following, so
       ci   ra,>08*256                 ; CMP #8            ; for a pulse laser with a LASCT between 8 and 10, the
       joc  MA16                       ; BCS MA16          ; laser stays on, but for a LASCT of 7 or less it gets
                                                           ; turned off and stays off until LASCT reaches zero and
                                                           ; the next pulse can start (if the fire button is still
                                                           ; being pressed)
                                                           ; 
                                                           ; For pulse lasers, LASCT gets set to 10 in ma1 above,
                                                           ; and it decrements every vertical sync (50 times a
                                                           ; second), so this means it pulses five times a second,
                                                           ; with the laser being on for the first 3/10 of each
                                                           ; pulse and off for the rest of the pulse
                                                           ; 
                                                           ; If this is a beam laser, LASCT is 0 so we always keep
                                                           ; going here. This means the laser doesn't pulse, but it
                                                           ; does get drawn and removed every cycle, in a slightly
                                                           ; different place each time, so the beams still flicker
                                                           ; around the screen

       .jsr @LASLI2                    ; JSR LASLI2        ; Redraw the existing laser lines, which has the effect
                                                           ; of removing them from the screen

       li   ra,>00*256                 ; LDA #0            ; Set LAS2 to 0 so if this is a pulse laser, it will
       movb ra,@LAS2                   ; STA LAS2          ; skip over the above until the next pulse (this has no
                                                           ; effect if this is a beam laser)

MA16:
       movb @ECMP,ra                   ; LDA ECMP          ; If our E.C.M is not on, skip to MA69, otherwise keep
       jeq  MA69                       ; BEQ MA69          ; going to drain some energy

       .jsr @DENGY                     ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1

       jeq  MA70                       ; BEQ MA70          ; If we have no energy left, jump to MA70 to turn our
                                                           ; E.C.M. off

MA69:
       movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M is going off (ours or an opponent's) then
       jeq  MA66                       ; BEQ MA66          ; keep going, otherwise skip to MA66

       sb   rone,ra                    ; DEC ECMA          ; Decrement the E.C.M. countdown timer, and if it has
       jne  MA66                       ; BNE MA66          ; reached zero, keep going, otherwise skip to MA66

MA70:
       .jsr @ECMOF                     ; JSR ECMOF         ; If we get here then either we have either run out of
                                                           ; energy, or the E.C.M. timer has run down, so switch
                                                           ; off the E.C.M.

MA66:
       movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
       jne  MA9                        ; BNE MA9           ; then jump to MA9 to return from the main flight loop
                                                           ; (as MA9 is an RTS)

       b    @STARS                     ; JMP STARS         ; This is a space view, so jump to the STARS routine to
                                                           ; process the stardust, and return from the main flight
                                                           ; loop using a tail call

* ******************************************************************************
* 
* Name: MAS1
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Add an orientation vector coordinate to an INWK coordinate
* Deep dive: The space station safe zone
* 
* ------------------------------------------------------------------------------
* 
* Add a doubled nosev vector coordinate, e.g. (nosev_y_hi nosev_y_lo) * 2, to
* an INWK coordinate, e.g. (x_sign x_hi x_lo), storing the result in the INWK
* coordinate. The axes used in each side of the addition are specified by the
* arguments X and Y.
* 
* In the comments below, we document the routine as if we are doing the
* following, i.e. if X = 0 and Y = 11:
* 
* (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (nosev_y_hi nosev_y_lo) * 2
* 
* as that way the variable names in the comments contain "x" and "y" to match
* the registers that specify the vector axis to use.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The coordinate to add, as follows:
* 
* * If X = 0, add (x_sign x_hi x_lo)
* * If X = 3, add (y_sign y_hi y_lo)
* * If X = 6, add (z_sign z_hi z_lo)
* 
* Y                   The vector to add, as follows:
* 
* * If Y = 9,  add (nosev_x_hi nosev_x_lo)
* * If Y = 11, add (nosev_y_hi nosev_y_lo)
* * If Y = 13, add (nosev_z_hi nosev_z_lo)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The highest byte of the result with the sign cleared
* (e.g. |x_sign| when X = 0, etc.)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MA9                 Contains an RTS
* 
* ******************************************************************************

MAS1:
       movb @INWK(ry),ra               ; LDA INWK,Y        ; Set K(2 1) = (nosev_y_hi nosev_y_lo) * 2
       .asla                           ; ASL A             
       movb ra,@K+1                    ; STA K+1           
       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      
       .rola                           ; ROL A             
       movb ra,@K+2                    ; STA K+2           

       li   ra,>00*256                 ; LDA #0            ; Set K+3 bit 7 to the C flag, so the sign bit of the
       .rora                           ; ROR A             ; above result goes into K+3
       movb ra,@K+3                    ; STA K+3           

       .jsr @MVT3                      ; JSR MVT3          ; Add (x_sign x_hi x_lo) to K(3 2 1)

       movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; Store the sign of the result in x_sign

       movb @K+1,ry                    ; LDY K+1           ; Store K(2 1) in (x_hi x_lo)
       movb ry,@INWK(rx)               ; STY INWK,X        
       movb @K+2,ry                    ; LDY K+2           
       movb ry,@INWK+1(rx)             ; STY INWK+1,X      

       andi ra,>7f*256                 ; AND #%01111111    ; Set A to the sign byte with the sign cleared,
                                                           ; i.e. |x_sign| when X = 0

MA9:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MAS2
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate a cap on the maximum distance to the planet or sun
* 
* ------------------------------------------------------------------------------
* 
* Given a value in Y that points to the start of a ship data block as an offset
* from K%, calculate the following:
* 
* A = A OR x_sign OR y_sign OR z_sign
* 
* and clear the sign bit of the result. The K% workspace contains the ship data
* blocks, so the offset in Y must be 0 or a multiple of NI% (as each block in
* K% contains NI% bytes).
* 
* The result effectively contains a maximum cap of the three values (though it
* might not be one of the three input values - it's just guaranteed to be
* larger than all of them).
* 
* If Y = 0 and A = 0, then this calculates the maximum cap of the highest byte
* containing the distance to the planet, as K%+2 = x_sign, K%+5 = y_sign and
* K%+8 = z_sign (the first slot in the K% workspace represents the planet).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The offset from K% for the start of the ship data block
* to use
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A OR K%+2+Y OR K%+5+Y OR K%+8+Y, with bit 7 cleared
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* m                   Do not include A in the calculation
* 
* ******************************************************************************

m_:
       li   ra,>00*256                 ; LDA #0            ; Set A = 0 and fall through into MAS2 to calculate the
                                                           ; OR of the three bytes at K%+2+Y, K%+5+Y and K%+8+Y

MAS2:
       socb @K.+2(ry),ra               ; ORA K%+2,Y        ; Set A = A OR x_sign OR y_sign OR z_sign
       socb @K.+5(ry),ra               ; ORA K%+5,Y        
       socb @K.+8(ry),ra               ; ORA K%+8,Y        

       andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 in A

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MAS3
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate A = x_hi^2 + y_hi^2 + z_hi^2 in the K% block
* 
* ------------------------------------------------------------------------------
* 
* Given a value in Y that points to the start of a ship data block as an offset
* from K%, calculate the following:
* 
* A = x_hi^2 + y_hi^2 + z_hi^2
* 
* returning A = &FF if the calculation overflows a one-byte result. The K%
* workspace contains the ship data blocks, so the offset in Y must be 0 or a
* multiple of NI% (as each block in K% contains NI% bytes).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The offset from K% for the start of the ship data block
* to use
* 
* Returns
* 
* A                   A = x_hi^2 + y_hi^2 + z_hi^2
* 
* A = &FF if the calculation overflows a one-byte result
* 
* ******************************************************************************

MAS3:
       movb @K.+1(ry),ra               ; LDA K%+1,Y        ; Set (A P) = x_hi * x_hi
       .jsr @SQUA2                     ; JSR SQUA2         

       movb ra,@R                      ; STA R             ; Store A (high byte of result) in R

       movb @K.+4(ry),ra               ; LDA K%+4,Y        ; Set (A P) = y_hi * y_hi
       .jsr @SQUA2                     ; JSR SQUA2         

       .adc @R,ra                      ; ADC R             ; Add A (high byte of second result) to R

       joc  MA30                       ; BCS MA30          ; If the addition of the two high bytes caused a carry
                                                           ; (i.e. they overflowed), jump to MA30 to return A = &FF

       movb ra,@R                      ; STA R             ; Store A (sum of the two high bytes) in R

       movb @K.+7(ry),ra               ; LDA K%+7,Y        ; Set (A P) = z_hi * z_hi
       .jsr @SQUA2                     ; JSR SQUA2         

       .adc @R,ra                      ; ADC R             ; Add A (high byte of third result) to R, so R now
                                                           ; contains the sum of x_hi^2 + y_hi^2 + z_hi^2

       jnc  B13                        ; BCC B13           ; If there is no carry, skip the following instruction
                                                           ; to return straight from the subroutine

MA30:
       li   ra,>ff*256                 ; LDA #&FF          ; The calculation has overflowed, so set A = &FF

B13:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MVEIT (Part 1 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Tidy the orientation vectors
* Deep dive: Program flow of the ship-moving routine
* Scheduling tasks with the main loop counter
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Tidy the orientation vectors for one of the ship slots
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* INWK                The current ship/planet/sun's data block
* 
* XSAV                The slot number of the current ship/planet/sun
* 
* TYPE                The type of the current ship/planet/sun
* 
* ******************************************************************************

MVEIT:
       movb @INWK+31,ra                ; LDA INWK+31       ; If bits 5 or 7 of ship byte #31 are set, jump to MV30
       andi ra,>a0*256                 ; AND #%10100000    ; as the ship is either exploding or has been killed, so
       jne  MV30                       ; BNE MV30          ; we don't need to tidy its orientation vectors or apply
                                                           ; tactics

       movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter

       .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
       andi ra,>0f*256                 ; AND #15           ; with the loop counter and apply mod 15 to the result.
       jne  MV3                        ; BNE MV3           ; The result will be zero when "counter mod 15" matches
                                                           ; the slot number, so this makes sure we call TIDY 12
                                                           ; times every 16 main loop iterations, like this:
                                                           ; 
                                                           ; Iteration 0, tidy the ship in slot 0
                                                           ; Iteration 1, tidy the ship in slot 1
                                                           ; Iteration 2, tidy the ship in slot 2
                                                           ; ...
                                                           ; Iteration 11, tidy the ship in slot 11
                                                           ; Iteration 12, do nothing
                                                           ; Iteration 13, do nothing
                                                           ; Iteration 14, do nothing
                                                           ; Iteration 15, do nothing
                                                           ; Iteration 16, tidy the ship in slot 0
                                                           ; ...
                                                           ; 
                                                           ; and so on

       .jsr @TIDY                      ; JSR TIDY          ; Call TIDY to tidy up the orientation vectors, to
                                                           ; prevent the ship from getting elongated and out of
                                                           ; shape due to the imprecise nature of trigonometry
                                                           ; in assembly language

* ******************************************************************************
* 
* Name: MVEIT (Part 2 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Call tactics routine, remove ship from scanner
* Deep dive: Scheduling tasks with the main loop counter
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Apply tactics to ships with AI enabled (by calling the TACTICS routine)
* 
* * Remove the ship from the scanner, so we can move it
* 
* ******************************************************************************

MV3:
       movb @TYPE,rx                   ; LDX TYPE          ; If the type of the ship we are moving is positive,
       jgt  B14                        ; BPL B14           ; i.e. it is not a planet (types 128 and 130) or sun
                                                           ; (type 129), then skip the following instruction

       b    @MV40                      ; JMP MV40          ; This item is the planet or sun, so jump to MV40 to
                                                           ; move it, which ends by jumping back into this routine
                                                           ; at MV45 (after all the rotation, tactics and scanner
                                                           ; code, which we don't need to apply to planets or suns)

B14:
       movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the ship's byte #32 (AI flag) into A

       jgt  MV30                       ; BPL MV30          ; If bit 7 of the AI flag is clear, then if this is a
                                                           ; ship or missile it is dumb and has no AI, and if this
                                                           ; is the space station it is not hostile, so in both
                                                           ; cases skip the following as it has no tactics

       ci   rx,(MSL)*256               ; CPX #MSL          ; If the ship is a missile, skip straight to MV26 to
       jeq  MV26                       ; BEQ MV26          ; call the TACTICS routine, as we do this every
                                                           ; iteration of the main loop for missiles only

       movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter

       .eor @XSAV                      ; EOR XSAV          ; Fetch the slot number of the ship we are moving, EOR
       andi ra,>07*256                 ; AND #7            ; with the loop counter and apply mod 8 to the result.
       jne  MV30                       ; BNE MV30          ; The result will be zero when "counter mod 8" matches
                                                           ; the slot number mod 8, so this makes sure we call
                                                           ; TACTICS 12 times every 8 main loop iterations, like
                                                           ; this:
                                                           ; 
                                                           ; Iteration 0, apply tactics to slots 0 and 8
                                                           ; Iteration 1, apply tactics to slots 1 and 9
                                                           ; Iteration 2, apply tactics to slots 2 and 10
                                                           ; Iteration 3, apply tactics to slots 3 and 11
                                                           ; Iteration 4, apply tactics to slot 4
                                                           ; Iteration 5, apply tactics to slot 5
                                                           ; Iteration 6, apply tactics to slot 6
                                                           ; Iteration 7, apply tactics to slot 7
                                                           ; Iteration 8, apply tactics to slots 0 and 8
                                                           ; ...
                                                           ; 
                                                           ; and so on

MV26:
       .jsr @TACTICS                   ; JSR TACTICS       ; Call TACTICS to apply AI tactics to this ship

MV30:
       .jsr @SCAN                      ; JSR SCAN          ; Draw the ship on the scanner, which has the effect of
                                                           ; removing it, as it's already at this point and hasn't
                                                           ; yet moved

* ******************************************************************************
* 
* Name: MVEIT (Part 3 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Move ship forward according to its speed
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Move the ship forward (along the vector pointing in the direction of
* travel) according to its speed:
* 
* (x, y, z) += nosev_hi * speed / 64
* 
* ******************************************************************************

       movb @INWK+27,ra                ; LDA INWK+27       ; Set Q = the ship's speed byte #27 * 4
       .asla                           ; ASL A             
       .asla                           ; ASL A             
       movb ra,@Q                      ; STA Q             

       movb @INWK+10,ra                ; LDA INWK+10       ; Set A = |nosev_x_hi|
       andi ra,>7f*256                 ; AND #%01111111    

       .jsr @FMLTU                     ; JSR FMLTU         ; Set R = A * Q / 256
       movb ra,@R                      ; STA R             ; = |nosev_x_hi| * speed / 64

       movb @INWK+10,ra                ; LDA INWK+10       ; If nosev_x_hi is positive, then:
       li   rx,>00*256                 ; LDX #0            ; 
       .jsr @MVT1-2                    ; JSR MVT1-2        ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + R
                                                           ; 
                                                           ; If nosev_x_hi is negative, then:
                                                           ; 
                                                           ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - R
                                                           ; 
                                                           ; So in effect, this does:
                                                           ; 
                                                           ; (x_sign x_hi x_lo) += nosev_x_hi * speed / 64

       movb @INWK+12,ra                ; LDA INWK+12       ; Set A = |nosev_y_hi|
       andi ra,>7f*256                 ; AND #%01111111    

       .jsr @FMLTU                     ; JSR FMLTU         ; Set R = A * Q / 256
       movb ra,@R                      ; STA R             ; = |nosev_y_hi| * speed / 64

       movb @INWK+12,ra                ; LDA INWK+12       ; If nosev_y_hi is positive, then:
       li   rx,>03*256                 ; LDX #3            ; 
       .jsr @MVT1-2                    ; JSR MVT1-2        ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) + R
                                                           ; 
                                                           ; If nosev_y_hi is negative, then:
                                                           ; 
                                                           ; (y_sign y_hi y_lo) = (y_sign y_hi y_lo) - R
                                                           ; 
                                                           ; So in effect, this does:
                                                           ; 
                                                           ; (y_sign y_hi y_lo) += nosev_y_hi * speed / 64

       movb @INWK+14,ra                ; LDA INWK+14       ; Set A = |nosev_z_hi|
       andi ra,>7f*256                 ; AND #%01111111    

       .jsr @FMLTU                     ; JSR FMLTU         ; Set R = A * Q / 256
       movb ra,@R                      ; STA R             ; = |nosev_z_hi| * speed / 64

       movb @INWK+14,ra                ; LDA INWK+14       ; If nosev_y_hi is positive, then:
       li   rx,>06*256                 ; LDX #6            ; 
       .jsr @MVT1-2                    ; JSR MVT1-2        ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + R
                                                           ; 
                                                           ; If nosev_z_hi is negative, then:
                                                           ; 
                                                           ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) - R
                                                           ; 
                                                           ; So in effect, this does:
                                                           ; 
                                                           ; (z_sign z_hi z_lo) += nosev_z_hi * speed / 64

* ******************************************************************************
* 
* Name: MVEIT (Part 4 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Apply acceleration to ship's speed as a one-off
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Apply acceleration to the ship's speed (if acceleration is non-zero),
* and then zero the acceleration as it's a one-off change
* 
* ******************************************************************************

       movb @INWK+27,ra                ; LDA INWK+27       ; Set A = the ship's speed in byte #24 + the ship's
       .clc                            ; CLC               ; acceleration in byte #28
       .adc @INWK+28,ra                ; ADC INWK+28       

       jgt  B15                        ; BPL B15           ; If the result is positive, skip the following
                                                           ; instruction

       li   ra,>00*256                 ; LDA #0            ; Set A to 0 to stop the speed from going negative

B15:
       li   ry,>0f*256                 ; LDY #15           ; We now fetch byte #15 from the ship's blueprint, which
                                                           ; contains the ship's maximum speed, so set Y = 15 to
                                                           ; use as an index

       .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; If A < the ship's maximum speed, skip the following
       jnc  B16                        ; BCC B16           ; instruction

       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Set A to the ship's maximum speed

B16:
       movb ra,@INWK+27                ; STA INWK+27       ; We have now calculated the new ship's speed after
                                                           ; accelerating and keeping the speed within the ship's
                                                           ; limits, so store the updated speed in byte #27

       li   ra,>00*256                 ; LDA #0            ; We have added the ship's acceleration, so we now set
       movb ra,@INWK+28                ; STA INWK+28       ; it back to 0 in byte #28, as it's a one-off change

* ******************************************************************************
* 
* Name: MVEIT (Part 5 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Rotate ship's location by our pitch and roll
* Deep dive: Rotating the universe
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Rotate the ship's location in space by the amount of pitch and roll of
* our ship. See below for a deeper explanation of this routine
* 
* ******************************************************************************

       movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
                                                           ; if the roll angle is alpha, X contains |alpha|

       movb @INWK,ra                   ; LDA INWK          ; Set P = ~x_lo (i.e. with all its bits flipped) so that
       .eoi (>ff*256)                  ; EOR #%11111111    ; we can pass x_lo to MLTU2 below)
       movb ra,@P                      ; STA P             

       movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi

       .jsr @MLTU2-2                   ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
                                                           ; = (x_hi x_lo) * alpha

       movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
                                                           ; have:
                                                           ; 
                                                           ; P(2 1 0) = (x_hi x_lo) * alpha

       movb @ALP2+1,ra                 ; LDA ALP2+1        ; Fetch the flipped sign of the current roll angle alpha
       .eor @INWK+2                    ; EOR INWK+2        ; from ALP2+1 and EOR with byte #2 (x_sign), so if the
                                                           ; flipped roll angle and x_sign have the same sign, A
                                                           ; will be positive, else it will be negative. So A will
                                                           ; contain the sign bit of x_sign * flipped alpha sign,
                                                           ; which is the opposite to the sign of the above result,
                                                           ; so we now have:
                                                           ; 
                                                           ; (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256

       li   rx,>03*256                 ; LDX #3            ; Set (A P+2 P+1) = (y_sign y_hi y_lo) + (A P+2 P+1)
       .jsr @MVT6                      ; JSR MVT6          ; = y - x * alpha / 256

       movb ra,@K2+3                   ; STA K2+3          ; Set K2(3) = A = the sign of the result

       movb @P+1,ra                    ; LDA P+1           ; Set K2(1) = P+1, the low byte of the result
       movb ra,@K2+1                   ; STA K2+1          

       .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~K2+1 (i.e. with all its bits flipped) so
       movb ra,@P                      ; STA P             ; that we can pass K2+1 to MLTU2 below)

       movb @P+2,ra                    ; LDA P+2           ; Set K2(2) = A = P+2
       movb ra,@K2+2                   ; STA K2+2          

                                                           ; So we now have result 1 above:
                                                           ; 
                                                           ; K2(3 2 1) = (A P+2 P+1)
                                                           ; = y - x * alpha / 256

       movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the current pitch into X, so
                                                           ; if the pitch angle is beta, X contains |beta|

       .jsr @MLTU2-2                   ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
                                                           ; = K2(2 1) * beta

       movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
                                                           ; have:
                                                           ; 
                                                           ; P(2 1 0) = K2(2 1) * beta

       movb @K2+3,ra                   ; LDA K2+3          ; Fetch the sign of the above result in K(3 2 1) from
       .eor @BET2                      ; EOR BET2          ; K2+3 and EOR with BET2, the sign of the current pitch
                                                           ; rate, so if the pitch and K(3 2 1) have the same sign,
                                                           ; A will be positive, else it will be negative. So A
                                                           ; will contain the sign bit of K(3 2 1) * beta, which is
                                                           ; the same as the sign of the above result, so we now
                                                           ; have:
                                                           ; 
                                                           ; (A P+2 P+1) = K2(3 2 1) * beta / 256

       li   rx,>06*256                 ; LDX #6            ; Set (A P+2 P+1) = (z_sign z_hi z_lo) + (A P+2 P+1)
       .jsr @MVT6                      ; JSR MVT6          ; = z + K2 * beta / 256

       movb ra,@INWK+8                 ; STA INWK+8        ; Set z_sign = A = the sign of the result

       movb @P+1,ra                    ; LDA P+1           ; Set z_lo = P+1, the low byte of the result
       movb ra,@INWK+6                 ; STA INWK+6        

       .eoi (>ff*256)                  ; EOR #%11111111    ; Set P = ~z_lo (i.e. with all its bits flipped) so that
       movb ra,@P                      ; STA P             ; we can pass z_lo to MLTU2 below)

       movb @P+2,ra                    ; LDA P+2           ; Set z_hi = P+2
       movb ra,@INWK+7                 ; STA INWK+7        

                                                           ; So we now have result 2 above:
                                                           ; 
                                                           ; (z_sign z_hi z_lo) = (A P+2 P+1)
                                                           ; = z + K2 * beta / 256

       .jsr @MLTU2                     ; JSR MLTU2         ; MLTU2 doesn't change Q, and Q was set to beta in
                                                           ; the previous call to MLTU2, so this call does:
                                                           ; 
                                                           ; (A P+1 P) = (A ~P) * Q
                                                           ; = (z_hi z_lo) * beta

       movb ra,@P+2                    ; STA P+2           ; Set P+2 = A = the high byte of the result, so we
                                                           ; now have:
                                                           ; 
                                                           ; P(2 1 0) = (z_hi z_lo) * beta

       movb @K2+3,ra                   ; LDA K2+3          ; Set y_sign = K2+3
       movb ra,@INWK+5                 ; STA INWK+5        

       .eor @BET2                      ; EOR BET2          ; EOR y_sign with BET2, the sign of the current pitch
       .eor @INWK+8                    ; EOR INWK+8        ; rate, and z_sign. If the result is positive jump to
       jgt  MV43                       ; BPL MV43          ; MV43, otherwise this means beta * z and y have
                                                           ; different signs, i.e. P(2 1) and K2(3 2 1) have
                                                           ; different signs, so we need to add them in order to
                                                           ; calculate K2(2 1) - P(2 1)

       movb @P+1,ra                    ; LDA P+1           ; Set (y_hi y_lo) = K2(2 1) + P(2 1)
       .adc @K2+1,ra                   ; ADC K2+1          
       movb ra,@INWK+3                 ; STA INWK+3        
       movb @P+2,ra                    ; LDA P+2           
       .adc @K2+2,ra                   ; ADC K2+2          
       movb ra,@INWK+4                 ; STA INWK+4        

       b    @MV44                      ; JMP MV44          ; Jump to MV44 to continue the calculation

MV43:
       movb @K2+1,ra                   ; LDA K2+1          ; Reversing the logic above, we need to subtract P(2 1)
       .sbc @P+1,ra                    ; SBC P+1           ; and K2(3 2 1) to calculate K2(2 1) - P(2 1), so this
       movb ra,@INWK+3                 ; STA INWK+3        ; sets (y_hi y_lo) = K2(2 1) - P(2 1)
       movb @K2+2,ra                   ; LDA K2+2          
       .sbc @P+2,ra                    ; SBC P+2           
       movb ra,@INWK+4                 ; STA INWK+4        

       joc  MV44                       ; BCS MV44          ; If the above subtraction did not underflow, then
                                                           ; jump to MV44, otherwise we need to negate the result

       li   ra,>01*256                 ; LDA #1            ; Negate (y_sign y_hi y_lo) using two's complement,
       .sbc @INWK+3,ra                 ; SBC INWK+3        ; first doing the low bytes:
       movb ra,@INWK+3                 ; STA INWK+3        ; 
                                                           ; y_lo = 1 - y_lo

       li   ra,>00*256                 ; LDA #0            ; Then the high bytes:
       .sbc @INWK+4,ra                 ; SBC INWK+4        ; 
       movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi

       movb @INWK+5,ra                 ; LDA INWK+5        ; And finally flip the sign in y_sign
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+5                 ; STA INWK+5        

MV44:
                                                           ; So we now have result 3 above:
                                                           ; 
                                                           ; (y_sign y_hi y_lo) = K2(2 1) - P(2 1)
                                                           ; = K2 - beta * z
       movb @ALP1,rx                   ; LDX ALP1          ; Fetch the magnitude of the current roll into X, so
                                                           ; if the roll angle is alpha, X contains |alpha|

       movb @INWK+3,ra                 ; LDA INWK+3        ; Set P = ~y_lo (i.e. with all its bits flipped) so that
       .eoi (>ff*256)                  ; EOR #&FF          ; we can pass y_lo to MLTU2 below)
       movb ra,@P                      ; STA P             

       movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi

       .jsr @MLTU2-2                   ; JSR MLTU2-2       ; Set (A P+1 P) = (A ~P) * X
                                                           ; = (y_hi y_lo) * alpha

       movb ra,@P+2                    ; STA P+2           ; Store the high byte of the result in P+2, so we now
                                                           ; have:
                                                           ; 
                                                           ; P(2 1 0) = (y_hi y_lo) * alpha

       movb @ALP2,ra                   ; LDA ALP2          ; Fetch the correct sign of the current roll angle alpha
       .eor @INWK+5                    ; EOR INWK+5        ; from ALP2 and EOR with byte #5 (y_sign), so if the
                                                           ; correct roll angle and y_sign have the same sign, A
                                                           ; will be positive, else it will be negative. So A will
                                                           ; contain the sign bit of x_sign * correct alpha sign,
                                                           ; which is the same as the sign of the above result,
                                                           ; so we now have:
                                                           ; 
                                                           ; (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256

       li   rx,>00*256                 ; LDX #0            ; Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
       .jsr @MVT6                      ; JSR MVT6          ; = x + y * alpha / 256

       movb ra,@INWK+2                 ; STA INWK+2        ; Set x_sign = A = the sign of the result

       movb @P+2,ra                    ; LDA P+2           ; Set x_hi = P+2, the high byte of the result
       movb ra,@INWK+1                 ; STA INWK+1        

       movb @P+1,ra                    ; LDA P+1           ; Set x_lo = P+1, the low byte of the result
       movb ra,@INWK                   ; STA INWK          

                                                           ; So we now have result 4 above:
                                                           ; 
                                                           ; x = x + alpha * y
                                                           ; 
                                                           ; and the rotation of (x, y, z) is done

* ******************************************************************************
* 
* Name: MVEIT (Part 6 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Move the ship in space according to our speed
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Move the ship in space according to our speed (we already moved it
* according to its own speed in part 3).
* 
* We do this by subtracting our speed (i.e. the distance we travel in this
* iteration of the loop) from the other ship's z-coordinate. We subtract because
* they appear to be "moving" in the opposite direction to us, and the whole
* MVEIT routine is about moving the other ships rather than us (even though we
* are the one doing the moving).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MV45                Rejoin the MVEIT routine after the rotation, tactics and
* scanner code
* 
* ******************************************************************************

MV45:
       movb @DELTA,ra                  ; LDA DELTA         ; Set R to our speed in DELTA
       movb ra,@R                      ; STA R             

       li   ra,>80*256                 ; LDA #%10000000    ; Set A to zeroes but with bit 7 set, so that (A R) is
                                                           ; a 16-bit number containing -R, or -speed

       li   rx,>06*256                 ; LDX #6            ; Set X to the z-axis so the call to MVT1 does this:
       .jsr @MVT1                      ; JSR MVT1          ; 
                                                           ; (z_sign z_hi z_lo) = (z_sign z_hi z_lo) + (A R)
                                                           ; = (z_sign z_hi z_lo) - speed

       movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is not the sun (129) then skip the
       andi ra,>81*256                 ; AND #%10000001    ; next instruction, otherwise return from the subroutine
       ci   ra,>81*256                 ; CMP #129          ; as we don't need to rotate the sun around its origin.
       jne  B17                        ; BNE B17           ; Having both the AND and the CMP is a little odd, as
                                                           ; the sun is the only ship type with bits 0 and 7 set,
                                                           ; so the AND has no effect and could be removed

       .rts                            ; RTS               ; Return from the subroutine, as the ship we are moving
                                                           ; is the sun and doesn't need any of the following

* ******************************************************************************
* 
* Name: MVEIT (Part 7 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Rotate ship's orientation vectors by pitch/roll
* Deep dive: Orientation vectors
* Pitching and rolling
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * Rotate the ship's orientation vectors according to our pitch and roll
* 
* As with the previous step, this is all about moving the other ships rather
* than us (even though we are the one doing the moving). So we rotate the
* current ship's orientation vectors (which defines its orientation in space),
* by the angles we are "moving" the rest of the sky through (alpha and beta, our
* roll and pitch), so the ship appears to us to be stationary while we rotate.
* 
* ******************************************************************************

B17:
       li   ry,>09*256                 ; LDY #9            ; Apply our pitch and roll rotations to the current
       .jsr @MVS4                      ; JSR MVS4          ; ship's nosev vector

       li   ry,>0f*256                 ; LDY #15           ; Apply our pitch and roll rotations to the current
       .jsr @MVS4                      ; JSR MVS4          ; ship's roofv vector

       li   ry,>15*256                 ; LDY #21           ; Apply our pitch and roll rotations to the current
       .jsr @MVS4                      ; JSR MVS4          ; ship's sidev vector

* ******************************************************************************
* 
* Name: MVEIT (Part 8 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Rotate ship about itself by its own pitch/roll
* Deep dive: Orientation vectors
* Pitching and rolling by a fixed angle
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * If the ship we are processing is rolling or pitching itself, rotate it and
* apply damping if required
* 
* ******************************************************************************

       movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the sign
       andi ra,>80*256                 ; AND #%10000000    ; into RAT2
       movb ra,@RAT2                   ; STA RAT2          

       movb @INWK+30,ra                ; LDA INWK+30       ; Fetch the ship's pitch counter and extract the value
       andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A

       jeq  MV8                        ; BEQ MV8           ; If the pitch counter is 0, then jump to MV8 to skip
                                                           ; the following, as the ship is not pitching

       ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the pitch counter (i.e. the
                                                           ; ship's pitch is not damping down), then the C flag
                                                           ; will be set by this instruction

       .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
                                                           ; reduce A by 1, otherwise it is unchanged

       socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
                                                           ; the updated pitch counter in A retains its sign

       movb ra,@INWK+30                ; STA INWK+30       ; Store the updated pitch counter in byte #30

       li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, nosev_x) by a small angle (pitch)
       li   ry,>09*256                 ; LDY #9            
       .jsr @MVS5                      ; JSR MVS5          

       li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, nosev_y) by a small angle (pitch)
       li   ry,>0b*256                 ; LDY #11           
       .jsr @MVS5                      ; JSR MVS5          

       li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, nosev_z) by a small angle (pitch)
       li   ry,>0d*256                 ; LDY #13           
       .jsr @MVS5                      ; JSR MVS5          

MV8:
       movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the sign
       andi ra,>80*256                 ; AND #%10000000    ; into RAT2
       movb ra,@RAT2                   ; STA RAT2          

       movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the ship's roll counter and extract the value
       andi ra,>7f*256                 ; AND #%01111111    ; without the sign bit into A

       jeq  MV5                        ; BEQ MV5           ; If the roll counter is 0, then jump to MV5 to skip the
                                                           ; following, as the ship is not rolling

       ci   ra,>7f*256                 ; CMP #%01111111    ; If bits 0-6 are set in the roll counter (i.e. the
                                                           ; ship's roll is not damping down), then the C flag
                                                           ; will be set by this instruction

       .sbi (>00*256)                  ; SBC #0            ; Set A = A - 0 - (1 - C), so if we are damping then we
                                                           ; reduce A by 1, otherwise it is unchanged

       socb @RAT2,ra                   ; ORA RAT2          ; Change bit 7 of A to the sign we saved in RAT2, so
                                                           ; the updated roll counter in A retains its sign

       movb ra,@INWK+29                ; STA INWK+29       ; Store the updated pitch counter in byte #29

       li   rx,>0f*256                 ; LDX #15           ; Rotate (roofv_x, sidev_x) by a small angle (roll)
       li   ry,>15*256                 ; LDY #21           
       .jsr @MVS5                      ; JSR MVS5          

       li   rx,>11*256                 ; LDX #17           ; Rotate (roofv_y, sidev_y) by a small angle (roll)
       li   ry,>17*256                 ; LDY #23           
       .jsr @MVS5                      ; JSR MVS5          

       li   rx,>13*256                 ; LDX #19           ; Rotate (roofv_z, sidev_z) by a small angle (roll)
       li   ry,>19*256                 ; LDY #25           
       .jsr @MVS5                      ; JSR MVS5          

* ******************************************************************************
* 
* Name: MVEIT (Part 9 of 9)
* Type: Subroutine
* Category: Moving
* Summary: Move current ship: Redraw on scanner, if it hasn't been destroyed
* 
* ------------------------------------------------------------------------------
* 
* This routine has multiple stages. This stage does the following:
* 
* * If the ship is exploding or being removed, hide it on the scanner
* 
* * Otherwise redraw the ship on the scanner, now that it's been moved
* 
* ******************************************************************************

MV5:
       movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's exploding/killed state from byte #31

       andi ra,>a0*256                 ; AND #%10100000    ; If we are exploding or removing this ship then jump to
       jne  MVD1                       ; BNE MVD1          ; MVD1 to remove it from the scanner permanently

       movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 4 to keep the ship visible on the scanner
       ori  ra,>10*256                 ; ORA #%00010000    
       movb ra,@INWK+31                ; STA INWK+31       

       b    @SCAN                      ; JMP SCAN          ; Display the ship on the scanner, returning from the
                                                           ; subroutine using a tail call

MVD1:
       movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 4 to hide the ship on the scanner
       andi ra,>ef*256                 ; AND #%11101111    
       movb ra,@INWK+31                ; STA INWK+31       

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MVT1
* Type: Subroutine
* Category: Moving
* Summary: Calculate (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
* 
* ------------------------------------------------------------------------------
* 
* Add the signed delta (A R) to a ship's coordinate, along the axis given in X.
* Mathematically speaking, this routine translates the ship along a single axis
* by a signed delta. Taking the example of X = 0, the x-axis, it does the
* following:
* 
* (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (A R)
* 
* (In practice, MVT1 is only ever called directly with A = 0 or 128, otherwise
* it is always called via MVT-2, which clears A apart from the sign bit. The
* routine is written to cope with a non-zero delta_hi, so it supports a full
* 16-bit delta, but it appears that delta_hi is only ever used to hold the
* sign of the delta.)
* 
* The comments below assume we are adding delta to the x-axis, though the axis
* is determined by the value of X.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* (A R)               The signed delta, so A = delta_hi and R = delta_lo
* 
* X                   Determines which coordinate axis of INWK to change:
* 
* * X = 0 adds the delta to (x_lo, x_hi, x_sign)
* 
* * X = 3 adds the delta to (y_lo, y_hi, y_sign)
* 
* * X = 6 adds the delta to (z_lo, z_hi, z_sign)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MVT1-2              Clear bits 0-6 of A before entering MVT1
* 
* ******************************************************************************

       andi ra,>80*256                 ; AND #%10000000    ; Clear bits 0-6 of A

MVT1:
       .asla                           ; ASL A             ; Set the C flag to the sign bit of the delta, leaving
                                                           ; delta_hi << 1 in A

       movb ra,@S                      ; STA S             ; Set S = delta_hi << 1
                                                           ; 
                                                           ; This also clears bit 0 of S

       li   ra,>00*256                 ; LDA #0            ; Set T = just the sign bit of delta (in bit 7)
       .rora                           ; ROR A             
       movb ra,@T                      ; STA T             

       .lsr @S                         ; LSR S             ; Set S = delta_hi >> 1
                                                           ; = |delta_hi|
                                                           ; 
                                                           ; This also clear the C flag, as we know that bit 0 of
                                                           ; S was clear before the LSR

       .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If T EOR x_sign has bit 7 set, then x_sign and delta
       jlt  MV10                       ; BMI MV10          ; have different signs, so jump to MV10

                                                           ; At this point, we know x_sign and delta have the same
                                                           ; sign, that sign is in T, and S contains |delta_hi|,
                                                           ; so now we want to do:
                                                           ; 
                                                           ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) + (S R)
                                                           ; 
                                                           ; and then set the sign of the result to the same sign
                                                           ; as x_sign and delta

       movb @R,ra                      ; LDA R             ; First we add the low bytes, so:
       .adc @INWK(rx),ra               ; ADC INWK,X        ; 
       movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = x_lo + R

       movb @S,ra                      ; LDA S             ; Then we add the high bytes:
       .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ; 
       movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi + S

       movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we add any carry into x_sign, and if the
       .adi (>00*256)                  ; ADC #0            ; sign of x_sign and delta in T is negative, make sure
       socb @T,ra                      ; ORA T             ; the result is negative (by OR'ing with T)
       movb ra,@INWK+2(rx)             ; STA INWK+2,X      

       .rts                            ; RTS               ; Return from the subroutine

MV10:
                                                           ; If we get here, we know x_sign and delta have
                                                           ; different signs, with delta's sign in T, and
                                                           ; |delta_hi| in S, so now we want to do:
                                                           ; 
                                                           ; (x_sign x_hi x_lo) = (x_sign x_hi x_lo) - (S R)
                                                           ; 
                                                           ; and then set the sign of the result according to
                                                           ; the signs of x_sign and delta
       movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes, so:
       .sec                            ; SEC               ; 
       .sbc @R,ra                      ; SBC R             ; x_lo = x_lo - R
       movb ra,@INWK(rx)               ; STA INWK,X        

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then we subtract the high bytes:
       .sbc @S,ra                      ; SBC S             ; 
       movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = x_hi - S

       movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally we subtract any borrow from bits 0-6 of
       andi ra,>7f*256                 ; AND #%01111111    ; x_sign, and give the result the opposite sign bit to T
       .sbi (>00*256)                  ; SBC #0            ; (i.e. give it the sign of the original x_sign)
       ori  ra,>80*256                 ; ORA #%10000000    
       .eor @T                         ; EOR T             
       movb ra,@INWK+2(rx)             ; STA INWK+2,X      

       joc  MV11                       ; BCS MV11          ; If the C flag is set by the above SBC, then our sum
                                                           ; above didn't underflow and is correct - to put it
                                                           ; another way, (x_sign x_hi x_lo) >= (S R) so the result
                                                           ; should indeed have the same sign as x_sign, so jump to
                                                           ; MV11 to return from the subroutine

                                                           ; Otherwise our subtraction underflowed because
                                                           ; (x_sign x_hi x_lo) < (S R), so we now need to flip the
                                                           ; subtraction around by using two's complement to this:
                                                           ; 
                                                           ; (S R) - (x_sign x_hi x_lo)
                                                           ; 
                                                           ; and then we need to give the result the same sign as
                                                           ; (S R), the delta, as that's the dominant figure in the
                                                           ; sum

       li   ra,>01*256                 ; LDA #1            ; First we subtract the low bytes, so:
       .sbc @INWK(rx),ra               ; SBC INWK,X        ; 
       movb ra,@INWK(rx)               ; STA INWK,X        ; x_lo = 1 - x_lo

       li   ra,>00*256                 ; LDA #0            ; Then we subtract the high bytes:
       .sbc @INWK+1(rx),ra             ; SBC INWK+1,X      ; 
       movb ra,@INWK+1(rx)             ; STA INWK+1,X      ; x_hi = 0 - x_hi

       li   ra,>00*256                 ; LDA #0            ; And then we subtract the sign bytes:
       .sbc @INWK+2(rx),ra             ; SBC INWK+2,X      ; 
                                                           ; x_sign = 0 - x_sign

       andi ra,>7f*256                 ; AND #%01111111    ; Finally, we set the sign bit to the sign in T, the
       socb @T,ra                      ; ORA T             ; sign of the original delta, as the delta is the
       movb ra,@INWK+2(rx)             ; STA INWK+2,X      ; dominant figure in the sum

MV11:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MVT3
* Type: Subroutine
* Category: Moving
* Summary: Calculate K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
* 
* ------------------------------------------------------------------------------
* 
* Add an INWK position coordinate - i.e. x, y or z - to K(3 2 1), like this:
* 
* K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
* 
* The INWK coordinate to add to K(3 2 1) is specified by X.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The coordinate to add to K(3 2 1), as follows:
* 
* * If X = 0, add (x_sign x_hi x_lo)
* 
* * If X = 3, add (y_sign y_hi y_lo)
* 
* * If X = 6, add (z_sign z_hi z_lo)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   Contains a copy of the high byte of the result, K+3
* 
* X                   X is preserved
* 
* ******************************************************************************

MVT3:
       movb @K+3,ra                    ; LDA K+3           ; Set S = K+3
       movb ra,@S                      ; STA S             

       andi ra,>80*256                 ; AND #%10000000    ; Set T = sign bit of K(3 2 1)
       movb ra,@T                      ; STA T             

       .eor @INWK+2(rx)                ; EOR INWK+2,X      ; If x_sign has a different sign to K(3 2 1), jump to
       jlt  MV13                       ; BMI MV13          ; MV13 to process the addition as a subtraction

       movb @K+1,ra                    ; LDA K+1           ; Set K(3 2 1) = K(3 2 1) + (x_sign x_hi x_lo)
       .clc                            ; CLC               ; starting with the low bytes
       .adc @INWK(rx),ra               ; ADC INWK,X        
       movb ra,@K+1                    ; STA K+1           

       movb @K+2,ra                    ; LDA K+2           ; Then the middle bytes
       .adc @INWK+1(rx),ra             ; ADC INWK+1,X      
       movb ra,@K+2                    ; STA K+2           

       movb @K+3,ra                    ; LDA K+3           ; And finally the high bytes
       .adc @INWK+2(rx),ra             ; ADC INWK+2,X      

       andi ra,>7f*256                 ; AND #%01111111    ; Setting the sign bit of K+3 to T, the original sign
       socb @T,ra                      ; ORA T             ; of K(3 2 1)
       movb ra,@K+3                    ; STA K+3           

       .rts                            ; RTS               ; Return from the subroutine

MV13:
       movb @S,ra                      ; LDA S             ; Set S = |K+3| (i.e. K+3 with the sign bit cleared)
       andi ra,>7f*256                 ; AND #%01111111    
       movb ra,@S                      ; STA S             

       movb @INWK(rx),ra               ; LDA INWK,X        ; Set K(3 2 1) = (x_sign x_hi x_lo) - K(3 2 1)
       .sec                            ; SEC               ; starting with the low bytes
       .sbc @K+1,ra                    ; SBC K+1           
       movb ra,@K+1                    ; STA K+1           

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Then the middle bytes
       .sbc @K+2,ra                    ; SBC K+2           
       movb ra,@K+2                    ; STA K+2           

       movb @INWK+2(rx),ra             ; LDA INWK+2,X      ; And finally the high bytes, doing A = |x_sign| - |K+3|
       andi ra,>7f*256                 ; AND #%01111111    ; and setting the C flag for testing below
       .sbc @S,ra                      ; SBC S             

       ori  ra,>80*256                 ; ORA #%10000000    ; Set the sign bit of K+3 to the opposite sign of T,
       .eor @T                         ; EOR T             ; i.e. the opposite sign to the original K(3 2 1)
       movb ra,@K+3                    ; STA K+3           

       joc  MV14                       ; BCS MV14          ; If the C flag is set, i.e. |x_sign| >= |K+3|, then
                                                           ; the sign of K(3 2 1). In this case, we want the
                                                           ; result to have the same sign as the largest argument,
                                                           ; which is (x_sign x_hi x_lo), which we know has the
                                                           ; opposite sign to K(3 2 1), and that's what we just set
                                                           ; the sign of K(3 2 1) to... so we can jump to MV14 to
                                                           ; return from the subroutine

       li   ra,>01*256                 ; LDA #1            ; We need to swap the sign of the result in K(3 2 1),
       .sbc @K+1,ra                    ; SBC K+1           ; which we do by calculating 0 - K(3 2 1), which we can
       movb ra,@K+1                    ; STA K+1           ; do with 1 - C - K(3 2 1), as we know the C flag is
                                                           ; clear. We start with the low bytes

       li   ra,>00*256                 ; LDA #0            ; Then the middle bytes
       .sbc @K+2,ra                    ; SBC K+2           
       movb ra,@K+2                    ; STA K+2           

       li   ra,>00*256                 ; LDA #0            ; And finally the high bytes
       .sbc @K+3,ra                    ; SBC K+3           

       andi ra,>7f*256                 ; AND #%01111111    ; Set the sign bit of K+3 to the same sign as T,
       socb @T,ra                      ; ORA T             ; i.e. the same sign as the original K(3 2 1), as
       movb ra,@K+3                    ; STA K+3           ; that's the largest argument

MV14:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MVS4
* Type: Subroutine
* Category: Moving
* Summary: Apply pitch and roll to an orientation vector
* Deep dive: Orientation vectors
* Pitching and rolling
* 
* ------------------------------------------------------------------------------
* 
* Apply pitch and roll angles alpha and beta to the orientation vector in Y.
* 
* Specifically, this routine rotates a point (x, y, z) around the origin by
* pitch alpha and roll beta, using the small angle approximation to make the
* maths easier, and incorporating the Minsky circle algorithm to make the
* rotation more stable (though more elliptic).
* 
* If that paragraph makes sense to you, then you should probably be writing
* this commentary! For the rest of us, there's a detailed explanation of all
* this in the deep dive on "Pitching and rolling".
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   Determines which of the INWK orientation vectors to
* transform:
* 
* * Y = 9 rotates nosev: (nosev_x, nosev_y, nosev_z)
* 
* * Y = 15 rotates roofv: (roofv_x, roofv_y, roofv_z)
* 
* * Y = 21 rotates sidev: (sidev_x, sidev_y, sidev_z)
* 
* ******************************************************************************

MVS4:
       movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = alpha (the roll angle to rotate through)
       movb ra,@Q                      ; STA Q             

       movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
       movb rx,@R                      ; STX R             
       movb @INWK+3(ry),rx             ; LDX INWK+3,Y      
       movb rx,@S                      ; STX S             

       movb @INWK(ry),rx               ; LDX INWK,Y        ; These instructions have no effect as MAD overwrites
       movb rx,@P                      ; STX P             ; X and P when called, but they set X = P = nosev_x_lo

       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Set A = -nosev_x_hi
       .eoi (>80*256)                  ; EOR #%10000000    

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
       movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = alpha * -nosev_x_hi + nosev_y
       movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ; 
                                                           ; and store (A X) in nosev_y, so this does:
                                                           ; 
                                                           ; nosev_y = nosev_y - alpha * nosev_x_hi

       movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
                                                           ; but it sets P = nosev_y_lo

       movb @INWK(ry),rx               ; LDX INWK,Y        ; Set (S R) = nosev_x
       movb rx,@R                      ; STX R             
       movb @INWK+1(ry),rx             ; LDX INWK+1,Y      
       movb rx,@S                      ; STX S             

       movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
       movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; = alpha * nosev_y_hi + nosev_x
       movb rx,@INWK(ry)               ; STX INWK,Y        ; 
                                                           ; and store (A X) in nosev_x, so this does:
                                                           ; 
                                                           ; nosev_x = nosev_x + alpha * nosev_y_hi

       movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
                                                           ; but it sets P = nosev_x_lo

       movb @BETA,ra                   ; LDA BETA          ; Set Q = beta (the pitch angle to rotate through)
       movb ra,@Q                      ; STA Q             

       movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set (S R) = nosev_y
       movb rx,@R                      ; STX R             
       movb @INWK+3(ry),rx             ; LDX INWK+3,Y      
       movb rx,@S                      ; STX S             
       movb @INWK+4(ry),rx             ; LDX INWK+4,Y      

       movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
                                                           ; but it sets P = nosev_y

       movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; Set A = -nosev_z_hi
       .eoi (>80*256)                  ; EOR #%10000000    

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
       movb ra,@INWK+3(ry)             ; STA INWK+3,Y      ; = beta * -nosev_z_hi + nosev_y
       movb rx,@INWK+2(ry)             ; STX INWK+2,Y      ; 
                                                           ; and store (A X) in nosev_y, so this does:
                                                           ; 
                                                           ; nosev_y = nosev_y - beta * nosev_z_hi

       movb rx,@P                      ; STX P             ; This instruction has no effect as MAD overwrites P,
                                                           ; but it sets P = nosev_y_lo

       movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set (S R) = nosev_z
       movb rx,@R                      ; STX R             
       movb @INWK+5(ry),rx             ; LDX INWK+5,Y      
       movb rx,@S                      ; STX S             

       movb @INWK+3(ry),ra             ; LDA INWK+3,Y      ; Set A = nosev_y_hi

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
       movb ra,@INWK+5(ry)             ; STA INWK+5,Y      ; = beta * nosev_y_hi + nosev_z
       movb rx,@INWK+4(ry)             ; STX INWK+4,Y      ; 
                                                           ; and store (A X) in nosev_z, so this does:
                                                           ; 
                                                           ; nosev_z = nosev_z + beta * nosev_y_hi

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MVS5
* Type: Subroutine
* Category: Moving
* Summary: Apply a 3.6 degree pitch or roll to an orientation vector
* Deep dive: Orientation vectors
* Pitching and rolling by a fixed angle
* 
* ------------------------------------------------------------------------------
* 
* Pitch or roll a ship by a small, fixed amount (1/16 radians, or 3.6 degrees),
* in a specified direction, by rotating the orientation vectors. The vectors to
* rotate are given in X and Y, and the direction of the rotation is given in
* RAT2. The calculation is as follows:
* 
* * If the direction is positive:
* 
* X = X * (1 - 1/512) + Y / 16
* Y = Y * (1 - 1/512) - X / 16
* 
* * If the direction is negative:
* 
* X = X * (1 - 1/512) - Y / 16
* Y = Y * (1 - 1/512) + X / 16
* 
* So if X = 15 (roofv_x), Y = 21 (sidev_x) and RAT2 is positive, it does this:
* 
* roofv_x = roofv_x * (1 - 1/512)  + sidev_x / 16
* sidev_x = sidev_x * (1 - 1/512)  - roofv_x / 16
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The first vector to rotate:
* 
* * If X = 15, rotate roofv_x
* 
* * If X = 17, rotate roofv_y
* 
* * If X = 19, rotate roofv_z
* 
* * If X = 21, rotate sidev_x
* 
* * If X = 23, rotate sidev_y
* 
* * If X = 25, rotate sidev_z
* 
* Y                   The second vector to rotate:
* 
* * If Y = 9,  rotate nosev_x
* 
* * If Y = 11, rotate nosev_y
* 
* * If Y = 13, rotate nosev_z
* 
* * If Y = 21, rotate sidev_x
* 
* * If Y = 23, rotate sidev_y
* 
* * If Y = 25, rotate sidev_z
* 
* RAT2                The direction of the pitch or roll to perform, positive
* or negative (i.e. the sign of the roll or pitch counter
* in bit 7)
* 
* ******************************************************************************

MVS5:
       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi, clear the sign bit, divide by 2 and
       andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
       srl  ra,1                       ; LSR A             ; 
       movb ra,@T                      ; STA T             ; T = |roofv_x_hi| / 2
                                                           ; = |roofv_x| / 512
                                                           ; 
                                                           ; The above is true because:
                                                           ; 
                                                           ; |roofv_x| = |roofv_x_hi| * 256 + roofv_x_lo
                                                           ; 
                                                           ; so:
                                                           ; 
                                                           ; |roofv_x| / 512 = |roofv_x_hi| * 256 / 512
                                                           ; + roofv_x_lo / 512
                                                           ; = |roofv_x_hi| / 2

       movb @INWK(rx),ra               ; LDA INWK,X        ; Now we do the following subtraction:
       .sec                            ; SEC               ; 
       .sbc @T,ra                      ; SBC T             ; (S R) = (roofv_x_hi roofv_x_lo) - |roofv_x| / 512
       movb ra,@R                      ; STA R             ; = (1 - 1/512) * roofv_x
                                                           ; 
                                                           ; by doing the low bytes first

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes (the high byte of the right
       .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
       movb ra,@S                      ; STA S             

       movb @INWK(ry),ra               ; LDA INWK,Y        ; Set P = nosev_x_lo
       movb ra,@P                      ; STA P             

       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch the sign of nosev_x_hi (bit 7) and store in T
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@T                      ; STA T             

       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi into A and clear the sign bit, so
       andi ra,>7f*256                 ; AND #%01111111    ; A = |nosev_x_hi|

       srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
       .ror @P                         ; ROR P             ; = |nosev_x_hi nosev_x_lo| / 16
       srl  ra,1                       ; LSR A             ; = |nosev_x| / 16
       .ror @P                         ; ROR P             
       srl  ra,1                       ; LSR A             
       .ror @P                         ; ROR P             
       srl  ra,1                       ; LSR A             
       .ror @P                         ; ROR P             

       socb @T,ra                      ; ORA T             ; Set the sign of A to the sign in T (i.e. the sign of
                                                           ; the original nosev_x), so now:
                                                           ; 
                                                           ; (A P) = nosev_x / 16

       .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
                                                           ; by the pitch or roll direction

       movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
                                                           ; call to ADD

       .jsr @ADD                       ; JSR ADD           ; (A X) = (A P) + (S R)
                                                           ; = +/-nosev_x / 16 + (1 - 1/512) * roofv_x

       movb ra,@K+1                    ; STA K+1           ; Set K(1 0) = (1 - 1/512) * roofv_x +/- nosev_x / 16
       movb rx,@K                      ; STX K             

       movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD

       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Fetch nosev_x_hi, clear the sign bit, divide by 2 and
       andi ra,>7f*256                 ; AND #%01111111    ; store in T, so:
       srl  ra,1                       ; LSR A             ; 
       movb ra,@T                      ; STA T             ; T = |nosev_x_hi| / 2
                                                           ; = |nosev_x| / 512

       movb @INWK(ry),ra               ; LDA INWK,Y        ; Now we do the following subtraction:
       .sec                            ; SEC               ; 
       .sbc @T,ra                      ; SBC T             ; (S R) = (nosev_x_hi nosev_x_lo) - |nosev_x| / 512
       movb ra,@R                      ; STA R             ; = (1 - 1/512) * nosev_x
                                                           ; 
                                                           ; by doing the low bytes first

       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; And then the high bytes (the high byte of the right
       .sbi (>00*256)                  ; SBC #0            ; side of the subtraction being 0)
       movb ra,@S                      ; STA S             

       movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = roofv_x_lo
       movb ra,@P                      ; STA P             

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch the sign of roofv_x_hi (bit 7) and store in T
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@T                      ; STA T             

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Fetch roofv_x_hi into A and clear the sign bit, so
       andi ra,>7f*256                 ; AND #%01111111    ; A = |roofv_x_hi|

       srl  ra,1                       ; LSR A             ; Set (A P) = (A P) / 16
       .ror @P                         ; ROR P             ; = |roofv_x_hi roofv_x_lo| / 16
       srl  ra,1                       ; LSR A             ; = |roofv_x| / 16
       .ror @P                         ; ROR P             
       srl  ra,1                       ; LSR A             
       .ror @P                         ; ROR P             
       srl  ra,1                       ; LSR A             
       .ror @P                         ; ROR P             

       socb @T,ra                      ; ORA T             ; Set the sign of A to the opposite sign to T (i.e. the
       .eoi (>80*256)                  ; EOR #%10000000    ; sign of the original -roofv_x), so now:
                                                           ; 
                                                           ; (A P) = -roofv_x / 16

       .eor @RAT2                      ; EOR RAT2          ; Give it the sign as if we multiplied by the direction
                                                           ; by the pitch or roll direction

       movb rx,@Q                      ; STX Q             ; Store the value of X so it can be restored after the
                                                           ; call to ADD

       .jsr @ADD                       ; JSR ADD           ; (A X) = (A P) + (S R)
                                                           ; = -/+roofv_x / 16 + (1 - 1/512) * nosev_x

       movb ra,@INWK+1(ry)             ; STA INWK+1,Y      ; Set nosev_x = (1-1/512) * nosev_x -/+ roofv_x / 16
       movb rx,@INWK(ry)               ; STX INWK,Y        

       movb @Q,rx                      ; LDX Q             ; Restore the value of X from before the call to ADD

       movb @K,ra                      ; LDA K             ; Set roofv_x = K(1 0)
       movb ra,@INWK(rx)               ; STA INWK,X        ; = (1-1/512) * roofv_x +/- nosev_x / 16
       movb @K+1,ra                    ; LDA K+1           
       movb ra,@INWK+1(rx)             ; STA INWK+1,X      

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MVT6
* Type: Subroutine
* Category: Moving
* Summary: Calculate (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
* 
* ------------------------------------------------------------------------------
* 
* Do the following calculation, for the coordinate given by X (so this is what
* it does for the x-coordinate):
* 
* (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1)
* 
* A is a sign bit and is not included in the calculation, but bits 0-6 of A are
* preserved. Bit 7 is set to the sign of the result.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The sign of P(2 1) in bit 7
* 
* P(2 1)              The 16-bit value we want to add the coordinate to
* 
* X                   The coordinate to add, as follows:
* 
* * If X = 0, add to (x_sign x_hi x_lo)
* 
* * If X = 3, add to (y_sign y_hi y_lo)
* 
* * If X = 6, add to (z_sign z_hi z_lo)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The sign of the result (in bit 7)
* 
* ******************************************************************************

MVT6:
       movb ra,ry                      ; TAY               ; Store argument A into Y, for later use

       .eor @INWK+2(rx)                ; EOR INWK+2,X      ; Set A = A EOR x_sign

       jlt  MV50                       ; BMI MV50          ; If the sign is negative, i.e. A and x_sign have
                                                           ; different signs, jump to MV50

                                                           ; The signs are the same, so we can add the two
                                                           ; arguments and keep the sign to get the result

       movb @P+1,ra                    ; LDA P+1           ; First we add the low bytes:
       .clc                            ; CLC               ; 
       .adc @INWK(rx),ra               ; ADC INWK,X        ; P+1 = P+1 + x_lo
       movb ra,@P+1                    ; STA P+1           

       movb @P+2,ra                    ; LDA P+2           ; And then the high bytes:
       .adc @INWK+1(rx),ra             ; ADC INWK+1,X      ; 
       movb ra,@P+2                    ; STA P+2           ; P+2 = P+2 + x_hi

       movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
                                                           ; so that we keep the original sign

       .rts                            ; RTS               ; Return from the subroutine

MV50:
       movb @INWK(rx),ra               ; LDA INWK,X        ; First we subtract the low bytes:
       .sec                            ; SEC               ; 
       .sbc @P+1,ra                    ; SBC P+1           ; P+1 = x_lo - P+1
       movb ra,@P+1                    ; STA P+1           

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; And then the high bytes:
       .sbc @P+2,ra                    ; SBC P+2           ; 
       movb ra,@P+2                    ; STA P+2           ; P+2 = x_hi - P+2

       jnc  MV51                       ; BCC MV51          ; If the last subtraction underflowed, then the C flag
                                                           ; will be clear and x_hi < P+2, so jump to MV51 to
                                                           ; negate the result

       movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
       .eoi (>80*256)                  ; EOR #%10000000    ; but flip bit 7, which flips the sign. We do this
                                                           ; because x_hi >= P+2 so we want the result to have the
                                                           ; same sign as x_hi (as it's the dominant side in this
                                                           ; calculation). The sign of x_hi is x_sign, and x_sign
                                                           ; has the opposite sign to A, so we flip the sign in A
                                                           ; to return the correct result

       .rts                            ; RTS               ; Return from the subroutine

MV51:
       li   ra,>01*256                 ; LDA #1            ; Our subtraction underflowed, so we negate the result
       .sbc @P+1,ra                    ; SBC P+1           ; using two's complement, first with the low byte:
       movb ra,@P+1                    ; STA P+1           ; 
                                                           ; P+1 = 1 - P+1

       li   ra,>00*256                 ; LDA #0            ; And then the high byte:
       .sbc @P+2,ra                    ; SBC P+2           ; 
       movb ra,@P+2                    ; STA P+2           ; P+2 = 0 - P+2

       movb ry,ra                      ; TYA               ; Restore the original A argument that we stored earlier
                                                           ; as this is the correct sign for the result. This is
                                                           ; because x_hi < P+2, so we want to return the same sign
                                                           ; as P+2, the dominant side

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MV40
* Type: Subroutine
* Category: Moving
* Summary: Rotate the planet or sun's location in space by the amount of
* pitch and roll of our ship
* Deep dive: Rotating the universe
* 
* ------------------------------------------------------------------------------
* 
* We implement this using the same equations as in part 5 of MVEIT, where we
* rotated the current ship's location by our pitch and roll. Specifically, the
* calculation is as follows:
* 
* 1. K2 = y - alpha * x
* 2. z = z + beta * K2
* 3. y = K2 - beta * z
* 4. x = x + alpha * y
* 
* See the deep dive on "Rotating the universe" for more details on the above.
* 
* ******************************************************************************

MV40:
       movb @ALPHA,ra                  ; LDA ALPHA         ; Set Q = -ALPHA, so Q contains the angle we want to
       .eoi (>80*256)                  ; EOR #%10000000    ; roll the planet through (i.e. in the opposite
       movb ra,@Q                      ; STA Q             ; direction to our ship's roll angle alpha)

       movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
       movb ra,@P                      ; STA P             
       movb @INWK+1,ra                 ; LDA INWK+1        
       movb ra,@P+1                    ; STA P+1           

       movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign

       .jsr @MULT3                     ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
                                                           ; 
                                                           ; which also means:
                                                           ; 
                                                           ; K(3 2 1) = (A P+1 P) * Q / 256
                                                           ; = x * -alpha / 256
                                                           ; = - alpha * x / 256

       li   rx,>03*256                 ; LDX #3            ; Set K(3 2 1) = (y_sign y_hi y_lo) + K(3 2 1)
       .jsr @MVT3                      ; JSR MVT3          ; = y - alpha * x / 256

       movb @K+1,ra                    ; LDA K+1           ; Set K2(2 1) = P(1 0) = K(2 1)
       movb ra,@K2+1                   ; STA K2+1          
       movb ra,@P                      ; STA P             

       movb @K+2,ra                    ; LDA K+2           ; Set K2+2 = K+2
       movb ra,@K2+2                   ; STA K2+2          

       movb ra,@P+1                    ; STA P+1           ; Set P+1 = K+2

       movb @BETA,ra                   ; LDA BETA          ; Set Q = beta, the pitch angle of our ship
       movb ra,@Q                      ; STA Q             

       movb @K+3,ra                    ; LDA K+3           ; Set K+3 to K2+3, so now we have result 1 above:
       movb ra,@K2+3                   ; STA K2+3          ; 
                                                           ; K2(3 2 1) = K(3 2 1)
                                                           ; = y - alpha * x / 256

                                                           ; We also have:
                                                           ; 
                                                           ; A = K+3
                                                           ; 
                                                           ; P(1 0) = K(2 1)
                                                           ; 
                                                           ; so combined, these mean:
                                                           ; 
                                                           ; (A P+1 P) = K(3 2 1)
                                                           ; = K2(3 2 1)

       .jsr @MULT3                     ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
                                                           ; 
                                                           ; which also means:
                                                           ; 
                                                           ; K(3 2 1) = (A P+1 P) * Q / 256
                                                           ; = K2(3 2 1) * beta / 256
                                                           ; = beta * K2 / 256

       li   rx,>06*256                 ; LDX #6            ; K(3 2 1) = (z_sign z_hi z_lo) + K(3 2 1)
       .jsr @MVT3                      ; JSR MVT3          ; = z + beta * K2 / 256

       movb @K+1,ra                    ; LDA K+1           ; Set P = K+1
       movb ra,@P                      ; STA P             

       movb ra,@INWK+6                 ; STA INWK+6        ; Set z_lo = K+1

       movb @K+2,ra                    ; LDA K+2           ; Set P+1 = K+2
       movb ra,@P+1                    ; STA P+1           

       movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi = K+2

       movb @K+3,ra                    ; LDA K+3           ; Set A = z_sign = K+3, so now we have:
       movb ra,@INWK+8                 ; STA INWK+8        ; 
                                                           ; (z_sign z_hi z_lo) = K(3 2 1)
                                                           ; = z + beta * K2 / 256

                                                           ; So we now have result 2 above:
                                                           ; 
                                                           ; z = z + beta * K2

       .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit of A to give A = -z_sign

       .jsr @MULT3                     ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
                                                           ; = (-z_sign z_hi z_lo) * beta
                                                           ; = -z * beta

       movb @K+3,ra                    ; LDA K+3           ; Set T to the sign bit of K(3 2 1 0), i.e. to the sign
       andi ra,>80*256                 ; AND #%10000000    ; bit of -z * beta
       movb ra,@T                      ; STA T             

       .eor @K2+3                      ; EOR K2+3          ; If K2(3 2 1 0) has a different sign to K(3 2 1 0),
       jlt  MV1                        ; BMI MV1           ; then EOR'ing them will produce a 1 in bit 7, so jump
                                                           ; to MV1 to take this into account

                                                           ; If we get here, K and K2 have the same sign, so we can
                                                           ; add them together to get the result we're after, and
                                                           ; then set the sign afterwards

       movb @K,ra                      ; LDA K             ; We now do the following sum:
* CLC                    \
       .adc @K2,ra                     ; ADC K2            ; (A y_hi y_lo -) = K(3 2 1 0) + K2(3 2 1 0)
                                                           ; 
                                                           ; starting with the low bytes (which we don't keep)
                                                           ; 
                                                           ; The CLC instruction is commented out in the original
                                                           ; source. It isn't needed because MULT3 clears the C
                                                           ; flag, so this is an example of the authors finding
                                                           ; one more precious byte to save

       movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
       .adc @K2+1,ra                   ; ADC K2+1          
       movb ra,@INWK+3                 ; STA INWK+3        

       movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
       .adc @K2+2,ra                   ; ADC K2+2          
       movb ra,@INWK+4                 ; STA INWK+4        

       movb @K+3,ra                    ; LDA K+3           ; And then the sign bytes into A, so overall we have the
       .adc @K2+3,ra                   ; ADC K2+3          ; following, if we drop the low bytes from the result:
                                                           ; 
                                                           ; (A y_hi y_lo) = (K + K2) / 256

       b    @MV2                       ; JMP MV2           ; Jump to MV2 to skip the calculation for when K and K2
                                                           ; have different signs

MV1:
       movb @K,ra                      ; LDA K             ; If we get here then K2 and K have different signs, so
       .sec                            ; SEC               ; instead of adding, we need to subtract to get the
       .sbc @K2,ra                     ; SBC K2            ; result we want, like this:
                                                           ; 
                                                           ; (A y_hi y_lo -) = K(3 2 1 0) - K2(3 2 1 0)
                                                           ; 
                                                           ; starting with the low bytes (which we don't keep)

       movb @K+1,ra                    ; LDA K+1           ; We then do the middle bytes, which go into y_lo
       .sbc @K2+1,ra                   ; SBC K2+1          
       movb ra,@INWK+3                 ; STA INWK+3        

       movb @K+2,ra                    ; LDA K+2           ; And then the high bytes, which go into y_hi
       .sbc @K2+2,ra                   ; SBC K2+2          
       movb ra,@INWK+4                 ; STA INWK+4        

       movb @K2+3,ra                   ; LDA K2+3          ; Now for the sign bytes, so first we extract the sign
       andi ra,>7f*256                 ; AND #%01111111    ; byte from K2 without the sign bit, so P = |K2+3|
       movb ra,@P                      ; STA P             

       movb @K+3,ra                    ; LDA K+3           ; And then we extract the sign byte from K without the
       andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |K+3|

       .sbc @P,ra                      ; SBC P             ; And finally we subtract the sign bytes, so P = A - P
       movb ra,@P                      ; STA P             

                                                           ; By now we have the following, if we drop the low bytes
                                                           ; from the result:
                                                           ; 
                                                           ; (A y_hi y_lo) = (K - K2) / 256
                                                           ; 
                                                           ; so now we just need to make sure the sign of the
                                                           ; result is correct

       joc  MV2                        ; BCS MV2           ; If the C flag is set, then the last subtraction above
                                                           ; didn't underflow and the result is correct, so jump to
                                                           ; MV2 as we are done with this particular stage

       li   ra,>01*256                 ; LDA #1            ; Otherwise the subtraction above underflowed, as K2 is
       .sbc @INWK+3,ra                 ; SBC INWK+3        ; the dominant part of the subtraction, so we need to
       movb ra,@INWK+3                 ; STA INWK+3        ; negate the result using two's complement, starting
                                                           ; with the low bytes:
                                                           ; 
                                                           ; y_lo = 1 - y_lo

       li   ra,>00*256                 ; LDA #0            ; And then the high bytes:
       .sbc @INWK+4,ra                 ; SBC INWK+4        ; 
       movb ra,@INWK+4                 ; STA INWK+4        ; y_hi = 0 - y_hi

       li   ra,>00*256                 ; LDA #0            ; And finally the sign bytes:
       .sbc @P,ra                      ; SBC P             ; 
                                                           ; A = 0 - P

       ori  ra,>80*256                 ; ORA #%10000000    ; We now force the sign bit to be negative, so that the
                                                           ; final result below gets the opposite sign to K, which
                                                           ; we want as K2 is the dominant part of the sum

MV2:
       .eor @T                         ; EOR T             ; T contains the sign bit of K, so if K is negative,
                                                           ; this flips the sign of A

       movb ra,@INWK+5                 ; STA INWK+5        ; Store A in y_sign

                                                           ; So we now have result 3 above:
                                                           ; 
                                                           ; y = K2 + K
                                                           ; = K2 - beta * z

       movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha
       movb ra,@Q                      ; STA Q             

       movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
       movb ra,@P                      ; STA P             
       movb @INWK+4,ra                 ; LDA INWK+4        
       movb ra,@P+1                    ; STA P+1           

       movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = y_sign

       .jsr @MULT3                     ; JSR MULT3         ; Set K(3 2 1 0) = (A P+1 P) * Q
                                                           ; = (y_sign y_hi y_lo) * alpha
                                                           ; = y * alpha

       li   rx,>00*256                 ; LDX #0            ; Set K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
       .jsr @MVT3                      ; JSR MVT3          ; = x + y * alpha / 256

       movb @K+1,ra                    ; LDA K+1           ; Set (x_sign x_hi x_lo) = K(3 2 1)
       movb ra,@INWK                   ; STA INWK          ; = x + y * alpha / 256
       movb @K+2,ra                    ; LDA K+2           
       movb ra,@INWK+1                 ; STA INWK+1        
       movb @K+3,ra                    ; LDA K+3           
       movb ra,@INWK+2                 ; STA INWK+2        

                                                           ; So we now have result 4 above:
                                                           ; 
                                                           ; x = x + y * alpha

       b    @MV45                      ; JMP MV45          ; We have now finished rotating the planet or sun by
                                                           ; our pitch and roll, so jump back into the MVEIT
                                                           ; routine at MV45 to apply all the other movements

* ******************************************************************************
* 
* Save ELTA.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE B FILE
* 
* Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_B.:
       equ $

LOAD_B.:
       equ LOAD. + $ - CODE.

* ******************************************************************************
* 
* Name: NA%
* Type: Variable
* Category: Save and load
* Summary: The data block for the last saved commander
* Deep dive: Commander save files
* The competition code
* 
* ------------------------------------------------------------------------------
* 
* Contains the last saved commander data, with the name at NA% and the data at
* NA%+8 onwards. The size of the data block is given in NT% (which also includes
* the two checksum bytes that follow this block). This block is initially set up
* with the default commander, which can be maxed out for testing purposes by
* setting Q% to TRUE.
* 
* The commander's name is stored at NA%, and can be up to 7 characters long
* (the DFS filename limit). It is terminated with a carriage return character,
* ASCII 13.
* 
* The offset of each byte within a saved commander file is also shown as #0, #1
* and so on, so the kill tally, for example, is in bytes #71 and #72 of the
* saved file. The related variable name from the current commander block is
* also shown.
* 
* ******************************************************************************

NA.:
       text 'JAMESON'                                                ; The current commander name, which defaults to JAMESON
       byte >0d                                                      ; 
                                                                     ; The commander name can be up to 7 characters (the DFS
                                                                     ; limit for filenames), and is terminated by a carriage
                                                                     ; return

                                                           ; NA%+8 is the start of the commander data block
                                                           ; 
                                                           ; This block contains the last saved commander data
                                                           ; block. As the game is played it uses an identical
                                                           ; block at location TP to store the current commander
                                                           ; state, and that block is copied here when the game is
                                                           ; saved. Conversely, when the game starts up, the block
                                                           ; here is copied to TP, which restores the last saved
                                                           ; commander when we die
                                                           ; 
                                                           ; The initial state of this block defines the default
                                                           ; commander. Q% can be set to TRUE to give the default
                                                           ; commander lots of credits and equipment

       byte >00                                                      ; TP = Mission status, #0

       byte >14                                                      ; QQ0 = Current system X-coordinate (Lave), #1
       byte >ad                                                      ; QQ1 = Current system Y-coordinate (Lave), #2

       data >4a5a                                                    ; QQ21 = Seed s0 for system 0, galaxy 0 (Tibedied), #3-4
       data >4802                                                    ; QQ21 = Seed s1 for system 0, galaxy 0 (Tibedied), #5-6
       data >53b7                                                    ; QQ21 = Seed s2 for system 0, galaxy 0 (Tibedied), #7-8

       data >0000, >0000                                             ; CASH = Amount of cash (100,000,000 Cr), #9-12
       data >0000, >0000                                             ; CASH = Amount of cash (100 Cr), #9-12

       byte >46                                                      ; QQ14 = Fuel level, #13

       byte >00                                                      ; COK = Competition flags, #14

       byte >00                                                      ; GCNT = Galaxy number, 0-7, #15

       byte >00                                                      ; LASER = Front laser, #16

       byte >00                                                      ; LASER+1 = Rear laser, #17

       byte >00                                                      ; LASER+2 = Left laser, #18

       byte >00                                                      ; LASER+3 = Right laser, #19

       data >0000                                                    ; These bytes appear to be unused (they were originally
                                                                     ; used for up/down lasers, but they were dropped),
                                                                     ; #20-21

       byte >16                                                      ; CRGO = Cargo capacity, #22

       byte >00                                                      ; QQ20+0  = Amount of food in cargo hold, #23
       byte >00                                                      ; QQ20+1  = Amount of textiles in cargo hold, #24
       byte >00                                                      ; QQ20+2  = Amount of radioactives in cargo hold, #25
       byte >00                                                      ; QQ20+3  = Amount of slaves in cargo hold, #26
       byte >00                                                      ; QQ20+4  = Amount of liquor/Wines in cargo hold, #27
       byte >00                                                      ; QQ20+5  = Amount of luxuries in cargo hold, #28
       byte >00                                                      ; QQ20+6  = Amount of narcotics in cargo hold, #29
       byte >00                                                      ; QQ20+7  = Amount of computers in cargo hold, #30
       byte >00                                                      ; QQ20+8  = Amount of machinery in cargo hold, #31
       byte >00                                                      ; QQ20+9  = Amount of alloys in cargo hold, #32
       byte >00                                                      ; QQ20+10 = Amount of firearms in cargo hold, #33
       byte >00                                                      ; QQ20+11 = Amount of furs in cargo hold, #34
       byte >00                                                      ; QQ20+12 = Amount of minerals in cargo hold, #35
       byte >00                                                      ; QQ20+13 = Amount of gold in cargo hold, #36
       byte >00                                                      ; QQ20+14 = Amount of platinum in cargo hold, #37
       byte >00                                                      ; QQ20+15 = Amount of gem-stones in cargo hold, #38
       byte >00                                                      ; QQ20+16 = Amount of alien items in cargo hold, #39

       byte >00                                                      ; ECM = E.C.M. system, #40

       byte >00                                                      ; BST = Fuel scoops ("barrel status"), #41

       byte >00                                                      ; BOMB = Energy bomb, #42

       byte >00                                                      ; ENGY = Energy/shield level, #43

       byte >00                                                      ; DKCMP = Docking computer, #44

       byte >00                                                      ; GHYP = Galactic hyperdrive, #45

       byte >00                                                      ; ESCP = Escape pod, #46

       data >0000, >0000                                             ; These four bytes appear to be unused, #47-50

       byte >03                                                      ; NOMSL = Number of missiles, #51

       byte >00                                                      ; FIST = Legal status ("fugitive/innocent status"), #52

       byte >10                                                      ; AVL+0  = Market availability of food, #53
       byte >0f                                                      ; AVL+1  = Market availability of textiles, #54
       byte >11                                                      ; AVL+2  = Market availability of radioactives, #55
       byte >00                                                      ; AVL+3  = Market availability of slaves, #56
       byte >03                                                      ; AVL+4  = Market availability of liquor/Wines, #57
       byte >1c                                                      ; AVL+5  = Market availability of luxuries, #58
       byte >0e                                                      ; AVL+6  = Market availability of narcotics, #59
       byte >00                                                      ; AVL+7  = Market availability of computers, #60
       byte >00                                                      ; AVL+8  = Market availability of machinery, #61
       byte >0a                                                      ; AVL+9  = Market availability of alloys, #62
       byte >00                                                      ; AVL+10 = Market availability of firearms, #63
       byte >11                                                      ; AVL+11 = Market availability of furs, #64
       byte >3a                                                      ; AVL+12 = Market availability of minerals, #65
       byte >07                                                      ; AVL+13 = Market availability of gold, #66
       byte >09                                                      ; AVL+14 = Market availability of platinum, #67
       byte >08                                                      ; AVL+15 = Market availability of gem-stones, #68
       byte >00                                                      ; AVL+16 = Market availability of alien items, #69

       byte >00                                                      ; QQ26 = Random byte that changes for each visit to a
                                                                     ; system, for randomising market prices, #70

       data >0000                                                    ; TALLY = Number of kills, #71-72

       byte >80                                                      ; SVC = Save count, #73

* ******************************************************************************
* 
* Name: CHK2
* Type: Variable
* Category: Save and load
* Summary: Second checksum byte for the saved commander data file
* Deep dive: Commander save files
* The competition code
* 
* ------------------------------------------------------------------------------
* 
* Second commander checksum byte. If the default commander is changed, a new
* checksum will be calculated and inserted by the elite-checksum.py script.
* 
* The offset of this byte within a saved commander file is also shown (it's at
* byte #74).
* 
* ******************************************************************************

CHK2:
       byte >03                                                      ; The checksum value for the default commander, EOR'd
                                                                     ; with &A9 to make it harder to tamper with the checksum
                                                                     ; byte, #74

* ******************************************************************************
* 
* Name: CHK
* Type: Variable
* Category: Save and load
* Summary: First checksum byte for the saved commander data file
* Deep dive: Commander save files
* The competition code
* 
* ------------------------------------------------------------------------------
* 
* Commander checksum byte. If the default commander is changed, a new checksum
* will be calculated and inserted by the elite-checksum.py script.
* 
* The offset of this byte within a saved commander file is also shown (it's at
* byte #75).
* 
* ******************************************************************************

CHK:
       byte >03                                                      ; The checksum value for the default commander, #75

* ******************************************************************************
* 
* Name: UNIV
* Type: Variable
* Category: Universe
* Summary: Table of pointers to the local universe's ship data blocks
* Deep dive: The local bubble of universe
* 
* ------------------------------------------------------------------------------
* 
* See the deep dive on "Ship data blocks" for details on ship data blocks, and
* the deep dive on "The local bubble of universe" for details of how Elite
* stores the local universe in K%, FRIN and UNIV.
* 
* ******************************************************************************

UNIV:
       ;  FOR I%, 0, NOSH

       ; EQUW K% + I% * NI%            ;                   ; Address of block no. I%, of size NI%, in workspace K%

       ;  NEXT

* ******************************************************************************
* 
* Name: TWOS
* Type: Variable
* Category: Drawing pixels
* Summary: Ready-made single-pixel character row bytes for mode 4
* Deep dive: Drawing monochrome pixels in mode 4
* 
* ------------------------------------------------------------------------------
* 
* Ready-made bytes for plotting one-pixel points in mode 4 (the top part of the
* split screen). See the PIXEL routine for details.
* 
* ******************************************************************************

TWOS:
       byte >80
       byte >40
       byte >20
       byte >10
       byte >08
       byte >04
       byte >02
       byte >01

* ******************************************************************************
* 
* Name: TWOS2
* Type: Variable
* Category: Drawing pixels
* Summary: Ready-made double-pixel character row bytes for mode 4
* Deep dive: Drawing monochrome pixels in mode 4
* 
* ------------------------------------------------------------------------------
* 
* Ready-made bytes for plotting two-pixel dashes in mode 4 (the top part of the
* split screen). See the PIXEL routine for details.
* 
* ******************************************************************************

TWOS2:
       byte >c0
       byte >60
       byte >30
       byte >18
       byte >0c
       byte >06
       byte >03
       byte >03

* ******************************************************************************
* 
* Name: CTWOS
* Type: Variable
* Category: Drawing pixels
* Summary: Ready-made single-pixel character row bytes for mode 5
* Deep dive: Drawing colour pixels in mode 5
* 
* ------------------------------------------------------------------------------
* 
* Ready-made bytes for plotting one-pixel points in mode 5 (the bottom part of
* the split screen). See the dashboard routines SCAN, DIL2 and CPIX2 for
* details.
* 
* There is one extra row to support the use of CTWOS+1,X indexing in the CPIX2
* routine. The extra row is a repeat of the first row, and saves us from having
* to work out whether CTWOS+1+X needs to be wrapped around when drawing a
* two-pixel dash that crosses from one character block into another. See CPIX2
* for more details.
* 
* ******************************************************************************

CTWOS:
       byte >88
       byte >44
       byte >22
       byte >11
       byte >88

* ******************************************************************************
* 
* Name: LOIN (Part 1 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a line: Calculate the line gradient in the form of deltas
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* This stage calculates the line deltas.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X1                  The screen x-coordinate of the start of the line
* 
* Y1                  The screen y-coordinate of the start of the line
* 
* X2                  The screen x-coordinate of the end of the line
* 
* Y2                  The screen y-coordinate of the end of the line
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is preserved
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL30                LL30 is a synonym for LOIN and draws a line from
* (X1, Y1) to (X2, Y2)
* 
* ******************************************************************************

LL30:
       bss 0                                               ; LL30 is a synonym for LOIN
                                                           ; 
                                                           ; In the cassette and disc versions of Elite, LL30 and
                                                           ; LOIN are synonyms for the same routine, presumably
                                                           ; because the two developers each had their own line
                                                           ; routines to start with, and then chose one of them for
                                                           ; the final game

LOIN:
       movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
                                                           ; call to this subroutine

       li   ra,>80*256                 ; LDA #128          ; Set S = 128, which is the starting point for the
       movb ra,@S                      ; STA S             ; slope error (representing half a pixel)

       .asla                           ; ASL A             ; Set SWAP = 0, as %10000000 << 1 = 0
       movb ra,@SWAP                   ; STA SWAP          

       movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1
       .sbc @X1,ra                     ; SBC X1            ; = delta_x
                                                           ; 
                                                           ; This subtraction works as the ASL A above sets the C
                                                           ; flag

       joc  LI1                        ; BCS LI1           ; If X2 > X1 then A is already positive and we can skip
                                                           ; the next three instructions

       .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
       .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
                                                           ; positive

       .sec                            ; SEC               ; Set the C flag, ready for the subtraction below

LI1:
       movb ra,@P                      ; STA P             ; Store A in P, so P = |X2 - X1|, or |delta_x|

       movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1
       .sbc @Y1,ra                     ; SBC Y1            ; = delta_y
                                                           ; 
                                                           ; This subtraction works as we either set the C flag
                                                           ; above, or we skipped that SEC instruction with a BCS

       joc  LI2                        ; BCS LI2           ; If Y2 > Y1 then A is already positive and we can skip
                                                           ; the next two instructions

       .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A by flipping all the bits and
       .adi (>01*256)                  ; ADC #1            ; adding 1, i.e. using two's complement to make it
                                                           ; positive

LI2:
       movb ra,@Q                      ; STA Q             ; Store A in Q, so Q = |Y2 - Y1|, or |delta_y|

       cb   @P,ra                      ; CMP P             ; If Q < P, jump to STPX to step along the x-axis, as
       jnc  STPX                       ; BCC STPX          ; the line is closer to being horizontal than vertical

       b    @STPY                      ; JMP STPY          ; Otherwise Q >= P so jump to STPY to step along the
                                                           ; y-axis, as the line is closer to being vertical than
                                                           ; horizontal

* ******************************************************************************
* 
* Name: LOIN (Part 2 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a line: Line has a shallow gradient, step right along x-axis
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* If we get here, then:
* 
* * |delta_y| < |delta_x|
* 
* * The line is closer to being horizontal than vertical
* 
* * We are going to step right along the x-axis
* 
* * We potentially swap coordinates to make sure X1 < X2
* 
* ******************************************************************************

STPX:
       movb @X1,rx                     ; LDX X1            ; Set X = X1

       cb   @X2,rx                     ; CPX X2            ; If X1 < X2, jump down to LI3, as the coordinates are
       jnc  LI3                        ; BCC LI3           ; already in the order that we want

       sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
                                                           ; we are swapping the coordinates around

       movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
       movb ra,@X1                     ; STA X1            
       movb rx,@X2                     ; STX X2            

       movb ra,rx                      ; TAX               ; Set X = X1

       movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
       movb @Y1,ry                     ; LDY Y1            
       movb ra,@Y1                     ; STA Y1            
       movb ry,@Y2                     ; STY Y2            

LI3:
                                                           ; By this point we know the line is horizontal-ish and
                                                           ; X1 < X2, so we're going from left to right as we go
                                                           ; from X1 to X2
       movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
       srl  ra,1                       ; LSR A             ; that will contain our horizontal line
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             

       ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
                                                           ; us the screen address of the character row (as each
                                                           ; character row takes up 256 bytes, and the first
                                                           ; character row is at screen address &6000, or page &60)

       movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
                                                           ; the high byte of SC is set correctly for drawing the
                                                           ; start of our line

       movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
       andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
       movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)

       movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
       andi ra,>f8*256                 ; AND #%11111000    

       movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
                                                           ; screen address of the far left end (x-coordinate = 0)
                                                           ; of the horizontal pixel row that we want to draw the
                                                           ; start of our line on

       movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
       andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
       movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
                                                           ; wide)

       movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
       movb ra,@R                      ; STA R             ; and store it in R

                                                           ; The following calculates:
                                                           ; 
                                                           ; Q = Q / P
                                                           ; = |delta_y| / |delta_x|
                                                           ; 
                                                           ; using the same shift-and-subtract algorithm that's
                                                           ; documented in TIS2

       movb @Q,ra                      ; LDA Q             ; Set A = |delta_y|

       li   rx,>fe*256                 ; LDX #%11111110    ; Set Q to have bits 1-7 set, so we can rotate through 7
       movb rx,@Q                      ; STX Q             ; loop iterations, getting a 1 each time, and then
                                                           ; getting a 0 on the 8th iteration... and we can also
                                                           ; use Q to catch our result bits into bit 0 each time

LIL1:
       .asla                           ; ASL A             ; Shift A to the left

       joc  LI4                        ; BCS LI4           ; If bit 7 of A was set, then jump straight to the
                                                           ; subtraction

       cb   @P,ra                      ; CMP P             ; If A < P, skip the following subtraction
       jnc  LI5                        ; BCC LI5           

LI4:
       .sbc @P,ra                      ; SBC P             ; A >= P, so set A = A - P

       .sec                            ; SEC               ; Set the C flag to rotate into the result in Q

LI5:
       .rol @Q                         ; ROL Q             ; Rotate the counter in Q to the left, and catch the
                                                           ; result bit into bit 0 (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       joc  LIL1                       ; BCS LIL1          ; If we still have set bits in Q, loop back to TIL2 to
                                                           ; do the next iteration of 7

                                                           ; We now have:
                                                           ; 
                                                           ; Q = A / P
                                                           ; = |delta_y| / |delta_x|
                                                           ; 
                                                           ; and the C flag is clear

       movb @P,rx                      ; LDX P             ; Set X = P + 1
       ab   rone,rx                    ; INX               ; = |delta_x| + 1
                                                           ; 
                                                           ; We add 1 so we can skip the first pixel plot if the
                                                           ; line is being drawn with swapped coordinates

       movb @Y2,ra                     ; LDA Y2            ; Set A = Y2 - Y1 - 1 (as the C flag is clear following
       .sbc @Y1,ra                     ; SBC Y1            ; the above division)

       joc  DOWN                       ; BCS DOWN          ; If Y2 >= Y1 - 1 then jump to DOWN, as we need to draw
                                                           ; the line to the right and down

* ******************************************************************************
* 
* Name: LOIN (Part 3 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a shallow line going right and up or left and down
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* If we get here, then:
* 
* * The line is going right and up (no swap) or left and down (swap)
* 
* * X1 < X2 and Y1-1 > Y2
* 
* * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
* first pixel
* 
* ******************************************************************************

       movb @SWAP,ra                   ; LDA SWAP          ; If SWAP > 0 then we swapped the coordinates above, so
       jne  LI6                        ; BNE LI6           ; jump down to LI6 to skip plotting the first pixel
                                                           ; 
                                                           ; This appears to be a bug that omits the last pixel
                                                           ; of this type of shallow line, rather than the first
                                                           ; pixel, which makes the treatment of this kind of line
                                                           ; different to the other kinds of slope (they all have a
                                                           ; BEQ instruction at this point, rather than a BNE)
                                                           ; 
                                                           ; The result is a rather messy line join when a shallow
                                                           ; line that goes right and up or left and down joins a
                                                           ; line with any of the other three types of slope
                                                           ; 
                                                           ; This bug was fixed in the advanced versions of Elite,
                                                           ; where the BNE is replaced by a BEQ to bring it in line
                                                           ; with the other three slopes

       sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
                                                           ; the first pixel

LIL2:
                                                           ; We now loop along the line from left to right, using X
                                                           ; as a decreasing counter, and at each count we plot a
                                                           ; single pixel using the pixel mask in R
       movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R

       .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen

LI6:
       .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
                                                           ; the x-axis, so the next pixel we plot will be at the
                                                           ; next x-coordinate along

       jnc  LI7                        ; BCC LI7           ; If the pixel didn't fall out of the right end of R
                                                           ; into the C flag, then jump to LI7

       .ror @R                         ; ROR R             ; Otherwise we need to move over to the next character
                                                           ; block, so first rotate R right so the set C flag goes
                                                           ; back into the left end, giving %10000000

       movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
       .adi (>08*256)                  ; ADC #8            ; character along to the right
       movb ra,@SC                     ; STA SC            

LI7:
       movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
       .adc @Q,ra                      ; ADC Q             
       movb ra,@S                      ; STA S             

       jnc  LIC2                       ; BCC LIC2          ; If the addition didn't overflow, jump to LIC2

       sb   rone,ry                    ; DEY               ; Otherwise we just overflowed, so decrement Y to move
                                                           ; to the pixel line above

       jgt  LIC2                       ; BPL LIC2          ; If Y is positive we are still within the same
                                                           ; character block, so skip to LIC2

       sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
       li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
                                                           ; address and set the pixel line to the last line in
                                                           ; that character block

LIC2:
       sb   rone,rx                    ; DEX               ; Decrement the counter in X

       jne  LIL2                       ; BNE LIL2          ; If we haven't yet reached the right end of the line,
                                                           ; loop back to LIL2 to plot the next pixel along

       movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LOIN (Part 4 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a shallow line going right and down or left and up
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* If we get here, then:
* 
* * The line is going right and down (no swap) or left and up (swap)
* 
* * X1 < X2 and Y1-1 <= Y2
* 
* * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
* first pixel
* 
* ******************************************************************************

DOWN:
       movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
       jeq  LI9                        ; BEQ LI9           ; so jump down to LI9 to skip plotting the first pixel

       sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
                                                           ; the first pixel

LIL3:
                                                           ; We now loop along the line from left to right, using X
                                                           ; as a decreasing counter, and at each count we plot a
                                                           ; single pixel using the pixel mask in R
       movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R

       .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen

LI9:
       .lsr @R                         ; LSR R             ; Shift the single pixel in R to the right to step along
                                                           ; the x-axis, so the next pixel we plot will be at the
                                                           ; next x-coordinate along

       jnc  LI10                       ; BCC LI10          ; If the pixel didn't fall out of the right end of R
                                                           ; into the C flag, then jump to LI10

       .ror @R                         ; ROR R             ; Otherwise we need to move over to the next character
                                                           ; block, so first rotate R right so the set C flag goes
                                                           ; back into the left end, giving %10000000

       movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
       .adi (>08*256)                  ; ADC #8            ; character along to the right
       movb ra,@SC                     ; STA SC            

LI10:
       movb @S,ra                      ; LDA S             ; Set S = S + Q to update the slope error
       .adc @Q,ra                      ; ADC Q             
       movb ra,@S                      ; STA S             

       jnc  LIC3                       ; BCC LIC3          ; If the addition didn't overflow, jump to LIC3

       ab   rone,ry                    ; INY               ; Otherwise we just overflowed, so increment Y to move
                                                           ; to the pixel line below

       ci   ry,>08*256                 ; CPY #8            ; If Y < 8 we are still within the same character block,
       jne  LIC3                       ; BNE LIC3          ; so skip to LIC3

       ab   rone,ra                    ; INC SCH           ; Otherwise we need to move down into the character
       li   ry,>00*256                 ; LDY #0            ; block below, so increment the high byte of the screen
                                                           ; address and set the pixel line to the first line in
                                                           ; that character block

LIC3:
       sb   rone,rx                    ; DEX               ; Decrement the counter in X

       jne  LIL3                       ; BNE LIL3          ; If we haven't yet reached the right end of the line,
                                                           ; loop back to LIL3 to plot the next pixel along

       movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LOIN (Part 5 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a line: Line has a steep gradient, step up along y-axis
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* If we get here, then:
* 
* * |delta_y| >= |delta_x|
* 
* * The line is closer to being vertical than horizontal
* 
* * We are going to step up along the y-axis
* 
* * We potentially swap coordinates to make sure Y1 >= Y2
* 
* ******************************************************************************

STPY:
       movb @Y1,ry                     ; LDY Y1            ; Set A = Y = Y1
       movb ry,ra                      ; TYA               

       movb @X1,rx                     ; LDX X1            ; Set X = X1

       cb   @Y2,ry                     ; CPY Y2            ; If Y1 >= Y2, jump down to LI15, as the coordinates are
       joc  LI15                       ; BCS LI15          ; already in the order that we want

       sb   rone,ra                    ; DEC SWAP          ; Otherwise decrement SWAP from 0 to &FF, to denote that
                                                           ; we are swapping the coordinates around

       movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2
       movb ra,@X1                     ; STA X1            
       movb rx,@X2                     ; STX X2            

       movb ra,rx                      ; TAX               ; Set X = X1

       movb @Y2,ra                     ; LDA Y2            ; Swap the values of Y1 and Y2
       movb ra,@Y1                     ; STA Y1            
       movb ry,@Y2                     ; STY Y2            

       movb ra,ry                      ; TAY               ; Set Y = A = Y1

LI15:
                                                           ; By this point we know the line is vertical-ish and
                                                           ; Y1 >= Y2, so we're going from top to bottom as we go
                                                           ; from Y1 to Y2
       srl  ra,1                       ; LSR A             ; Set A = Y1 / 8, so A now contains the character row
       srl  ra,1                       ; LSR A             ; that will contain our horizontal line
       srl  ra,1                       ; LSR A             

       ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
                                                           ; us the screen address of the character row (as each
                                                           ; character row takes up 256 bytes, and the first
                                                           ; character row is at screen address &6000, or page &60)

       movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
                                                           ; the high byte of SC is set correctly for drawing the
                                                           ; start of our line

       movb rx,ra                      ; TXA               ; Set A = bits 3-7 of X1
       andi ra,>f8*256                 ; AND #%11111000    

       movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
                                                           ; screen address of the far left end (x-coordinate = 0)
                                                           ; of the horizontal pixel row that we want to draw the
                                                           ; start of our line on

       movb rx,ra                      ; TXA               ; Set X = X1 mod 8, which is the horizontal pixel number
       andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
       movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
                                                           ; wide)

       movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS where pixel X is set,
       movb ra,@R                      ; STA R             ; and store it in R

       movb @Y1,ra                     ; LDA Y1            ; Set Y = Y1 mod 8, which is the pixel row within the
       andi ra,>07*256                 ; AND #7            ; character block at which we want to draw the start of
       movb ra,ry                      ; TAY               ; our line (as each character block has 8 rows)

                                                           ; The following calculates:
                                                           ; 
                                                           ; P = P / Q
                                                           ; = |delta_x| / |delta_y|
                                                           ; 
                                                           ; using the same shift-and-subtract algorithm
                                                           ; documented in TIS2

       movb @P,ra                      ; LDA P             ; Set A = |delta_x|

       li   rx,>01*256                 ; LDX #1            ; Set Q to have bits 1-7 clear, so we can rotate through
       movb rx,@P                      ; STX P             ; 7 loop iterations, getting a 1 each time, and then
                                                           ; getting a 1 on the 8th iteration... and we can also
                                                           ; use P to catch our result bits into bit 0 each time

LIL4:
       .asla                           ; ASL A             ; Shift A to the left

       joc  LI13                       ; BCS LI13          ; If bit 7 of A was set, then jump straight to the
                                                           ; subtraction

       cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
       jnc  LI14                       ; BCC LI14          

LI13:
       .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q

       .sec                            ; SEC               ; Set the C flag to rotate into the result in Q

LI14:
       .rol @P                         ; ROL P             ; Rotate the counter in P to the left, and catch the
                                                           ; result bit into bit 0 (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       jnc  LIL4                       ; BCC LIL4          ; If we still have set bits in P, loop back to TIL2 to
                                                           ; do the next iteration of 7

                                                           ; We now have:
                                                           ; 
                                                           ; P = A / Q
                                                           ; = |delta_x| / |delta_y|
                                                           ; 
                                                           ; and the C flag is set

       movb @Q,rx                      ; LDX Q             ; Set X = Q + 1
       ab   rone,rx                    ; INX               ; = |delta_y| + 1
                                                           ; 
                                                           ; We add 1 so we can skip the first pixel plot if the
                                                           ; line is being drawn with swapped coordinates

       movb @X2,ra                     ; LDA X2            ; Set A = X2 - X1 (the C flag is set as we didn't take
       .sbc @X1,ra                     ; SBC X1            ; the above BCC)

       jnc  LFT                        ; BCC LFT           ; If X2 < X1 then jump to LFT, as we need to draw the
                                                           ; line to the left and down

* ******************************************************************************
* 
* Name: LOIN (Part 6 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a steep line going up and left or down and right
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* If we get here, then:
* 
* * The line is going up and left (no swap) or down and right (swap)
* 
* * X1 < X2 and Y1 >= Y2
* 
* * Draw from (X1, Y1) at top left to (X2, Y2) at bottom right, omitting the
* first pixel
* 
* ******************************************************************************

       .clc                            ; CLC               ; Clear the C flag

       movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
       jeq  LI17                       ; BEQ LI17          ; so jump down to LI17 to skip plotting the first pixel

       sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
                                                           ; the first pixel

LIL5:
                                                           ; We now loop along the line from left to right, using X
                                                           ; as a decreasing counter, and at each count we plot a
                                                           ; single pixel using the pixel mask in R
       movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R

       .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen

LI17:
       sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis

       jgt  LI16                       ; BPL LI16          ; If Y is positive we are still within the same
                                                           ; character block, so skip to LI16

       sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
       li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
                                                           ; address and set the pixel line to the last line in
                                                           ; that character block

LI16:
       movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
       .adc @P,ra                      ; ADC P             
       movb ra,@S                      ; STA S             

       jnc  LIC5                       ; BCC LIC5          ; If the addition didn't overflow, jump to LIC5

       .lsr @R                         ; LSR R             ; Otherwise we just overflowed, so shift the single
                                                           ; pixel in R to the right, so the next pixel we plot
                                                           ; will be at the next x-coordinate along

       jnc  LIC5                       ; BCC LIC5          ; If the pixel didn't fall out of the right end of R
                                                           ; into the C flag, then jump to LIC5

       .ror @R                         ; ROR R             ; Otherwise we need to move over to the next character
                                                           ; block, so first rotate R right so the set C flag goes
                                                           ; back into the left end, giving %10000000

       movb @SC,ra                     ; LDA SC            ; Add 8 to SC, so SC(1 0) now points to the next
       .adi (>08*256)                  ; ADC #8            ; character along to the right
       movb ra,@SC                     ; STA SC            

LIC5:
       sb   rone,rx                    ; DEX               ; Decrement the counter in X

       jne  LIL5                       ; BNE LIL5          ; If we haven't yet reached the right end of the line,
                                                           ; loop back to LIL5 to plot the next pixel along

       movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LOIN (Part 7 of 7)
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a steep line going up and right or down and left
* Deep dive: Bresenham's line algorithm
* 
* ------------------------------------------------------------------------------
* 
* This routine draws a line from (X1, Y1) to (X2, Y2). It has multiple stages.
* If we get here, then:
* 
* * The line is going up and right (no swap) or down and left (swap)
* 
* * X1 >= X2 and Y1 >= Y2
* 
* * Draw from (X1, Y1) at bottom left to (X2, Y2) at top right, omitting the
* first pixel
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* HL6                 Contains an RTS
* 
* ******************************************************************************

LFT:
       movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0 then we didn't swap the coordinates above,
       jeq  LI18                       ; BEQ LI18          ; so jump down to LI18 to skip plotting the first pixel

       sb   rone,rx                    ; DEX               ; Decrement the counter in X because we're about to plot
                                                           ; the first pixel

LIL6:
       movb @R,ra                      ; LDA R             ; Fetch the pixel byte from R

       .eor @SC                        ; EOR (SC),Y        ; Store R into screen memory at SC(1 0), using EOR
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen

LI18:
       sb   rone,ry                    ; DEY               ; Decrement Y to step up along the y-axis

       jgt  LI19                       ; BPL LI19          ; If Y is positive we are still within the same
                                                           ; character block, so skip to LI19

       sb   rone,ra                    ; DEC SCH           ; Otherwise we need to move up into the character block
       li   ry,>07*256                 ; LDY #7            ; above, so decrement the high byte of the screen
                                                           ; address and set the pixel line to the last line in
                                                           ; that character block

LI19:
       movb @S,ra                      ; LDA S             ; Set S = S + P to update the slope error
       .adc @P,ra                      ; ADC P             
       movb ra,@S                      ; STA S             

       jnc  LIC6                       ; BCC LIC6          ; If the addition didn't overflow, jump to LIC6

       .asl @R                         ; ASL R             ; Otherwise we just overflowed, so shift the single
                                                           ; pixel in R to the left, so the next pixel we plot
                                                           ; will be at the previous x-coordinate

       jnc  LIC6                       ; BCC LIC6          ; If the pixel didn't fall out of the left end of R
                                                           ; into the C flag, then jump to LIC6

       .rol @R                         ; ROL R             ; Otherwise we need to move over to the next character
                                                           ; block, so first rotate R left so the set C flag goes
                                                           ; back into the right end, giving %0000001

       movb @SC,ra                     ; LDA SC            ; Subtract 7 from SC, so SC(1 0) now points to the
       .sbi (>07*256)                  ; SBC #7            ; previous character along to the left
       movb ra,@SC                     ; STA SC            

       .clc                            ; CLC               ; Clear the C flag so it doesn't affect the additions
                                                           ; below

LIC6:
       sb   rone,rx                    ; DEX               ; Decrement the counter in X

       jne  LIL6                       ; BNE LIL6          ; If we haven't yet reached the left end of the line,
                                                           ; loop back to LIL6 to plot the next pixel along

       movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved

HL6:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: NLIN3
* Type: Subroutine
* Category: Drawing lines
* Summary: Print a title and draw a horizontal line at row 19 to box it in
* 
* ------------------------------------------------------------------------------
* 
* This routine print a text token at the cursor position and draws a horizontal
* line at pixel row 19. It is used for the Status Mode screen, the Short-range
* Chart, the Market Price screen and the Equip Ship screen.
* 
* ******************************************************************************

NLIN3:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A

                                                           ; Fall through into NLIN4 to draw a horizontal line at
                                                           ; pixel row 19

* ******************************************************************************
* 
* Name: NLIN4
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a horizontal line at pixel row 19 to box in a title
* 
* ------------------------------------------------------------------------------
* 
* This routine is used on the Inventory screen to draw a horizontal line at
* pixel row 19 to box in the title.
* 
* ******************************************************************************

NLIN4:
       li   ra,>13*256                 ; LDA #19           ; Jump to NLIN2 to draw a horizontal line at pixel row
       jne  NLIN2                      ; BNE NLIN2         ; 19, returning from the subroutine with using a tail
                                                           ; call (this BNE is effectively a JMP as A will never
                                                           ; be zero)

* ******************************************************************************
* 
* Name: NLIN
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a horizontal line at pixel row 23 to box in a title
* 
* ------------------------------------------------------------------------------
* 
* Draw a horizontal line at pixel row 23 and move the text cursor down one
* line.
* 
* ******************************************************************************

NLIN:
       li   ra,>17*256                 ; LDA #23           ; Set A = 23 so NLIN2 below draws a horizontal line at
                                                           ; pixel row 23

       ab   rone,ra                    ; INC YC            ; Move the text cursor down one line

                                                           ; Fall through into NLIN2 to draw the horizontal line
                                                           ; at row 23

* ******************************************************************************
* 
* Name: NLIN2
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a screen-wide horizontal line at the pixel row in A
* 
* ------------------------------------------------------------------------------
* 
* This draws a line from (2, A) to (254, A), which is almost screen-wide and
* fits in nicely between the white borders without clashing with it.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The pixel row on which to draw the horizontal line
* 
* ******************************************************************************

NLIN2:
       movb ra,@Y1                     ; STA Y1            ; Set Y1 = A

       li   rx,>02*256                 ; LDX #2            ; Set X1 = 2, so (X1, Y1) = (2, A)
       movb rx,@X1                     ; STX X1            

       li   rx,>fe*256                 ; LDX #254          ; Set X2 = 254, so (X2, Y2) = (254, A)
       movb rx,@X2                     ; STX X2            

       jne  HLOIN                      ; BNE HLOIN         ; Call HLOIN to draw a horizontal line from (2, A) to
                                                           ; (254, A) and return from the subroutine (this BNE is
                                                           ; effectively a JMP as A will never be zero)

* ******************************************************************************
* 
* Name: HLOIN2
* Type: Subroutine
* Category: Drawing lines
* Summary: Remove a line from the sun line heap and draw it on-screen
* 
* ------------------------------------------------------------------------------
* 
* Specifically, this does the following:
* 
* * Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
* centre YY(1 0) and length A to the left and right
* 
* * Set the Y-th byte of the LSO block to 0 (i.e. remove this line from the
* sun line heap)
* 
* * Draw a horizontal line from (X1, Y) to (X2, Y)
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* YY(1 0)             The x-coordinate of the centre point of the line
* 
* A                   The half-width of the line, i.e. the contents of the
* Y-th byte of the sun line heap
* 
* Y                   The number of the entry in the sun line heap (which is
* also the y-coordinate of the line)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is preserved
* 
* ******************************************************************************

HLOIN2:
       .jsr @EDGES                     ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
                                                           ; line centred on YY(1 0) and with half-width A

       movb ry,@Y1                     ; STY Y1            ; Set Y1 = Y

       li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
       movb ra,@LSO(ry)                ; STA LSO,Y         

                                                           ; Fall through into HLOIN to draw a horizontal line from
                                                           ; (X1, Y) to (X2, Y)

* ******************************************************************************
* 
* Name: HLOIN
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a horizontal line from (X1, Y1) to (X2, Y1)
* Deep dive: Drawing monochrome pixels in mode 4
* 
* ------------------------------------------------------------------------------
* 
* We do not draw a pixel at the right end of the line.
* 
* To understand how this routine works, you might find it helpful to read the
* deep dive on "Drawing monochrome pixels in mode 4".
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is preserved
* 
* ******************************************************************************

HLOIN:
       movb ry,@YSAV                   ; STY YSAV          ; Store Y into YSAV, so we can preserve it across the
                                                           ; call to this subroutine

       movb @X1,rx                     ; LDX X1            ; Set X = X1

       cb   @X2,rx                     ; CPX X2            ; If X1 = X2 then the start and end points are the same,
       jeq  HL6                        ; BEQ HL6           ; so return from the subroutine (as HL6 contains an RTS)

       jnc  HL5                        ; BCC HL5           ; If X1 < X2, jump to HL5 to skip the following code, as
                                                           ; (X1, Y1) is already the left point

       movb @X2,ra                     ; LDA X2            ; Swap the values of X1 and X2, so we know that (X1, Y1)
       movb ra,@X1                     ; STA X1            ; is on the left and (X2, Y1) is on the right
       movb rx,@X2                     ; STX X2            

       movb ra,rx                      ; TAX               ; Set X = X1

HL5:
       sb   rone,ra                    ; DEC X2            ; Decrement X2 so we do not draw a pixel at the end
                                                           ; point

       movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 / 8, so A now contains the character row
       srl  ra,1                       ; LSR A             ; that will contain our horizontal line
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             

       ori  ra,>60*256                 ; ORA #&60          ; As A < 32, this effectively adds &60 to A, which gives
                                                           ; us the screen address of the character row (as each
                                                           ; character row takes up 256 bytes, and the first
                                                           ; character row is at screen address &6000, or page &60)

       movb ra,@SCH                    ; STA SCH           ; Store the page number of the character row in SCH, so
                                                           ; the high byte of SC is set correctly for drawing our
                                                           ; line

       movb @Y1,ra                     ; LDA Y1            ; Set A = Y1 mod 8, which is the pixel row within the
       andi ra,>07*256                 ; AND #7            ; character block at which we want to draw our line (as
                                                           ; each character block has 8 rows)

       movb ra,@SC                     ; STA SC            ; Store this value in SC, so SC(1 0) now contains the
                                                           ; screen address of the far left end (x-coordinate = 0)
                                                           ; of the horizontal pixel row that we want to draw our
                                                           ; horizontal line on

       movb rx,ra                      ; TXA               ; Set Y = bits 3-7 of X1
       andi ra,>f8*256                 ; AND #%11111000    
       movb ra,ry                      ; TAY               

HL1:
       movb rx,ra                      ; TXA               ; Set T = bits 3-7 of X1, which will contain the
       andi ra,>f8*256                 ; AND #%11111000    ; character number of the start of the line * 8
       movb ra,@T                      ; STA T             

       movb @X2,ra                     ; LDA X2            ; Set A = bits 3-7 of X2, which will contain the
       andi ra,>f8*256                 ; AND #%11111000    ; character number of the end of the line * 8

       .sec                            ; SEC               ; Set A = A - T, which will contain the number of
       .sbc @T,ra                      ; SBC T             ; character blocks we need to fill - 1 * 8

       jeq  HL2                        ; BEQ HL2           ; If A = 0 then the start and end character blocks are
                                                           ; the same, so the whole line fits within one block, so
                                                           ; jump down to HL2 to draw the line

                                                           ; Otherwise the line spans multiple characters, so we
                                                           ; start with the left character, then do any characters
                                                           ; in the middle, and finish with the right character

       srl  ra,1                       ; LSR A             ; Set R = A / 8, so R now contains the number of
       srl  ra,1                       ; LSR A             ; character blocks we need to fill - 1
       srl  ra,1                       ; LSR A             
       movb ra,@R                      ; STA R             

       movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
       andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
       movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
                                                           ; wide)

       movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
                                                           ; right end of the byte (so the filled pixels start at
                                                           ; point X and go all the way to the end of the byte),
                                                           ; which is the shape we want for the left end of the
                                                           ; line

       .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
                                                           ; so we have now drawn the line's left cap

       movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
       .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
       movb ra,ry                      ; TAY               

       movb @R,rx                      ; LDX R             ; Fetch the number of character blocks we need to fill
                                                           ; from R

       sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X

       jeq  HL3                        ; BEQ HL3           ; If X = 0 then we only have the last block to do (i.e.
                                                           ; the right cap), so jump down to HL3 to draw it

       .clc                            ; CLC               ; Otherwise clear the C flag so we can do some additions
                                                           ; while we draw the character blocks with full-width
                                                           ; lines in them

HLL1:
       li   ra,>ff*256                 ; LDA #%11111111    ; Store a full-width 8-pixel horizontal line in SC(1 0)
       .eor @SC                        ; EOR (SC),Y        ; so that it draws the line on-screen, using EOR logic
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; so it merges with whatever is already on-screen

       movb ry,ra                      ; TYA               ; Set Y = Y + 8 so (SC),Y points to the next character
       .adi (>08*256)                  ; ADC #8            ; block along, on the same pixel row as before
       movb ra,ry                      ; TAY               

       sb   rone,rx                    ; DEX               ; Decrement the number of character blocks in X

       jne  HLL1                       ; BNE HLL1          ; Loop back to draw more full-width lines, if we have
                                                           ; any more to draw

HL3:
       movb @X2,ra                     ; LDA X2            ; Now to draw the last character block at the right end
       andi ra,>07*256                 ; AND #7            ; of the line, so set X = X2 mod 8, which is the
       movb ra,rx                      ; TAX               ; horizontal pixel number where the line ends

       movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
                                                           ; left end of the byte (so the filled pixels start at
                                                           ; the left edge and go up to point X), which is the
                                                           ; shape we want for the right end of the line

       .eor @SC                        ; EOR (SC),Y        ; Store this into screen memory at SC(1 0), using EOR
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; logic so it merges with whatever is already on-screen,
                                                           ; so we have now drawn the line's right cap

       movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved across the
                                                           ; call to this subroutine

       .rts                            ; RTS               ; Return from the subroutine

HL2:
                                                           ; If we get here then the entire horizontal line fits
                                                           ; into one character block
       movb @X1,ra                     ; LDA X1            ; Set X = X1 mod 8, which is the horizontal pixel number
       andi ra,>07*256                 ; AND #7            ; within the character block where the line starts (as
       movb ra,rx                      ; TAX               ; each pixel line in the character block is 8 pixels
                                                           ; wide)

       movb @TWFR(rx),ra               ; LDA TWFR,X        ; Fetch a ready-made byte with X pixels filled in at the
       movb ra,@T                      ; STA T             ; right end of the byte (so the filled pixels start at
                                                           ; point X and go all the way to the end of the byte)

       movb @X2,ra                     ; LDA X2            ; Set X = X2 mod 8, which is the horizontal pixel number
       andi ra,>07*256                 ; AND #7            ; where the line ends
       movb ra,rx                      ; TAX               

       movb @TWFL(rx),ra               ; LDA TWFL,X        ; Fetch a ready-made byte with X pixels filled in at the
                                                           ; left end of the byte (so the filled pixels start at
                                                           ; the left edge and go up to point X)

       .and @T                         ; AND T             ; We now have two bytes, one (T) containing pixels from
                                                           ; the starting point X1 onwards, and the other (A)
                                                           ; containing pixels up to the end point at X2, so we can
                                                           ; get the actual line we want to draw by AND'ing them
                                                           ; together. For example, if we want to draw a line from
                                                           ; point 2 to point 5 (within the row of 8 pixels
                                                           ; numbered from 0 to 7), we would have this:
                                                           ; 
                                                           ; T       = %00111111
                                                           ; A       = %11111100
                                                           ; T AND A = %00111100
                                                           ; 
                                                           ; So we can stick T AND A in screen memory to get the
                                                           ; line we want, which is what we do here by setting
                                                           ; A = A AND T

       .eor @SC                        ; EOR (SC),Y        ; Store our horizontal line byte into screen memory at
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; SC(1 0), using EOR logic so it merges with whatever is
                                                           ; already on-screen

       movb @YSAV,ry                   ; LDY YSAV          ; Restore Y from YSAV, so that it's preserved

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TWFL
* Type: Variable
* Category: Drawing lines
* Summary: Ready-made character rows for the left end of a horizontal line in
* mode 4
* 
* ------------------------------------------------------------------------------
* 
* Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
* of the split screen). This table provides a byte with pixels at the left end,
* which is used for the right end of the line.
* 
* See the HLOIN routine for details.
* 
* ******************************************************************************

TWFL:
       byte >80
       byte >c0
       byte >e0
       byte >f0
       byte >f8
       byte >fc
       byte >fe

* ******************************************************************************
* 
* Name: TWFR
* Type: Variable
* Category: Drawing lines
* Summary: Ready-made character rows for the right end of a horizontal line
* in mode 4
* 
* ------------------------------------------------------------------------------
* 
* Ready-made bytes for plotting horizontal line end caps in mode 4 (the top part
* of the split screen). This table provides a byte with pixels at the right end,
* which is used for the left end of the line.
* 
* See the HLOIN routine for details.
* 
* ******************************************************************************

TWFR:
       byte >ff
       byte >7f
       byte >3f
       byte >1f
       byte >0f
       byte >07
       byte >03
       byte >01

* ******************************************************************************
* 
* Name: PX3
* Type: Subroutine
* Category: Drawing pixels
* Summary: Plot a single pixel at (X, Y) within a character block
* 
* ------------------------------------------------------------------------------
* 
* This routine is called from PIXEL to set 1 pixel within a character block for
* a distant point (i.e. where the distance ZZ >= &90). See the PIXEL routine for
* details, as this routine is effectively part of PIXEL.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The x-coordinate of the pixel within the character block
* 
* Y                   The y-coordinate of the pixel within the character block
* 
* SC(1 0)             The screen address of the character block
* 
* T1                  The value of Y to restore on exit, so Y is preserved by
* the call to PIXEL
* 
* ******************************************************************************

PX3:
       movb @TWOS(rx),ra               ; LDA TWOS,X        ; Fetch a 1-pixel byte from TWOS and EOR it into SC+Y
       .eor @SC                        ; EOR (SC),Y        
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PIX1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (YY+1 SYL+Y) = (A P) + (S R) and draw stardust particle
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* (YY+1 SYL+Y) = (A P) + (S R)
* 
* and draw a stardust particle at (X1,Y1) with distance ZZ.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* (A P)               A is the angle ALPHA or BETA, P is always 0
* 
* (S R)               YY(1 0) or YY(1 0) + Q * A
* 
* Y                   Stardust particle number
* 
* X1                  The x-coordinate offset
* 
* Y1                  The y-coordinate offset
* 
* ZZ                  The distance of the point (further away = smaller point)
* 
* ******************************************************************************

PIX1:
       .jsr @ADD                       ; JSR ADD           ; Set (A X) = (A P) + (S R)

       movb ra,@YY+1                   ; STA YY+1          ; Set YY+1 to A, the high byte of the result

       movb rx,ra                      ; TXA               ; Set SYL+Y to X, the low byte of the result
       movb ra,@SYL(ry)                ; STA SYL,Y         

                                                           ; Fall through into PIX1 to draw the stardust particle
                                                           ; at (X1,Y1)

* ******************************************************************************
* 
* Name: PIXEL2
* Type: Subroutine
* Category: Drawing pixels
* Summary: Draw a stardust particle relative to the screen centre
* 
* ------------------------------------------------------------------------------
* 
* Draw a point (X1, Y1) from the middle of the screen with a size determined by
* a distance value. Used to draw stardust particles.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X1                  The x-coordinate offset
* 
* Y1                  The y-coordinate offset (positive means up the screen
* from the centre, negative means down the screen)
* 
* ZZ                  The distance of the point (further away = smaller point)
* 
* ******************************************************************************

PIXEL2:
       movb @X1,ra                     ; LDA X1            ; Fetch the x-coordinate offset into A

       jgt  PX1                        ; BPL PX1           ; If the x-coordinate offset is positive, jump to PX1
                                                           ; to skip the following negation

       .eoi (>7f*256)                  ; EOR #%01111111    ; The x-coordinate offset is negative, so flip all the
       .clc                            ; CLC               ; bits apart from the sign bit and add 1, to convert it
       .adi (>01*256)                  ; ADC #1            ; from a sign-magnitude number to a signed number

PX1:
       .eoi (>80*256)                  ; EOR #%10000000    ; Set X = X1 + 128
       movb ra,rx                      ; TAX               ; 
                                                           ; So X is now the offset converted to an x-coordinate,
                                                           ; centred on x-coordinate 128

       movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A and clear the
       andi ra,>7f*256                 ; AND #%01111111    ; sign bit, so A = |Y1|

       ci   ra,>60*256                 ; CMP #96           ; If |Y1| >= 96 then it's off the screen (as 96 is half
       joc  PX4                        ; BCS PX4           ; the screen height), so return from the subroutine (as
                                                           ; PX4 contains an RTS)

       movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate offset into A

       jgt  PX2                        ; BPL PX2           ; If the y-coordinate offset is positive, jump to PX2
                                                           ; to skip the following negation

       .eoi (>7f*256)                  ; EOR #%01111111    ; The y-coordinate offset is negative, so flip all the
       .adi (>01*256)                  ; ADC #1            ; bits apart from the sign bit and subtract 1, to negate
                                                           ; it to a positive number, i.e. A is now |Y1|

PX2:
       movb ra,@T                      ; STA T             ; Set A = 97 - Y1
       li   ra,>61*256                 ; LDA #97           ; 
       .sbc @T,ra                      ; SBC T             ; So if Y is positive we display the point up from the
                                                           ; centre at y-coordinate 97, while a negative Y means
                                                           ; down from the centre

                                                           ; Fall through into PIXEL to draw the stardust at the
                                                           ; screen coordinates in (X, A)

* ******************************************************************************
* 
* Name: PIXEL
* Type: Subroutine
* Category: Drawing pixels
* Summary: Draw a 1-pixel dot, 2-pixel dash or 4-pixel square
* Deep dive: Drawing monochrome pixels in mode 4
* 
* ------------------------------------------------------------------------------
* 
* Draw a point at screen coordinate (X, A) with the point size determined by the
* distance in ZZ. This applies to the top part of the screen (the monochrome
* mode 4 portion).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The screen x-coordinate of the point to draw
* 
* A                   The screen y-coordinate of the point to draw
* 
* ZZ                  The distance of the point (further away = smaller point)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is preserved
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* PX4                 Contains an RTS
* 
* ******************************************************************************

PIXEL:
       movb ry,@T1                     ; STY T1            ; Store Y in T1

       movb ra,ry                      ; TAY               ; Copy A into Y, for use later

       srl  ra,1                       ; LSR A             ; Set SCH = &60 + A >> 3
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       ori  ra,>60*256                 ; ORA #&60          
       movb ra,@SCH                    ; STA SCH           

       movb rx,ra                      ; TXA               ; Set SC = (X >> 3) * 8
       andi ra,>f8*256                 ; AND #%11111000    
       movb ra,@SC                     ; STA SC            

       movb ry,ra                      ; TYA               ; Set Y = Y AND %111
       andi ra,>07*256                 ; AND #%00000111    
       movb ra,ry                      ; TAY               

       movb rx,ra                      ; TXA               ; Set X = X AND %111
       andi ra,>07*256                 ; AND #%00000111    
       movb ra,rx                      ; TAX               

       movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 144, then this point is a very
       ci   ra,>90*256                 ; CMP #144          ; long way away, so jump to PX3 to fetch a 1-pixel point
       joc  PX3                        ; BCS PX3           ; from TWOS and EOR it into SC+Y

       movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Otherwise fetch a 2-pixel dash from TWOS2 and EOR it
       .eor @SC                        ; EOR (SC),Y        ; into SC+Y
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       movb @ZZ,ra                     ; LDA ZZ            ; If distance in ZZ >= 80, then this point is a medium
       ci   ra,>50*256                 ; CMP #80           ; distance away, so jump to PX13 to stop drawing, as a
       joc  PX13                       ; BCS PX13          ; 2-pixel dash is enough

                                                           ; Otherwise we keep going to draw another 2 pixel point
                                                           ; either above or below the one we just drew, to make a
                                                           ; 4-pixel square

       sb   rone,ry                    ; DEY               ; Reduce Y by 1 to point to the pixel row above the one
       jgt  PX14                       ; BPL PX14          ; we just plotted, and if it is still positive, jump to
                                                           ; PX14 to draw our second 2-pixel dash

       li   ry,>01*256                 ; LDY #1            ; Reducing Y by 1 made it negative, which means Y was
                                                           ; 0 before we did the DEY above, so set Y to 1 to point
                                                           ; to the pixel row after the one we just plotted

PX14:
       movb @TWOS2(rx),ra              ; LDA TWOS2,X       ; Fetch a 2-pixel dash from TWOS2 and EOR it into this
       .eor @SC                        ; EOR (SC),Y        ; second row to make a 4-pixel square
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

PX13:
       movb @T1,ry                     ; LDY T1            ; Restore Y from T1, so Y is preserved by the routine

PX4:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: BLINE
* Type: Subroutine
* Category: Drawing circles
* Summary: Draw a circle segment and add it to the ball line heap
* Deep dive: The ball line heap
* Drawing circles
* 
* ------------------------------------------------------------------------------
* 
* Draw a single segment of a circle, adding the point to the ball line heap.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* CNT                 The number of this segment
* 
* STP                 The step size for the circle
* 
* K6(1 0)             The x-coordinate of the new point on the circle, as
* a screen coordinate
* 
* (T X)               The y-coordinate of the new point on the circle, as
* an offset from the centre of the circle
* 
* FLAG                Set to &FF for the first call, so it sets up the first
* point in the heap but waits until the second call before
* drawing anything (as we need two points, i.e. two calls,
* before we can draw a line)
* 
* K4(1 0)             Pixel y-coordinate of the centre of the circle
* 
* K5(1 0)             Screen x-coordinate of the previous point added to the
* ball line heap (if this is not the first point)
* 
* K5(3 2)             Screen y-coordinate of the previous point added to the
* ball line heap (if this is not the first point)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* CNT                 CNT is updated to CNT + STP
* 
* A                   The new value of CNT
* 
* K5(1 0)             Screen x-coordinate of the point that we just added to
* the ball line heap
* 
* K5(3 2)             Screen y-coordinate of the point that we just added to
* the ball line heap
* 
* FLAG                Set to 0
* 
* ******************************************************************************

BLINE:
       movb rx,ra                      ; TXA               ; Set K6(3 2) = (T X) + K4(1 0)
       .adc @K4,ra                     ; ADC K4            ; = y-coord of centre + y-coord of new point
       movb ra,@K6+2                   ; STA K6+2          ; 
       movb @K4+1,ra                   ; LDA K4+1          ; so K6(3 2) now contains the y-coordinate of the new
       .adc @T,ra                      ; ADC T             ; point on the circle but as a screen coordinate, to go
       movb ra,@K6+3                   ; STA K6+3          ; along with the screen x-coordinate in K6(1 0)

       movb @FLAG,ra                   ; LDA FLAG          ; If FLAG = 0, jump down to BL1
       jeq  BL1                        ; BEQ BL1           

       ab   rone,ra                    ; INC FLAG          ; Flag is &FF so this is the first call to BLINE, so
                                                           ; increment FLAG to set it to 0, as then the next time
                                                           ; we call BLINE it can draw the first line, from this
                                                           ; point to the next

BL5:
                                                           ; The following inserts a &FF marker into the LSY2 line
                                                           ; heap to indicate that the next call to BLINE should
                                                           ; store both the (X1, Y1) and (X2, Y2) points. We do
                                                           ; this on the very first call to BLINE (when FLAG is
                                                           ; &FF), and on subsequent calls if the segment does not
                                                           ; fit on-screen, in which case we don't draw or store
                                                           ; that segment, and we start a new segment with the next
                                                           ; call to BLINE that does fit on-screen
       movb @LSP,ry                    ; LDY LSP           ; If byte LSP-1 of LSY2 = &FF, jump to BL7 to tidy up
       li   ra,>ff*256                 ; LDA #&FF          ; and return from the subroutine, as the point that has
       cb   @LSY2-1(ry),ra             ; CMP LSY2-1,Y      ; been passed to BLINE is the start of a segment, so all
       jeq  BL7                        ; BEQ BL7           ; we need to do is save the coordinate in K5, without
                                                           ; moving the pointer in LSP

       movb ra,@LSY2(ry)               ; STA LSY2,Y        ; Otherwise we just tried to plot a segment but it
                                                           ; didn't fit on-screen, so put the &FF marker into the
                                                           ; heap for this point, so the next call to BLINE starts
                                                           ; a new segment

       ab   rone,ra                    ; INC LSP           ; Increment LSP to point to the next point in the heap

       jne  BL7                        ; BNE BL7           ; Jump to BL7 to tidy up and return from the subroutine
                                                           ; (this BNE is effectively a JMP, as LSP will never be
                                                           ; zero)

BL1:
       movb @K5,ra                     ; LDA K5            ; Set XX15 = K5 = x_lo of previous point
       movb ra,@XX15                   ; STA XX15          

       movb @K5+1,ra                   ; LDA K5+1          ; Set XX15+1 = K5+1 = x_hi of previous point
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @K5+2,ra                   ; LDA K5+2          ; Set XX15+2 = K5+2 = y_lo of previous point
       movb ra,@XX15+2                 ; STA XX15+2        

       movb @K5+3,ra                   ; LDA K5+3          ; Set XX15+3 = K5+3 = y_hi of previous point
       movb ra,@XX15+3                 ; STA XX15+3        

       movb @K6,ra                     ; LDA K6            ; Set XX15+4 = x_lo of new point
       movb ra,@XX15+4                 ; STA XX15+4        

       movb @K6+1,ra                   ; LDA K6+1          ; Set XX15+5 = x_hi of new point
       movb ra,@XX15+5                 ; STA XX15+5        

       movb @K6+2,ra                   ; LDA K6+2          ; Set XX12 = y_lo of new point
       movb ra,@XX12                   ; STA XX12          

       movb @K6+3,ra                   ; LDA K6+3          ; Set XX12+1 = y_hi of new point
       movb ra,@XX12+1                 ; STA XX12+1        

       .jsr @LL145                     ; JSR LL145         ; Call LL145 to see if the new line segment needs to be
                                                           ; clipped to fit on-screen, returning the clipped line's
                                                           ; end-points in (X1, Y1) and (X2, Y2)

       joc  BL5                        ; BCS BL5           ; If the C flag is set then the line is not visible on
                                                           ; screen anyway, so jump to BL5, to avoid drawing and
                                                           ; storing this line

       movb @SWAP,ra                   ; LDA SWAP          ; If SWAP = 0, then we didn't have to swap the line
       jeq  BL9                        ; BEQ BL9           ; coordinates around during the clipping process, so
                                                           ; jump to BL9 to skip the following swap

       movb @X1,ra                     ; LDA X1            ; Otherwise the coordinates were swapped by the call to
       movb @X2,ry                     ; LDY X2            ; LL145 above, so we swap (X1, Y1) and (X2, Y2) back
       movb ra,@X2                     ; STA X2            ; again
       movb ry,@X1                     ; STY X1            
       movb @Y1,ra                     ; LDA Y1            
       movb @Y2,ry                     ; LDY Y2            
       movb ra,@Y2                     ; STA Y2            
       movb ry,@Y1                     ; STY Y1            

BL9:
       movb @LSP,ry                    ; LDY LSP           ; Set Y = LSP

       movb @LSY2-1(ry),ra             ; LDA LSY2-1,Y      ; If byte LSP-1 of LSY2 is not &FF, jump down to BL8
       ci   ra,>ff*256                 ; CMP #&FF          ; to skip the following (X1, Y1) code
       jne  BL8                        ; BNE BL8           

                                                           ; Byte LSP-1 of LSY2 is &FF, which indicates that we
                                                           ; need to store (X1, Y1) in the heap

       movb @X1,ra                     ; LDA X1            ; Store X1 in the LSP-th byte of LSX2
       movb ra,@LSX2(ry)               ; STA LSX2,Y        

       movb @Y1,ra                     ; LDA Y1            ; Store Y1 in the LSP-th byte of LSY2
       movb ra,@LSY2(ry)               ; STA LSY2,Y        

       ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2

BL8:
       movb @X2,ra                     ; LDA X2            ; Store X2 in the LSP-th byte of LSX2
       movb ra,@LSX2(ry)               ; STA LSX2,Y        

       movb @Y2,ra                     ; LDA Y2            ; Store Y2 in the LSP-th byte of LSX2
       movb ra,@LSY2(ry)               ; STA LSY2,Y        

       ab   rone,ry                    ; INY               ; Increment Y to point to the next byte in LSX2/LSY2

       movb ry,@LSP                    ; STY LSP           ; Update LSP to point to the same as Y

       .jsr @LOIN                      ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)

       movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, jump up to BL5 to add a &FF
       jne  BL5                        ; BNE BL5           ; marker to the end of the line heap. XX13 is non-zero
                                                           ; after the call to the clipping routine LL145 above if
                                                           ; the end of the line was clipped, meaning the next line
                                                           ; sent to BLINE can't join onto the end but has to start
                                                           ; a new segment, and that's what inserting the &FF
                                                           ; marker does

BL7:
       movb @K6,ra                     ; LDA K6            ; Copy the data for this step point from K6(3 2 1 0)
       movb ra,@K5                     ; STA K5            ; into K5(3 2 1 0), for use in the next call to BLINE:
       movb @K6+1,ra                   ; LDA K6+1          ; 
       movb ra,@K5+1                   ; STA K5+1          ; * K5(1 0) = screen x-coordinate of this point
       movb @K6+2,ra                   ; LDA K6+2          ; 
       movb ra,@K5+2                   ; STA K5+2          ; * K5(3 2) = screen y-coordinate of this point
       movb @K6+3,ra                   ; LDA K6+3          ; 
       movb ra,@K5+3                   ; STA K5+3          ; They now become the "previous point" in the next call

       movb @CNT,ra                    ; LDA CNT           ; Set CNT = CNT + STP
       .clc                            ; CLC               
       .adc @STP,ra                    ; ADC STP           
       movb ra,@CNT                    ; STA CNT           

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: FLIP
* Type: Subroutine
* Category: Stardust
* Summary: Reflect the stardust particles in the screen diagonal and redraw
* the stardust field
* 
* ------------------------------------------------------------------------------
* 
* Swap the x- and y-coordinates of all the stardust particles and draw the new
* set of particles. Called by LOOK1 when we switch views.
* 
* This is a quick way of making the stardust field in the new view feel
* different without having to generate a whole new field. If you look carefully
* at the stardust field when you switch views, you can just about see that the
* new field is a reflection of the previous field in the screen diagonal, i.e.
* in the line from bottom left to top right. This is the line where x = y when
* the origin is in the middle of the screen, and positive x and y are right and
* up, which is the coordinate system we use for stardust).
* 
* ******************************************************************************

FLIP:
* LDA MJ                 \ These instructions are commented out in the original
* BNE FLIP-1             \ source. They would have the effect of not swapping the
                                                           ; stardust if we had mis-jumped into witchspace
       movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
                                                           ; we can use it as a counter through all the stardust

FLL1:
       movb @SY(ry),rx                 ; LDX SY,Y          ; Copy the Y-th particle's y-coordinate from SY+Y into X

       movb @SX(ry),ra                 ; LDA SX,Y          ; Copy the Y-th particle's x-coordinate from SX+Y into
       movb ra,@Y1                     ; STA Y1            ; both Y1 and the particle's y-coordinate
       movb ra,@SY(ry)                 ; STA SY,Y          

       movb rx,ra                      ; TXA               ; Copy the Y-th particle's original y-coordinate into
       movb ra,@X1                     ; STA X1            ; both X1 and the particle's x-coordinate, so the x- and
       movb ra,@SX(ry)                 ; STA SX,Y          ; y-coordinates are now swapped and (X1, Y1) contains
                                                           ; the particle's new coordinates

       movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th particle's distance from SZ+Y into ZZ
       movb ra,@ZZ                     ; STA ZZ            

       .jsr @PIXEL2                    ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ

       sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
                                                           ; stardust

       jne  FLL1                       ; BNE FLL1          ; Loop back to FLL1 until we have moved all the stardust
                                                           ; particles

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: STARS
* Type: Subroutine
* Category: Stardust
* Summary: The main routine for processing the stardust
* 
* ------------------------------------------------------------------------------
* 
* Called at the very end of the main flight loop.
* 
* ******************************************************************************

STARS:
* LDA #&FF               \ These instructions are commented out in the original
* STA COL                \ source, but they would set the stardust colour to
                                                           ; white. That said, COL is only used when updating the
                                                           ; dashboard, so this would have no effect - perhaps it's
                                                           ; left over from experiments with a colour top part of
                                                           ; the screen? Who knows...
       movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
                                                           ; 
                                                           ; 0 = front
                                                           ; 1 = rear
                                                           ; 2 = left
                                                           ; 3 = right

       jeq  STARS1                     ; BEQ STARS1        ; If this 0, jump to STARS1 to process the stardust for
                                                           ; the front view

       sb   rone,rx                    ; DEX               ; If this is view 2 or 3, jump to STARS2 (via ST11) to
       jne  ST11                       ; BNE ST11          ; process the stardust for the left or right views

       b    @STARS6                    ; JMP STARS6        ; Otherwise this is the rear view, so jump to STARS6 to
                                                           ; process the stardust for the rear view

ST11:
       b    @STARS2                    ; JMP STARS2        ; Jump to STARS2 for the left or right views, as it's
                                                           ; too far for the branch instruction above

* ******************************************************************************
* 
* Name: STARS1
* Type: Subroutine
* Category: Stardust
* Summary: Process the stardust for the front view
* Deep dive: Stardust in the front view
* 
* ------------------------------------------------------------------------------
* 
* This moves the stardust towards us according to our speed (so the dust rushes
* past us), and applies our current pitch and roll to each particle of dust, so
* the stardust moves correctly when we steer our ship.
* 
* When a stardust particle rushes past us and falls off the side of the screen,
* its memory is recycled as a new particle that's positioned randomly on-screen.
* 
* These are the calculations referred to in the commentary:
* 
* 1. q = 64 * speed / z_hi
* 2. z = z - speed * 64
* 3. y = y + |y_hi| * q
* 4. x = x + |x_hi| * q
* 
* 5. y = y + alpha * x / 256
* 6. x = x - alpha * y / 256
* 
* 7. x = x + 2 * (beta * y / 256) ^ 2
* 8. y = y - beta * 256
* 
* For more information see the deep dive on "Stardust in the front view".
* 
* ******************************************************************************

STARS1:
       movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
                                                           ; we can use it as a counter through all the stardust

                                                           ; In the following, we're going to refer to the 16-bit
                                                           ; space coordinates of the current particle of stardust
                                                           ; (i.e. the Y-th particle) like this:
                                                           ; 
                                                           ; x = (x_hi x_lo)
                                                           ; y = (y_hi y_lo)
                                                           ; z = (z_hi z_lo)
                                                           ; 
                                                           ; These values are stored in (SX+Y SXL+Y), (SY+Y SYL+Y)
                                                           ; and (SZ+Y SZL+Y) respectively

STL1:
       .jsr @DV42                      ; JSR DV42          ; Call DV42 to set the following:
                                                           ; 
                                                           ; (P R) = 256 * DELTA / z_hi
                                                           ; = 256 * speed / z_hi
                                                           ; 
                                                           ; The maximum value returned is P = 2 and R = 128 (see
                                                           ; DV42 for an explanation)

       movb @R,ra                      ; LDA R             ; Set A = R, so now:
                                                           ; 
                                                           ; (P A) = 256 * speed / z_hi

       .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
       .rora                           ; ROR A             ; has a maximum value of 2) and leaves:
       .lsr @P                         ; LSR P             ; 
       .rora                           ; ROR A             ; A = 64 * speed / z_hi

       ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
       movb ra,@Q                      ; STA Q             ; now have result 1 above:
                                                           ; 
                                                           ; Q = 64 * speed / z_hi

       movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
       .sbc @DELT4,ra                  ; SBC DELT4         ; 
       movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) - DELT4(1 0)
                                                           ; 
                                                           ; starting with the low bytes

       movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
       movb ra,@ZZ                     ; STA ZZ            ; 
       .sbc @DELT4+1,ra                ; SBC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
       movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
                                                           ; 
                                                           ; So now we have result 2 above:
                                                           ; 
                                                           ; z = z - DELT4(1 0)
                                                           ; = z - speed * 64

       .jsr @MLU1                      ; JSR MLU1          ; Call MLU1 to set:
                                                           ; 
                                                           ; Y1 = y_hi
                                                           ; 
                                                           ; (A P) = |y_hi| * Q
                                                           ; 
                                                           ; So Y1 contains the original value of y_hi, which we
                                                           ; use below to remove the existing particle

                                                           ; We now calculate:
                                                           ; 
                                                           ; (S R) = YY(1 0) = (A P) + y

       movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
       movb @P,ra                      ; LDA P             ; 
       .adc @SYL(ry),ra                ; ADC SYL,Y         ; YY+1 = A
       movb ra,@YY                     ; STA YY            ; R = YY = P + y_lo
       movb ra,@R                      ; STA R             ; 
                                                           ; so we get this:
                                                           ; 
                                                           ; (? R) = YY(1 0) = (A P) + y_lo

       movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
       .adc @YY+1,ra                   ; ADC YY+1          ; 
       movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi + YY+1
       movb ra,@S                      ; STA S             ; 
                                                           ; so we get our result:
                                                           ; 
                                                           ; (S R) = YY(1 0) = (A P) + (y_hi y_lo)
                                                           ; = |y_hi| * Q + y
                                                           ; 
                                                           ; which is result 3 above, and (S R) is set to the new
                                                           ; value of y

       movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
       movb ra,@X1                     ; STA X1            ; 
                                                           ; So X1 contains the original value of x_hi, which we
                                                           ; use below to remove the existing particle

       .jsr @MLU2                      ; JSR MLU2          ; Set (A P) = |x_hi| * Q

                                                           ; We now calculate:
                                                           ; 
                                                           ; XX(1 0) = (A P) + x

       movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
       movb @P,ra                      ; LDA P             ; 
       .adc @SXL(ry),ra                ; ADC SXL,Y         ; XX(1 0) = (A P) + x_lo
       movb ra,@XX                     ; STA XX            

       movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
       .adc @XX+1,ra                   ; ADC XX+1          ; 
       movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = XX(1 0) + (x_hi 0)
                                                           ; 
                                                           ; so we get our result:
                                                           ; 
                                                           ; XX(1 0) = (A P) + x
                                                           ; = |x_hi| * Q + x
                                                           ; 
                                                           ; which is result 4 above, and we also have:
                                                           ; 
                                                           ; A = XX+1 = (|x_hi| * Q + x) / 256
                                                           ; 
                                                           ; i.e. A is the new value of x, divided by 256

       .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
                                                           ; A has the opposite sign to the flipped roll angle
                                                           ; alpha, i.e. it gets the same sign as alpha

       .jsr @MLS1                      ; JSR MLS1          ; Call MLS1 to calculate:
                                                           ; 
                                                           ; (A P) = A * ALP1
                                                           ; = (x / 256) * alpha

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = (x / 256) * alpha + y
                                                           ; = y + alpha * x / 256

       movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
       movb rx,@YY                     ; STX YY            ; 
                                                           ; YY(1 0) = y + alpha * x / 256
                                                           ; 
                                                           ; which is result 5 above, and we also have:
                                                           ; 
                                                           ; A = YY+1 = y + alpha * x / 256
                                                           ; 
                                                           ; i.e. A is the new value of y, divided by 256

       .eor @ALP2                      ; EOR ALP2          ; EOR A with the correct sign of the roll angle alpha,
                                                           ; so A has the opposite sign to the roll angle alpha

       .jsr @MLS2                      ; JSR MLS2          ; Call MLS2 to calculate:
                                                           ; 
                                                           ; (S R) = XX(1 0)
                                                           ; = x
                                                           ; 
                                                           ; (A P) = A * ALP1
                                                           ; = -y / 256 * alpha

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = -y / 256 * alpha + x

       movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
       movb rx,@XX                     ; STX XX            ; 
                                                           ; x = x - alpha * y / 256

       movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X

       movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
       .eor @BET2+1                    ; EOR BET2+1        

       .jsr @MULTS-2                   ; JSR MULTS-2       ; Call MULTS-2 to calculate:
                                                           ; 
                                                           ; (A P) = X * A
                                                           ; = -beta * y_hi

       movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
                                                           ; 
                                                           ; Q = -beta * y_hi / 256

       .jsr @MUT2                      ; JSR MUT2          ; Call MUT2 to calculate:
                                                           ; 
                                                           ; (S R) = XX(1 0) = x
                                                           ; 
                                                           ; (A P) = Q * A
                                                           ; = (-beta * y_hi / 256) * (-beta * y_hi / 256)
                                                           ; = (beta * y / 256) ^ 2

       .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
       .rola                           ; ROL A             ; flag to bit 7 of the original A, so this does:
       movb ra,@T                      ; STA T             ; 
                                                           ; (T P) = (A P) << 1
                                                           ; = 2 * (beta * y / 256) ^ 2

       li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
       .rora                           ; ROR A             ; calculation above and apply it to T, so we now have:
       socb @T,ra                      ; ORA T             ; 
                                                           ; (A P) = (A P) * 2
                                                           ; = 2 * (beta * y / 256) ^ 2
                                                           ; 
                                                           ; with the doubling retaining the sign of (A P)

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = 2 * (beta * y / 256) ^ 2 + x

       movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1

       movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
       movb ra,@SXL(ry)                ; STA SXL,Y         

                                                           ; So (XX+1 x_lo) now contains:
                                                           ; 
                                                           ; x = x + 2 * (beta * y / 256) ^ 2
                                                           ; 
                                                           ; which is result 7 above

       movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
       movb ra,@R                      ; STA R             
       movb @YY+1,ra                   ; LDA YY+1          
* JSR MAD                \ These instructions are commented out in the original
* STA S                  \ source
* STX R
       movb ra,@S                      ; STA S             

       li   ra,>00*256                 ; LDA #0            ; Set P = 0
       movb ra,@P                      ; STA P             

       movb @BETA,ra                   ; LDA BETA          ; Set A = -beta, so:
       .eoi (>80*256)                  ; EOR #%10000000    ; 
                                                           ; (A P) = (-beta 0)
                                                           ; = -beta * 256

       .jsr @PIX1                      ; JSR PIX1          ; Call PIX1 to calculate the following:
                                                           ; 
                                                           ; (YY+1 y_lo) = (A P) + (S R)
                                                           ; = -beta * 256 + y
                                                           ; 
                                                           ; i.e. y = y - beta * 256, which is result 8 above
                                                           ; 
                                                           ; PIX1 also draws a particle at (X1, Y1) with distance
                                                           ; ZZ, which will remove the old stardust particle, as we
                                                           ; set X1, Y1 and ZZ to the original values for this
                                                           ; particle during the calculations above

                                                           ; We now have our newly moved stardust particle at
                                                           ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                                                           ; and distance z_hi, so we draw it if it's still on
                                                           ; screen, otherwise we recycle it as a new bit of
                                                           ; stardust and draw that

       movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
       movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
       movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1

       andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 120 then jump to KILL1 to recycle this
       ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the side of the screen,
       joc  KILL1                      ; BCS KILL1         ; and rejoin at STC1 with the new particle

       movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
       movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
       movb ra,@Y1                     ; STA Y1            ; byte is in Y1

       andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 120 then jump to KILL1 to recycle this
       ci   ra,>78*256                 ; CMP #120          ; particle, as it's gone off the top or bottom of the
       joc  KILL1                      ; BCS KILL1         ; screen, and rejoin at STC1 with the new particle

       movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi < 16 then jump to KILL1 to recycle this
       ci   ra,>10*256                 ; CMP #16           ; particle, as it's so close that it's effectively gone
       jnc  KILL1                      ; BCC KILL1         ; past us, and rejoin at STC1 with the new particle

       movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi

STC1:
       .jsr @PIXEL2                    ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
                                                           ; i.e. draw the newly moved particle at (x_hi, y_hi)
                                                           ; with distance z_hi

       sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
                                                           ; stardust particle

       jeq  B18                        ; BEQ B18           ; If we have just done the last particle, skip the next
                                                           ; instruction to return from the subroutine

       b    @STL1                      ; JMP STL1          ; We have more stardust to process, so jump back up to
                                                           ; STL1 for the next particle

B18:
       .rts                            ; RTS               ; Return from the subroutine

KILL1:
                                                           ; Our particle of stardust just flew past us, so let's
                                                           ; recycle that particle, starting it at a random
                                                           ; position that isn't too close to the centre point
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>04*256                 ; ORA #4            ; Make sure A is at least 4 and store it in Y1 and y_hi,
       movb ra,@Y1                     ; STA Y1            ; so the new particle starts at least 4 pixels above or
       movb ra,@SY(ry)                 ; STA SY,Y          ; below the centre of the screen

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in X1 and x_hi,
       movb ra,@X1                     ; STA X1            ; so the new particle starts at least 8 pixels either
       movb ra,@SX(ry)                 ; STA SX,Y          ; side of the centre of the screen

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>90*256                 ; ORA #144          ; Make sure A is at least 144 and store it in ZZ and
       movb ra,@SZ(ry)                 ; STA SZ,Y          ; z_hi so the new particle starts in the far distance
       movb ra,@ZZ                     ; STA ZZ            

       movb @Y1,ra                     ; LDA Y1            ; Set A to the new value of y_hi. This has no effect as
                                                           ; STC1 starts with a jump to PIXEL2, which starts with a
                                                           ; LDA instruction

       b    @STC1                      ; JMP STC1          ; Jump up to STC1 to draw this new particle

* ******************************************************************************
* 
* Name: STARS6
* Type: Subroutine
* Category: Stardust
* Summary: Process the stardust for the rear view
* 
* ------------------------------------------------------------------------------
* 
* This routine is very similar to STARS1, which processes stardust for the front
* view. The main difference is that the direction of travel is reversed, so the
* signs in the calculations are different, as well as the order of the first
* batch of calculations.
* 
* When a stardust particle falls away into the far distance, it is removed from
* the screen and its memory is recycled as a new particle, positioned randomly
* along one of the four edges of the screen.
* 
* These are the calculations referred to in the commentary:
* 
* 1. q = 64 * speed / z_hi
* 2. z = z - speed * 64
* 3. y = y + |y_hi| * q
* 4. x = x + |x_hi| * q
* 
* 5. y = y + alpha * x / 256
* 6. x = x - alpha * y / 256
* 
* 7. x = x + 2 * (beta * y / 256) ^ 2
* 8. y = y - beta * 256
* 
* For more information see the deep dive on "Stardust in the front view".
* 
* ******************************************************************************

STARS6:
       movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
                                                           ; we can use it as a counter through all the stardust

STL6:
       .jsr @DV42                      ; JSR DV42          ; Call DV42 to set the following:
                                                           ; 
                                                           ; (P R) = 256 * DELTA / z_hi
                                                           ; = 256 * speed / z_hi
                                                           ; 
                                                           ; The maximum value returned is P = 2 and R = 128 (see
                                                           ; DV42 for an explanation)

       movb @R,ra                      ; LDA R             ; Set A = R, so now:
                                                           ; 
                                                           ; (P A) = 256 * speed / z_hi

       .lsr @P                         ; LSR P             ; Rotate (P A) right by 2 places, which sets P = 0 (as P
       .rora                           ; ROR A             ; has a maximum value of 2) and leaves:
       .lsr @P                         ; LSR P             ; 
       .rora                           ; ROR A             ; A = 64 * speed / z_hi

       ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1, and store it in Q, so we
       movb ra,@Q                      ; STA Q             ; now have result 1 above:
                                                           ; 
                                                           ; Q = 64 * speed / z_hi

       movb @SX(ry),ra                 ; LDA SX,Y          ; Set X1 = A = x_hi
       movb ra,@X1                     ; STA X1            ; 
                                                           ; So X1 contains the original value of x_hi, which we
                                                           ; use below to remove the existing particle

       .jsr @MLU2                      ; JSR MLU2          ; Set (A P) = |x_hi| * Q

                                                           ; We now calculate:
                                                           ; 
                                                           ; XX(1 0) = x - (A P)

       movb ra,@XX+1                   ; STA XX+1          ; First we do the low bytes:
       movb @SXL(ry),ra                ; LDA SXL,Y         ; 
       .sbc @P,ra                      ; SBC P             ; XX(1 0) = x_lo - (A P)
       movb ra,@XX                     ; STA XX            

       movb @X1,ra                     ; LDA X1            ; And then we do the high bytes:
       .sbc @XX+1,ra                   ; SBC XX+1          ; 
       movb ra,@XX+1                   ; STA XX+1          ; XX(1 0) = (x_hi 0) - XX(1 0)
                                                           ; 
                                                           ; so we get our result:
                                                           ; 
                                                           ; XX(1 0) = x - (A P)
                                                           ; = x - |x_hi| * Q
                                                           ; 
                                                           ; which is result 2 above, and we also have:

       .jsr @MLU1                      ; JSR MLU1          ; Call MLU1 to set:
                                                           ; 
                                                           ; Y1 = y_hi
                                                           ; 
                                                           ; (A P) = |y_hi| * Q
                                                           ; 
                                                           ; So Y1 contains the original value of y_hi, which we
                                                           ; use below to remove the existing particle

                                                           ; We now calculate:
                                                           ; 
                                                           ; (S R) = YY(1 0) = y - (A P)

       movb ra,@YY+1                   ; STA YY+1          ; First we do the low bytes with:
       movb @SYL(ry),ra                ; LDA SYL,Y         ; 
       .sbc @P,ra                      ; SBC P             ; YY+1 = A
       movb ra,@YY                     ; STA YY            ; R = YY = y_lo - P
       movb ra,@R                      ; STA R             ; 
                                                           ; so we get this:
                                                           ; 
                                                           ; (? R) = YY(1 0) = y_lo - (A P)

       movb @Y1,ra                     ; LDA Y1            ; And then we do the high bytes with:
       .sbc @YY+1,ra                   ; SBC YY+1          ; 
       movb ra,@YY+1                   ; STA YY+1          ; S = YY+1 = y_hi - YY+1
       movb ra,@S                      ; STA S             ; 
                                                           ; so we get our result:
                                                           ; 
                                                           ; (S R) = YY(1 0) = (y_hi y_lo) - (A P)
                                                           ; = y - |y_hi| * Q
                                                           ; 
                                                           ; which is result 3 above, and (S R) is set to the new
                                                           ; value of y

       movb @SZL(ry),ra                ; LDA SZL,Y         ; We now calculate the following:
       .adc @DELT4,ra                  ; ADC DELT4         ; 
       movb ra,@SZL(ry)                ; STA SZL,Y         ; (z_hi z_lo) = (z_hi z_lo) + DELT4(1 0)
                                                           ; 
                                                           ; starting with the low bytes

       movb @SZ(ry),ra                 ; LDA SZ,Y          ; And then we do the high bytes
       movb ra,@ZZ                     ; STA ZZ            ; 
       .adc @DELT4+1,ra                ; ADC DELT4+1       ; We also set ZZ to the original value of z_hi, which we
       movb ra,@SZ(ry)                 ; STA SZ,Y          ; use below to remove the existing particle
                                                           ; 
                                                           ; So now we have result 4 above:
                                                           ; 
                                                           ; z = z + DELT4(1 0)
                                                           ; = z + speed * 64

       movb @XX+1,ra                   ; LDA XX+1          ; EOR x with the correct sign of the roll angle alpha,
       .eor @ALP2                      ; EOR ALP2          ; so A has the opposite sign to the roll angle alpha

       .jsr @MLS1                      ; JSR MLS1          ; Call MLS1 to calculate:
                                                           ; 
                                                           ; (A P) = A * ALP1
                                                           ; = (-x / 256) * alpha

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = (-x / 256) * alpha + y
                                                           ; = y - alpha * x / 256

       movb ra,@YY+1                   ; STA YY+1          ; Set YY(1 0) = (A X) to give:
       movb rx,@YY                     ; STX YY            ; 
                                                           ; YY(1 0) = y - alpha * x / 256
                                                           ; 
                                                           ; which is result 5 above, and we also have:
                                                           ; 
                                                           ; A = YY+1 = y - alpha * x / 256
                                                           ; 
                                                           ; i.e. A is the new value of y, divided by 256

       .eor @ALP2+1                    ; EOR ALP2+1        ; EOR with the flipped sign of the roll angle alpha, so
                                                           ; A has the opposite sign to the flipped roll angle
                                                           ; alpha, i.e. it gets the same sign as alpha

       .jsr @MLS2                      ; JSR MLS2          ; Call MLS2 to calculate:
                                                           ; 
                                                           ; (S R) = XX(1 0)
                                                           ; = x
                                                           ; 
                                                           ; (A P) = A * ALP1
                                                           ; = y / 256 * alpha

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = y / 256 * alpha + x

       movb ra,@XX+1                   ; STA XX+1          ; Set XX(1 0) = (A X), which gives us result 6 above:
       movb rx,@XX                     ; STX XX            ; 
                                                           ; x = x + alpha * y / 256

       movb @YY+1,ra                   ; LDA YY+1          ; Set A to y_hi and set it to the flipped sign of beta
       .eor @BET2+1                    ; EOR BET2+1        

       movb @BET1,rx                   ; LDX BET1          ; Fetch the pitch magnitude into X

       .jsr @MULTS-2                   ; JSR MULTS-2       ; Call MULTS-2 to calculate:
                                                           ; 
                                                           ; (A P) = X * A
                                                           ; = beta * y_hi

       movb ra,@Q                      ; STA Q             ; Store the high byte of the result in Q, so:
                                                           ; 
                                                           ; Q = beta * y_hi / 256

       movb @XX+1,ra                   ; LDA XX+1          ; Set S = x_hi
       movb ra,@S                      ; STA S             

       .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A, so A now contains -x

       .jsr @MUT1                      ; JSR MUT1          ; Call MUT1 to calculate:
                                                           ; 
                                                           ; R = XX = x_lo
                                                           ; 
                                                           ; (A P) = Q * A
                                                           ; = (beta * y_hi / 256) * (-beta * y_hi / 256)
                                                           ; = (-beta * y / 256) ^ 2

       .asl @P                         ; ASL P             ; Double (A P), store the top byte in A and set the C
       .rola                           ; ROL A             ; flag to bit 7 of the original A, so this does:
       movb ra,@T                      ; STA T             ; 
                                                           ; (T P) = (A P) << 1
                                                           ; = 2 * (-beta * y / 256) ^ 2

       li   ra,>00*256                 ; LDA #0            ; Set bit 7 in A to the sign bit from the A in the
       .rora                           ; ROR A             ; calculation above and apply it to T, so we now have:
       socb @T,ra                      ; ORA T             ; 
                                                           ; (A P) = -2 * (beta * y / 256) ^ 2
                                                           ; 
                                                           ; with the doubling retaining the sign of (A P)

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = -2 * (beta * y / 256) ^ 2 + x

       movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1

       movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
       movb ra,@SXL(ry)                ; STA SXL,Y         

                                                           ; So (XX+1 x_lo) now contains:
                                                           ; 
                                                           ; x = x - 2 * (beta * y / 256) ^ 2
                                                           ; 
                                                           ; which is result 7 above

       movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0) = y
       movb ra,@R                      ; STA R             
       movb @YY+1,ra                   ; LDA YY+1          
       movb ra,@S                      ; STA S             

* EOR #128               \ These instructions are commented out in the original
* JSR MAD                \ source
* STA S
* STX R

       li   ra,>00*256                 ; LDA #0            ; Set P = 0
       movb ra,@P                      ; STA P             

       movb @BETA,ra                   ; LDA BETA          ; Set A = beta, so (A P) = (beta 0) = beta * 256

       .jsr @PIX1                      ; JSR PIX1          ; Call PIX1 to calculate the following:
                                                           ; 
                                                           ; (YY+1 y_lo) = (A P) + (S R)
                                                           ; = beta * 256 + y
                                                           ; 
                                                           ; i.e. y = y + beta * 256, which is result 8 above
                                                           ; 
                                                           ; PIX1 also draws a particle at (X1, Y1) with distance
                                                           ; ZZ, which will remove the old stardust particle, as we
                                                           ; set X1, Y1 and ZZ to the original values for this
                                                           ; particle during the calculations above

                                                           ; We now have our newly moved stardust particle at
                                                           ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                                                           ; and distance z_hi, so we draw it if it's still on
                                                           ; screen, otherwise we recycle it as a new bit of
                                                           ; stardust and draw that

       movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
       movb ra,@X1                     ; STA X1            ; the new x-coordinate is in (x_hi x_lo) and the high
       movb ra,@SX(ry)                 ; STA SX,Y          ; byte is in X1

       movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
       movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
       movb ra,@Y1                     ; STA Y1            ; byte is in Y1

       andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 110 then jump to KILL6 to recycle this
       ci   ra,>6e*256                 ; CMP #110          ; particle, as it's gone off the top or bottom of the
       joc  KILL6                      ; BCS KILL6         ; screen, and rejoin at STC6 with the new particle

       movb @SZ(ry),ra                 ; LDA SZ,Y          ; If z_hi >= 160 then jump to KILL6 to recycle this
       ci   ra,>a0*256                 ; CMP #160          ; particle, as it's so far away that it's too far to
       joc  KILL6                      ; BCS KILL6         ; see, and rejoin at STC1 with the new particle

       movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the z-coordinate in z_hi

STC6:
       .jsr @PIXEL2                    ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
                                                           ; i.e. draw the newly moved particle at (x_hi, y_hi)
                                                           ; with distance z_hi

       sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
                                                           ; stardust particle

       jeq  ST3                        ; BEQ ST3           ; If we have just done the last particle, skip the next
                                                           ; instruction to return from the subroutine

       b    @STL6                      ; JMP STL6          ; We have more stardust to process, so jump back up to
                                                           ; STL6 for the next particle

ST3:
       .rts                            ; RTS               ; Return from the subroutine

KILL6:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of A to get |A|

       .adi (>0a*256)                  ; ADC #10           ; Make sure A is at least 10 and store it in z_hi and
       movb ra,@SZ(ry)                 ; STA SZ,Y          ; ZZ, so the new particle starts close to us
       movb ra,@ZZ                     ; STA ZZ            

       srl  ra,1                       ; LSR A             ; Divide A by 2 and randomly set the C flag

       joc  ST4                        ; BCS ST4           ; Jump to ST4 half the time

       srl  ra,1                       ; LSR A             ; Randomly set the C flag again

       li   ra,>fc*256                 ; LDA #252          ; Set A to either +126 or -126 (252 >> 1) depending on
       .rora                           ; ROR A             ; the C flag, as this is a sign-magnitude number with
                                                           ; the C flag rotated into its sign bit

       movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on
       movb ra,@SX(ry)                 ; STA SX,Y          ; either the left or right edge of the screen

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
       movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along either the left or right edge

       b    @STC6                      ; JMP STC6          ; Jump up to STC6 to draw this new particle

ST4:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
       movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis

       srl  ra,1                       ; LSR A             ; Randomly set the C flag

       li   ra,>e6*256                 ; LDA #230          ; Set A to either +115 or -115 (230 >> 1) depending on
       .rora                           ; ROR A             ; the C flag, as this is a sign-magnitude number with
                                                           ; the C flag rotated into its sign bit

       movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts anywhere
       movb ra,@SY(ry)                 ; STA SY,Y          ; along either the top or bottom edge of the screen

       jne  STC6                       ; BNE STC6          ; Jump up to STC6 to draw this new particle (this BNE is
                                                           ; effectively a JMP as A will never be zero)

* ******************************************************************************
* 
* Name: PRXS
* Type: Variable
* Category: Equipment
* Summary: Equipment prices
* 
* ------------------------------------------------------------------------------
* 
* Equipment prices are stored as 10 * the actual value, so we can support prices
* with fractions of credits (0.1 Cr). This is used for the price of fuel only.
* 
* ******************************************************************************

PRXS:
       data >0100                                                    ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
       data >2c01                                                    ; 1  Missile                     30.0 Cr
       data >a00f                                                    ; 2  Large Cargo Bay            400.0 Cr
       data >7017                                                    ; 3  E.C.M. System              600.0 Cr
       data >a00f                                                    ; 4  Extra Pulse Lasers         400.0 Cr
       data >1027                                                    ; 5  Extra Beam Lasers         1000.0 Cr
       data >8214                                                    ; 6  Fuel Scoops                525.0 Cr
       data >1027                                                    ; 7  Escape Pod                1000.0 Cr
       data >2823                                                    ; 8  Energy Bomb                900.0 Cr
       data >983a                                                    ; 9  Energy Unit               1500.0 Cr
       data >1027                                                    ; 10 Docking Computer          1000.0 Cr
       data >50c3                                                    ; 11 Galactic Hyperspace       5000.0 Cr

* ******************************************************************************
* 
* Name: STATUS
* Type: Subroutine
* Category: Status
* Summary: Show the Status Mode screen (red key f8)
* Deep dive: Combat rank
* 
* ******************************************************************************

st4_:
                                                           ; We call this from st5 below with the high byte of the
                                                           ; kill tally in A, which is non-zero, and want to return
                                                           ; with the following in X, depending on our rating:
                                                           ; 
                                                           ; Competent = 6
                                                           ; Dangerous = 7
                                                           ; Deadly    = 8
                                                           ; Elite     = 9
                                                           ; 
                                                           ; The high bytes of the top tier ratings are as follows,
                                                           ; so this a relatively simple calculation:
                                                           ; 
                                                           ; Competent       = 1 to 2
                                                           ; Dangerous       = 2 to 9
                                                           ; Deadly          = 10 to 24
                                                           ; Elite           = 25 and up
       li   rx,>09*256                 ; LDX #9            ; Set X to 9 for an Elite rating

       ci   ra,>19*256                 ; CMP #25           ; If A >= 25, jump to st3 to print out our rating, as we
       joc  st3_                       ; BCS st3           ; are Elite

       sb   rone,rx                    ; DEX               ; Decrement X to 8 for a Deadly rating

       ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to st3 to print out our rating, as we
       joc  st3_                       ; BCS st3           ; are Deadly

       sb   rone,rx                    ; DEX               ; Decrement X to 7 for a Dangerous rating

       ci   ra,>02*256                 ; CMP #2            ; If A >= 2, jump to st3 to print out our rating, as we
       joc  st3_                       ; BCS st3           ; are Dangerous

       sb   rone,rx                    ; DEX               ; Decrement X to 6 for a Competent rating

       jne  st3_                       ; BNE st3           ; Jump to st3 to print out our rating, as we are
                                                           ; Competent (this BNE is effectively a JMP as A will
                                                           ; never be zero)

STATUS:
       li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 8 (Status
                                                           ; Mode screen)

       .jsr @TT111                     ; JSR TT111         ; Select the system closest to galactic coordinates
                                                           ; (QQ9, QQ10)

       li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
       movb ra,@XC                     ; STA XC            

       li   ra,>7e*256                 ; LDA #126          ; Print recursive token 126, which prints the top
       .jsr @NLIN3                     ; JSR NLIN3         ; four lines of the Status Mode screen:
                                                           ; 
                                                           ; COMMANDER {commander name}
                                                           ; 
                                                           ; 
                                                           ; Present System      : {current system name}
                                                           ; Hyperspace System   : {selected system name}
                                                           ; Condition           :
                                                           ; 
                                                           ; and draw a horizontal line at pixel row 19 to box
                                                           ; in the title

       li   ra,>0f*256                 ; LDA #15           ; Set A to token 129 ("{sentence case}DOCKED")

       movb @QQ12,ry                   ; LDY QQ12          ; Fetch the docked status from QQ12, and if we are
       jne  st6_                       ; BNE st6           ; docked, jump to st6 to print "Docked" for our
                                                           ; ship's condition

       li   ra,>e6*256                 ; LDA #230          ; Otherwise we are in space, so start off by setting A
                                                           ; to token 70 ("GREEN")

       movb @MANY+AST,ry               ; LDY MANY+AST      ; Set Y to the number of asteroids in our local bubble
                                                           ; of universe

       movb @FRIN+2(ry),rx             ; LDX FRIN+2,Y      ; The ship slots at FRIN are ordered with the first two
                                                           ; slots reserved for the planet and sun/space station,
                                                           ; and then any ships, so if the slot at FRIN+2+Y is not
                                                           ; empty (i.e. is non-zero), then that means the number
                                                           ; of non-asteroids in the vicinity is at least 1

       jeq  st6_                       ; BEQ st6           ; So if X = 0, there are no ships in the vicinity, so
                                                           ; jump to st6 to print "Green" for our ship's condition

       movb @ENERGY,ry                 ; LDY ENERGY        ; Otherwise we have ships in the vicinity, so we load
                                                           ; our energy levels into Y

       ci   ry,>80*256                 ; CPY #128          ; Set the C flag if Y >= 128, so C is set if we have
                                                           ; more than half of our energy banks charged

       .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have low
                                                           ; energy levels) then A is set to token 231 ("RED"),
                                                           ; and if C is set (i.e. we have healthy energy levels)
                                                           ; then A is set to token 232 ("YELLOW")

st6_:
       .jsr @plf_                      ; JSR plf           ; Print the text token in A (which contains our ship's
                                                           ; condition) followed by a newline

       li   ra,>7d*256                 ; LDA #125          ; Print recursive token 125, which prints the next
       .jsr @spc_                      ; JSR spc           ; three lines of the Status Mode screen:
                                                           ; 
                                                           ; Fuel: {fuel level} Light Years
                                                           ; Cash: {cash} Cr
                                                           ; Legal Status:
                                                           ; 
                                                           ; followed by a space

       li   ra,>13*256                 ; LDA #19           ; Set A to token 133 ("CLEAN")

       movb @FIST,ry                   ; LDY FIST          ; Fetch our legal status, and if it is 0, we are clean,
       jeq  st5_                       ; BEQ st5           ; so jump to st5 to print "Clean"

       ci   ry,>32*256                 ; CPY #50           ; Set the C flag if Y >= 50, so C is set if we have
                                                           ; a legal status of 50+ (i.e. we are a fugitive)

       .adi (>01*256)                  ; ADC #1            ; Add 1 + C to A, so if C is not set (i.e. we have a
                                                           ; legal status between 1 and 49) then A is set to token
                                                           ; 134 ("OFFENDER"), and if C is set (i.e. we have a
                                                           ; legal status of 50+) then A is set to token 135
                                                           ; ("FUGITIVE")

st5_:
       .jsr @plf_                      ; JSR plf           ; Print the text token in A (which contains our legal
                                                           ; status) followed by a newline

       li   ra,>10*256                 ; LDA #16           ; Print recursive token 130 ("RATING:") followed by a
       .jsr @spc_                      ; JSR spc           ; space

       movb @TALLY+1,ra                ; LDA TALLY+1       ; Fetch the high byte of the kill tally, and if it is
       jne  st4_                       ; BNE st4           ; not zero, then we have more than 256 kills, so jump
                                                           ; to st4 to work out whether we are Competent,
                                                           ; Dangerous, Deadly or Elite

                                                           ; Otherwise we have fewer than 256 kills, so we are one
                                                           ; of Harmless, Mostly Harmless, Poor, Average or Above
                                                           ; Average

       movb ra,rx                      ; TAX               ; Set X to 0 (as A is 0)

       movb @TALLY,ra                  ; LDA TALLY         ; Set A = lower byte of tally / 4
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             

st5L:
                                                           ; We now loop through bits 2 to 7, shifting each of them
                                                           ; off the end of A until there are no set bits left, and
                                                           ; incrementing X for each shift, so at the end of the
                                                           ; process, X contains the position of the leftmost 1 in
                                                           ; A. Looking at the rank values in TALLY:
                                                           ; 
                                                           ; Harmless        = %00000000 to %00000011
                                                           ; Mostly Harmless = %00000100 to %00000111
                                                           ; Poor            = %00001000 to %00001111
                                                           ; Average         = %00010000 to %00011111
                                                           ; Above Average   = %00100000 to %11111111
                                                           ; 
                                                           ; we can see that the values returned by this process
                                                           ; are:
                                                           ; 
                                                           ; Harmless        = 1
                                                           ; Mostly Harmless = 2
                                                           ; Poor            = 3
                                                           ; Average         = 4
                                                           ; Above Average   = 5
       ab   rone,rx                    ; INX               ; Increment X for each shift

       srl  ra,1                       ; LSR A             ; Shift A to the right

       jne  st5L                       ; BNE st5L          ; Keep looping around until A = 0, which means there are
                                                           ; no set bits left in A

st3_:
       movb rx,ra                      ; TXA               ; A now contains our rating as a value of 1 to 9, so
                                                           ; transfer X to A, so we can print it out

       .clc                            ; CLC               ; Print recursive token 135 + A, which will be in the
       .adi (>15*256)                  ; ADC #21           ; range 136 ("HARMLESS") to 144 ("---- E L I T E ----")
       .jsr @plf_                      ; JSR plf           ; followed by a newline

       li   ra,>12*256                 ; LDA #18           ; Print recursive token 132, which prints the next bit
       .jsr @plf2_                     ; JSR plf2          ; of the Status Mode screen:
                                                           ; 
                                                           ; EQUIPMENT:
                                                           ; 
                                                           ; followed by a newline and an indent of 6 characters

       movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
       ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
       jnc  B19                        ; BCC B19           ; instructions

       li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
       .jsr @plf2_                     ; JSR plf2          ; token 107 ("LARGE CARGO{sentence case} BAY"), followed
                                                           ; by a newline and an indent of 6 characters

B19:
       movb @BST,ra                    ; LDA BST           ; If we don't have fuel scoops fitted, skip the
       jeq  B20                        ; BEQ B20           ; following two instructions

       li   ra,>6f*256                 ; LDA #111          ; We do have fuel scoops fitted, so print recursive
       .jsr @plf2_                     ; JSR plf2          ; token 111 ("FUEL SCOOPS"), followed by a newline and
                                                           ; an indent of 6 characters

B20:
       movb @ECM,ra                    ; LDA ECM           ; If we don't have an E.C.M. fitted, skip the following
       jeq  B21                        ; BEQ B21           ; two instructions

       li   ra,>6c*256                 ; LDA #108          ; We do have an E.C.M. fitted, so print recursive token
       .jsr @plf2_                     ; JSR plf2          ; 108 ("E.C.M.SYSTEM"), followed by a newline and an
                                                           ; indent of 6 characters

B21:
       li   ra,>71*256                 ; LDA #113          ; We now cover the four pieces of equipment whose flags
       movb ra,@XX4                    ; STA XX4           ; are stored in BOMB through BOMB+3, and whose names
                                                           ; correspond with text tokens 113 through 116:
                                                           ; 
                                                           ; BOMB+0 = BOMB  = token 113 = Energy bomb
                                                           ; BOMB+1 = ENGY  = token 114 = Energy unit
                                                           ; BOMB+2 = DKCMP = token 115 = Docking computer
                                                           ; BOMB+3 = GHYP  = token 116 = Galactic hyperdrive
                                                           ; 
                                                           ; We can print these out using a loop, so we set XX4 to
                                                           ; 113 as a counter (and we also set A as well, to pass
                                                           ; through to plf2)

stqv_:
       movb ra,ry                      ; TAY               ; Fetch byte BOMB+0 through BOMB+4 for values of XX4
       movb @BOMB-113(ry),rx           ; LDX BOMB-113,Y    ; from 113 through 117

       jeq  B22                        ; BEQ B22           ; If it is zero then we do not own that piece of
                                                           ; equipment, so skip the next instruction

       .jsr @plf2_                     ; JSR plf2          ; Print the recursive token in A from 113 ("ENERGY
                                                           ; BOMB") through 116 ("GALACTIC HYPERSPACE "), followed
                                                           ; by a newline and an indent of 6 characters

B22:
       ab   rone,ra                    ; INC XX4           ; Increment the counter (and A as well)
       movb @XX4,ra                    ; LDA XX4           

       ci   ra,>75*256                 ; CMP #117          ; If A < 117, loop back up to stqv to print the next
       jnc  stqv_                      ; BCC stqv          ; piece of equipment

       li   rx,>00*256                 ; LDX #0            ; Now to print our ship's lasers, so set a counter in X
                                                           ; to count through the four views (0 = front, 1 = rear,
                                                           ; 2 = left, 3 = right)

st_:
       movb rx,@CNT                    ; STX CNT           ; Store the view number in CNT

       movb @LASER(rx),ry              ; LDY LASER,X       ; Fetch the laser power for view X, and if we do not
       jeq  st1_                       ; BEQ st1           ; have a laser fitted to that view, jump to st1 to move
                                                           ; on to the next one

       movb rx,ra                      ; TXA               ; Print recursive token 96 + X, which will print from 96
       .clc                            ; CLC               ; ("FRONT") through to 99 ("RIGHT"), followed by a space
       .adi (>60*256)                  ; ADC #96           
       .jsr @spc_                      ; JSR spc           

       li   ra,>67*256                 ; LDA #103          ; Set A to token 103 ("PULSE LASER")

       movb @CNT,rx                    ; LDX CNT           ; If the laser power for view X has bit 7 clear, then it
       movb @LASER(rx),ry              ; LDY LASER,X       ; is a pulse laser, so skip the following instruction
       jgt  B23                        ; BPL B23           

       li   ra,>68*256                 ; LDA #104          ; Set A to token 104 ("BEAM LASER")

B23:
       .jsr @plf2_                     ; JSR plf2          ; Print the text token in A (which contains the laser
                                                           ; type) followed by a newline and an indent of 6
                                                           ; characters

st1_:
       movb @CNT,rx                    ; LDX CNT           ; Increment the counter in X and CNT to point to the
       ab   rone,rx                    ; INX               ; next view

       ci   rx,>04*256                 ; CPX #4            ; If this isn't the last of the four views, jump back up
       jnc  st_                        ; BCC st            ; to st to print out the next one

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: plf2
* Type: Subroutine
* Category: Text
* Summary: Print text followed by a newline and indent of 6 characters
* 
* ------------------------------------------------------------------------------
* 
* Print a text token followed by a newline, and indent the next line to text
* column 6.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

plf2_:
       .jsr @plf_                      ; JSR plf           ; Print the text token in A followed by a newline

       li   rx,>06*256                 ; LDX #6            ; Move the text cursor to column 6
       movb rx,@XC                     ; STX XC            

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TENS
* Type: Variable
* Category: Text
* Summary: A constant used when printing large numbers in BPRNT
* Deep dive: Printing decimal numbers
* 
* ------------------------------------------------------------------------------
* 
* Contains the four low bytes of the value 100,000,000,000 (100 billion).
* 
* The maximum number of digits that we can print with the BPRNT routine is 11,
* so the biggest number we can print is 99,999,999,999. This maximum number
* plus 1 is 100,000,000,000, which in hexadecimal is:
* 
* & 17 48 76 E8 00
* 
* The TENS variable contains the lowest four bytes in this number, with the
* most significant byte first, i.e. 48 76 E8 00. This value is used in the
* BPRNT routine when working out which decimal digits to print when printing a
* number.
* 
* ******************************************************************************

TENS:
       data >0000, >0000

* ******************************************************************************
* 
* Name: pr2
* Type: Subroutine
* Category: Text
* Summary: Print an 8-bit number, left-padded to 3 digits, and optional point
* 
* ------------------------------------------------------------------------------
* 
* Print the 8-bit number in X to 3 digits, left-padding with spaces for numbers
* with fewer than 3 digits (so numbers < 100 are right-aligned). Optionally
* include a decimal point.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The number to print
* 
* C flag              If set, include a decimal point
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* pr2+2               Print the 8-bit number in X to the number of digits in A
* 
* ******************************************************************************

pr2_:
       li   ra,>03*256                 ; LDA #3            ; Set A to the number of digits (3)

       li   ry,>00*256                 ; LDY #0            ; Zero the Y register, so we can fall through into TT11
                                                           ; to print the 16-bit number (Y X) to 3 digits, which
                                                           ; effectively prints X to 3 digits as the high byte is
                                                           ; zero

* ******************************************************************************
* 
* Name: TT11
* Type: Subroutine
* Category: Text
* Summary: Print a 16-bit number, left-padded to n digits, and optional point
* 
* ------------------------------------------------------------------------------
* 
* Print the 16-bit number in (Y X) to a specific number of digits, left-padding
* with spaces for numbers with fewer digits (so lower numbers will be right-
* aligned). Optionally include a decimal point.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The low byte of the number to print
* 
* Y                   The high byte of the number to print
* 
* A                   The number of digits
* 
* C flag              If set, include a decimal point
* 
* ******************************************************************************

TT11:
       movb ra,@U                      ; STA U             ; We are going to use the BPRNT routine (below) to
                                                           ; print this number, so we store the number of digits
                                                           ; in U, as that's what BPRNT takes as an argument

       li   ra,>00*256                 ; LDA #0            ; BPRNT takes a 32-bit number in K to K+3, with the
       movb ra,@K                      ; STA K             ; most significant byte first (big-endian), so we set
       movb ra,@K+1                    ; STA K+1           ; the two most significant bytes to zero (K and K+1)
       movb ry,@K+2                    ; STY K+2           ; and store (Y X) in the least two significant bytes
       movb rx,@K+3                    ; STX K+3           ; (K+2 and K+3), so we are going to print the 32-bit
                                                           ; number (0 0 Y X)

                                                           ; Finally we fall through into BPRNT to print out the
                                                           ; number in K to K+3, which now contains (Y X), to 3
                                                           ; digits (as U = 3), using the same C flag as when pr2
                                                           ; was called to control the decimal point

* ******************************************************************************
* 
* Name: BPRNT
* Type: Subroutine
* Category: Text
* Summary: Print a 32-bit number, left-padded to a specific number of digits,
* with an optional decimal point
* Deep dive: Printing decimal numbers
* 
* ------------------------------------------------------------------------------
* 
* Print the 32-bit number stored in K(0 1 2 3) to a specific number of digits,
* left-padding with spaces for numbers with fewer digits (so lower numbers are
* right-aligned). Optionally include a decimal point.
* 
* See the deep dive on "Printing decimal numbers" for details of the algorithm
* used in this routine.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K(0 1 2 3)          The number to print, stored with the most significant
* byte in K and the least significant in K+3 (i.e. as a
* big-endian number, which is the opposite way to how the
* 6502 assembler stores addresses, for example)
* 
* U                   The maximum number of digits to print, including the
* decimal point (spaces will be used on the left to pad
* out the result to this width, so the number is right-
* aligned to this width). U must be 11 or less
* 
* C flag              If set, include a decimal point followed by one
* fractional digit (i.e. show the number to 1 decimal
* place). In this case, the number in K(0 1 2 3) contains
* 10 * the number we end up printing, so to print 123.4,
* we would pass 1234 in K(0 1 2 3) and would set the C
* flag to include the decimal point
* 
* ******************************************************************************

BPRNT:
       li   rx,>0b*256                 ; LDX #11           ; Set T to the maximum number of digits allowed (11
       movb rx,@T                      ; STX T             ; characters, which is the number of digits in 10
                                                           ; billion). We will use this as a flag when printing
                                                           ; characters in TT37 below

       .php                            ; PHP               ; Make a copy of the status register (in particular
                                                           ; the C flag) so we can retrieve it later

       jnc  TT30                       ; BCC TT30          ; If the C flag is clear, we do not want to print a
                                                           ; decimal point, so skip the next two instructions

       sb   rone,ra                    ; DEC T             ; As we are going to show a decimal point, decrement
       sb   rone,ra                    ; DEC U             ; both the number of characters and the number of
                                                           ; digits (as one of them is now a decimal point)

TT30:
       li   ra,>0b*256                 ; LDA #11           ; Set A to 11, the maximum number of digits allowed

       .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
                                                           ; C flag affecting the result

       movb ra,@XX17                   ; STA XX17          ; Store the maximum number of digits allowed (11) in
                                                           ; XX17

       .sbc @U,ra                      ; SBC U             ; Set U = 11 - U + 1, so U now contains the maximum
       movb ra,@U                      ; STA U             ; number of digits minus the number of digits we want
       ab   rone,ra                    ; INC U             ; to display, plus 1 (so this is the number of digits
                                                           ; we should skip before starting to print the number
                                                           ; itself, and the plus 1 is there to ensure we print at
                                                           ; least one digit)

       li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
                                                           ; of times we subtract 10 billion to get the leftmost
                                                           ; digit, so set this to zero

       movb ry,@S                      ; STY S             ; In the main loop below, we use location S as an
                                                           ; 8-bit overflow for the 32-bit calculations, so
                                                           ; we need to set this to 0 before joining the loop

       b    @TT36                      ; JMP TT36          ; Jump to TT36 to start the process of printing this
                                                           ; number's digits

TT35:
                                                           ; This subroutine multiplies K(S 0 1 2 3) by 10 and
                                                           ; stores the result back in K(S 0 1 2 3), using the fact
                                                           ; that K * 10 = (K * 2) + (K * 2 * 2 * 2)
       .asl @K+3                       ; ASL K+3           ; Set K(S 0 1 2 3) = K(S 0 1 2 3) * 2 by rotating left
       .rol @K+2                       ; ROL K+2           
       .rol @K+1                       ; ROL K+1           
       .rol @K                         ; ROL K             
       .rol @S                         ; ROL S             

       li   rx,>03*256                 ; LDX #3            ; Now we want to make a copy of the newly doubled K in
                                                           ; XX15, so we can use it for the first (K * 2) in the
                                                           ; equation above, so set up a counter in X for copying
                                                           ; four bytes, starting with the last byte in memory
                                                           ; (i.e. the least significant)

tt35_:
       movb @K(rx),ra                  ; LDA K,X           ; Copy the X-th byte of K(0 1 2 3) to the X-th byte of
       movb ra,@XX15(rx)               ; STA XX15,X        ; XX15(0 1 2 3), so that XX15 will contain a copy of
                                                           ; K(0 1 2 3) once we've copied all four bytes

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  tt35_                      ; BPL tt35          ; Loop back to copy the next byte until we have copied
                                                           ; all four

       movb @S,ra                      ; LDA S             ; Store the value of location S, our overflow byte, in
       movb ra,@XX15+4                 ; STA XX15+4        ; XX15+4, so now XX15(4 0 1 2 3) contains a copy of
                                                           ; K(S 0 1 2 3), which is the value of (K * 2) that we
                                                           ; want to use in our calculation

       .asl @K+3                       ; ASL K+3           ; Now to calculate the (K * 2 * 2 * 2) part. We still
       .rol @K+2                       ; ROL K+2           ; have (K * 2) in K(S 0 1 2 3), so we just need to shift
       .rol @K+1                       ; ROL K+1           ; it twice. This is the first one, so we do this:
       .rol @K                         ; ROL K             ; 
       .rol @S                         ; ROL S             ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 4

       .asl @K+3                       ; ASL K+3           ; And then we do it again, so that means:
       .rol @K+2                       ; ROL K+2           ; 
       .rol @K+1                       ; ROL K+1           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 2 = K * 8
       .rol @K                         ; ROL K             
       .rol @S                         ; ROL S             

       .clc                            ; CLC               ; Clear the C flag so we can do addition without the
                                                           ; C flag affecting the result

       li   rx,>03*256                 ; LDX #3            ; By now we've got (K * 2) in XX15(4 0 1 2 3) and
                                                           ; (K * 8) in K(S 0 1 2 3), so the final step is to add
                                                           ; these two 32-bit numbers together to get K * 10.
                                                           ; So we set a counter in X for four bytes, starting
                                                           ; with the last byte in memory (i.e. the least
                                                           ; significant)

tt36_:
       movb @K(rx),ra                  ; LDA K,X           ; Fetch the X-th byte of K into A

       .adc @XX15(rx),ra               ; ADC XX15,X        ; Add the X-th byte of XX15 to A, with carry

       movb ra,@K(rx)                  ; STA K,X           ; Store the result in the X-th byte of K

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  tt36_                      ; BPL tt36          ; Loop back to add the next byte, moving from the least
                                                           ; significant byte to the most significant, until we
                                                           ; have added all four

       movb @XX15+4,ra                 ; LDA XX15+4        ; Finally, fetch the overflow byte from XX15(4 0 1 2 3)

       .adc @S,ra                      ; ADC S             ; And add it to the overflow byte from K(S 0 1 2 3),
                                                           ; with carry

       movb ra,@S                      ; STA S             ; And store the result in the overflow byte from
                                                           ; K(S 0 1 2 3), so now we have our desired result, i.e.
                                                           ; 
                                                           ; K(S 0 1 2 3) = K(S 0 1 2 3) * 10

       li   ry,>00*256                 ; LDY #0            ; In the main loop below, we use Y to count the number
                                                           ; of times we subtract 10 billion to get the leftmost
                                                           ; digit, so set this to zero so we can rejoin the main
                                                           ; loop for another subtraction process

TT36:
                                                           ; This is the main loop of our digit-printing routine.
                                                           ; In the following loop, we are going to count the
                                                           ; number of times that we can subtract 10 million and
                                                           ; store that count in Y, which we have already set to 0
       li   rx,>03*256                 ; LDX #3            ; Our first calculation concerns 32-bit numbers, so
                                                           ; set up a counter for a four-byte loop

       .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
                                                           ; C flag affecting the result

tt37_:
                                                           ; We now loop through each byte in turn to do this:
                                                           ; 
                                                           ; XX15(4 0 1 2 3) = K(S 0 1 2 3) - 100,000,000,000
       movb @K(rx),ra                  ; LDA K,X           ; Subtract the X-th byte of TENS (i.e. 10 billion) from
       .sbc @TENS(rx),ra               ; SBC TENS,X        ; the X-th byte of K

       movb ra,@XX15(rx)               ; STA XX15,X        ; Store the result in the X-th byte of XX15

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  tt37_                      ; BPL tt37          ; Loop back to subtract the next byte, moving from the
                                                           ; least significant byte to the most significant, until
                                                           ; we have subtracted all four

       movb @S,ra                      ; LDA S             ; Subtract the fifth byte of 10 billion (i.e. &17) from
       .sbi (>17*256)                  ; SBC #&17          ; the fifth (overflow) byte of K, which is S

       movb ra,@XX15+4                 ; STA XX15+4        ; Store the result in the overflow byte of XX15

       jnc  TT37                       ; BCC TT37          ; If subtracting 10 billion took us below zero, jump to
                                                           ; TT37 to print out this digit, which is now in Y

       li   rx,>03*256                 ; LDX #3            ; We now want to copy XX15(4 0 1 2 3) back into
                                                           ; K(S 0 1 2 3), so we can loop back up to do the next
                                                           ; subtraction, so set up a counter for a four-byte loop

tt38_:
       movb @XX15(rx),ra               ; LDA XX15,X        ; Copy the X-th byte of XX15(0 1 2 3) to the X-th byte
       movb ra,@K(rx)                  ; STA K,X           ; of K(0 1 2 3), so that K(0 1 2 3) will contain a copy
                                                           ; of XX15(0 1 2 3) once we've copied all four bytes

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  tt38_                      ; BPL tt38          ; Loop back to copy the next byte, until we have copied
                                                           ; all four

       movb @XX15+4,ra                 ; LDA XX15+4        ; Store the value of location XX15+4, our overflow
       movb ra,@S                      ; STA S             ; byte in S, so now K(S 0 1 2 3) contains a copy of
                                                           ; XX15(4 0 1 2 3)

       ab   rone,ry                    ; INY               ; We have now managed to subtract 10 billion from our
                                                           ; number, so increment Y, which is where we are keeping
                                                           ; a count of the number of subtractions so far

       b    @TT36                      ; JMP TT36          ; Jump back to TT36 to subtract the next 10 billion

TT37:
       movb ry,ra                      ; TYA               ; If we get here then Y contains the digit that we want
                                                           ; to print (as Y has now counted the total number of
                                                           ; subtractions of 10 billion), so transfer Y into A

       jne  TT32                       ; BNE TT32          ; If the digit is non-zero, jump to TT32 to print it

       movb @T,ra                      ; LDA T             ; Otherwise the digit is zero. If we are already
                                                           ; printing the number then we will want to print a 0,
                                                           ; but if we haven't started printing the number yet,
                                                           ; then we probably don't, as we don't want to print
                                                           ; leading zeroes unless this is the only digit before
                                                           ; the decimal point
                                                           ; 
                                                           ; To help with this, we are going to use T as a flag
                                                           ; that tells us whether we have already started
                                                           ; printing digits:
                                                           ; 
                                                           ; * If T <> 0 we haven't printed anything yet
                                                           ; 
                                                           ; * If T = 0 then we have started printing digits
                                                           ; 
                                                           ; We initially set T above to the maximum number of
                                                           ; characters allowed, less 1 if we are printing a
                                                           ; decimal point, so the first time we enter the digit
                                                           ; printing routine at TT37, it is definitely non-zero

       jeq  TT32                       ; BEQ TT32          ; If T = 0, jump straight to the print routine at TT32,
                                                           ; as we have already started printing the number, so we
                                                           ; definitely want to print this digit too

       sb   rone,ra                    ; DEC U             ; We initially set U to the number of digits we want to
       jgt  TT34                       ; BPL TT34          ; skip before starting to print the number. If we get
                                                           ; here then we haven't printed any digits yet, so
                                                           ; decrement U to see if we have reached the point where
                                                           ; we should start printing the number, and if not, jump
                                                           ; to TT34 to set up things for the next digit

       li   ra,(' ')*256               ; LDA #' '          ; We haven't started printing any digits yet, but we
       jne  tt34_                      ; BNE tt34          ; have reached the point where we should start printing
                                                           ; our number, so call TT26 (via tt34) to print a space
                                                           ; so that the number is left-padded with spaces (this
                                                           ; BNE is effectively a JMP as A will never be zero)

TT32:
       li   ry,>00*256                 ; LDY #0            ; We are printing an actual digit, so first set T to 0,
       movb ry,@T                      ; STY T             ; to denote that we have now started printing digits as
                                                           ; opposed to spaces

       .clc                            ; CLC               ; The digit value is in A, so add ASCII "0" to get the
       .adi (('0')*256)                ; ADC #'0'          ; ASCII character number to print

tt34_:
       .jsr @TT26                      ; JSR TT26          ; Call TT26 to print the character in A and fall through
                                                           ; into TT34 to get things ready for the next digit

TT34:
       sb   rone,ra                    ; DEC T             ; Decrement T but keep T >= 0 (by incrementing it
       jgt  B24                        ; BPL B24           ; again if the above decrement made T negative)
       ab   rone,ra                    ; INC T             

B24:
       sb   rone,ra                    ; DEC XX17          ; Decrement the total number of characters left to
                                                           ; print, which we stored in XX17

       jlt  RR3+1                      ; BMI RR3+1         ; If the result is negative, we have printed all the
                                                           ; characters, so return from the subroutine (as RR3
                                                           ; contains an ORA #&60 instruction, so RR3+1 is &60,
                                                           ; which is the opcode for an RTS)

       jne  B25                        ; BNE B25           ; If the result is positive (> 0) then we still have
                                                           ; characters left to print, so loop back to TT35 (via
                                                           ; the JMP TT35 instruction below) to print the next
                                                           ; digit

       .plp                            ; PLP               ; If we get here then we have printed the exact number
                                                           ; of digits that we wanted to, so restore the C flag
                                                           ; that we stored at the start of the routine

       jnc  B25                        ; BCC B25           ; If the C flag is clear, we don't want a decimal point,
                                                           ; so loop back to TT35 (via the JMP TT35 instruction
                                                           ; below) to print the next digit

       li   ra,('.')*256               ; LDA #'.'          ; Otherwise the C flag is set, so print the decimal
       .jsr @TT26                      ; JSR TT26          ; point

B25:
       b    @TT35                      ; JMP TT35          ; Loop back to TT35 to print the next digit

* ******************************************************************************
* 
* Name: BELL
* Type: Subroutine
* Category: Sound
* Summary: Make a standard system beep
* 
* ------------------------------------------------------------------------------
* 
* This is the standard system beep, as made by the ASCII 7 "BELL" control code.
* 
* ******************************************************************************

BELL:
       li   ra,>07*256                 ; LDA #7            ; Control code 7 makes a beep, so load this into A

                                                           ; Fall through into the TT26 print routine to
                                                           ; actually make the sound

* ******************************************************************************
* 
* Name: TT26
* Type: Subroutine
* Category: Text
* Summary: Print a character at the text cursor by poking into screen memory
* Deep dive: Drawing text
* 
* ------------------------------------------------------------------------------
* 
* Print a character at the text cursor (XC, YC), do a beep, print a newline,
* or delete left (backspace).
* 
* WRCHV is set to point here by the loading process.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The character to be printed. Can be one of the
* following:
* 
* * 7 (beep)
* 
* * 10-13 (line feeds and carriage returns)
* 
* * 32-95 (ASCII capital letters, numbers and
* punctuation)
* 
* * 127 (delete the character to the left of the text
* cursor and move the cursor to the left)
* 
* XC                  Contains the text column to print at (the x-coordinate)
* 
* YC                  Contains the line number to print on (the y-coordinate)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A is preserved
* 
* X                   X is preserved
* 
* Y                   Y is preserved
* 
* C flag              The C flag is cleared
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* RR3+1               Contains an RTS
* 
* RREN                Prints the character definition pointed to by P(2 1) at
* the screen address pointed to by (A SC). Used by the
* BULB routine
* 
* rT9                 Contains an RTS
* 
* ******************************************************************************

TT26:
       movb ra,@K3                     ; STA K3            ; Store the A, X and Y registers, so we can restore
       movb ry,@YSAV2                  ; STY YSAV2         ; them at the end (so they don't get changed by this
       movb rx,@XSAV2                  ; STX XSAV2         ; routine)

       movb @QQ17,ry                   ; LDY QQ17          ; Load the QQ17 flag, which contains the text printing
                                                           ; flags

       ci   ry,>ff*256                 ; CPY #255          ; If QQ17 = 255 then printing is disabled, so jump to
       jeq  RR4                        ; BEQ RR4           ; RR4, which doesn't print anything, it just restores
                                                           ; the registers and returns from the subroutine

       ci   ra,>07*256                 ; CMP #7            ; If this is a beep character (A = 7), jump to R5,
       jeq  R5_                        ; BEQ R5_           ; which will emit the beep, restore the registers and
                                                           ; return from the subroutine

       ci   ra,>20*256                 ; CMP #32           ; If this is an ASCII character (A >= 32), jump to RR1
       joc  RR1                        ; BCS RR1           ; below, which will print the character, restore the
                                                           ; registers and return from the subroutine

       ci   ra,>0a*256                 ; CMP #10           ; If this is control code 10 (line feed) then jump to
       jeq  RRX1                       ; BEQ RRX1          ; RRX1, which will move down a line, restore the
                                                           ; registers and return from the subroutine

       li   rx,>01*256                 ; LDX #1            ; If we get here, then this is control code 11-13, of
       movb rx,@XC                     ; STX XC            ; which only 13 is used. This code prints a newline,
                                                           ; which we can achieve by moving the text cursor
                                                           ; to the start of the line (carriage return) and down
                                                           ; one line (line feed). These two lines do the first
                                                           ; bit by setting XC = 1, and we then fall through into
                                                           ; the line feed routine that's used by control code 10

RRX1:
       ab   rone,ra                    ; INC YC            ; Print a line feed, simply by incrementing the row
                                                           ; number (y-coordinate) of the text cursor, which is
                                                           ; stored in YC

       jne  RR4                        ; BNE RR4           ; Jump to RR4 to restore the registers and return from
                                                           ; the subroutine (this BNE is effectively a JMP as Y
                                                           ; will never be zero)

RR1:
                                                           ; If we get here, then the character to print is an
                                                           ; ASCII character in the range 32-95. The quickest way
                                                           ; to display text on-screen is to poke the character
                                                           ; pixel by pixel, directly into screen memory, so
                                                           ; that's what the rest of this routine does
                                                           ; 
                                                           ; The first step, then, is to get hold of the bitmap
                                                           ; definition for the character we want to draw on the
                                                           ; screen (i.e. we need the pixel shape of this
                                                           ; character). The MOS ROM contains bitmap definitions
                                                           ; of the system's ASCII characters, starting from &C000
                                                           ; for space (ASCII 32) and ending with the £ symbol
                                                           ; (ASCII 126)
                                                           ; 
                                                           ; There are definitions for 32 characters in each of the
                                                           ; three pages of MOS memory, as each definition takes up
                                                           ; 8 bytes (8 rows of 8 pixels) and 32 * 8 = 256 bytes =
                                                           ; 1 page. So:
                                                           ; 
                                                           ; ASCII 32-63  are defined in &C000-&C0FF (page 0)
                                                           ; ASCII 64-95  are defined in &C100-&C1FF (page 1)
                                                           ; ASCII 96-126 are defined in &C200-&C2F0 (page 2)
                                                           ; 
                                                           ; The following code reads the relevant character
                                                           ; bitmap from the above locations in ROM and pokes
                                                           ; those values into the correct position in screen
                                                           ; memory, thus printing the character on-screen
                                                           ; 
                                                           ; It's a long way from 10 PRINT "Hello world!":GOTO 10
* LDX #LO(K3)            \ These instructions are commented out in the original
* INX                    \ source, but they call OSWORD 10, which reads the
* STX P+1                \ character bitmap for the character number in K3 and
* DEX                    \ stores it in the block at K3+1, while also setting
* LDY #HI(K3)            \ P+1 to point to the character definition. This is
* STY P+2                \ exactly what the following uncommented code does,
* LDA #10                \ just without calling OSWORD. Presumably the code
* JSR OSWORD             \ below is faster than using the system call, as this
                                                           ; version takes up 15 bytes, while the version below
                                                           ; (which ends with STA P+1 and SYX P+2) is 17 bytes.
                                                           ; Every efficiency saving helps, especially as this
                                                           ; routine is run each time the game prints a character
                                                           ; 
                                                           ; If you want to switch this code back on, uncomment
                                                           ; the above block, and comment out the code below from
                                                           ; TAY to STX P+2. You will also need to uncomment the
                                                           ; LDA YC instruction a few lines down (in RR2), just to
                                                           ; make sure the rest of the code doesn't shift in
                                                           ; memory. To be honest I can't see a massive difference
                                                           ; in speed, but there you go
       movb ra,ry                      ; TAY               ; Copy the character number from A to Y, as we are
                                                           ; about to pull A apart to work out where this
                                                           ; character definition lives in memory

                                                           ; Now we want to set X to point to the relevant page
                                                           ; number for this character - i.e. &C0, &C1 or &C2.

                                                           ; The following logic is easier to follow if we look
                                                           ; at the three character number ranges in binary:
                                                           ; 
                                                           ; Bit #  76543210
                                                           ; 
                                                           ; 32  = %00100000     Page 0 of bitmap definitions
                                                           ; 63  = %00111111
                                                           ; 
                                                           ; 64  = %01000000     Page 1 of bitmap definitions
                                                           ; 95  = %01011111
                                                           ; 
                                                           ; 96  = %01100000     Page 2 of bitmap definitions
                                                           ; 125 = %01111101
                                                           ; 
                                                           ; We'll refer to this below

       li   rx,>bf*256                 ; LDX #&BF          ; Set X to point to the first font page in ROM minus 1,
                                                           ; which is &C0 - 1, or &BF

       .asla                           ; ASL A             ; If bit 6 of the character is clear (A is 32-63)
       .asla                           ; ASL A             ; then skip the following instruction
       jnc  B26                        ; BCC B26           

       li   rx,>c1*256                 ; LDX #&C1          ; A is 64-126, so set X to point to page &C1

B26:
       .asla                           ; ASL A             ; If bit 5 of the character is clear (A is 64-95)
       jnc  B27                        ; BCC B27           ; then skip the following instruction

       ab   rone,rx                    ; INX               ; Increment X
                                                           ; 
                                                           ; By this point, we started with X = &BF, and then
                                                           ; we did the following:
                                                           ; 
                                                           ; If A = 32-63:   skip    then INX  so X = &C0
                                                           ; If A = 64-95:   X = &C1 then skip so X = &C1
                                                           ; If A = 96-126:  X = &C1 then INX  so X = &C2
                                                           ; 
                                                           ; In other words, X points to the relevant page. But
                                                           ; what about the value of A? That gets shifted to the
                                                           ; left three times during the above code, which
                                                           ; multiplies the number by 8 but also drops bits 7, 6
                                                           ; and 5 in the process. Look at the above binary
                                                           ; figures and you can see that if we cleared bits 5-7,
                                                           ; then that would change 32-53 to 0-31... but it would
                                                           ; do exactly the same to 64-95 and 96-125. And because
                                                           ; we also multiply this figure by 8, A now points to
                                                           ; the start of the character's definition within its
                                                           ; page (because there are 8 bytes per character
                                                           ; definition)
                                                           ; 
                                                           ; Or, to put it another way, X contains the high byte
                                                           ; (the page) of the address of the definition that we
                                                           ; want, while A contains the low byte (the offset into
                                                           ; the page) of the address

B27:
       movb ra,@P+1                    ; STA P+1           ; Store the address of this character's definition in
       movb rx,@P+2                    ; STX P+2           ; P(2 1)

       movb @XC,ra                     ; LDA XC            ; Fetch XC, the x-coordinate (column) of the text cursor
                                                           ; into A

       .asla                           ; ASL A             ; Multiply A by 8, and store in SC. As each character is
       .asla                           ; ASL A             ; 8 pixels wide, and the special screen mode Elite uses
       .asla                           ; ASL A             ; for the top part of the screen is 256 pixels across
       movb ra,@SC                     ; STA SC            ; with one bit per pixel, this value is not only the
                                                           ; screen address offset of the text cursor from the left
                                                           ; side of the screen, it's also the least significant
                                                           ; byte of the screen address where we want to print this
                                                           ; character, as each row of on-screen pixels corresponds
                                                           ; to one page. To put this more explicitly, the screen
                                                           ; starts at &6000, so the text rows are stored in screen
                                                           ; memory like this:
                                                           ; 
                                                           ; Row 1: &6000 - &60FF    YC = 1, XC = 0 to 31
                                                           ; Row 2: &6100 - &61FF    YC = 2, XC = 0 to 31
                                                           ; Row 3: &6200 - &62FF    YC = 3, XC = 0 to 31
                                                           ; 
                                                           ; and so on

       movb @YC,ra                     ; LDA YC            ; Fetch YC, the y-coordinate (row) of the text cursor

       ci   ry,>7f*256                 ; CPY #127          ; If the character number (which is in Y) <> 127, then
       jne  RR2                        ; BNE RR2           ; skip to RR2 to print that character, otherwise this is
                                                           ; the delete character, so continue on

       sb   rone,ra                    ; DEC XC            ; We want to delete the character to the left of the
                                                           ; text cursor and move the cursor back one, so let's
                                                           ; do that by decrementing YC. Note that this doesn't
                                                           ; have anything to do with the actual deletion below,
                                                           ; we're just updating the cursor so it's in the right
                                                           ; position following the deletion

       .adi (>5e*256)                  ; ADC #&5E          ; A contains YC (from above) and the C flag is set (from
       movb ra,rx                      ; TAX               ; the CPY #127 above), so these instructions do this:
                                                           ; 
                                                           ; X = YC + &5E + 1
                                                           ; = YC + &5F

                                                           ; Because YC starts at 0 for the first text row, this
                                                           ; means that X will be &5F for row 0, &60 for row 1 and
                                                           ; so on. In other words, X is now set to the page number
                                                           ; for the row before the one containing the text cursor,
                                                           ; and given that we set SC above to point to the offset
                                                           ; in memory of the text cursor within the row's page,
                                                           ; this means that (X SC) now points to the character
                                                           ; above the text cursor

       li   ry,>f8*256                 ; LDY #&F8          ; Set Y = &F8, so the following call to ZES2 will count
                                                           ; Y upwards from &F8 to &FF

       .jsr @ZES2                      ; JSR ZES2          ; Call ZES2, which zero-fills from address (X SC) + Y to
                                                           ; (X SC) + &FF. (X SC) points to the character above the
                                                           ; text cursor, and adding &FF to this would point to the
                                                           ; cursor, so adding &F8 points to the character before
                                                           ; the cursor, which is the one we want to delete. So
                                                           ; this call zero-fills the character to the left of the
                                                           ; cursor, which erases it from the screen

       jeq  RR4                        ; BEQ RR4           ; We are done deleting, so restore the registers and
                                                           ; return from the subroutine (this BNE is effectively
                                                           ; a JMP as ZES2 always returns with the Z flag set)

RR2:
                                                           ; Now to actually print the character
       ab   rone,ra                    ; INC XC            ; Once we print the character, we want to move the text
                                                           ; cursor to the right, so we do this by incrementing
                                                           ; XC. Note that this doesn't have anything to do
                                                           ; with the actual printing below, we're just updating
                                                           ; the cursor so it's in the right position following
                                                           ; the print

* LDA YC                 \ This instruction is commented out in the original
                                                           ; source. It isn't required because we only just did a
                                                           ; LDA YC before jumping to RR2, so this is presumably
                                                           ; an example of the authors squeezing the code to save
                                                           ; 2 bytes and 3 cycles
                                                           ; 
                                                           ; If you want to re-enable the commented block near the
                                                           ; start of this routine, you should uncomment this
                                                           ; instruction as well

       ci   ra,>18*256                 ; CMP #24           ; If the text cursor is on the screen (i.e. YC < 24, so
       jnc  RR3                        ; BCC RR3           ; we are on rows 0-23), then jump to RR3 to print the
                                                           ; character

       .jsr @TTX66                     ; JSR TTX66         ; Otherwise we are off the bottom of the screen, so
                                                           ; clear the screen and draw a white border

       b    @RR4                       ; JMP RR4           ; And restore the registers and return from the
                                                           ; subroutine

RR3:
                                                           ; A contains the value of YC - the screen row where we
                                                           ; want to print this character - so now we need to
                                                           ; convert this into a screen address, so we can poke
                                                           ; the character data to the right place in screen
                                                           ; memory
       ori  ra,>60*256                 ; ORA #&60          ; We already stored the least significant byte
                                                           ; of this screen address in SC above (see the STA SC
                                                           ; instruction above), so all we need is the most
                                                           ; significant byte. As mentioned above, in Elite's
                                                           ; square mode 4 screen, each row of text on-screen
                                                           ; takes up exactly one page, so the first row is page
                                                           ; &60xx, the second row is page &61xx, so we can get
                                                           ; the page for character (XC, YC) by OR'ing with &60.
                                                           ; To see this in action, consider that our two values
                                                           ; are, in binary:
                                                           ; 
                                                           ; YC is between:  %00000000
                                                           ; and:  %00010111
                                                           ; &60 is:  %01100000
                                                           ; 
                                                           ; so YC OR &60 effectively adds &60 to YC, giving us
                                                           ; the page number that we want

RREN:
       movb ra,@SC+1                   ; STA SC+1          ; Store the page number of the destination screen
                                                           ; location in SC+1, so SC now points to the full screen
                                                           ; location where this character should go

       li   ry,>07*256                 ; LDY #7            ; We want to print the 8 bytes of character data to the
                                                           ; screen (one byte per row), so set up a counter in Y
                                                           ; to count these bytes

RRL1:
       .ld_ind_y_idx @P+1,ra           ; LDA (P+1),Y       ; The character definition is at P(2 1) - we set this up
                                                           ; above - so load the Y-th byte from P(2 1), which will
                                                           ; contain the bitmap for the Y-th row of the character

       .eor @SC                        ; EOR (SC),Y        ; If we EOR this value with the existing screen
                                                           ; contents, then it's reversible (so reprinting the
                                                           ; same character in the same place will revert the
                                                           ; screen to what it looked like before we printed
                                                           ; anything); this means that printing a white pixel
                                                           ; onto a white background results in a black pixel, but
                                                           ; that's a small price to pay for easily erasable text

       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store the Y-th byte at the screen address for this
                                                           ; character location

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jgt  RRL1                       ; BPL RRL1          ; Loop back for the next byte to print to the screen

RR4:
       movb @YSAV2,ry                  ; LDY YSAV2         ; We're done printing, so restore the values of the
       movb @XSAV2,rx                  ; LDX XSAV2         ; A, X and Y registers that we saved above and clear
       movb @K3,ra                     ; LDA K3            ; the C flag, so everything is back to how it was
       .clc                            ; CLC               

rT9:
       .rts                            ; RTS               ; Return from the subroutine

R5_:
       .jsr @BEEP                      ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep

       b    @RR4                       ; JMP RR4           ; Jump to RR4 to restore the registers and return from
                                                           ; the subroutine using a tail call

* ******************************************************************************
* 
* Name: DIALS (Part 1 of 4)
* Type: Subroutine
* Category: Dashboard
* Summary: Update the dashboard: speed indicator
* Deep dive: The dashboard indicators
* 
* ------------------------------------------------------------------------------
* 
* This routine updates the dashboard. First we draw all the indicators in the
* right part of the dashboard, from top (speed) to bottom (energy banks), and
* then we move on to the left part, again drawing from top (forward shield) to
* bottom (altitude).
* 
* This first section starts us off with the speedometer in the top right.
* 
* ******************************************************************************

DIALS:
       li   ra,>d0*256                 ; LDA #&D0          ; Set SC(1 0) = &78D0, which is the screen address for
       movb ra,@SC                     ; STA SC            ; the character block containing the left end of the
       li   ra,>78*256                 ; LDA #&78          ; top indicator in the right part of the dashboard, the
       movb ra,@SC+1                   ; STA SC+1          ; one showing our speed

       .jsr @PZW                       ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
                                                           ; and X to the colour for safe values

       movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
                                                           ; X (the colour to use for safe values)

       movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
                                                           ; A (the colour to use for dangerous values)

                                                           ; The above sets the following indicators to show red
                                                           ; for high values and yellow/white for low values

       li   ra,>0e*256                 ; LDA #14           ; Set T1 to 14, the threshold at which we change the
       movb ra,@T1                     ; STA T1            ; indicator's colour

       movb @DELTA,ra                  ; LDA DELTA         ; Fetch our ship's speed into A, in the range 0-40

* LSR A                  \ Draw the speed indicator using a range of 0-31, and
       .jsr @DIL-1                     ; JSR DIL-1         ; increment SC to point to the next indicator (the roll
                                                           ; indicator). The LSR is commented out as it isn't
                                                           ; required with a call to DIL-1, so perhaps this was
                                                           ; originally a call to DIL that got optimised

* ******************************************************************************
* 
* Name: DIALS (Part 2 of 4)
* Type: Subroutine
* Category: Dashboard
* Summary: Update the dashboard: pitch and roll indicators
* Deep dive: The dashboard indicators
* 
* ******************************************************************************

       li   ra,>00*256                 ; LDA #0            ; Set R = P = 0 for the low bytes in the call to the ADD
       movb ra,@R                      ; STA R             ; routine below
       movb ra,@P                      ; STA P             

       li   ra,>08*256                 ; LDA #8            ; Set S = 8, which is the value of the centre of the
       movb ra,@S                      ; STA S             ; roll indicator

       movb @ALP1,ra                   ; LDA ALP1          ; Fetch the roll angle alpha as a value between 0 and
       srl  ra,1                       ; LSR A             ; 31, and divide by 4 to get a value of 0 to 7
       srl  ra,1                       ; LSR A             

       socb @ALP2,ra                   ; ORA ALP2          ; Apply the roll sign to the value, and flip the sign,
       .eoi (>80*256)                  ; EOR #%10000000    ; so it's now in the range -7 to +7, with a positive
                                                           ; roll angle alpha giving a negative value in A

       .jsr @ADD                       ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
                                                           ; 15, which we can pass to DIL2 to draw the vertical
                                                           ; bar on the indicator at this position. We use the ADD
                                                           ; routine like this:
                                                           ; 
                                                           ; (A X) = (A 0) + (S 0)
                                                           ; 
                                                           ; and just take the high byte of the result. We use ADD
                                                           ; rather than a normal ADC because ADD separates out the
                                                           ; sign bit and does the arithmetic using absolute values
                                                           ; and separate sign bits, which we want here rather than
                                                           ; the two's complement that ADC uses

       .jsr @DIL2                      ; JSR DIL2          ; Draw a vertical bar on the roll indicator at offset A
                                                           ; and increment SC to point to the next indicator (the
                                                           ; pitch indicator)

       movb @BETA,ra                   ; LDA BETA          ; Fetch the pitch angle beta as a value between -8 and
                                                           ; +8

       movb @BET1,rx                   ; LDX BET1          ; Fetch the magnitude of the pitch angle beta, and if it
       jeq  B28                        ; BEQ B28           ; is 0 (i.e. we are not pitching), skip the next
                                                           ; instruction

       .sbi (>01*256)                  ; SBC #1            ; The pitch angle beta is non-zero, so set A = A - 1
                                                           ; (the C flag is set by the call to DIL2 above, so we
                                                           ; don't need to do a SEC). This gives us a value of A
                                                           ; from -7 to +7 because these are magnitude-based
                                                           ; numbers with sign bits, rather than two's complement
                                                           ; numbers

B28:
       .jsr @ADD                       ; JSR ADD           ; We now add A to S to give us a value in the range 1 to
                                                           ; 15, which we can pass to DIL2 to draw the vertical
                                                           ; bar on the indicator at this position (see the JSR ADD
                                                           ; above for more on this)

       .jsr @DIL2                      ; JSR DIL2          ; Draw a vertical bar on the pitch indicator at offset A
                                                           ; and increment SC to point to the next indicator (the
                                                           ; four energy banks)

* ******************************************************************************
* 
* Name: DIALS (Part 3 of 4)
* Type: Subroutine
* Category: Dashboard
* Summary: Update the dashboard: four energy banks
* Deep dive: The dashboard indicators
* 
* ------------------------------------------------------------------------------
* 
* This and the next section only run once every four iterations of the main
* loop, so while the speed, pitch and roll indicators update every iteration,
* the other indicators update less often.
* 
* ******************************************************************************

       movb @MCNT,ra                   ; LDA MCNT          ; Fetch the main loop counter and calculate MCNT mod 4,
       andi ra,>03*256                 ; AND #3            ; jumping to rT9 if it is non-zero. rT9 contains an RTS,
       jne  rT9                        ; BNE rT9           ; so the following code only runs every 4 iterations of
                                                           ; the main loop, otherwise we return from the subroutine

       li   ry,>00*256                 ; LDY #0            ; Set Y = 0, for use in various places below

       .jsr @PZW                       ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
                                                           ; and X to the colour for safe values

       movb rx,@K                      ; STX K             ; Set K (the colour we should show for high values) to X
                                                           ; (the colour to use for safe values)

       movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
                                                           ; A (the colour to use for dangerous values)

                                                           ; The above sets the following indicators to show red
                                                           ; for low values and yellow/white for high values, which
                                                           ; we use not only for the energy banks, but also for the
                                                           ; shield levels and current fuel

       li   rx,>03*256                 ; LDX #3            ; Set up a counter in X so we can zero the four bytes at
                                                           ; XX12, so we can then calculate each of the four energy
                                                           ; banks' values before drawing them later

       movb rx,@T1                     ; STX T1            ; Set T1 to 3, the threshold at which we change the
                                                           ; indicator's colour

DLL23:
       movb ry,@XX12(rx)               ; STY XX12,X        ; Set the X-th byte of XX12 to 0

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  DLL23                      ; BPL DLL23         ; Loop back for the next byte until the four bytes at
                                                           ; XX12 are all zeroed

       li   rx,>03*256                 ; LDX #3            ; Set up a counter in X to loop through the 4 energy
                                                           ; bank indicators, so we can calculate each of the four
                                                           ; energy banks' values and store them in XX12

       movb @ENERGY,ra                 ; LDA ENERGY        ; Set A = Q = ENERGY / 4, so they are both now in the
       srl  ra,1                       ; LSR A             ; range 0-63 (so that's a maximum of 16 in each of the
       srl  ra,1                       ; LSR A             ; banks, and a maximum of 15 in the top bank)

       movb ra,@Q                      ; STA Q             ; Set Q to A, so we can use Q to hold the remaining
                                                           ; energy as we work our way through each bank, from the
                                                           ; full ones at the bottom to the empty ones at the top

DLL24:
       .sec                            ; SEC               ; Set A = A - 16 to reduce the energy count by a full
       .sbi (>10*256)                  ; SBC #16           ; bank

       jnc  DLL26                      ; BCC DLL26         ; If the C flag is clear then A < 16, so this bank is
                                                           ; not full to the brim, and is therefore the last one
                                                           ; with any energy in it, so jump to DLL26

       movb ra,@Q                      ; STA Q             ; This bank is full, so update Q with the energy of the
                                                           ; remaining banks

       li   ra,>10*256                 ; LDA #16           ; Store this bank's level in XX12 as 16, as it is full,
       movb ra,@XX12(rx)               ; STA XX12,X        ; with XX12+3 for the bottom bank and XX12+0 for the top

       movb @Q,ra                      ; LDA Q             ; Set A to the remaining energy level again

       sb   rone,rx                    ; DEX               ; Decrement X to point to the next bank, i.e. the one
                                                           ; above the bank we just processed

       jgt  DLL24                      ; BPL DLL24         ; Loop back to DLL24 until we have either processed all
                                                           ; four banks, or jumped out early to DLL26 if the top
                                                           ; banks have no charge

       jlt  DLL9                       ; BMI DLL9          ; Jump to DLL9 as we have processed all four banks (this
                                                           ; BMI is effectively a JMP as A will never be positive)

DLL26:
       movb @Q,ra                      ; LDA Q             ; If we get here then the bank we just checked is not
       movb ra,@XX12(rx)               ; STA XX12,X        ; fully charged, so store its value in XX12 (using Q,
                                                           ; which contains the energy of the remaining banks -
                                                           ; i.e. this one)

                                                           ; Now that we have the four energy bank values in XX12,
                                                           ; we can draw them, starting with the top bank in XX12
                                                           ; and looping down to the bottom bank in XX12+3, using Y
                                                           ; as a loop counter, which was set to 0 above

DLL9:
       movb @XX12(ry),ra               ; LDA XX12,Y        ; Fetch the value of the Y-th indicator, starting from
                                                           ; the top

       movb ry,@P                      ; STY P             ; Store the indicator number in P for retrieval later

       .jsr @DIL                       ; JSR DIL           ; Draw the energy bank using a range of 0-15, and
                                                           ; increment SC to point to the next indicator (the
                                                           ; next energy bank down)

       movb @P,ry                      ; LDY P             ; Restore the indicator number into Y

       ab   rone,ry                    ; INY               ; Increment the indicator number

       ci   ry,>04*256                 ; CPY #4            ; Check to see if we have drawn the last energy bank

       jne  DLL9                       ; BNE DLL9          ; Loop back to DLL9 if we have more banks to draw,
                                                           ; otherwise we are done

* ******************************************************************************
* 
* Name: DIALS (Part 4 of 4)
* Type: Subroutine
* Category: Dashboard
* Summary: Update the dashboard: shields, fuel, laser & cabin temp, altitude
* Deep dive: The dashboard indicators
* 
* ******************************************************************************

       li   ra,>78*256                 ; LDA #&78          ; Set SC(1 0) = &7810, which is the screen address for
       movb ra,@SC+1                   ; STA SC+1          ; the character block containing the left end of the
       li   ra,>10*256                 ; LDA #&10          ; top indicator in the left part of the dashboard, the
       movb ra,@SC                     ; STA SC            ; one showing the forward shield

       movb @FSH,ra                    ; LDA FSH           ; Draw the forward shield indicator using a range of
       .jsr @DILX                      ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
                                                           ; (the aft shield)

       movb @ASH,ra                    ; LDA ASH           ; Draw the aft shield indicator using a range of 0-255,
       .jsr @DILX                      ; JSR DILX          ; and increment SC to point to the next indicator (the
                                                           ; fuel level)

       movb @QQ14,ra                   ; LDA QQ14          ; Draw the fuel level indicator using a range of 0-63,
       .jsr @DILX+2                    ; JSR DILX+2        ; and increment SC to point to the next indicator (the
                                                           ; cabin temperature)

       .jsr @PZW                       ; JSR PZW           ; Call PZW to set A to the colour for dangerous values
                                                           ; and X to the colour for safe values

       movb rx,@K+1                    ; STX K+1           ; Set K+1 (the colour we should show for low values) to
                                                           ; X (the colour to use for safe values)

       movb ra,@K                      ; STA K             ; Set K (the colour we should show for high values) to
                                                           ; A (the colour to use for dangerous values)

                                                           ; The above sets the following indicators to show red
                                                           ; for high values and yellow/white for low values, which
                                                           ; we use for the cabin and laser temperature bars

       li   rx,>0b*256                 ; LDX #11           ; Set T1 to 11, the threshold at which we change the
       movb rx,@T1                     ; STX T1            ; cabin and laser temperature indicators' colours

       movb @CABTMP,ra                 ; LDA CABTMP        ; Draw the cabin temperature indicator using a range of
       .jsr @DILX                      ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
                                                           ; (the laser temperature)

       movb @GNTMP,ra                  ; LDA GNTMP         ; Draw the laser temperature indicator using a range of
       .jsr @DILX                      ; JSR DILX          ; 0-255, and increment SC to point to the next indicator
                                                           ; (the altitude)

       li   ra,>f0*256                 ; LDA #240          ; Set T1 to 240, the threshold at which we change the
       movb ra,@T1                     ; STA T1            ; altitude indicator's colour. As the altitude has a
                                                           ; range of 0-255, pixel 16 will not be filled in, and
                                                           ; 240 would change the colour when moving between pixels
                                                           ; 15 and 16, so this effectively switches off the colour
                                                           ; change for the altitude indicator

       movb ra,@K+1                    ; STA K+1           ; Set K+1 (the colour we should show for low values) to
                                                           ; 240, or &F0 (dashboard colour 2, yellow/white), so the
                                                           ; altitude indicator always shows in this colour

       movb @ALTIT,ra                  ; LDA ALTIT         ; Draw the altitude indicator using a range of 0-255
       .jsr @DILX                      ; JSR DILX          

       b    @COMPAS                    ; JMP COMPAS        ; We have now drawn all the indicators, so jump to
                                                           ; COMPAS to draw the compass, returning from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: PZW
* Type: Subroutine
* Category: Dashboard
* Summary: Fetch the current dashboard colours, to support flashing
* 
* ------------------------------------------------------------------------------
* 
* Set A and X to the colours we should use for indicators showing dangerous and
* safe values respectively. This enables us to implement flashing indicators,
* which is one of the game's configurable options.
* 
* If flashing is enabled, the colour returned in A (dangerous values) will be
* red for 8 iterations of the main loop, and yellow/white for the next 8, before
* going back to red. If we always use PZW to decide which colours we should use
* when updating indicators, flashing colours will be automatically taken care of
* for us.
* 
* The values returned are &F0 for yellow/white and &0F for red. These are mode 5
* bytes that contain 4 pixels, with the colour of each pixel given in two bits,
* the high bit from the first nibble (bits 4-7) and the low bit from the second
* nibble (bits 0-3). So in &F0 each pixel is %10, or colour 2 (yellow or white,
* depending on the dashboard palette), while in &0F each pixel is %01, or colour
* 1 (red).
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The colour to use for indicators with dangerous values
* 
* X                   The colour to use for indicators with safe values
* 
* ******************************************************************************

PZW:
       li   rx,>f0*256                 ; LDX #&F0          ; Set X to dashboard colour 2 (yellow/white)

       movb @MCNT,ra                   ; LDA MCNT          ; A will be non-zero for 8 out of every 16 main loop
       andi ra,>08*256                 ; AND #%00001000    ; counts, when bit 4 is set, so this is what we use to
                                                           ; flash the "danger" colour

       .and @FLH                       ; AND FLH           ; A will be zeroed if flashing colours are disabled

       jeq  B29                        ; BEQ B29           ; If A is zero, skip to the LDA instruction below

       movb rx,ra                      ; TXA               ; Otherwise flashing colours are enabled and it's the
                                                           ; main loop iteration where we flash them, so set A to
                                                           ; colour 2 (yellow/white) and use the BIT trick below to
                                                           ; return from the subroutine

       byte >2c                                                      ; Skip the next instruction by turning it into
                                                                     ; &2C &A9 &0F, or BIT &0FA9, which does nothing apart
                                                                     ; from affect the flags

B29:
       li   ra,>0f*256                 ; LDA #&0F          ; Set A to dashboard colour 1 (red)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DILX
* Type: Subroutine
* Category: Dashboard
* Summary: Update a bar-based indicator on the dashboard
* Deep dive: The dashboard indicators
* 
* ------------------------------------------------------------------------------
* 
* The range of values shown on the indicator depends on which entry point is
* called. For the default entry point of DILX, the range is 0-255 (as the value
* passed in A is one byte). The other entry points are shown below.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The value to be shown on the indicator (so the larger
* the value, the longer the bar)
* 
* T1                  The threshold at which we change the indicator's colour
* from the low value colour to the high value colour. The
* threshold is in pixels, so it should have a value from
* 0-16, as each bar indicator is 16 pixels wide
* 
* K                   The colour to use when A is a high value, as a 4-pixel
* mode 5 character row byte
* 
* K+1                 The colour to use when A is a low value, as a 4-pixel
* mode 5 character row byte
* 
* SC(1 0)             The screen address of the first character block in the
* indicator
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* DILX+2              The range of the indicator is 0-64 (for the fuel
* indicator)
* 
* DIL-1               The range of the indicator is 0-32 (for the speed
* indicator)
* 
* DIL                 The range of the indicator is 0-16 (for the energy
* banks)
* 
* ******************************************************************************

DILX:
       srl  ra,1                       ; LSR A             ; If we call DILX, we set A = A / 16, so A is 0-15
       srl  ra,1                       ; LSR A             

       srl  ra,1                       ; LSR A             ; If we call DILX+2, we set A = A / 4, so A is 0-15

       srl  ra,1                       ; LSR A             ; If we call DIL-1, we set A = A / 2, so A is 0-15

DIL:
                                                           ; If we call DIL, we leave A alone, so A is 0-15
       movb ra,@Q                      ; STA Q             ; Store the indicator value in Q, now reduced to 0-15,
                                                           ; which is the length of the indicator to draw in pixels

       li   rx,>ff*256                 ; LDX #&FF          ; Set R = &FF, to use as a mask for drawing each row of
       movb rx,@R                      ; STX R             ; each character block of the bar, starting with a full
                                                           ; character's width of 4 pixels

       cb   @T1,ra                     ; CMP T1            ; If A >= T1 then we have passed the threshold where we
       joc  DL30                       ; BCS DL30          ; change bar colour, so jump to DL30 to set A to the
                                                           ; "high value" colour

       movb @K+1,ra                    ; LDA K+1           ; Set A to K+1, the "low value" colour to use

       jne  DL31                       ; BNE DL31          ; Jump down to DL31 (this BNE is effectively a JMP as A
                                                           ; will never be zero)

DL30:
       movb @K,ra                      ; LDA K             ; Set A to K, the "high value" colour to use

DL31:
       movb ra,@COL                    ; STA COL           ; Store the colour of the indicator in COL

       li   ry,>02*256                 ; LDY #2            ; We want to start drawing the indicator on the third
                                                           ; line in this character row, so set Y to point to that
                                                           ; row's offset

       li   rx,>03*256                 ; LDX #3            ; Set up a counter in X for the width of the indicator,
                                                           ; which is 4 characters (each of which is 4 pixels wide,
                                                           ; to give a total width of 16 pixels)

DL1:
       movb @Q,ra                      ; LDA Q             ; Fetch the indicator value (0-15) from Q into A

       ci   ra,>04*256                 ; CMP #4            ; If Q < 4, then we need to draw the end cap of the
       jnc  DL2                        ; BCC DL2           ; indicator, which is less than a full character's
                                                           ; width, so jump down to DL2 to do this

       .sbi (>04*256)                  ; SBC #4            ; Otherwise we can draw a 4-pixel wide block, so
       movb ra,@Q                      ; STA Q             ; subtract 4 from Q so it contains the amount of the
                                                           ; indicator that's left to draw after this character

       movb @R,ra                      ; LDA R             ; Fetch the shape of the indicator row that we need to
                                                           ; display from R, so we can use it as a mask when
                                                           ; painting the indicator. It will be &FF at this point
                                                           ; (i.e. a full 4-pixel row)

DL5:
       .and @COL                       ; AND COL           ; Fetch the 4-pixel mode 5 colour byte from COL, and
                                                           ; only keep pixels that have their equivalent bits set
                                                           ; in the mask byte in A

       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
                                                           ; character block we are processing

       ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       movb ry,ra                      ; TYA               ; Add 6 to Y, so Y is now 8 more than when we started
       .clc                            ; CLC               ; this loop iteration, so Y now points to the address
       .adi (>06*256)                  ; ADC #6            ; of the first line of the indicator bar in the next
       movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
                                                           ; screen memory)

       sb   rone,rx                    ; DEX               ; Decrement the loop counter for the next character
                                                           ; block along in the indicator

       jlt  DL6                        ; BMI DL6           ; If we just drew the last character block then we are
                                                           ; done drawing, so jump down to DL6 to finish off

       jgt  DL1                        ; BPL DL1           ; Loop back to DL1 to draw the next character block of
                                                           ; the indicator (this BPL is effectively a JMP as A will
                                                           ; never be negative following the previous BMI)

DL2:
       .eoi (>03*256)                  ; EOR #3            ; If we get here then we are drawing the indicator's
       movb ra,@Q                      ; STA Q             ; end cap, so Q is < 4, and this EOR flips the bits, so
                                                           ; instead of containing the number of indicator columns
                                                           ; we need to fill in on the left side of the cap's
                                                           ; character block, Q now contains the number of blank
                                                           ; columns there should be on the right side of the cap's
                                                           ; character block

       movb @R,ra                      ; LDA R             ; Fetch the current mask from R, which will be &FF at
                                                           ; this point, so we need to turn Q of the columns on the
                                                           ; right side of the mask to black to get the correct end
                                                           ; cap shape for the indicator

DL3:
       .asla                           ; ASL A             ; Shift the mask left so bit 0 is cleared, and then
       andi ra,>ef*256                 ; AND #%11101111    ; clear bit 4, which has the effect of shifting zeroes
                                                           ; from the left into each nibble (i.e. xxxx xxxx becomes
                                                           ; xxx0 xxx0, which blanks out the last column in the
                                                           ; 4-pixel mode 5 character block)

       sb   rone,ra                    ; DEC Q             ; Decrement the counter for the number of columns to
                                                           ; blank out

       jgt  DL3                        ; BPL DL3           ; If we still have columns to blank out in the mask,
                                                           ; loop back to DL3 until the mask is correct for the
                                                           ; end cap

       .pha                            ; PHA               ; Store the mask byte on the stack while we use the
                                                           ; accumulator for a bit

       li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so the characters
       movb ra,@R                      ; STA R             ; after the one we're about to draw will be all blank

       li   ra,>63*256                 ; LDA #99           ; Set Q to a high number (99, why not) so we will keep
       movb ra,@Q                      ; STA Q             ; drawing blank characters until we reach the end of
                                                           ; the indicator row

       .pla                            ; PLA               ; Restore the mask byte from the stack so we can use it
                                                           ; to draw the end cap of the indicator

       b    @DL5                       ; JMP DL5           ; Jump back up to DL5 to draw the mask byte on-screen

DL6:
       ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
                                                           ; character row on-screen (as each row takes up exactly
                                                           ; one page of 256 bytes) - so this sets up SC to point
                                                           ; to the next indicator, i.e. the one below the one we
                                                           ; just drew

DL9:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DIL2
* Type: Subroutine
* Category: Dashboard
* Summary: Update the roll or pitch indicator on the dashboard
* Deep dive: The dashboard indicators
* 
* ------------------------------------------------------------------------------
* 
* The indicator can show a vertical bar in 16 positions, with a value of 8
* showing the bar in the middle of the indicator.
* 
* In practice this routine is only ever called with A in the range 1 to 15, so
* the vertical bar never appears in the leftmost position (though it does appear
* in the rightmost).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The offset of the vertical bar to show in the indicator,
* from 0 at the far left, to 8 in the middle, and 15 at
* the far right
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is set
* 
* ******************************************************************************

DIL2:
       li   ry,>01*256                 ; LDY #1            ; We want to start drawing the vertical indicator bar on
                                                           ; the second line in the indicator's character block, so
                                                           ; set Y to point to that row's offset

       movb ra,@Q                      ; STA Q             ; Store the offset of the vertical bar to draw in Q

                                                           ; We are now going to work our way along the indicator
                                                           ; on the dashboard, from left to right, working our way
                                                           ; along one character block at a time. Y will be used as
                                                           ; a pixel row counter to work our way through the
                                                           ; character blocks, so each time we draw a character
                                                           ; block, we will increment Y by 8 to move on to the next
                                                           ; block (as each character block contains 8 rows)

DLL10:
       .sec                            ; SEC               ; Set A = Q - 4, so that A contains the offset of the
       movb @Q,ra                      ; LDA Q             ; vertical bar from the start of this character block
       .sbi (>04*256)                  ; SBC #4            

       joc  DLL11                      ; BCS DLL11         ; If Q >= 4 then the character block we are drawing does
                                                           ; not contain the vertical indicator bar, so jump to
                                                           ; DLL11 to draw a blank character block

       li   ra,>ff*256                 ; LDA #&FF          ; Set A to a high number (and &FF is as high as they go)

       movb @Q,rx                      ; LDX Q             ; Set X to the offset of the vertical bar, which we know
                                                           ; is within this character block

       movb ra,@Q                      ; STA Q             ; Set Q to a high number (&FF, why not) so we will keep
                                                           ; drawing blank characters after this one until we reach
                                                           ; the end of the indicator row

       movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; CTWOS is a table of ready-made 1-pixel mode 5 bytes,
                                                           ; just like the TWOS and TWOS2 tables for mode 4 (see
                                                           ; the PIXEL routine for details of how they work). This
                                                           ; fetches a mode 5 1-pixel byte with the pixel position
                                                           ; at X, so the pixel is at the offset that we want for
                                                           ; our vertical bar

       andi ra,>f0*256                 ; AND #&F0          ; The 4-pixel mode 5 colour byte &F0 represents four
                                                           ; pixels of colour %10 (3), which is yellow in the
                                                           ; normal dashboard palette and white if we have an
                                                           ; escape pod fitted. We AND this with A so that we only
                                                           ; keep the pixel that matches the position of the
                                                           ; vertical bar (i.e. A is acting as a mask on the
                                                           ; 4-pixel colour byte)

       jne  DLL12                      ; BNE DLL12         ; Jump to DLL12 to skip the code for drawing a blank,
                                                           ; and move on to drawing the indicator (this BNE is
                                                           ; effectively a JMP as A is always non-zero)

DLL11:
                                                           ; If we get here then we want to draw a blank for this
                                                           ; character block
       movb ra,@Q                      ; STA Q             ; Update Q with the new offset of the vertical bar, so
                                                           ; it becomes the offset after the character block we
                                                           ; are about to draw

       li   ra,>00*256                 ; LDA #0            ; Change the mask so no bits are set, so all of the
                                                           ; character blocks we display from now on will be blank
DLL12:
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the shape of the mask on pixel row Y of the
                                                           ; character block we are processing

       ab   rone,ry                    ; INY               ; Draw the next pixel row, incrementing Y
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       ab   rone,ry                    ; INY               ; And draw the third pixel row, incrementing Y
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       ab   rone,ry                    ; INY               ; And draw the fourth pixel row, incrementing Y
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        

       movb ry,ra                      ; TYA               ; Add 5 to Y, so Y is now 8 more than when we started
       .clc                            ; CLC               ; this loop iteration, so Y now points to the address
       .adi (>05*256)                  ; ADC #5            ; of the first line of the indicator bar in the next
       movb ra,ry                      ; TAY               ; character block (as each character is 8 bytes of
                                                           ; screen memory)

       ci   ry,>1e*256                 ; CPY #30           ; If Y < 30 then we still have some more character
       jnc  DLL10                      ; BCC DLL10         ; blocks to draw, so loop back to DLL10 to display the
                                                           ; next one along

       ab   rone,ra                    ; INC SC+1          ; Increment the high byte of SC to point to the next
                                                           ; character row on-screen (as each row takes up exactly
                                                           ; one page of 256 bytes) - so this sets up SC to point
                                                           ; to the next indicator, i.e. the one below the one we
                                                           ; just drew

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TVT1
* Type: Variable
* Category: Drawing the screen
* Summary: Palette data for space and the two dashboard colour schemes
* 
* ------------------------------------------------------------------------------
* 
* Palette bytes for use with the split-screen mode (see IRQ1 below for more
* details).
* 
* Palette data is given as a set of bytes, with each byte mapping a logical
* colour to a physical one. In each byte, the logical colour is given in bits
* 4-7 and the physical colour in bits 0-3. See p.379 of the Advanced User Guide
* for details of how palette mapping works, as in modes 4 and 5 we have to do
* multiple palette commands to change the colours correctly, and the physical
* colour value is EOR'd with 7, just to make things even more confusing.
* 
* Similarly, the palette at TVT1+16 is for the monochrome space view, where
* logical colour 1 is mapped to physical colour 0 EOR 7 = 7 (white), and
* logical colour 0 is mapped to physical colour 7 EOR 7 = 0 (black). Each of
* these mappings requires six calls to SHEILA &21 - see p.379 of the Advanced
* User Guide for an explanation.
* 
* The mode 5 palette table has two blocks which overlap. The block used depends
* on whether or not we have an escape pod fitted. The block at TVT1 is used for
* the standard dashboard colours, while TVT1+8 is used for the dashboard when an
* escape pod is fitted. The colours are as follows:
* 
* Normal (TVT1)     Escape pod (TVT1+8)
* 
* Colour 0      Black             Black
* Colour 1      Red               Red
* Colour 2      Yellow            White
* Colour 3      Green             Cyan
* 
* ******************************************************************************

TVT1:
       byte >d4                                                      ; This block of palette data is used to create two
       byte >94                                                      ; palettes used in three different places, all of them
       byte >f5                                                      ; redefining four colours in mode 5:
       byte >b5                                                      ; 
                                                                     ; 12 bytes from TVT1 (i.e. the first 6 rows): applied
       byte >76                                                      ; when the T1 timer runs down at the switch from the
       byte >36                                                      ; space view to the dashboard, so this is the standard
                                                                     ; dashboard palette
       byte >e1                                                      ; 
       byte >b1                                                      ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
                                                                     ; when the T1 timer runs down at the switch from the
                                                                     ; space view to the dashboard, and we have an escape
                                                                     ; pod fitted, so this is the escape pod dashboard
                                                                     ; palette
                                                                     ; 
                                                                     ; 8 bytes from TVT1+8 (i.e. the last 4 rows): applied
                                                                     ; at vertical sync in LINSCN when HFX is non-zero, to
                                                                     ; create the hyperspace effect in LINSCN (where the
                                                                     ; whole screen is switched to mode 5 at vertical sync)

       byte >f0                                                      ; 12 bytes of palette data at TVT1+16, used to set the
       byte >b0                                                      ; mode 4 palette in LINSCN when we hit vertical sync,
       byte >d0                                                      ; so the palette is set to monochrome when we start to
       byte >90                                                      ; draw the first row of the screen
       byte >77
       byte >37

* ******************************************************************************
* 
* Name: IRQ1
* Type: Subroutine
* Category: Drawing the screen
* Summary: The main screen-mode interrupt handler (IRQ1V points here)
* Deep dive: The split-screen mode in BBC Micro Elite
* 
* ------------------------------------------------------------------------------
* 
* The main interrupt handler, which implements Elite's split-screen mode (see
* the deep dive on "The split-screen mode in BBC Micro Elite" for details).
* 
* IRQ1V is set to point to IRQ1 by the loading process.
* 
* ******************************************************************************

LINSCN:
                                                           ; This is called from the interrupt handler below, at
                                                           ; the start of each vertical sync (i.e. when the screen
                                                           ; refresh starts)
       li   ra,>1e*256                 ; LDA #30           ; Set the line scan counter to a non-zero value, so
       movb ra,@DL                     ; STA DL            ; routines like WSCAN can set DL to 0 and then wait for
                                                           ; it to change to non-zero to catch the vertical sync

       movb ra,@VIA+>44                ; STA VIA+&44       ; Set 6522 System VIA T1C-L timer 1 low-order counter
                                                           ; (SHEILA &44) to 30

       li   ra,(VSCAN)*256             ; LDA #VSCAN        ; Set 6522 System VIA T1C-L timer 1 high-order counter
       movb ra,@VIA+>45                ; STA VIA+&45       ; (SHEILA &45) to VSCAN (57) to start the T1 counter
                                                           ; counting down from 14622 at a rate of 1 MHz

       movb @HFX,ra                    ; LDA HFX           ; If HFX is non-zero, jump to VNT1 to set the mode 5
       jne  VNT1                       ; BNE VNT1          ; palette instead of switching to mode 4, which will
                                                           ; have the effect of blurring and colouring the top
                                                           ; screen. This is how the white hyperspace rings turn
                                                           ; to colour when we do a hyperspace jump, and is
                                                           ; triggered by setting HFX to 1 in routine LL164

       li   ra,>08*256                 ; LDA #%00001000    ; Set the Video ULA control register (SHEILA &20) to
       movb ra,@VIA+>20                ; STA VIA+&20       ; %00001000, which is the same as switching to mode 4
                                                           ; (i.e. the top part of the screen) but with no cursor

VNT3:
       movb @TVT1+16(ry),ra            ; LDA TVT1+16,Y     ; Copy the Y-th palette byte from TVT1+16 to SHEILA &21
       movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
                                                           ; of the screen (i.e. the dashboard)

       sb   rone,ry                    ; DEY               ; Decrement the palette byte counter

       jgt  VNT3                       ; BPL VNT3          ; Loop back to VNT3 until we have copied all the
                                                           ; palette bytes

       movb @LASCT,ra                  ; LDA LASCT         ; Decrement the value of LASCT, but if we go too far
       jeq  B30                        ; BEQ B30           ; and it becomes negative, bump it back up again (this
       sb   rone,ra                    ; DEC LASCT         ; controls the pulsing of pulse lasers)

B30:
       movb @SVN,ra                    ; LDA SVN           ; If SVN is non-zero, we are in the process of saving
       jne  jvec_                      ; BNE jvec          ; the commander file, so jump to jvec to pass control
                                                           ; to the next interrupt handler, so we don't break file
                                                           ; saving by blocking the interrupt chain

       .pla                            ; PLA               ; Otherwise restore Y from the stack
       movb ra,ry                      ; TAY               

       movb @VIA+>41,ra                ; LDA VIA+&41       ; Read 6522 System VIA input register IRA (SHEILA &41)

       movb @>FC,ra                    ; LDA &FC           ; Set A to the interrupt accumulator save register,
                                                           ; which restores A to the value it had on entering the
                                                           ; interrupt

       ; RTI                           ; RTI               ; Return from interrupts, so this interrupt is not
                                                           ; passed on to the next interrupt handler, but instead
                                                           ; the interrupt terminates here

IRQ1:
       movb ry,ra                      ; TYA               ; Store Y on the stack
       .pha                            ; PHA               

       li   ry,>0b*256                 ; LDY #11           ; Set Y as a counter for 12 bytes, to use when setting
                                                           ; the dashboard palette below

       li   ra,>02*256                 ; LDA #%00000010    ; Read the 6522 System VIA status byte bit 1 (SHEILA
       .bit @VIA+>4D                   ; BIT VIA+&4D       ; &4D), which is set if vertical sync has occurred on
                                                           ; the video system

       jne  LINSCN                     ; BNE LINSCN        ; If we are on the vertical sync pulse, jump to LINSCN
                                                           ; to set up the timers to enable us to switch the
                                                           ; screen mode between the space view and dashboard

       jno  jvec_                      ; BVC jvec          ; Read the 6522 System VIA status byte bit 6, which is
                                                           ; set if timer 1 has timed out. We set the timer in
                                                           ; LINSCN above, so this means we only run the next bit
                                                           ; if the screen redraw has reached the boundary between
                                                           ; the space view and the dashboard. Otherwise bit 6 is
                                                           ; clear and we aren't at the boundary, so we jump to
                                                           ; jvec to pass control to the next interrupt handler

       .asla                           ; ASL A             ; Double the value in A to 4

       movb ra,@VIA+>20                ; STA VIA+&20       ; Set the Video ULA control register (SHEILA &20) to
                                                           ; %00000100, which is the same as switching to mode 5,
                                                           ; (i.e. the bottom part of the screen) but with no
                                                           ; cursor

       movb @ESCP,ra                   ; LDA ESCP          ; If an escape pod is fitted, jump to VNT1 to set the
       jne  VNT1                       ; BNE VNT1          ; mode 5 palette differently (so the dashboard is a
                                                           ; different colour if we have an escape pod)

B31:
       movb @TVT1(ry),ra               ; LDA TVT1,Y        ; Copy the Y-th palette byte from TVT1 to SHEILA &21
       movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
                                                           ; of the screen (i.e. the dashboard)

       sb   rone,ry                    ; DEY               ; Decrement the palette byte counter

       jgt  B31                        ; BPL B31           ; Loop back to the LDA TVT1,Y instruction until we have
                                                           ; copied all the palette bytes

jvec_:
       .pla                            ; PLA               ; Restore Y from the stack
       movb ra,ry                      ; TAY               

       .jmpi @VEC                      ; JMP (VEC)         ; Jump to the address in VEC, which was set to the
                                                           ; original IRQ1V vector by the loading process, so this
                                                           ; instruction passes control to the next interrupt
                                                           ; handler

VNT1:
       li   ry,>07*256                 ; LDY #7            ; Set Y as a counter for 8 bytes

       movb @TVT1+8(ry),ra             ; LDA TVT1+8,Y      ; Copy the Y-th palette byte from TVT1+8 to SHEILA &21
       movb ra,@VIA+>21                ; STA VIA+&21       ; to map logical to actual colours for the bottom part
                                                           ; of the screen (i.e. the dashboard)

       sb   rone,ry                    ; DEY               ; Decrement the palette byte counter

       jgt  VNT1+2                     ; BPL VNT1+2        ; Loop back to the LDA TVT1+8,Y instruction until we
                                                           ; have copied all the palette bytes

       jlt  jvec_                      ; BMI jvec          ; Jump up to jvec to pass control to the next interrupt
                                                           ; handler (this BMI is effectively a JMP as we didn't
                                                           ; loop back with the BPL above, so BMI is always true)

* ******************************************************************************
* 
* Name: ESCAPE
* Type: Subroutine
* Category: Flight
* Summary: Launch our escape pod
* 
* ------------------------------------------------------------------------------
* 
* This routine displays our doomed Cobra Mk III disappearing off into the ether
* before arranging our replacement ship. Called when we press ESCAPE during
* flight and have an escape pod fitted.
* 
* ******************************************************************************

ESCAPE:
       movb @MJ,ra                     ; LDA MJ            ; Store the value of MJ on the stack (the "are we in
       .pha                            ; PHA               ; witchspace?" flag)

       .jsr @RES2                      ; JSR RES2          ; Reset a number of flight variables and workspaces

       li   rx,(CYL)*256               ; LDX #CYL          ; Set the current ship type to a Cobra Mk III, so we
       movb rx,@TYPE                   ; STX TYPE          ; can show our ship disappear into the distance when we
                                                           ; eject in our pod

       .jsr @FRS1                      ; JSR FRS1          ; Call FRS1 to launch the Cobra Mk III straight ahead,
                                                           ; like a missile launch, but with our ship instead

       li   ra,>08*256                 ; LDA #8            ; Set the Cobra's byte #27 (speed) to 8
       movb ra,@INWK+27                ; STA INWK+27       

       li   ra,>c2*256                 ; LDA #194          ; Set the Cobra's byte #30 (pitch counter) to 194, so it
       movb ra,@INWK+30                ; STA INWK+30       ; pitches up as we pull away

       srl  ra,1                       ; LSR A             ; Set the Cobra's byte #32 (AI flag) to %01100001, so it
       movb ra,@INWK+32                ; STA INWK+32       ; has no AI, and we can use this value as a counter to
                                                           ; do the following loop 97 times

ESL1:
       .jsr @MVEIT                     ; JSR MVEIT         ; Call MVEIT to move the Cobra in space

       .jsr @LL9                       ; JSR LL9           ; Call LL9 to draw the Cobra on-screen

       sb   rone,ra                    ; DEC INWK+32       ; Decrement the counter in byte #32

       jne  ESL1                       ; BNE ESL1          ; Loop back to keep moving the Cobra until the AI flag
                                                           ; is 0, which gives it time to drift away from our pod

       .jsr @SCAN                      ; JSR SCAN          ; Call SCAN to remove the Cobra from the scanner (by
                                                           ; redrawing it)

       .jsr @RESET                     ; JSR RESET         ; Call RESET to reset our ship and various controls

       .pla                            ; PLA               ; Restore the witchspace flag from before the escape pod
       jeq  B32                        ; BEQ B32           ; launch, and if we were in normal space, skip the
                                                           ; following instruction

       b    @DEATH                     ; JMP DEATH         ; Launching an escape pod in witchspace is fatal, so
                                                           ; jump to DEATH to begin the funeral and return from the
                                                           ; subroutine using a tail call

B32:
       li   rx,>10*256                 ; LDX #16           ; We lose all our cargo when using our escape pod, so
                                                           ; up a counter in X so we can zero the 17 cargo slots
                                                           ; in QQ20

ESL2:
       movb ra,@QQ20(rx)               ; STA QQ20,X        ; Set the X-th byte of QQ20 to zero (as we know A = 0
                                                           ; from the BEQ above), so we no longer have any of item
                                                           ; type X in the cargo hold

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  ESL2                       ; BPL ESL2          ; Loop back to ESL2 until we have emptied the entire
                                                           ; cargo hold

       movb ra,@FIST                   ; STA FIST          ; Launching an escape pod also clears our criminal
                                                           ; record, so set our legal status in FIST to 0 ("clean")

       movb ra,@ESCP                   ; STA ESCP          ; The escape pod is a one-use item, so set ESCP to 0 so
                                                           ; we no longer have one fitted

       li   ra,>46*256                 ; LDA #70           ; Our replacement ship is delivered with a full tank of
       movb ra,@QQ14                   ; STA QQ14          ; fuel, so set the current fuel level in QQ14 to 70, or
                                                           ; 7.0 light years

       b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
                                                           ; screen) and return from the subroutine with a tail
                                                           ; call

* ******************************************************************************
* 
* Save ELTB.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE C FILE
* 
* Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_C.:
       equ $

LOAD_C.:
       equ LOAD. +$ - CODE.

* ******************************************************************************
* 
* Name: TACTICS (Part 1 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Process missiles, both enemy missiles and our own
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section implements missile tactics and is entered at TA18 from the main
* entry point below, if the current ship is a missile. Specifically:
* 
* * If E.C.M. is active, destroy the missile
* 
* * If the missile is hostile towards us, then check how close it is. If it
* hasn't reached us, jump to part 3 so it can streak towards us, otherwise
* we've been hit, so process a large amount of damage to our ship
* 
* * Otherwise see how close the missile is to its target. If it has not yet
* reached its target, give the target a chance to activate its E.C.M. if it
* has one, otherwise jump to TA19 with K3 set to the vector from the target
* to the missile
* 
* * If it has reached its target and the target is the space station, destroy
* the missile, potentially damaging us if we are nearby
* 
* * If it has reached its target and the target is a ship, destroy the missile
* and the ship, potentially damaging us if we are nearby
* 
* ******************************************************************************

TA34:
                                                           ; If we get here, the missile is hostile
       li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
       .jsr @MAS4                      ; JSR MAS4          

       jeq  B33                        ; BEQ B33           ; If A = 0 then the missile is very close to our ship,
                                                           ; so skip the following instruction

B33:
       b    @TA21                      ; JMP TA21          ; Jump down to part 3 to set up the vectors and skip
                                                           ; straight to aggressive manoeuvring

       .jsr @TA87+3                    ; JSR TA87+3        ; The missile has hit our ship, so call TA87+3 to set
                                                           ; bit 7 of the missile's byte #31, which marks the
                                                           ; missile as being killed

       .jsr @EXNO3                     ; JSR EXNO3         ; Make the sound of the missile exploding

       li   ra,>fa*256                 ; LDA #250          ; Call OOPS to damage the ship by 250, which is a pretty
       b    @OOPS                      ; JMP OOPS          ; big hit, and return from the subroutine using a tail
                                                           ; call

TA18:
                                                           ; This is the entry point for missile tactics and is
                                                           ; called from the main TACTICS routine below
       movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
       jne  TA35                       ; BNE TA35          ; opponent's), jump to TA35 to destroy this missile

       movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if bit 6 is set
       .asla                           ; ASL A             ; (i.e. missile is hostile), jump up to TA34 to check
       jlt  TA34                       ; BMI TA34          ; whether the missile has hit us

       srl  ra,1                       ; LSR A             ; Otherwise shift A right again. We know bits 6 and 7
                                                           ; are now clear, so this leaves bits 0-5. Bits 1-5
                                                           ; contain the target's slot number, and bit 0 is cleared
                                                           ; in FRMIS when a missile is launched, so A contains
                                                           ; the slot number shifted left by 1 (i.e. doubled) so we
                                                           ; can use it as an index for the two-byte address table
                                                           ; at UNIV

       movb ra,rx                      ; TAX               ; Copy the address of the target ship's data block from
       movb @UNIV(rx),ra               ; LDA UNIV,X        ; UNIV(X+1 X) to V(1 0)
       movb ra,@V                      ; STA V             
       movb @UNIV+1(rx),ra             ; LDA UNIV+1,X      
       movb ra,@V+1                    ; STA V+1           

       li   ry,>02*256                 ; LDY #2            ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
       .jsr @TAS1                      ; JSR TAS1          ; target ship

       li   ry,>05*256                 ; LDY #5            ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
       .jsr @TAS1                      ; JSR TAS1          ; target ship

       li   ry,>08*256                 ; LDY #8            ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
       .jsr @TAS1                      ; JSR TAS1          ; target ship

                                                           ; So K3 now contains the vector from the target ship to
                                                           ; the missile

       movb @K3+2,ra                   ; LDA K3+2          ; Set A = OR of all the sign and high bytes of the
       socb @K3+5,ra                   ; ORA K3+5          ; above, clearing bit 7 (i.e. ignore the signs)
       socb @K3+8,ra                   ; ORA K3+8          
       andi ra,>7f*256                 ; AND #%01111111    
       socb @K3+1,ra                   ; ORA K3+1          
       socb @K3+4,ra                   ; ORA K3+4          
       socb @K3+7,ra                   ; ORA K3+7          

       jne  TA64                       ; BNE TA64          ; If the result is non-zero, then the missile is some
                                                           ; distance from the target, so jump down to TA64 see if
                                                           ; the target activates its E.C.M.

       movb @INWK+32,ra                ; LDA INWK+32       ; Fetch the AI flag from byte #32 and if only bits 7 and
       ci   ra,>82*256                 ; CMP #%10000010    ; 1 are set (AI is enabled and the target is slot 1, the
       jeq  TA35                       ; BEQ TA35          ; space station), jump to TA35 to destroy this missile,
                                                           ; as the space station ain't kidding around

       li   ry,>1f*256                 ; LDY #31           ; Fetch byte #31 (the exploding flag) of the target ship
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into A

       .bit @M32+1                     ; BIT M32+1         ; M32 contains an LDY #32 instruction, so M32+1 contains
                                                           ; 32, so this instruction tests A with %00100000, which
                                                           ; checks bit 5 of A (the "already exploding?" bit)

       jne  TA35                       ; BNE TA35          ; If the target ship is already exploding, jump to TA35
                                                           ; to destroy this missile

       ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 of the target's byte #31 to mark
       .st_ind_y_idx @V,ra             ; STA (V),Y         ; the ship as having been killed, so it explodes

TA35:
       movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo OR y_lo OR z_lo of the missile
       socb @INWK+3,ra                 ; ORA INWK+3        
       socb @INWK+6,ra                 ; ORA INWK+6        

       jne  TA87                       ; BNE TA87          ; If A is non-zero then the missile is not near our
                                                           ; ship, so jump to TA87 to skip damaging our ship

       li   ra,>50*256                 ; LDA #80           ; Otherwise the missile just got destroyed near us, so
       .jsr @OOPS                      ; JSR OOPS          ; call OOPS to damage the ship by 80, which is nowhere
                                                           ; near as bad as the 250 damage from a missile slamming
                                                           ; straight into us, but it's still pretty nasty

TA87:
       .jsr @EXNO2                     ; JSR EXNO2         ; Call EXNO2 to process the fact that we have killed a
                                                           ; missile (so increase the kill tally, make an explosion
                                                           ; sound and so on)

       .asl @INWK+31                   ; ASL INWK+31       ; Set bit 7 of the missile's byte #31 flag to mark it as
       .sec                            ; SEC               ; having been killed, so it explodes
       .ror @INWK+31                   ; ROR INWK+31       

TA1:
       .rts                            ; RTS               ; Return from the subroutine

TA64:
                                                           ; If we get here then the missile has not reached the
                                                           ; target
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>10*256                 ; CMP #16           ; If A >= 16 (94% chance), jump down to TA19 with the
       joc  TA19                       ; BCS TA19          ; vector from the target to the missile in K3

M32:
       li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; into the C flag
       srl  ra,1                       ; LSR A             

       jnc  TA19                       ; BCC TA19          ; If the C flag is clear then the target does not have
                                                           ; E.C.M. fitted, so jump down to TA19 with the vector
                                                           ; from the target to the missile in K3

       b    @ECBLB2                    ; JMP ECBLB2        ; The target has E.C.M., so jump to ECBLB2 to set it
                                                           ; off, returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TACTICS (Part 2 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section contains the main entry point at TACTICS, which is called from
* part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
* This part does the following:
* 
* * If this is a missile, jump up to the missile code in part 1
* 
* * If this is an escape pod, point it at the planet and jump to the
* manoeuvring code in part 7
* 
* * If this is the space station and it is hostile, consider spawning a cop
* (45% chance, up to a maximum of four) and we're done
* 
* * If this is a lone Thargon without a mothership, set it adrift aimlessly
* and we're done
* 
* * If this is a pirate and we are within the space station safe zone, stop
* the pirate from attacking by removing all its aggression
* 
* * Recharge the ship's energy banks by 1
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The ship type
* 
* ******************************************************************************

TACTICS:
       ci   rx,(MSL)*256               ; CPX #MSL          ; If this is a missile, jump up to TA18 to implement
       jeq  TA18                       ; BEQ TA18          ; missile tactics

       ci   rx,(ESC)*256               ; CPX #ESC          ; If this is not an escape pod, skip the following two
       jne  B34                        ; BNE B34           ; instructions

       .jsr @SPS1                      ; JSR SPS1          ; This is an escape pod, so call SPS1 to calculate the
                                                           ; vector to the planet and store it in XX15

       b    @TA15                      ; JMP TA15          ; Jump down to TA15

B34:
       ci   rx,(SST)*256               ; CPX #SST          ; If this is not the space station, jump down to TA13
       jne  TA13                       ; BNE TA13          

                                                           ; We only call the tactics routine for the space station
                                                           ; when it is hostile, so if we get here then this is the
                                                           ; station, and we already know it's hostile, so we need
                                                           ; to spawn some cops

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>8c*256                 ; CMP #140          ; If A < 140 (55% chance) then return from the
       jnc  TA14-1                     ; BCC TA14-1        ; subroutine (as TA14-1 contains an RTS)

       movb @MANY+COPS,ra              ; LDA MANY+COPS     ; We only call the tactics routine for the space station
       ci   ra,>04*256                 ; CMP #4            ; when it is hostile, so first check the number of cops
       joc  TA14-1                     ; BCS TA14-1        ; in the vicinity, and if we already have 4 or more, we
                                                           ; don't need to spawn any more, so return from the
                                                           ; subroutine (as TA14-1 contains an RTS)

       li   rx,(COPS)*256              ; LDX #COPS         ; Set X to the ship type for a cop

       li   ra,>f1*256                 ; LDA #%11110001    ; Set the AI flag to give the ship E.C.M., enable AI and
                                                           ; make it very aggressive (60 out of 63)

       b    @SFS1                      ; JMP SFS1          ; Jump to SFS1 to spawn the ship, returning from the
                                                           ; subroutine using a tail call

TA13:
       ci   rx,(TGL)*256               ; CPX #TGL          ; If this is not a Thargon, jump down to TA14
       jne  TA14                       ; BNE TA14          

       movb @MANY+THG,ra               ; LDA MANY+THG      ; If there is at least one Thargoid in the vicinity,
       jne  TA14                       ; BNE TA14          ; jump down to TA14

       .lsr @INWK+32                   ; LSR INWK+32       ; This is a Thargon but there is no Thargoid mothership,
       .asl @INWK+32                   ; ASL INWK+32       ; so clear bit 0 of the AI flag to disable its E.C.M.

       .lsr @INWK+27                   ; LSR INWK+27       ; And halve the Thargon's speed

       .rts                            ; RTS               ; Return from the subroutine

TA14:
       ci   rx,(CYL)*256               ; CPX #CYL          ; If A >= #CYL, i.e. this is a Cobra Mk III trader (as
       joc  TA62                       ; BCS TA62          ; asteroids and cargo canisters never have AI), jump
                                                           ; down to TA62

       ci   rx,(COPS)*256              ; CPX #COPS         ; If this is a cop, jump down to TA62
       jeq  TA62                       ; BEQ TA62          

       movb @SSPR,ra                   ; LDA SSPR          ; If we aren't within range of the space station, jump
       jeq  TA62                       ; BEQ TA62          ; down to TA62

       movb @INWK+32,ra                ; LDA INWK+32       ; This is a pirate or bounty hunter, but we are inside
       andi ra,>81*256                 ; AND #%10000001    ; the space station's safe zone, so clear bits 1-6 of
       movb ra,@INWK+32                ; STA INWK+32       ; the AI flag to stop it being hostile, because even
                                                           ; pirates aren't crazy enough to breach the station's
                                                           ; no-fire zone

TA62:
       li   ry,>0e*256                 ; LDY #14           ; If the ship's energy is greater or equal to the
       movb @INWK+35,ra                ; LDA INWK+35       ; maximum value from the ship's blueprint pointed to by
       .cmp_ind_y_idx @XX0,ra          ; CMP (XX0),Y       ; XX0, then skip the next instruction
       joc  TA21                       ; BCS TA21          

       ab   rone,ra                    ; INC INWK+35       ; The ship's energy is not at maximum, so recharge the
                                                           ; energy banks by 1

* ******************************************************************************
* 
* Name: TACTICS (Part 3 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Calculate dot product to determine ship's aim
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section sets up some vectors and calculates dot products. Specifically:
* 
* * Calculate the dot product of the ship's nose vector (i.e. the direction it
* is pointing) with the vector between us and the ship. This value will help
* us work out later on whether the enemy ship is pointing towards us, and
* therefore whether it can hit us with its lasers.
* 
* ******************************************************************************

TA21:
       li   rx,>08*256                 ; LDX #8            ; We now want to copy the ship's x, y and z coordinates
                                                           ; from INWK to K3, so set up a counter for 9 bytes

TAL1:
       movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte from INWK to the X-th byte of K3
       movb ra,@K3(rx)                 ; STA K3,X          

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  TAL1                       ; BPL TAL1          ; Loop back until we have copied all 9 bytes

TA19:
                                                           ; If this is a missile that's heading for its target
                                                           ; (not us, one of the other ships), then the missile
                                                           ; routine at TA18 above jumps here after setting K3 to
                                                           ; the vector from the target to the missile
       .jsr @TAS2                      ; JSR TAS2          ; Normalise the vector in K3 and store the normalised
                                                           ; version in XX15, so XX15 contains the normalised
                                                           ; vector from our ship to the ship we are applying AI
                                                           ; tactics to (or the normalised vector from the target
                                                           ; to the missile - in both cases it's the vector from
                                                           ; the potential victim to the attacker)

       li   ry,>0a*256                 ; LDY #10           ; Set (A X) = nosev . XX15
       .jsr @TAS3                      ; JSR TAS3          

       movb ra,@CNT                    ; STA CNT           ; Store the high byte of the dot product in CNT. The
                                                           ; bigger the value, the more aligned the two ships are,
                                                           ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
                                                           ; is positive, the ships are facing in a similar
                                                           ; direction, if it's negative they are facing in
                                                           ; opposite directions

* ******************************************************************************
* 
* Name: TACTICS (Part 4 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section works out what kind of condition the ship is in. Specifically:
* 
* * Rarely (2.5% chance) roll the ship by a noticeable amount
* 
* * If the ship has at least half its energy banks full, jump to part 6 to
* consider firing the lasers
* 
* * If the ship is not into the last 1/8th of its energy, jump to part 5 to
* consider firing a missile
* 
* * If the ship is into the last 1/8th of its energy, then rarely (10% chance)
* the ship launches an escape pod and is left drifting in space
* 
* ******************************************************************************

       movb @TYPE,ra                   ; LDA TYPE          ; If this is not a missile, skip the following
       ci   ra,(MSL)*256               ; CMP #MSL          ; instruction
       jne  B35                        ; BNE B35           

       b    @TA20                      ; JMP TA20          ; This is a missile, so jump down to TA20 to get
                                                           ; straight into some aggressive manoeuvring

B35:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>fa*256                 ; CMP #250          ; If A < 250 (97.5% chance), jump down to TA7 to skip
       jnc  TA7                        ; BCC TA7           ; the following

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>68*256                 ; ORA #104          ; Bump A up to at least 104 and store in the roll
       movb ra,@INWK+29                ; STA INWK+29       ; counter, to gives the ship a noticeable roll

TA7:
       li   ry,>0e*256                 ; LDY #14           ; Set A = the ship's maximum energy / 2
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       
       srl  ra,1                       ; LSR A             

       cb   @INWK+35,ra                ; CMP INWK+35       ; If the ship's current energy in byte #35 > A, i.e. the
       jnc  TA3                        ; BCC TA3           ; ship has at least half of its energy banks charged,
                                                           ; jump down to TA3

       srl  ra,1                       ; LSR A             ; If the ship's current energy in byte #35 > A / 4, i.e.
       srl  ra,1                       ; LSR A             ; the ship is not into the last 1/8th of its energy,
       cb   @INWK+35,ra                ; CMP INWK+35       ; jump down to ta3 to consider firing a missile
       jnc  ta3_                       ; BCC ta3           

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>e6*256                 ; CMP #230          ; If A < 230 (90% chance), jump down to ta3 to consider
       jnc  ta3_                       ; BCC ta3           ; firing a missile

       movb @TYPE,ra                   ; LDA TYPE          ; If this is a Thargoid, jump down to ta3 to consider
       ci   ra,(THG)*256               ; CMP #THG          ; launching a Thargon
       jeq  ta3_                       ; BEQ ta3           

                                                           ; By this point, the ship has run out of both energy and
                                                           ; luck, so it's time to bail

       li   ra,>00*256                 ; LDA #0            ; Set the AI flag to 0 to disable AI, hostility and
       movb ra,@INWK+32                ; STA INWK+32       ; E.C.M., so the ship's a sitting duck

       b    @SESCP                     ; JMP SESCP         ; Jump to SESCP to spawn an escape pod from the ship,
                                                           ; returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TACTICS (Part 5 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Consider whether to launch a missile at us
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section considers whether to launch a missile. Specifically:
* 
* * If the ship doesn't have any missiles, skip to the next part
* 
* * If an E.C.M. is firing, skip to the next part
* 
* * Randomly decide whether to fire a missile (or, in the case of Thargoids,
* release a Thargon), and if we do, we're done
* 
* ******************************************************************************

ta3_:
                                                           ; If we get here then the ship has less than half energy
                                                           ; so there may not be enough juice for lasers, but let's
                                                           ; see if we can fire a missile
       movb @INWK+31,ra                ; LDA INWK+31       ; Set A = bits 0-2 of byte #31, the number of missiles
       andi ra,>07*256                 ; AND #%00000111    ; the ship has left

       jeq  TA3                        ; BEQ TA3           ; If it doesn't have any missiles, jump to TA3

       movb ra,@T                      ; STA T             ; Store the number of missiles in T

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       andi ra,>1f*256                 ; AND #31           ; Restrict A to a random number in the range 0-31

       cb   @T,ra                      ; CMP T             ; If A >= T, which is quite likely, though less likely
       joc  TA3                        ; BCS TA3           ; with higher numbers of missiles, jump to TA3 to skip
                                                           ; firing a missile

       movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
       jne  TA3                        ; BNE TA3           ; opponent's), jump to TA3 to skip firing a missile

       sb   rone,ra                    ; DEC INWK+31       ; We're done with the checks, so it's time to fire off a
                                                           ; missile, so reduce the missile count in byte #31 by 1

       movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type into A

       ci   ra,(THG)*256               ; CMP #THG          ; If this is not a Thargoid, jump down to TA16 to launch
       jne  TA16                       ; BNE TA16          ; a missile

       li   rx,(TGL)*256               ; LDX #TGL          ; This is a Thargoid, so instead of launching a missile,
       movb @INWK+32,ra                ; LDA INWK+32       ; the mothership launches a Thargon, so call SFS1 to
       b    @SFS1                      ; JMP SFS1          ; spawn a Thargon from the parent ship, and return from
                                                           ; the subroutine using a tail call

TA16:
       b    @SFRMIS                    ; JMP SFRMIS        ; Jump to SFRMIS to spawn a missile as a child of the
                                                           ; current ship, make a noise and print a message warning
                                                           ; of incoming missiles, and return from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: TACTICS (Part 6 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Consider firing a laser at us, if aim is true
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section looks at potentially firing the ship's laser at us. Specifically:
* 
* * If the ship is not pointing at us, skip to the next part
* 
* * If the ship is pointing at us but not accurately, fire its laser at us and
* skip to the next part
* 
* * If we are in the ship's crosshairs, register some damage to our ship, slow
* down the attacking ship, make the noise of us being hit by laser fire, and
* we're done
* 
* ******************************************************************************

TA3:
                                                           ; If we get here then the ship either has plenty of
                                                           ; energy, or levels are low but it couldn't manage to
                                                           ; launch a missile, so maybe we can fire the laser?
       li   ra,>00*256                 ; LDA #0            ; Set A to x_hi OR y_hi OR z_hi
       .jsr @MAS4                      ; JSR MAS4          

       andi ra,>e0*256                 ; AND #%11100000    ; If any of the hi bytes have any of bits 5-7 set, then
       jne  TA4                        ; BNE TA4           ; jump to TA4 to skip the laser checks, as the ship is
                                                           ; too far away from us to hit us with a laser

       movb @CNT,rx                    ; LDX CNT           ; Set X = the dot product set above in CNT. If this is
                                                           ; positive, this ship and our ship are facing in similar
                                                           ; directions, but if it's negative then we are facing
                                                           ; each other, so for us to be in the enemy ship's line
                                                           ; of fire, X needs to be negative. The value in X can
                                                           ; have a maximum magnitude of 36, which would mean we
                                                           ; were facing each other square on, so in the following
                                                           ; code we check X like this:
                                                           ; 
                                                           ; X = 0 to -31, we are not in the enemy ship's line
                                                           ; of fire, so they can't shoot at us
                                                           ; 
                                                           ; X = -32 to -34, we are in the enemy ship's line
                                                           ; of fire, so they can shoot at us, but they can't
                                                           ; hit us as we're not dead in their crosshairs
                                                           ; 
                                                           ; X = -35 to -36, we are bang in the middle of the
                                                           ; enemy ship's crosshairs, so they can not only
                                                           ; shoot us, they can hit us

       ci   rx,>a0*256                 ; CPX #160          ; If X < 160, i.e. X > -32, then we are not in the enemy
       jnc  TA4                        ; BCC TA4           ; ship's line of fire, so jump to TA4 to skip the laser
                                                           ; checks

       movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 in byte #31 to denote that the ship is
       ori  ra,>40*256                 ; ORA #%01000000    ; firing its laser at us
       movb ra,@INWK+31                ; STA INWK+31       

       ci   rx,>a3*256                 ; CPX #163          ; If X < 163, i.e. X > -35, then we are not in the enemy
       jnc  TA4                        ; BCC TA4           ; ship's crosshairs, so jump to TA4 to skip the laser
                                                           ; checks

HIT:
       li   ry,>13*256                 ; LDY #19           ; We are being hit by enemy laser fire, so fetch the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; enemy ship's byte #19 from their ship's blueprint
                                                           ; into A

       srl  ra,1                       ; LSR A             ; Halve the enemy ship's byte #19 (which contains both
                                                           ; the laser power and number of missiles) to get the
                                                           ; amount of damage we should take

       .jsr @OOPS                      ; JSR OOPS          ; Call OOPS to take some damage, which could do anything
                                                           ; from reducing the shields and energy, all the way to
                                                           ; losing cargo or dying (if the latter, we don't come
                                                           ; back from this subroutine)

       sb   rone,ra                    ; DEC INWK+28       ; Halve the attacking ship's acceleration in byte #28

       movb @ECMA,ra                   ; LDA ECMA          ; If an E.C.M. is currently active (either ours or an
       jne  TA10                       ; BNE TA10          ; opponent's), return from the subroutine without making
                                                           ; the laser-strike sound (as TA10 contains an RTS)

       li   ra,>08*256                 ; LDA #8            ; Call the NOISE routine with A = 8 to make the sound
       b    @NOISE                     ; JMP NOISE         ; of us being hit by lasers, returning from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: TACTICS (Part 7 of 7)
* Type: Subroutine
* Category: Tactics
* Summary: Apply tactics: Set pitch, roll, and acceleration
* Deep dive: Program flow of the tactics routine
* 
* ------------------------------------------------------------------------------
* 
* This section looks at manoeuvring the ship. Specifically:
* 
* * Work out which direction the ship should be moving, depending on whether
* it's an escape pod, where it is, which direction it is pointing, and how
* aggressive it is
* 
* * Set the pitch and roll counters to head in that direction
* 
* * Speed up or slow down, depending on where the ship is in relation to us
* 
* ******************************************************************************

TA4:
       movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi >= 3 then the ship is quite far away, so jump
       ci   ra,>03*256                 ; CMP #3            ; down to TA5
       joc  TA5                        ; BCS TA5           

       movb @INWK+1,ra                 ; LDA INWK+1        ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
       socb @INWK+4,ra                 ; ORA INWK+4        
       andi ra,>fe*256                 ; AND #%11111110    

       jeq  TA15                       ; BEQ TA15          ; If A = 0 then the ship is pretty close to us, so jump
                                                           ; to TA15 so it heads away from us

TA5:
                                                           ; If we get here then the ship is quite far away
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A, so A is at least 128

       cb   @INWK+32,ra                ; CMP INWK+32       ; If A >= byte #32 (the ship's AI flag) then jump down
       joc  TA15                       ; BCS TA15          ; to TA15 so it heads away from us

                                                           ; We get here if A < byte #32, and the chances of this
                                                           ; being true are greater with high values of byte #32,
                                                           ; as long as they are at least 128
                                                           ; 
                                                           ; In other words, higher byte #32 values increase the
                                                           ; chances of a ship changing direction to head towards
                                                           ; us - or, to put it another way, ships with higher
                                                           ; byte #32 values of 128 or more are spoiling for a
                                                           ; fight
                                                           ; 
                                                           ; Thargoids have byte #32 set to 255, which explains
                                                           ; an awful lot

TA20:
                                                           ; If this is a missile we will have jumped straight
                                                           ; here, but we also get here if the ship is either far
                                                           ; away and aggressive, or not too close
       movb @XX15,ra                   ; LDA XX15          ; Reverse the signs of XX15 and the dot product in CNT,
       .eoi (>80*256)                  ; EOR #%10000000    ; starting with the x-coordinate
       movb ra,@XX15                   ; STA XX15          

       movb @XX15+1,ra                 ; LDA XX15+1        ; Then reverse the sign of the y-coordinate
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX15+2,ra                 ; LDA XX15+2        ; And then the z-coordinate, so now the XX15 vector goes
       .eoi (>80*256)                  ; EOR #%10000000    ; from the enemy ship to our ship (it was previously the
       movb ra,@XX15+2                 ; STA XX15+2        ; other way round)

       movb @CNT,ra                    ; LDA CNT           ; And finally change the sign of the dot product in CNT,
       .eoi (>80*256)                  ; EOR #%10000000    ; so now it's positive if the ships are facing each
       movb ra,@CNT                    ; STA CNT           ; other, and negative if they are facing the same way

TA15:
                                                           ; If we get here, then one of the following is true:
                                                           ; 
                                                           ; * This is an escape pod and XX15 is pointing towards
                                                           ; the planet
                                                           ; 
                                                           ; * The ship is pretty close to us, or it's just not
                                                           ; very aggressive (though there is a random factor
                                                           ; at play here too). XX15 is still pointing from our
                                                           ; ship towards the enemy ship
                                                           ; 
                                                           ; * The ship is aggressive (though again, there's an
                                                           ; element of randomness here). XX15 is pointing from
                                                           ; the enemy ship towards our ship
                                                           ; 
                                                           ; * This is a missile heading for a target. XX15 is
                                                           ; pointing from the missile towards the target
                                                           ; 
                                                           ; We now want to move the ship in the direction of XX15,
                                                           ; which will make aggressive ships head towards us, and
                                                           ; ships that are too close turn away. Escape pods,
                                                           ; meanwhile, head off towards the planet in search of a
                                                           ; space station, and missiles home in on their targets
       li   ry,>10*256                 ; LDY #16           ; Set (A X) = roofv . XX15
       .jsr @TAS3                      ; JSR TAS3          ; 
                                                           ; This will be positive if XX15 is pointing in the same
                                                           ; direction as an arrow out of the top of the ship, in
                                                           ; other words if the ship should pull up to head in the
                                                           ; direction of XX15

       .eoi (>80*256)                  ; EOR #%10000000    ; Set the ship's pitch counter to 3, with the opposite
       andi ra,>80*256                 ; AND #%10000000    ; sign to the dot product result, which gently pitches
       ori  ra,>03*256                 ; ORA #%00000011    ; the ship towards the direction of the XX15 vector
       movb ra,@INWK+30                ; STA INWK+30       

       movb @INWK+29,ra                ; LDA INWK+29       ; Fetch the roll counter from byte #29 into A and clear
       andi ra,>7f*256                 ; AND #%01111111    ; the sign bit (to give an endless clockwise roll)

       ci   ra,>10*256                 ; CMP #16           ; If A >= 16 then jump to TA6, as the ship is already
       joc  TA6                        ; BCS TA6           ; in the process of rolling

       li   ry,>16*256                 ; LDY #22           ; Set (A X) = sidev . XX15
       .jsr @TAS3                      ; JSR TAS3          ; 
                                                           ; This will be positive if XX15 is pointing in the same
                                                           ; direction as an arrow out of the right side of the
                                                           ; ship, in other words if the ship should roll right to
                                                           ; head in the direction of XX15

       .eor @INWK+30                   ; EOR INWK+30       ; Set the ship's roll counter to 5, with the sign set to
       andi ra,>80*256                 ; AND #%10000000    ; positive (clockwise roll) if the pitch counter and dot
       .eoi (>85*256)                  ; EOR #%10000101    ; product have different signs, negative (anti-clockwise
       movb ra,@INWK+29                ; STA INWK+29       ; roll) if they have the same sign

TA6:
       movb @CNT,ra                    ; LDA CNT           ; Fetch the dot product, and if it's negative jump to
       jlt  TA9                        ; BMI TA9           ; TA9, as the ships are facing away from each other and
                                                           ; the ship might want to slow down to take another shot

       ci   ra,>16*256                 ; CMP #22           ; The dot product is positive, so the ships are facing
       jnc  TA9                        ; BCC TA9           ; each other. If A < 22 then the ships are not heading
                                                           ; directly towards each other, so jump to TA9 to slow
                                                           ; down

       li   ra,>03*256                 ; LDA #3            ; Otherwise set the acceleration in byte #28 to 3
       movb ra,@INWK+28                ; STA INWK+28       

       .rts                            ; RTS               ; Return from the subroutine

TA9:
       andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit of the dot product in A

       ci   ra,>12*256                 ; CMP #18           ; If A < 18 then the ship is way off the XX15 vector, so
       jnc  TA10                       ; BCC TA10          ; return from the subroutine (TA10 contains an RTS)
                                                           ; without slowing down, as it still has quite a bit of
                                                           ; turning to do to get on course

       li   ra,>ff*256                 ; LDA #&FF          ; Otherwise set A = -1

       movb @TYPE,rx                   ; LDX TYPE          ; If this is not a missile then skip the ASL instruction
       ci   rx,(MSL)*256               ; CPX #MSL          
       jne  B36                        ; BNE B36           

       .asla                           ; ASL A             ; This is a missile, so set A = -2, as missiles are more
                                                           ; nimble and can brake more quickly

B36:
       movb ra,@INWK+28                ; STA INWK+28       ; Set the ship's acceleration to A

TA10:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TAS1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
* 
* ------------------------------------------------------------------------------
* 
* Calculate one of the following, depending on the value in Y:
* 
* K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
* 
* K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
* 
* K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
* 
* where the first coordinate is from the ship data block in INWK, and the second
* coordinate is from the ship data block pointed to by V(1 0).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* V(1 0)              The address of the ship data block to subtract
* 
* Y                   The coordinate in the V(1 0) block to subtract:
* 
* * If Y = 2, subtract the x-coordinate and store the
* result in K3(2 1 0)
* 
* * If Y = 5, subtract the y-coordinate and store the
* result in K3(5 4 3)
* 
* * If Y = 8, subtract the z-coordinate and store the
* result in K3(8 7 6)
* 
* ******************************************************************************

TAS1:
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Copy the sign byte of the V(1 0) coordinate into K+3,
       .eoi (>80*256)                  ; EOR #%10000000    ; flipping it in the process
       movb ra,@K+3                    ; STA K+3           

       sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+2
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         
       movb ra,@K+2                    ; STA K+2           

       sb   rone,ry                    ; DEY               ; Copy the high byte of the V(1 0) coordinate into K+1,
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; so now:
       movb ra,@K+1                    ; STA K+1           ; 
                                                           ; K(3 2 1) = - coordinate in V(1 0)

       movb ry,@U                      ; STY U             ; Copy the index (now 0, 3 or 6) into U and X
       movb @U,rx                      ; LDX U             

       .jsr @MVT3                      ; JSR MVT3          ; Call MVT3 to add the same coordinates, but this time
                                                           ; from INWK, so this would look like this for the
                                                           ; x-axis:
                                                           ; 
                                                           ; K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
                                                           ; = (x_sign x_hi x_lo) - coordinate in V(1 0)

       movb @U,ry                      ; LDY U             ; Restore the index into Y, though this instruction has
                                                           ; no effect, as Y is not used again, either here or
                                                           ; following calls to this routine

       movb ra,@K3+2(rx)               ; STA K3+2,X        ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
                                                           ; byte

       movb @K+2,ra                    ; LDA K+2           ; And then doing the high byte
       movb ra,@K3+1(rx)               ; STA K3+1,X        

       movb @K+1,ra                    ; LDA K+1           ; And finally the low byte
       movb ra,@K3(rx)                 ; STA K3,X          

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: HITCH
* Type: Subroutine
* Category: Tactics
* Summary: Work out if the ship in INWK is in our crosshairs
* Deep dive: In the crosshairs
* 
* ------------------------------------------------------------------------------
* 
* This is called by the main flight loop to see if we have laser or missile lock
* on an enemy ship.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the ship is in our crosshairs, clear if it isn't
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* HI1                 Contains an RTS
* 
* ******************************************************************************

HITCH:
       .clc                            ; CLC               ; Clear the C flag so we can return with it cleared if
                                                           ; our checks fail

       movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign

       jne  HI1                        ; BNE HI1           ; If A is non-zero then the ship is behind us and can't
                                                           ; be in our crosshairs, so return from the subroutine
                                                           ; with the C flag clear (as HI1 contains an RTS)

       movb @TYPE,ra                   ; LDA TYPE          ; If the ship type has bit 7 set then it is the planet
       jlt  HI1                        ; BMI HI1           ; or sun, which we can't target or hit with lasers, so
                                                           ; return from the subroutine with the C flag clear (as
                                                           ; HI1 contains an RTS)

       movb @INWK+31,ra                ; LDA INWK+31       ; Fetch bit 5 of byte #31 (the exploding flag) and OR
       andi ra,>20*256                 ; AND #%00100000    ; with x_hi and y_hi
       socb @INWK+1,ra                 ; ORA INWK+1        
       socb @INWK+4,ra                 ; ORA INWK+4        

       jne  HI1                        ; BNE HI1           ; If this value is non-zero then either the ship is
                                                           ; exploding (so we can't target it), or the ship is too
                                                           ; far away from our line of fire to be targeted, so
                                                           ; return from the subroutine with the C flag clear (as
                                                           ; HI1 contains an RTS)

       movb @INWK,ra                   ; LDA INWK          ; Set A = x_lo

       .jsr @SQUA2                     ; JSR SQUA2         ; Set (A P) = A * A = x_lo^2

       movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2
       movb @P,ra                      ; LDA P             
       movb ra,@R                      ; STA R             

       movb @INWK+3,ra                 ; LDA INWK+3        ; Set A = y_lo

       .jsr @SQUA2                     ; JSR SQUA2         ; Set (A P) = A * A = y_lo^2

       movb ra,rx                      ; TAX               ; Store the high byte in X

       movb @P,ra                      ; LDA P             ; Add the two low bytes, so:
       .adc @R,ra                      ; ADC R             ; 
       movb ra,@R                      ; STA R             ; R = P + R

       movb rx,ra                      ; TXA               ; Restore the high byte into A and add S to give the
       .adc @S,ra                      ; ADC S             ; following:
                                                           ; 
                                                           ; (A R) = (S R) + (A P) = x_lo^2 + y_lo^2

       joc  FR1-2                      ; BCS FR1-2         ; If the addition just overflowed then there is no way
                                                           ; our crosshairs are within the ship's targetable area,
                                                           ; so return from the subroutine with the C flag clear
                                                           ; (as FR1-2 contains a CLC then an RTS)

       movb ra,@S                      ; STA S             ; Set (S R) = (A P) = x_lo^2 + y_lo^2

       li   ry,>02*256                 ; LDY #2            ; Fetch the ship's blueprint and set A to the high byte
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; of the targetable area of the ship

       cb   @S,ra                      ; CMP S             ; We now compare the high bytes of the targetable area
                                                           ; and the calculation in (S R):
                                                           ; 
                                                           ; * If A >= S then then the C flag will be set
                                                           ; 
                                                           ; * If A < S then the C flag will be C clear

       jne  HI1                        ; BNE HI1           ; If A <> S we have just set the C flag correctly, so
                                                           ; return from the subroutine (as HI1 contains an RTS)

       sb   rone,ry                    ; DEY               ; The high bytes were identical, so now we fetch the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; low byte of the targetable area into A

       cb   @R,ra                      ; CMP R             ; We now compare the low bytes of the targetable area
                                                           ; and the calculation in (S R):
                                                           ; 
                                                           ; * If A >= R then the C flag will be set
                                                           ; 
                                                           ; * If A < R then the C flag will be C clear

HI1:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: FRS1
* Type: Subroutine
* Category: Tactics
* Summary: Launch a ship straight ahead of us, below the laser sights
* 
* ------------------------------------------------------------------------------
* 
* This is used in two places:
* 
* * When we launch a missile, in which case the missile is the ship that is
* launched ahead of us
* 
* * When we launch our escape pod, in which case it's our abandoned Cobra Mk
* III that is launched ahead of us
* 
* * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
* us as part of the death screen
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The type of ship to launch ahead of us
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the ship was successfully launched, clear if it
* wasn't (as there wasn't enough free memory)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* fq1                 Used to add a cargo canister to the universe
* 
* ******************************************************************************

FRS1:
       .jsr @ZINF                      ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace

       li   ra,>1c*256                 ; LDA #28           ; Set y_lo = 28
       movb ra,@INWK+3                 ; STA INWK+3        

       srl  ra,1                       ; LSR A             ; Set z_lo = 14, so the launched ship starts out
       movb ra,@INWK+6                 ; STA INWK+6        ; ahead of us

       li   ra,>80*256                 ; LDA #%10000000    ; Set y_sign to be negative, so the launched ship is
       movb ra,@INWK+5                 ; STA INWK+5        ; launched just below our line of sight

       movb @MSTG,ra                   ; LDA MSTG          ; Set A to the missile lock target, shifted left so the
       .asla                           ; ASL A             ; slot number is in bits 1-5

       ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 and store the result in byte #32, the AI
       movb ra,@INWK+32                ; STA INWK+32       ; flag launched ship for the launched ship. For missiles
                                                           ; this enables AI (bit 7), makes it friendly towards us
                                                           ; (bit 6), sets the target to the value of MSTG (bits
                                                           ; 1-5), and sets its lock status as launched (bit 0).
                                                           ; It doesn't matter what it does for our abandoned
                                                           ; Cobra, as the AI flag gets overwritten once we return
                                                           ; from the subroutine back to the ESCAPE routine that
                                                           ; called FRS1 in the first place

fq1_:
       li   ra,>60*256                 ; LDA #&60          ; Set byte #14 (nosev_z_hi) to 1 (&60), so the launched
       movb ra,@INWK+14                ; STA INWK+14       ; ship is pointing away from us

       ori  ra,>80*256                 ; ORA #128          ; Set byte #22 (sidev_x_hi) to -1 (&D0), so the launched
       movb ra,@INWK+22                ; STA INWK+22       ; ship has the same orientation as spawned ships, just
                                                           ; pointing away from us (if we set sidev to +1 instead,
                                                           ; this ship would be a mirror image of all the other
                                                           ; ships, which are spawned with -1 in nosev and +1 in
                                                           ; sidev)

       movb @DELTA,ra                  ; LDA DELTA         ; Set byte #27 (speed) to 2 * DELTA, so the launched
       .rola                           ; ROL A             ; ship flies off at twice our speed
       movb ra,@INWK+27                ; STA INWK+27       

       movb rx,ra                      ; TXA               ; Add a new ship of type X to our local bubble of
       b    @NWSHP                     ; JMP NWSHP         ; universe and return from the subroutine using a tail
                                                           ; call

* ******************************************************************************
* 
* Name: FRMIS
* Type: Subroutine
* Category: Tactics
* Summary: Fire a missile from our ship
* 
* ------------------------------------------------------------------------------
* 
* We fired a missile, so send it streaking away from us to unleash mayhem and
* destruction on our sworn enemies.
* 
* ******************************************************************************

FRMIS:
       li   rx,(MSL)*256               ; LDX #MSL          ; Call FRS1 to launch a missile straight ahead of us
       .jsr @FRS1                      ; JSR FRS1          

       jnc  FR1                        ; BCC FR1           ; If FRS1 returns with the C flag clear, then there
                                                           ; isn't room in the universe for our missile, so jump
                                                           ; down to FR1 to display a "missile jammed" message

       movb @MSTG,rx                   ; LDX MSTG          ; Fetch the slot number of the missile's target

       .jsr @GINF                      ; JSR GINF          ; Get the address of the data block for the target ship
                                                           ; and store it in INF

       movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type of the missile's target into A

       .jsr @ANGRY                     ; JSR ANGRY         ; Call ANGRY to make the target ship hostile

       li   ry,>00*256                 ; LDY #0            ; We have just launched a missile, so we need to remove
       .jsr @ABORT                     ; JSR ABORT         ; missile lock and hide the leftmost indicator on the
                                                           ; dashboard by setting it to black (Y = 0)

       sb   rone,ra                    ; DEC NOMSL         ; Reduce the number of missiles we have by 1

       li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
       b    @NOISE                     ; JMP NOISE         ; of a missile launch, returning from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: ANGRY
* Type: Subroutine
* Category: Tactics
* Summary: Make a ship hostile
* 
* ------------------------------------------------------------------------------
* 
* All this routine does is set the ship's hostile flag, start it turning and
* give it a kick of acceleration - later calls to TACTICS will make the ship
* start to attack us.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The type of ship we're going to irritate
* 
* INF                 The address of the data block for the ship we're going
* to infuriate
* 
* ******************************************************************************

ANGRY:
       ci   ra,(SST)*256               ; CMP #SST          ; If this is the space station, jump to AN2 to make the
       jeq  AN2                        ; BEQ AN2           ; space station hostile

       joc  HI1                        ; BCS HI1           ; If A >= #SST then this is a missile, asteroid, cargo
                                                           ; canister, Thargon or escape pod, and they can't get
                                                           ; hostile, so return from the subroutine (as HI1
                                                           ; contains an RTS)

       ci   ra,(CYL)*256               ; CMP #CYL          ; If this is not a Cobra Mk III trader, skip the
       jne  B37                        ; BNE B37           ; following instruction

       .jsr @AN2                       ; JSR AN2           ; Call AN2 to make the space station hostile

B37:
       li   ry,>20*256                 ; LDY #32           ; Fetch the ship's byte #32 (AI flag)
       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       

       jeq  HI1                        ; BEQ HI1           ; If the AI flag is zero then this ship has no AI and
                                                           ; it can't get hostile, so return from the subroutine
                                                           ; (as HI1 contains an RTS)

       ori  ra,>80*256                 ; ORA #%10000000    ; Otherwise set bit 7 (AI enabled) to ensure AI is
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; definitely enabled

       li   ry,>1c*256                 ; LDY #28           ; Set the ship's byte #28 (acceleration) to 2, so it
       li   ra,>02*256                 ; LDA #2            ; speeds up
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       

       .asla                           ; ASL A             ; Set the ship's byte #30 (pitch counter) to 4, so it
       li   ry,>1e*256                 ; LDY #30           ; starts diving
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       

       .rts                            ; RTS               ; Return from the subroutine

AN2:
       .asl @K.+NI.+32                 ; ASL K%+NI%+32     ; Fetch the AI counter (byte #32) of the second ship
       .sec                            ; SEC               ; in the ship data workspace at K%, which is reserved
       .ror @K.+NI.+32                 ; ROR K%+NI%+32     ; for the sun or the space station (in this case it's
                                                           ; the latter), and set bit 7 to make it hostile

       .clc                            ; CLC               ; Clear the C flag, which isn't used by calls to this
                                                           ; routine, but it does set up the entry point FR1-2
                                                           ; so that it clears the C flag and does an RTS

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: FR1
* Type: Subroutine
* Category: Tactics
* Summary: Display the "missile jammed" message
* 
* ------------------------------------------------------------------------------
* 
* This is shown if there isn't room in the local bubble of universe for a new
* missile.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* FR1-2               Clear the C flag and return from the subroutine
* 
* ******************************************************************************

FR1:
       li   ra,>c9*256                 ; LDA #201          ; Print recursive token 41 ("MISSILE JAMMED") as an
       b    @MESS                      ; JMP MESS          ; in-flight message and return from the subroutine using
                                                           ; a tail call

* ******************************************************************************
* 
* Name: SESCP
* Type: Subroutine
* Category: Flight
* Summary: Spawn an escape pod from the current (parent) ship
* 
* ------------------------------------------------------------------------------
* 
* This is called when an enemy ship has run out of both energy and luck, so it's
* time to bail.
* 
* ******************************************************************************

SESCP:
       li   rx,(ESC)*256               ; LDX #ESC          ; Set X to the ship type for an escape pod

       li   ra,>fe*256                 ; LDA #%11111110    ; Set A to an AI flag that has AI enabled, is hostile,
                                                           ; but has no E.C.M.

                                                           ; Fall through into SFS1 to spawn the escape pod

* ******************************************************************************
* 
* Name: SFS1
* Type: Subroutine
* Category: Universe
* Summary: Spawn a child ship from the current (parent) ship
* 
* ------------------------------------------------------------------------------
* 
* If the parent is a space station then the child ship is spawned coming out of
* the slot, and if the child is a cargo canister, it is sent tumbling through
* space. Otherwise the child ship is spawned with the same ship data as the
* parent, just with damping disabled and the ship type and AI flag that are
* passed in A and X.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   AI flag for the new ship (see the documentation on ship
* data byte #32 for details)
* 
* X                   The ship type of the child to spawn
* 
* INF                 Address of the parent's ship data block
* 
* TYPE                The type of the parent ship
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if ship successfully added, clear if it failed
* 
* INF                 INF is preserved
* 
* XX0                 XX0 is preserved
* 
* INWK                The whole INWK workspace is preserved
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* SFS1-2              Add a missile to the local bubble that has AI enabled,
* is hostile, but has no E.C.M.
* 
* ******************************************************************************

SFS1:
       movb ra,@T1                     ; STA T1            ; Store the child ship's AI flag in T1

                                                           ; Before spawning our child ship, we need to save the
                                                           ; INF and XX00 variables and the whole INWK workspace,
                                                           ; so we can restore them later when returning from the
                                                           ; subroutine

       movb @XX0,ra                    ; LDA XX0           ; Store XX0(1 0) on the stack, so we can restore it
       .pha                            ; PHA               ; later when returning from the subroutine
       movb @XX0+1,ra                  ; LDA XX0+1         
       .pha                            ; PHA               

       movb @INF,ra                    ; LDA INF           ; Store INF(1 0) on the stack, so we can restore it
       .pha                            ; PHA               ; later when returning from the subroutine
       movb @INF+1,ra                  ; LDA INF+1         
       .pha                            ; PHA               

       li   ry,(NI.-1)*256             ; LDY #NI%-1        ; Now we want to store the current INWK data block in
                                                           ; temporary memory so we can restore it when we are
                                                           ; done, and we also want to copy the parent's ship data
                                                           ; into INWK, which we can do at the same time, so set up
                                                           ; a counter in Y for NI% bytes

FRL2:
       movb @INWK(ry),ra               ; LDA INWK,Y        ; Copy the Y-th byte of INWK to the Y-th byte of
       movb ra,@XX3(ry)                ; STA XX3,Y         ; temporary memory in XX3, so we can restore it later
                                                           ; when returning from the subroutine

       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte of the parent ship's data block to
       movb ra,@INWK(ry)               ; STA INWK,Y        ; the Y-th byte of INWK

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jgt  FRL2                       ; BPL FRL2          ; Loop back to copy the next byte until we have done
                                                           ; them all

                                                           ; INWK now contains the ship data for the parent ship,
                                                           ; so now we need to tweak the data before creating the
                                                           ; new child ship (in this way, the child inherits things
                                                           ; like location from the parent)

       movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship type of the parent into A

       ci   ra,(SST)*256               ; CMP #SST          ; If the parent is not a space station, jump to rx to
       jne  rx_                        ; BNE rx            ; skip the following

                                                           ; The parent is a space station, so the child needs to
                                                           ; launch out of the space station's slot. The space
                                                           ; station's nosev vector points out of the station's
                                                           ; slot, so we want to move the ship along this vector.
                                                           ; We do this by taking the unit vector in nosev and
                                                           ; doubling it, so we spawn our ship 2 units along the
                                                           ; vector from the space station's centre

       movb rx,ra                      ; TXA               ; Store the child's ship type in X on the stack
       .pha                            ; PHA               

       li   ra,>20*256                 ; LDA #32           ; Set the child's byte #27 (speed) to 32
       movb ra,@INWK+27                ; STA INWK+27       

       li   rx,>00*256                 ; LDX #0            ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
       movb @INWK+10,ra                ; LDA INWK+10       ; child's x-coordinate
       .jsr @SFS2                      ; JSR SFS2          

       li   rx,>03*256                 ; LDX #3            ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
       movb @INWK+12,ra                ; LDA INWK+12       ; child's y-coordinate
       .jsr @SFS2                      ; JSR SFS2          

       li   rx,>06*256                 ; LDX #6            ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
       movb @INWK+14,ra                ; LDA INWK+14       ; child's z-coordinate
       .jsr @SFS2                      ; JSR SFS2          

       .pla                            ; PLA               ; Restore the child's ship type from the stack into X
       movb ra,rx                      ; TAX               

rx_:
       movb @T1,ra                     ; LDA T1            ; Restore the child ship's AI flag from T1 and store it
       movb ra,@INWK+32                ; STA INWK+32       ; in the child's byte #32 (AI)

       .lsr @INWK+29                   ; LSR INWK+29       ; Clear bit 0 of the child's byte #29 (roll counter) so
       .asl @INWK+29                   ; ASL INWK+29       ; that its roll dampens (so if we are spawning from a
                                                           ; space station, for example, the spawned ship won't
                                                           ; keep rolling forever)

       movb rx,ra                      ; TXA               ; Copy the child's ship type from X into A

       ci   ra,(OIL)*256               ; CMP #OIL          ; If the child we are spawning is not a cargo canister,
       jne  NOIL                       ; BNE NOIL          ; jump to NOIL to skip us setting up the pitch and roll
                                                           ; for the canister

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       .asla                           ; ASL A             ; Set the child's byte #30 (pitch counter) to a random
       movb ra,@INWK+30                ; STA INWK+30       ; value, and at the same time set the C flag randomly

       movb rx,ra                      ; TXA               ; Set the child's byte #27 (speed) to a random value
       andi ra,>0f*256                 ; AND #%00001111    ; between 0 and 15
       movb ra,@INWK+27                ; STA INWK+27       

       li   ra,>ff*256                 ; LDA #&FF          ; Set the child's byte #29 (roll counter) to a full
       .rora                           ; ROR A             ; roll with no damping (as bits 0 to 6 are set), so the
       movb ra,@INWK+29                ; STA INWK+29       ; canister tumbles through space, with the direction in
                                                           ; bit 7 set randomly, depending on the C flag from above

       li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship type of a cargo canister

NOIL:
       .jsr @NWSHP                     ; JSR NWSHP         ; Add a new ship of type A to the local bubble

                                                           ; We have now created our child ship, so we need to
                                                           ; restore all the variables we saved at the start of
                                                           ; the routine, so they are preserved when we return
                                                           ; from the subroutine

       .pla                            ; PLA               ; Restore INF(1 0) from the stack
       movb ra,@INF+1                  ; STA INF+1         
       .pla                            ; PLA               
       movb ra,@INF                    ; STA INF           

       li   rx,(NI.-1)*256             ; LDX #NI%-1        ; Now to restore the INWK workspace that we saved into
                                                           ; XX3 above, so set a counter in X for NI% bytes

FRL3:
       movb @XX3(rx),ra                ; LDA XX3,X         ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
       movb ra,@INWK(rx)               ; STA INWK,X        

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  FRL3                       ; BPL FRL3          ; Loop back to copy the next byte until we have done
                                                           ; them all

       .pla                            ; PLA               ; Restore XX0(1 0) from the stack
       movb ra,@XX0+1                  ; STA XX0+1         
       .pla                            ; PLA               
       movb ra,@XX0                    ; STA XX0           

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SFS2
* Type: Subroutine
* Category: Moving
* Summary: Move a ship in space along one of the coordinate axes
* 
* ------------------------------------------------------------------------------
* 
* Move a ship's coordinates by a certain amount in the direction of one of the
* axes, where X determines the axis. Mathematically speaking, this routine
* translates the ship along a single axis by a signed delta.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The amount of movement, i.e. the signed delta
* 
* X                   Determines which coordinate axis of INWK to move:
* 
* * X = 0 moves the ship along the x-axis
* 
* * X = 3 moves the ship along the y-axis
* 
* * X = 6 moves the ship along the z-axis
* 
* ******************************************************************************

SFS2:
       .asla                           ; ASL A             ; Set R = |A * 2|, with the C flag set to bit 7 of A
       movb ra,@R                      ; STA R             

       li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to the C flag, i.e. the sign bit from
       .rora                           ; ROR A             ; the original argument in A

       b    @MVT1                      ; JMP MVT1          ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
                                                           ; (or y or z, depending on the value in X) and return
                                                           ; from the subroutine using a tail call

* ******************************************************************************
* 
* Name: LL164
* Type: Subroutine
* Category: Drawing circles
* Summary: Make the hyperspace sound and draw the hyperspace tunnel
* 
* ------------------------------------------------------------------------------
* 
* See the IRQ1 routine for details on the multi-coloured effect that's used.
* 
* ******************************************************************************

LL164:
       li   ra,>38*256                 ; LDA #56           ; Call the NOISE routine with A = 56 to make the sound
       .jsr @NOISE                     ; JSR NOISE         ; of the hyperspace drive being engaged

       li   ra,>01*256                 ; LDA #1            ; Set HFX to 1, which switches the screen mode to a full
       movb ra,@HFX                    ; STA HFX           ; mode 5 screen, therefore making the hyperspace rings
                                                           ; multi-coloured and all zig-zaggy (see the IRQ1 routine
                                                           ; for details)

       li   ra,>04*256                 ; LDA #4            ; Set the step size for the hyperspace rings to 4, so
                                                           ; there are more sections in the rings and they are
                                                           ; quite round (compared to the step size of 8 used in
                                                           ; the much more polygonal launch rings)

       .jsr @HFS2                      ; JSR HFS2          ; Call HFS2 to draw the hyperspace tunnel rings

       sb   rone,ra                    ; DEC HFX           ; Set HFX back to 0, so we switch back to the normal
                                                           ; split-screen mode

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LAUN
* Type: Subroutine
* Category: Drawing circles
* Summary: Make the launch sound and draw the launch tunnel
* 
* ------------------------------------------------------------------------------
* 
* This is shown when launching from or docking with the space station.
* 
* ******************************************************************************

LAUN:
       li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
       .jsr @NOISE                     ; JSR NOISE         ; of the ship launching from the station

       li   ra,>08*256                 ; LDA #8            ; Set the step size for the launch tunnel rings to 8, so
                                                           ; there are fewer sections in the rings and they are
                                                           ; quite polygonal (compared to the step size of 4 used
                                                           ; in the much rounder hyperspace rings)

                                                           ; Fall through into HFS2 to draw the launch tunnel rings

* ******************************************************************************
* 
* Name: HFS2
* Type: Subroutine
* Category: Drawing circles
* Summary: Draw the launch or hyperspace tunnel
* 
* ------------------------------------------------------------------------------
* 
* The animation gets drawn like this. First, we draw a circle of radius 8 at the
* centre, and then double the radius, draw another circle, double the radius
* again and draw a circle, and we keep doing this until the radius is bigger
* than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
* equivalent to a radius of 128). We then repeat this whole process for an
* initial circle of radius 9, then radius 10, all the way up to radius 15.
* 
* This has the effect of making the tunnel appear to be racing towards us as we
* hurtle out into hyperspace or through the space station's docking tunnel.
* 
* The hyperspace effect is done in a full mode 5 screen, which makes the rings
* all coloured and zig-zaggy, while the launch screen is in the normal
* monochrome mode 4 screen.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The step size of the straight lines making up the rings
* (4 for launch, 8 for hyperspace)
* 
* ******************************************************************************

HFS2:
       movb ra,@STP                    ; STA STP           ; Store the step size in A

       .jsr @TTX66                     ; JSR TTX66         ; Clear the screen and draw a white border

       .jsr @HFS1                      ; JSR HFS1          ; Call HFS1 below and then fall through into the same
                                                           ; routine, so this effectively runs HFS1 twice, and as
                                                           ; HFS1 draws 8 concentric rings, this means we draw 16
                                                           ; of them in all

HFS1:
       li   ra,>80*256                 ; LDA #128          ; Set K3 = 128 (the x-coordinate of the centre of the
       movb ra,@K3                     ; STA K3            ; screen)

       li   rx,(Y)*256                 ; LDX #Y            ; Set K4 = #Y (the y-coordinate of the centre of the
       movb rx,@K4                     ; STX K4            ; screen)

       .asla                           ; ASL A             ; Set A = 0

       movb ra,@XX4                    ; STA XX4           ; Set XX4 = 0, which we will use as a counter for
                                                           ; drawing eight concentric rings

       movb ra,@K3+1                   ; STA K3+1          ; Set the high bytes of K3(1 0) and K4(1 0) to 0
       movb ra,@K4+1                   ; STA K4+1          

HFL5:
       .jsr @HFL1                      ; JSR HFL1          ; Call HFL1 below to draw a set of rings, with each one
                                                           ; twice the radius of the previous one, until they won't
                                                           ; fit on-screen

       ab   rone,ra                    ; INC XX4           ; Increment the counter and fetch it into X
       movb @XX4,rx                    ; LDX XX4           

       ci   rx,>08*256                 ; CPX #8            ; If we haven't drawn 8 sets of rings yet, loop back to
       jne  HFL5                       ; BNE HFL5          ; HFL5 to draw the next ring

       .rts                            ; RTS               ; Return from the subroutine

HFL1:
       movb @XX4,ra                    ; LDA XX4           ; Set K to the ring number in XX4 (0-7) + 8, so K has
       andi ra,>07*256                 ; AND #7            ; a value of 8 to 15, which we will use as the starting
       .clc                            ; CLC               ; radius for our next set of rings
       .adi (>08*256)                  ; ADC #8            
       movb ra,@K                      ; STA K             

HFL2:
       li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap
       movb ra,@LSP                    ; STA LSP           

       .jsr @CIRCLE2                   ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
                                                           ; (K3(1 0), K4(1 0)) and radius K

       .asl @K                         ; ASL K             ; Double the radius in K

       joc  HF8                        ; BCS HF8           ; If the radius had a 1 in bit 7 before the above shift,
                                                           ; then doubling K will means the circle will no longer
                                                           ; fit on the screen (which is width 256), so jump to
                                                           ; HF8 to stop drawing circles

       movb @K,ra                      ; LDA K             ; If the radius in K <= 160, loop back to HFL2 to draw
       ci   ra,>a0*256                 ; CMP #160          ; another one
       jnc  HFL2                       ; BCC HFL2          

HF8:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: STARS2
* Type: Subroutine
* Category: Stardust
* Summary: Process the stardust for the left or right view
* Deep dive: Stardust in the side views
* 
* ------------------------------------------------------------------------------
* 
* This moves the stardust sideways according to our speed and which side we are
* looking out of, and applies our current pitch and roll to each particle of
* dust, so the stardust moves correctly when we steer our ship.
* 
* These are the calculations referred to in the commentary:
* 
* 1. delta_x = 8 * 256 * speed / z_hi
* 2. x = x + delta_x
* 
* 3. x = x + beta * y
* 4. y = y - beta * x
* 
* 5. x = x - alpha * x * y
* 6. y = y + alpha * y * y + alpha
* 
* For more information see the deep dive on "Stardust in the side views".
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The view to process:
* 
* * X = 1 for left view
* 
* * X = 2 for right view
* 
* ******************************************************************************

STARS2:
       li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can use it to capture a sign bit

       ci   rx,>02*256                 ; CPX #2            ; If X >= 2 then the C flag is set

       .rora                           ; ROR A             ; Roll the C flag into the sign bit of A and store in
       movb ra,@RAT                    ; STA RAT           ; RAT, so:
                                                           ; 
                                                           ; * Left view, C is clear so RAT = 0 (positive)
                                                           ; 
                                                           ; * Right view, C is set so RAT = 128 (negative)
                                                           ; 
                                                           ; RAT represents the end of the x-axis where we want new
                                                           ; stardust particles to come from: positive for the left
                                                           ; view where new particles come in from the right,
                                                           ; negative for the right view where new particles come
                                                           ; in from the left

       .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT2 to the opposite sign, so:
       movb ra,@RAT2                   ; STA RAT2          ; 
                                                           ; * Left view, RAT2 = 128 (negative)
                                                           ; 
                                                           ; * Right view, RAT2 = 0 (positive)
                                                           ; 
                                                           ; RAT2 represents the direction in which stardust
                                                           ; particles should move along the x-axis: negative for
                                                           ; the left view where particles go from right to left,
                                                           ; positive for the right view where particles go from
                                                           ; left to right

       .jsr @ST2                       ; JSR ST2           ; Call ST2 to flip the signs of the following if this is
                                                           ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1

       movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
                                                           ; we can use it as a counter through all the stardust

STL2:
       movb @SZ(ry),ra                 ; LDA SZ,Y          ; Set A = ZZ = z_hi

       movb ra,@ZZ                     ; STA ZZ            ; We also set ZZ to the original value of z_hi, which we
                                                           ; use below to remove the existing particle

       srl  ra,1                       ; LSR A             ; Set A = z_hi / 8
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             

       .jsr @DV41                      ; JSR DV41          ; Call DV41 to set the following:
                                                           ; 
                                                           ; (P R) = 256 * DELTA / A
                                                           ; = 256 * speed / (z_hi / 8)
                                                           ; = 8 * 256 * speed / z_hi
                                                           ; 
                                                           ; This represents the distance we should move this
                                                           ; particle along the x-axis, let's call it delta_x

       movb @P,ra                      ; LDA P             ; Set S = P but with the sign from RAT2, so we now have
       .eor @RAT2                      ; EOR RAT2          ; the distance delta_x with the correct sign in (S R):
       movb ra,@S                      ; STA S             ; 
                                                           ; (S R) = delta_x
                                                           ; = 8 * 256 * speed / z_hi
                                                           ; 
                                                           ; So (S R) is the delta, signed to match the direction
                                                           ; the stardust should move in, which is result 1 above

       movb @SXL(ry),ra                ; LDA SXL,Y         ; Set (A P) = (x_hi x_lo)
       movb ra,@P                      ; STA P             ; = x
       movb @SX(ry),ra                 ; LDA SX,Y          

       movb ra,@X1                     ; STA X1            ; Set X1 = A, so X1 contains the original value of x_hi,
                                                           ; which we use below to remove the existing particle

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = x + delta_x

       movb ra,@S                      ; STA S             ; Set (S R) = (A X)
       movb rx,@R                      ; STX R             ; = x + delta_x

       movb @SY(ry),ra                 ; LDA SY,Y          ; Set A = y_hi

       movb ra,@Y1                     ; STA Y1            ; Set Y1 = A, so Y1 contains the original value of y_hi,
                                                           ; which we use below to remove the existing particle

       .eor @BET2                      ; EOR BET2          ; Give A the correct sign of A * beta, i.e. y_hi * beta

       movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle

       .jsr @MULTS-2                   ; JSR MULTS-2       ; Call MULTS-2 to calculate:
                                                           ; 
                                                           ; (A P) = X * A
                                                           ; = beta * y_hi

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = beta * y + x + delta_x

       movb rx,@XX                     ; STX XX            ; Set XX(1 0) = (A X), which gives us results 2 and 3
       movb ra,@XX+1                   ; STA XX+1          ; above, done at the same time:
                                                           ; 
                                                           ; x = x + delta_x + beta * y

       movb @SYL(ry),rx                ; LDX SYL,Y         ; Set (S R) = (y_hi y_lo)
       movb rx,@R                      ; STX R             ; = y
       movb @Y1,rx                     ; LDX Y1            
       movb rx,@S                      ; STX S             

       movb @BET1,rx                   ; LDX BET1          ; Fetch |beta| from BET1, the pitch angle

       .eor @BET2+1                    ; EOR BET2+1        ; Give A the opposite sign to x * beta

       .jsr @MULTS-2                   ; JSR MULTS-2       ; Call MULTS-2 to calculate:
                                                           ; 
                                                           ; (A P) = X * A
                                                           ; = -beta * x

       .jsr @ADD                       ; JSR ADD           ; Call ADD to calculate:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = -beta * x + y

       movb rx,@YY                     ; STX YY            ; Set YY(1 0) = (A X), which gives us result 4 above:
       movb ra,@YY+1                   ; STA YY+1          ; 
                                                           ; y = y - beta * x

       movb @ALP1,rx                   ; LDX ALP1          ; Set X = |alpha| from ALP2, the roll angle

       .eor @ALP2                      ; EOR ALP2          ; Give A the correct sign of A * alpha, i.e. y_hi *
                                                           ; alpha

       .jsr @MULTS-2                   ; JSR MULTS-2       ; Call MULTS-2 to calculate:
                                                           ; 
                                                           ; (A P) = X * A
                                                           ; = alpha * y

       movb ra,@Q                      ; STA Q             ; Set Q = high byte of alpha * y

       movb @XX,ra                     ; LDA XX            ; Set (S R) = XX(1 0)
       movb ra,@R                      ; STA R             ; = x
       movb @XX+1,ra                   ; LDA XX+1          ; 
       movb ra,@S                      ; STA S             ; and set A = y_hi at the same time

       .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A = -x_hi

       .jsr @MAD                       ; JSR MAD           ; Call MAD to calculate:
                                                           ; 
                                                           ; (A X) = Q * A + (S R)
                                                           ; = alpha * y * -x + x

       movb ra,@XX+1                   ; STA XX+1          ; Store the high byte A in XX+1

       movb rx,ra                      ; TXA               ; Store the low byte X in x_lo
       movb ra,@SXL(ry)                ; STA SXL,Y         

                                                           ; So (XX+1 x_lo) now contains result 5 above:
                                                           ; 
                                                           ; x = x - alpha * x * y

       movb @YY,ra                     ; LDA YY            ; Set (S R) = YY(1 0)
       movb ra,@R                      ; STA R             ; = y
       movb @YY+1,ra                   ; LDA YY+1          ; 
       movb ra,@S                      ; STA S             ; and set A = y_hi at the same time

       .jsr @MAD                       ; JSR MAD           ; Call MAD to calculate:
                                                           ; 
                                                           ; (A X) = Q * A + (S R)
                                                           ; = alpha * y * y_hi + y

       movb ra,@S                      ; STA S             ; Set (S R) = (A X)
       movb rx,@R                      ; STX R             ; = y + alpha * y * y

       li   ra,>00*256                 ; LDA #0            ; Set P = 0
       movb ra,@P                      ; STA P             

       movb @ALPHA,ra                  ; LDA ALPHA         ; Set A = alpha, so:
                                                           ; 
                                                           ; (A P) = (alpha 0)
                                                           ; = alpha / 256

       .jsr @PIX1                      ; JSR PIX1          ; Call PIX1 to calculate the following:
                                                           ; 
                                                           ; (YY+1 y_lo) = (A P) + (S R)
                                                           ; = alpha * 256 + y + alpha * y * y
                                                           ; 
                                                           ; i.e. y = y + alpha / 256 + alpha * y^2, which is
                                                           ; result 6 above
                                                           ; 
                                                           ; PIX1 also draws a particle at (X1, Y1) with distance
                                                           ; ZZ, which will remove the old stardust particle, as we
                                                           ; set X1, Y1 and ZZ to the original values for this
                                                           ; particle during the calculations above

                                                           ; We now have our newly moved stardust particle at
                                                           ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                                                           ; and distance z_hi, so we draw it if it's still on
                                                           ; screen, otherwise we recycle it as a new bit of
                                                           ; stardust and draw that

       movb @XX+1,ra                   ; LDA XX+1          ; Set X1 and x_hi to the high byte of XX in XX+1, so
       movb ra,@SX(ry)                 ; STA SX,Y          ; the new x-coordinate is in (x_hi x_lo) and the high
       movb ra,@X1                     ; STA X1            ; byte is in X1

       andi ra,>7f*256                 ; AND #%01111111    ; If |x_hi| >= 116 then jump to KILL2 to recycle this
       ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the side of the screen,
       joc  KILL2                      ; BCS KILL2         ; and rejoin at STC2 with the new particle

       movb @YY+1,ra                   ; LDA YY+1          ; Set Y1 and y_hi to the high byte of YY in YY+1, so
       movb ra,@SY(ry)                 ; STA SY,Y          ; the new x-coordinate is in (y_hi y_lo) and the high
       movb ra,@Y1                     ; STA Y1            ; byte is in Y1

       andi ra,>7f*256                 ; AND #%01111111    ; If |y_hi| >= 116 then jump to ST5 to recycle this
       ci   ra,>74*256                 ; CMP #116          ; particle, as it's gone off the top or bottom of the
       joc  ST5                        ; BCS ST5           ; screen, and rejoin at STC2 with the new particle

STC2:
       .jsr @PIXEL2                    ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ,
                                                           ; i.e. draw the newly moved particle at (x_hi, y_hi)
                                                           ; with distance z_hi

       sb   rone,ry                    ; DEY               ; Decrement the loop counter to point to the next
                                                           ; stardust particle

       jeq  ST2                        ; BEQ ST2           ; If we have just done the last particle, skip the next
                                                           ; instruction to return from the subroutine

       b    @STL2                      ; JMP STL2          ; We have more stardust to process, so jump back up to
                                                           ; STL2 for the next particle

                                                           ; Fall through into ST2 to restore the signs of the
                                                           ; following if this is the right view: ALPHA, ALP2,
                                                           ; ALP2+1, BET2 and BET2+1

ST2:
       movb @ALPHA,ra                  ; LDA ALPHA         ; If this is the right view, flip the sign of ALPHA
       .eor @RAT                       ; EOR RAT           
       movb ra,@ALPHA                  ; STA ALPHA         

       movb @ALP2,ra                   ; LDA ALP2          ; If this is the right view, flip the sign of ALP2
       .eor @RAT                       ; EOR RAT           
       movb ra,@ALP2                   ; STA ALP2          

       .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of ALP2+1
       movb ra,@ALP2+1                 ; STA ALP2+1        

       movb @BET2,ra                   ; LDA BET2          ; If this is the right view, flip the sign of BET2
       .eor @RAT                       ; EOR RAT           
       movb ra,@BET2                   ; STA BET2          

       .eoi (>80*256)                  ; EOR #%10000000    ; If this is the right view, flip the sign of BET2+1
       movb ra,@BET2+1                 ; STA BET2+1        

       .rts                            ; RTS               ; Return from the subroutine

KILL2:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to random numbers, so the particle
       movb ra,@SY(ry)                 ; STA SY,Y          ; starts anywhere along the y-axis

       li   ra,>73*256                 ; LDA #115          ; Make sure A is at least 115 and has the sign in RAT
       socb @RAT,ra                    ; ORA RAT           

       movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to A, so this particle starts on the
       movb ra,@SX(ry)                 ; STA SX,Y          ; correct edge of the screen for new particles

       jne  STF1                       ; BNE STF1          ; Jump down to STF1 to set the z-coordinate (this BNE is
                                                           ; effectively a JMP as A will never be zero)

ST5:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@X1                     ; STA X1            ; Set x_hi and X1 to random numbers, so the particle
       movb ra,@SX(ry)                 ; STA SX,Y          ; starts anywhere along the x-axis

       li   ra,>6e*256                 ; LDA #110          ; Make sure A is at least 110 and has the sign in AL2+1,
       socb @ALP2+1,ra                 ; ORA ALP2+1        ; the flipped sign of the roll angle alpha

       movb ra,@Y1                     ; STA Y1            ; Set y_hi and Y1 to A, so the particle starts at the
       movb ra,@SY(ry)                 ; STA SY,Y          ; top or bottom edge, depending on the current roll
                                                           ; angle alpha

STF1:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>08*256                 ; ORA #8            ; Make sure A is at least 8 and store it in z_hi and
       movb ra,@ZZ                     ; STA ZZ            ; ZZ, so the new particle starts at any distance from
       movb ra,@SZ(ry)                 ; STA SZ,Y          ; us, but not too close

       jne  STC2                       ; BNE STC2          ; Jump up to STC2 to draw this new particle (this BNE is
                                                           ; effectively a JMP as A will never be zero)

* ******************************************************************************
* 
* Name: SNE
* Type: Variable
* Category: Maths (Geometry)
* Summary: Sine/cosine table
* Deep dive: The sine, cosine and arctan tables
* Drawing circles
* Drawing ellipses
* 
* ------------------------------------------------------------------------------
* 
* This lookup table contains sine values for the first half of a circle, from 0
* to 180 degrees (0 to PI radians). In terms of circle or ellipse line segments,
* there are 64 segments in a circle, so this contains sine values for segments
* 0 to 31.
* 
* In terms of segments, to calculate the sine of the angle at segment x, we look
* up the value in SNE + x, and to calculate the cosine of the angle we look up
* the value in SNE + ((x + 16) mod 32).
* 
* In terms of radians, to calculate the following:
* 
* sin(theta) * 256
* 
* where theta is in radians, we look up the value in:
* 
* SNE + (theta * 10)
* 
* To calculate the following:
* 
* cos(theta) * 256
* 
* where theta is in radians, look up the value in:
* 
* SNE + ((theta * 10) + 16) mod 32
* 
* Theta must be between 0 and 3.1 radians, so theta * 10 is between 0 and 31.
* 
* ******************************************************************************

SNE:
       ;  FOR I%, 0, 31

       ; N = ABS(SIN((I% / 64) * 2 * PI)) ;                   

       ; IF N >= 1                     ;                   
       ; B% = 255                      ;                   
       ; ELSE                          ;                   
       ; B% = INT(256 * N + 0.5)       ;                   
       ; ENDIF                         ;                   

       ; EQUB B%                       ;                   

       ;  NEXT

* ******************************************************************************
* 
* Name: MU5
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
* 
* ------------------------------------------------------------------------------
* 
* In practice this is only called via a BEQ following an AND instruction, in
* which case A = 0, so this routine effectively does this:
* 
* K(3 2 1 0) = 0
* 
* ******************************************************************************

MU5:
       movb ra,@K                      ; STA K             ; Set K(3 2 1 0) to (A A A A)
       movb ra,@K+1                    ; STA K+1           
       movb ra,@K+2                    ; STA K+2           
       movb ra,@K+3                    ; STA K+3           

       .clc                            ; CLC               ; Clear the C flag

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MULT3
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
* Deep dive: Shift-and-add multiplication
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following multiplication between a signed 24-bit number and a
* signed 8-bit number, returning the result as a signed 32-bit number:
* 
* K(3 2 1 0) = (A P+1 P) * Q
* 
* The algorithm is the same shift-and-add algorithm as in routine MULT1, but
* extended to cope with more bits.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is cleared
* 
* ******************************************************************************

MULT3:
       movb ra,@R                      ; STA R             ; Store the high byte of (A P+1 P) in R

       andi ra,>7f*256                 ; AND #%01111111    ; Set K+2 to |A|, the high byte of K(2 1 0)
       movb ra,@K+2                    ; STA K+2           

       movb @Q,ra                      ; LDA Q             ; Set A to bits 0-6 of Q, so A = |Q|
       andi ra,>7f*256                 ; AND #%01111111    

       jeq  MU5                        ; BEQ MU5           ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
                                                           ; returning from the subroutine using a tail call

       .sec                            ; SEC               ; Set T = |Q| - 1
       .sbi (>01*256)                  ; SBC #1            
       movb ra,@T                      ; STA T             

                                                           ; We now use the same shift-and-add algorithm as MULT1
                                                           ; to calculate the following:
                                                           ; 
                                                           ; K(2 1 0) = K(2 1 0) * |Q|
                                                           ; 
                                                           ; so we start with the first shift right, in which we
                                                           ; take (K+2 P+1 P) and shift it right, storing the
                                                           ; result in K(2 1 0), ready for the multiplication loop
                                                           ; (so the multiplication loop actually calculates
                                                           ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
                                                           ; (|A| P+1 P) shifted right)

       movb @P+1,ra                    ; LDA P+1           ; Set A = P+1

       .lsr @K+2                       ; LSR K+2           ; Shift the high byte in K+2 to the right

       .rora                           ; ROR A             ; Shift the middle byte in A to the right and store in
       movb ra,@K+1                    ; STA K+1           ; K+1 (so K+1 contains P+1 shifted right)

       movb @P,ra                      ; LDA P             ; Shift the middle byte in P to the right and store in
       .rora                           ; ROR A             ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
       movb ra,@K                      ; STA K             

                                                           ; We now use the same shift-and-add algorithm as MULT1
                                                           ; to calculate the following:
                                                           ; 
                                                           ; K(2 1 0) = K(2 1 0) * |Q|

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A

       li   rx,>18*256                 ; LDX #24           ; Set up a counter in X to count the 24 bits in K(2 1 0)

MUL2:
       jnc  B38                        ; BCC B38           ; If C (i.e. the next bit from K) is set, do the
       .adc @T,ra                      ; ADC T             ; addition for this bit of K:
                                                           ; 
                                                           ; A = A + T + C
                                                           ; = A + |Q| - 1 + 1
                                                           ; = A + |Q|

B38:
       .rora                           ; ROR A             ; Shift A right by one place to catch the next digit
       .ror @K+2                       ; ROR K+2           ; next digit of our result in the left end of K(2 1 0),
       .ror @K+1                       ; ROR K+1           ; while also shifting K(2 1 0) right to fetch the next
       .ror @K                         ; ROR K             ; bit for the calculation into the C flag
                                                           ; 
                                                           ; On the last iteration of this loop, the bit falling
                                                           ; off the end of K will be bit 0 of the original A, as
                                                           ; we did one shift before the loop and we are doing 24
                                                           ; iterations. We set A to 0 before looping, so this
                                                           ; means the loop exits with the C flag clear

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  MUL2                       ; BNE MUL2          ; Loop back for the next bit until K(2 1 0) has been
                                                           ; rotated all the way

                                                           ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
                                                           ; but it is positive and doesn't have the correct sign
                                                           ; of the final result yet

       movb ra,@T                      ; STA T             ; Save the high byte of the result into T

       movb @R,ra                      ; LDA R             ; Fetch the sign byte from the original (A P+1 P)
                                                           ; argument that we stored in R

       .eor @Q                         ; EOR Q             ; EOR with Q so the sign bit is the same as that of
                                                           ; (A P+1 P) * Q

       andi ra,>80*256                 ; AND #%10000000    ; Extract the sign bit

       socb @T,ra                      ; ORA T             ; Apply this to the high byte of the result in T, so
                                                           ; that A now has the correct sign for the result, and
                                                           ; (A K+2 K+1 K) therefore contains the correctly signed
                                                           ; result

       movb ra,@K+3                    ; STA K+3           ; Store A in K+3, so K(3 2 1 0) now contains the result

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MLS2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* (S R) = XX(1 0)
* 
* (A P) = A * ALP1
* 
* where ALP1 is the magnitude of the current roll angle alpha, in the range
* 0-31.
* 
* ******************************************************************************

MLS2:
       movb @XX,rx                     ; LDX XX            ; Set (S R) = XX(1 0), starting with the low bytes
       movb rx,@R                      ; STX R             

       movb @XX+1,rx                   ; LDX XX+1          ; And then doing the high bytes
       movb rx,@S                      ; STX S             

                                                           ; Fall through into MLS1 to calculate (A P) = A * ALP1

* ******************************************************************************
* 
* Name: MLS1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P) = ALP1 * A
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* (A P) = ALP1 * A
* 
* where ALP1 is the magnitude of the current roll angle alpha, in the range
* 0-31.
* 
* This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
* use the same algorithm but with P set to ALP1 and X set to A. The unrolled
* version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
* only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
* shifts can be done without a test (for bits 5-7).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MULTS-2             Calculate (A P) = X * A
* 
* ******************************************************************************

MLS1:
       movb @ALP1,rx                   ; LDX ALP1          ; Set P to the roll angle alpha magnitude in ALP1
       movb rx,@P                      ; STX P             ; (0-31), so now we calculate P * A

MULTS:
       movb ra,rx                      ; TAX               ; Set X = A, so now we can calculate P * X instead of
                                                           ; P * A to get our result, and we can use the algorithm
                                                           ; from MU11 to do that, just unrolled (as MU11 returns
                                                           ; P * X)

       andi ra,>80*256                 ; AND #%10000000    ; Set T to the sign bit of A
       movb ra,@T                      ; STA T             

       movb rx,ra                      ; TXA               ; Set A = |A|
       andi ra,>7f*256                 ; AND #127          

       jeq  MU6                        ; BEQ MU6           ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
                                                           ; from the subroutine using a tail call

       movb ra,rx                      ; TAX               ; Set T1 = X - 1
       sb   rone,rx                    ; DEX               ; 
       movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
                                                           ; to do an addition in the loop below

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A

       .lsr @P                         ; LSR P             ; Set P = P >> 1
                                                           ; and C flag = bit 0 of P

                                                           ; We are now going to work our way through the bits of
                                                           ; P, and do a shift-add for any bits that are set,
                                                           ; keeping the running total in A, but instead of using a
                                                           ; loop like MU11, we just unroll it, starting with bit 0

       jnc  B39                        ; BCC B39           ; If C (i.e. the next bit from P) is set, do the
       .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
                                                           ; 
                                                           ; A = A + T1 + C
                                                           ; = A + X - 1 + 1
                                                           ; = A + X

B39:
       .rora                           ; ROR A             ; Shift A right to catch the next digit of our result,
                                                           ; which the next ROR sticks into the left end of P while
                                                           ; also extracting the next bit of P

       .ror @P                         ; ROR P             ; Add the overspill from shifting A to the right onto
                                                           ; the start of P, and shift P right to fetch the next
                                                           ; bit for the calculation into the C flag

       jnc  B40                        ; BCC B40           ; Repeat the shift-and-add loop for bit 1
       .adc @T1,ra                     ; ADC T1            
B40:
       .rora                           ; ROR A             
       .ror @P                         ; ROR P             

       jnc  B41                        ; BCC B41           ; Repeat the shift-and-add loop for bit 2
       .adc @T1,ra                     ; ADC T1            
B41:
       .rora                           ; ROR A             
       .ror @P                         ; ROR P             

       jnc  B42                        ; BCC B42           ; Repeat the shift-and-add loop for bit 3
       .adc @T1,ra                     ; ADC T1            
B42:
       .rora                           ; ROR A             
       .ror @P                         ; ROR P             

       jnc  B43                        ; BCC B43           ; Repeat the shift-and-add loop for bit 4
       .adc @T1,ra                     ; ADC T1            
B43:
       .rora                           ; ROR A             
       .ror @P                         ; ROR P             

       srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 5
       .ror @P                         ; ROR P             

       srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 6
       .ror @P                         ; ROR P             

       srl  ra,1                       ; LSR A             ; Just do the "shift" part for bit 7
       .ror @P                         ; ROR P             

       socb @T,ra                      ; ORA T             ; Give A the sign bit of the original argument A that
                                                           ; we put into T above

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SQUA
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Clear bit 7 of A and calculate (A P) = A * A
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of unsigned 8-bit numbers, after first
* clearing bit 7 of A:
* 
* (A P) = A * A
* 
* ******************************************************************************

SQUA:
       andi ra,>7f*256                 ; AND #%01111111    ; Clear bit 7 of A and fall through into SQUA2 to set
                                                           ; (A P) = A * A

* ******************************************************************************
* 
* Name: SQUA2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P) = A * A
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of unsigned 8-bit numbers:
* 
* (A P) = A * A
* 
* ******************************************************************************

SQUA2:
       movb ra,@P                      ; STA P             ; Copy A into P and X
       movb ra,rx                      ; TAX               

       jne  MU11                       ; BNE MU11          ; If X = 0 fall through into MU1 to return a 0,
                                                           ; otherwise jump to MU11 to return P * X

* ******************************************************************************
* 
* Name: MU1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Copy X into P and A, and clear the C flag
* 
* ------------------------------------------------------------------------------
* 
* Used to return a 0 result quickly from MULTU below.
* 
* ******************************************************************************

MU1:
       .clc                            ; CLC               ; Clear the C flag

       movb rx,@P                      ; STX P             ; Copy X into P and A
       movb rx,ra                      ; TXA               

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MLU1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
* 
* ------------------------------------------------------------------------------
* 
* Do the following assignment, and multiply the Y-th stardust particle's
* y-coordinate with an unsigned number Q:
* 
* Y1 = y_hi
* 
* (A P) = |y_hi| * Q
* 
* ******************************************************************************

MLU1:
       movb @SY(ry),ra                 ; LDA SY,Y          ; Set Y1 the Y-th byte of SY
       movb ra,@Y1                     ; STA Y1            

                                                           ; Fall through into MLU2 to calculate:
                                                           ; 
                                                           ; (A P) = |A| * Q

* ******************************************************************************
* 
* Name: MLU2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P) = |A| * Q
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of a sign-magnitude 8-bit number P with an
* unsigned number Q:
* 
* (A P) = |A| * Q
* 
* ******************************************************************************

MLU2:
       andi ra,>7f*256                 ; AND #%01111111    ; Clear the sign bit in P, so P = |A|
       movb ra,@P                      ; STA P             

                                                           ; Fall through into MULTU to calculate:
                                                           ; 
                                                           ; (A P) = P * Q
                                                           ; = |A| * Q

* ******************************************************************************
* 
* Name: MULTU
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P) = P * Q
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of unsigned 8-bit numbers:
* 
* (A P) = P * Q
* 
* ******************************************************************************

MULTU:
       movb @Q,rx                      ; LDX Q             ; Set X = Q

       jeq  MU1                        ; BEQ MU1           ; If X = Q = 0, jump to MU1 to copy X into P and A,
                                                           ; clear the C flag and return from the subroutine using
                                                           ; a tail call

                                                           ; Otherwise fall through into MU11 to set (A P) = P * X

* ******************************************************************************
* 
* Name: MU11
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P) = P * X
* Deep dive: Shift-and-add multiplication
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of two unsigned 8-bit numbers:
* 
* (A P) = P * X
* 
* This uses the same shift-and-add approach as MULT1, but it's simpler as we
* are dealing with unsigned numbers in P and X. See the deep dive on
* "Shift-and-add multiplication" for a discussion of how this algorithm works.
* 
* ******************************************************************************

MU11:
       sb   rone,rx                    ; DEX               ; Set T = X - 1
       movb rx,@T                      ; STX T             ; 
                                                           ; We subtract 1 as the C flag will be set when we want
                                                           ; to do an addition in the loop below

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A

       li   rx,>08*256                 ; LDX #8            ; Set up a counter in X to count the 8 bits in P

       .lsr @P                         ; LSR P             ; Set P = P >> 1
                                                           ; and C flag = bit 0 of P

                                                           ; We are now going to work our way through the bits of
                                                           ; P, and do a shift-add for any bits that are set,
                                                           ; keeping the running total in A. We just did the first
                                                           ; shift right, so we now need to do the first add and
                                                           ; loop through the other bits in P

MUL6:
       jnc  B44                        ; BCC B44           ; If C (i.e. the next bit from P) is set, do the
       .adc @T,ra                      ; ADC T             ; addition for this bit of P:
                                                           ; 
                                                           ; A = A + T + C
                                                           ; = A + X - 1 + 1
                                                           ; = A + X

B44:
       .rora                           ; ROR A             ; Shift A right to catch the next digit of our result,
                                                           ; which the next ROR sticks into the left end of P while
                                                           ; also extracting the next bit of P

       .ror @P                         ; ROR P             ; Add the overspill from shifting A to the right onto
                                                           ; the start of P, and shift P right to fetch the next
                                                           ; bit for the calculation into the C flag

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  MUL6                       ; BNE MUL6          ; Loop back for the next bit until P has been rotated
                                                           ; all the way

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MU6
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Set P(1 0) = (A A)
* 
* ------------------------------------------------------------------------------
* 
* In practice this is only called via a BEQ following an AND instruction, in
* which case A = 0, so this routine effectively does this:
* 
* P(1 0) = 0
* 
* ******************************************************************************

MU6:
       movb ra,@P+1                    ; STA P+1           ; Set P(1 0) = (A A)
       movb ra,@P                      ; STA P             

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: FMLTU2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate A = K * sin(A)
* Deep dive: The sine, cosine and arctan tables
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* A = K * sin(A)
* 
* Because this routine uses the sine lookup table SNE, we can also call this
* routine to calculate cosine multiplication. To calculate the following:
* 
* A = K * cos(B)
* 
* call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
* 
* ******************************************************************************

FMLTU2:
       andi ra,>1f*256                 ; AND #%00011111    ; Restrict A to bits 0-5 (so it's in the range 0-31)

       movb ra,rx                      ; TAX               ; Set Q = sin(A) * 256
       movb @SNE(rx),ra                ; LDA SNE,X         
       movb ra,@Q                      ; STA Q             

       movb @K,ra                      ; LDA K             ; Set A to the radius in K

                                                           ; Fall through into FMLTU to do the following:
                                                           ; 
                                                           ; (A ?) = A * Q
                                                           ; = K * sin(A) * 256
                                                           ; 
                                                           ; which is equivalent to:
                                                           ; 
                                                           ; A = K * sin(A)

* ******************************************************************************
* 
* Name: FMLTU
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate A = A * Q / 256
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of two unsigned 8-bit numbers, returning only
* the high byte of the result:
* 
* (A ?) = A * Q
* 
* or, to put it another way:
* 
* A = A * Q / 256
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is set
* 
* ******************************************************************************

FMLTU:
       .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A, set the C flag and rotate right,
       .sec                            ; SEC               ; so the C flag now contains bit 0 of A inverted, and P
       .rora                           ; ROR A             ; contains A inverted and shifted right by one, with bit
       movb ra,@P                      ; STA P             ; 7 set to a 1. We can now use P as our source of bits
                                                           ; to shift right, just as in MU11, just with the logic
                                                           ; reversed

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A

MUL3:
       joc  MU7                        ; BCS MU7           ; If C (i.e. the next bit from P) is set, do not do the
                                                           ; addition for this bit of P, and instead skip to MU7
                                                           ; to just do the shifts

       .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
                                                           ; 
                                                           ; A = A + Q + C
                                                           ; = A + Q

       .rora                           ; ROR A             ; Shift A right to catch the next digit of our result.
                                                           ; If we were interested in the low byte of the result we
                                                           ; would want to save the bit that falls off the end, but
                                                           ; we aren't, so we can ignore it

       .lsr @P                         ; LSR P             ; Shift P right to fetch the next bit for the
                                                           ; calculation into the C flag

       jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
                                                           ; (so we loop through the bits of P until we get to the
                                                           ; 1 we inserted before the loop, and then we stop)

                                                           ; If we get here then the C flag is set as we just
                                                           ; rotated a 1 out of the right end of P

       .rts                            ; RTS               ; Return from the subroutine

MU7:
       srl  ra,1                       ; LSR A             ; Shift A right to catch the next digit of our result,
                                                           ; pushing a 0 into bit 7 as we aren't adding anything
                                                           ; here (we can't use a ROR here as the C flag is set, so
                                                           ; a ROR would push a 1 into bit 7)

       .lsr @P                         ; LSR P             ; Fetch the next bit from P into the C flag

       jne  MUL3                       ; BNE MUL3          ; Loop back to MUL3 if P still contains some set bits
                                                           ; (so we loop through the bits of P until we get to the
                                                           ; 1 we inserted before the loop, and then we stop)

                                                           ; If we get here then the C flag is set as we just
                                                           ; rotated a 1 out of the right end of P

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: Unused duplicate of MULTU
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: An unused duplicate of the MULTU routine
* 
* ------------------------------------------------------------------------------
* 
* This is a duplicate of the MULTU routine, but with no entry label, so it can't
* be called by name. It is unused, and could have been culled to save a few
* bytes (24 to be precise), but it's still here, unnamed, unloved and unvisited,
* through no fault of its own.
* 
* ******************************************************************************

* {
* LDX Q
* BEQ MU1
* DEX
* STX T
* LDA #0
* LDX #8
* LSR P
* 
* .MUL6
* 
* BCC B45
* ADC T
* .B45
* ROR A
* ROR P
* DEX
* BNE MUL6
* RTS
* }

* ******************************************************************************
* 
* Name: MLTU2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P+1 P) = (A ~P) * Q
* Deep dive: Shift-and-add multiplication
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of an unsigned 16-bit number and an unsigned
* 8-bit number:
* 
* (A P+1 P) = (A ~P) * Q
* 
* where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
* words, if you wanted to calculate &1234 * &56, you would:
* 
* * Set A to &12
* * Set P to &34 EOR %11111111 = &CB
* * Set Q to &56
* 
* before calling MLTU2.
* 
* This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
* inverted argument trick to work out whether or not to do an addition, and like
* MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
* extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
* the algorithm is still the shift-and-add approach explained in MULT1, just
* with more bits.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Q                   Q is preserved
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
* 
* ******************************************************************************

       movb rx,@Q                      ; STX Q             ; Store X in Q

MLTU2:
       .eoi (>ff*256)                  ; EOR #%11111111    ; Flip the bits in A and rotate right, storing the
       srl  ra,1                       ; LSR A             ; result in P+1, so we now calculate (P+1 P) * Q
       movb ra,@P+1                    ; STA P+1           

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A

       li   rx,>10*256                 ; LDX #16           ; Set up a counter in X to count the 16 bits in (P+1 P)

       .ror @P                         ; ROR P             ; Set P = P >> 1 with bit 7 = bit 0 of A
                                                           ; and C flag = bit 0 of P

MUL7:
       joc  MU21                       ; BCS MU21          ; If C (i.e. the next bit from P) is set, do not do the
                                                           ; addition for this bit of P, and instead skip to MU21
                                                           ; to just do the shifts

       .adc @Q,ra                      ; ADC Q             ; Do the addition for this bit of P:
                                                           ; 
                                                           ; A = A + Q + C
                                                           ; = A + Q

       .rora                           ; ROR A             ; Rotate (A P+1 P) to the right, so we capture the next
       .ror @P+1                       ; ROR P+1           ; digit of the result in P+1, and extract the next digit
       .ror @P                         ; ROR P             ; of (P+1 P) in the C flag

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
                                                           ; all the way

       .rts                            ; RTS               ; Return from the subroutine

MU21:
       srl  ra,1                       ; LSR A             ; Shift (A P+1 P) to the right, so we capture the next
       .ror @P+1                       ; ROR P+1           ; digit of the result in P+1, and extract the next digit
       .ror @P                         ; ROR P             ; of (P+1 P) in the C flag

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  MUL7                       ; BNE MUL7          ; Loop back for the next bit until P has been rotated
                                                           ; all the way

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MUT3
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: An unused routine that does the same as MUT2
* 
* ------------------------------------------------------------------------------
* 
* This routine is never actually called, but it is identical to MUT2, as the
* extra instructions have no effect.
* 
* ******************************************************************************

MUT3:
       movb @ALP1,rx                   ; LDX ALP1          ; Set P = ALP1, though this gets overwritten by the
       movb rx,@P                      ; STX P             ; following, so this has no effect

                                                           ; Fall through into MUT2 to do the following:
                                                           ; 
                                                           ; (S R) = XX(1 0)
                                                           ; (A P) = Q * A

* ******************************************************************************
* 
* Name: MUT2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
* 
* ------------------------------------------------------------------------------
* 
* Do the following assignment, and multiplication of two signed 8-bit numbers:
* 
* (S R) = XX(1 0)
* (A P) = Q * A
* 
* ******************************************************************************

MUT2:
       movb @XX+1,rx                   ; LDX XX+1          ; Set S = XX+1
       movb rx,@S                      ; STX S             

                                                           ; Fall through into MUT1 to do the following:
                                                           ; 
                                                           ; R = XX
                                                           ; (A P) = Q * A

* ******************************************************************************
* 
* Name: MUT1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate R = XX and (A P) = Q * A
* 
* ------------------------------------------------------------------------------
* 
* Do the following assignment, and multiplication of two signed 8-bit numbers:
* 
* R = XX
* (A P) = Q * A
* 
* ******************************************************************************

MUT1:
       movb @XX,rx                     ; LDX XX            ; Set R = XX
       movb rx,@R                      ; STX R             

                                                           ; Fall through into MULT1 to do the following:
                                                           ; 
                                                           ; (A P) = Q * A

* ******************************************************************************
* 
* Name: MULT1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A P) = Q * A
* Deep dive: Shift-and-add multiplication
* 
* ------------------------------------------------------------------------------
* 
* Do the following multiplication of two 8-bit sign-magnitude numbers:
* 
* (A P) = Q * A
* 
* ******************************************************************************

MULT1:
       movb ra,rx                      ; TAX               ; Store A in X

       andi ra,>7f*256                 ; AND #%01111111    ; Set P = |A| >> 1
       srl  ra,1                       ; LSR A             ; and C flag = bit 0 of A
       movb ra,@P                      ; STA P             

       movb rx,ra                      ; TXA               ; Restore argument A

       .eor @Q                         ; EOR Q             ; Set bit 7 of A and T if Q and A have different signs,
       andi ra,>80*256                 ; AND #%10000000    ; clear bit 7 if they have the same signs, 0 all other
       movb ra,@T                      ; STA T             ; bits, i.e. T contains the sign bit of Q * A

       movb @Q,ra                      ; LDA Q             ; Set A = |Q|
       andi ra,>7f*256                 ; AND #%01111111    

       jeq  mu10_                      ; BEQ mu10          ; If |Q| = 0 jump to mu10 (with A set to 0)

       movb ra,rx                      ; TAX               ; Set T1 = |Q| - 1
       sb   rone,rx                    ; DEX               ; 
       movb rx,@T1                     ; STX T1            ; We subtract 1 as the C flag will be set when we want
                                                           ; to do an addition in the loop below

                                                           ; We are now going to work our way through the bits of
                                                           ; P, and do a shift-add for any bits that are set,
                                                           ; keeping the running total in A. We already set up
                                                           ; the first shift at the start of this routine, as
                                                           ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
                                                           ; up a loop to sift through the other 7 bits in P

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can start building the answer in A

       li   rx,>07*256                 ; LDX #7            ; Set up a counter in X to count the 7 bits remaining
                                                           ; in P

MUL4:
       jnc  B46                        ; BCC B46           ; If C (i.e. the next bit from P) is set, do the
       .adc @T1,ra                     ; ADC T1            ; addition for this bit of P:
                                                           ; 
                                                           ; A = A + T1 + C
                                                           ; = A + |Q| - 1 + 1
                                                           ; = A + |Q|

B46:
       .rora                           ; ROR A             ; As mentioned above, this ROR shifts A right and
                                                           ; catches bit 0 in C - giving another digit for our
                                                           ; result - and the next ROR sticks that bit into the
                                                           ; left end of P while also extracting the next bit of P
                                                           ; for the next addition

       .ror @P                         ; ROR P             ; Add the overspill from shifting A to the right onto
                                                           ; the start of P, and shift P right to fetch the next
                                                           ; bit for the calculation

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  MUL4                       ; BNE MUL4          ; Loop back for the next bit until P has been rotated
                                                           ; all the way

       srl  ra,1                       ; LSR A             ; Rotate (A P) once more to get the final result, as
       .ror @P                         ; ROR P             ; we only pushed 7 bits through the above process

       socb @T,ra                      ; ORA T             ; Set the sign bit of the result that we stored in T

       .rts                            ; RTS               ; Return from the subroutine

mu10_:
       movb ra,@P                      ; STA P             ; If we get here, the result is 0 and A = 0, so set
                                                           ; P = 0 so (A P) = 0

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MULT12
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (S R) = Q * A
* 
* ------------------------------------------------------------------------------
* 
* Calculate:
* 
* (S R) = Q * A
* 
* ******************************************************************************

MULT12:
       .jsr @MULT1                     ; JSR MULT1         ; Set (A P) = Q * A

       movb ra,@S                      ; STA S             ; Set (S R) = (A P)
       movb @P,ra                      ; LDA P             ; = Q * A
       movb ra,@R                      ; STA R             

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TAS3
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate the dot product of XX15 and an orientation vector
* 
* ------------------------------------------------------------------------------
* 
* Calculate the dot product of the vector in XX15 and one of the orientation
* vectors, as determined by the value of Y. If vect is the orientation vector,
* we calculate this:
* 
* (A X) = vect . XX15
* = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The orientation vector:
* 
* * If Y = 10, calculate nosev . XX15
* 
* * If Y = 16, calculate roofv . XX15
* 
* * If Y = 22, calculate sidev . XX15
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* (A X)               The result of the dot product
* 
* ******************************************************************************

TAS3:
       movb @INWK(ry),rx               ; LDX INWK,Y        ; Set Q = the Y-th byte of INWK, i.e. vect_x
       movb rx,@Q                      ; STX Q             

       movb @XX15,ra                   ; LDA XX15          ; Set A = XX15

       .jsr @MULT12                    ; JSR MULT12        ; Set (S R) = Q * A
                                                           ; = vect_x * XX15

       movb @INWK+2(ry),rx             ; LDX INWK+2,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
       movb rx,@Q                      ; STX Q             

       movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = XX15+1

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
                                                           ; = vect_y * XX15+1 + vect_x * XX15

       movb ra,@S                      ; STA S             ; Set (S R) = (A X)
       movb rx,@R                      ; STX R             

       movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
       movb rx,@Q                      ; STX Q             

       movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2

                                                           ; Fall through into MAD to set:
                                                           ; 
                                                           ; (A X) = Q * A + (S R)
                                                           ; = vect_z * XX15+2 + vect_y * XX15+1 +
                                                           ; vect_x * XX15

* ******************************************************************************
* 
* Name: MAD
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A X) = Q * A + (S R)
* 
* ------------------------------------------------------------------------------
* 
* Calculate
* 
* (A X) = Q * A + (S R)
* 
* ******************************************************************************

MAD:
       .jsr @MULT1                     ; JSR MULT1         ; Call MULT1 to set (A P) = Q * A

                                                           ; Fall through into ADD to do:
                                                           ; 
                                                           ; (A X) = (A P) + (S R)
                                                           ; = Q * A + (S R)

* ******************************************************************************
* 
* Name: ADD
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A X) = (A P) + (S R)
* Deep dive: Adding sign-magnitude numbers
* 
* ------------------------------------------------------------------------------
* 
* Add two 16-bit sign-magnitude numbers together, calculating:
* 
* (A X) = (A P) + (S R)
* 
* ******************************************************************************

ADD:
       movb ra,@T1                     ; STA T1            ; Store argument A in T1

       andi ra,>80*256                 ; AND #%10000000    ; Extract the sign (bit 7) of A and store it in T
       movb ra,@T                      ; STA T             

       .eor @S                         ; EOR S             ; EOR bit 7 of A with S. If they have different bit 7s
       jlt  MU8                        ; BMI MU8           ; (i.e. they have different signs) then bit 7 in the
                                                           ; EOR result will be 1, which means the EOR result is
                                                           ; negative. So the AND, EOR and BMI together mean "jump
                                                           ; to MU8 if A and S have different signs"

                                                           ; If we reach here, then A and S have the same sign, so
                                                           ; we can add them and set the sign to get the result

       movb @R,ra                      ; LDA R             ; Add the least significant bytes together into X:
       .clc                            ; CLC               ; 
       .adc @P,ra                      ; ADC P             ; X = P + R
       movb ra,rx                      ; TAX               

       movb @S,ra                      ; LDA S             ; Add the most significant bytes together into A. We
       .adc @T1,ra                     ; ADC T1            ; stored the original argument A in T1 earlier, so we
                                                           ; can do this with:
                                                           ; 
                                                           ; A = A  + S + C
                                                           ; = T1 + S + C

       socb @T,ra                      ; ORA T             ; If argument A was negative (and therefore S was also
                                                           ; negative) then make sure result A is negative by
                                                           ; OR'ing the result with the sign bit from argument A
                                                           ; (which we stored in T)

       .rts                            ; RTS               ; Return from the subroutine

MU8:
                                                           ; If we reach here, then A and S have different signs,
                                                           ; so we can subtract their absolute values and set the
                                                           ; sign to get the result
       movb @S,ra                      ; LDA S             ; Clear the sign (bit 7) in S and store the result in
       andi ra,>7f*256                 ; AND #%01111111    ; U, so U now contains |S|
       movb ra,@U                      ; STA U             

       movb @P,ra                      ; LDA P             ; Subtract the least significant bytes into X:
       .sec                            ; SEC               ; 
       .sbc @R,ra                      ; SBC R             ; X = P - R
       movb ra,rx                      ; TAX               

       movb @T1,ra                     ; LDA T1            ; Restore the A of the argument (A P) from T1 and
       andi ra,>7f*256                 ; AND #%01111111    ; clear the sign (bit 7), so A now contains |A|

       .sbc @U,ra                      ; SBC U             ; Set A = |A| - |S|

                                                           ; At this point we have |A P| - |S R| in (A X), so we
                                                           ; need to check whether the subtraction above was the
                                                           ; right way round (i.e. that we subtracted the smaller
                                                           ; absolute value from the larger absolute value)

       joc  MU9                        ; BCS MU9           ; If |A| >= |S|, our subtraction was the right way
                                                           ; round, so jump to MU9 to set the sign

                                                           ; If we get here, then |A| < |S|, so our subtraction
                                                           ; above was the wrong way round (we actually subtracted
                                                           ; the larger absolute value from the smaller absolute
                                                           ; value). So let's subtract the result we have in (A X)
                                                           ; from zero, so that the subtraction is the right way
                                                           ; round

       movb ra,@U                      ; STA U             ; Store A in U

       movb rx,ra                      ; TXA               ; Set X = 0 - X using two's complement (to negate a
       .eoi (>ff*256)                  ; EOR #&FF          ; number in two's complement, you can invert the bits
       .adi (>01*256)                  ; ADC #1            ; and add one - and we know the C flag is clear as we
       movb ra,rx                      ; TAX               ; didn't take the BCS branch above, so the ADC will do
                                                           ; the correct addition)

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 - A, which we can do this time using a
       .sbc @U,ra                      ; SBC U             ; subtraction with the C flag clear

       ori  ra,>80*256                 ; ORA #%10000000    ; We now set the sign bit of A, so that the EOR on the
                                                           ; next line will give the result the opposite sign to
                                                           ; argument A (as T contains the sign bit of argument
                                                           ; A). This is the same as giving the result the same
                                                           ; sign as argument S (as A and S have different signs),
                                                           ; which is what we want, as S has the larger absolute
                                                           ; value

MU9:
       .eor @T                         ; EOR T             ; If we get here from the BCS above, then |A| >= |S|,
                                                           ; so we want to give the result the same sign as
                                                           ; argument A, so if argument A was negative, we flip
                                                           ; the sign of the result with an EOR (to make it
                                                           ; negative)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TIS1
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (A ?) = (-X * A + (S R)) / 96
* Deep dive: Shift-and-subtract division
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following expression between sign-magnitude numbers, ignoring
* the low byte of the result:
* 
* (A ?) = (-X * A + (S R)) / 96
* 
* This uses the same shift-and-subtract algorithm as TIS2, just with the
* quotient A hard-coded to 96.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Q                   Gets set to the value of argument X
* 
* ******************************************************************************

TIS1:
       movb rx,@Q                      ; STX Q             ; Set Q = X

       .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign bit in A

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
                                                           ; = X * -A + (S R)

DVID96:
       movb ra,rx                      ; TAX               ; Set T to the sign bit of the result
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@T                      ; STA T             

       movb rx,ra                      ; TXA               ; Set A to the high byte of the result with the sign bit
       andi ra,>7f*256                 ; AND #%01111111    ; cleared, so (A ?) = |X * A + (S R)|

                                                           ; The following is identical to TIS2, except Q is
                                                           ; hard-coded to 96, so this does A = A / 96

       li   rx,>fe*256                 ; LDX #254          ; Set T1 to have bits 1-7 set, so we can rotate through
       movb rx,@T1                     ; STX T1            ; 7 loop iterations, getting a 1 each time, and then
                                                           ; getting a 0 on the 8th iteration... and we can also
                                                           ; use T1 to catch our result bits into bit 0 each time

DVL3:
       .asla                           ; ASL A             ; Shift A to the left

       ci   ra,>60*256                 ; CMP #96           ; If A < 96 skip the following subtraction
       jnc  DV4                        ; BCC DV4           

       .sbi (>60*256)                  ; SBC #96           ; Set A = A - 96
                                                           ; 
                                                           ; Going into this subtraction we know the C flag is
                                                           ; set as we passed through the BCC above, and we also
                                                           ; know that A >= 96, so the C flag will still be set
                                                           ; once we are done

DV4:
       .rol @T1                        ; ROL T1            ; Rotate the counter in T1 to the left, and catch the
                                                           ; result bit into bit 0 (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       joc  DVL3                       ; BCS DVL3          ; If we still have set bits in T1, loop back to DVL3 to
                                                           ; do the next iteration of 7

       movb @T1,ra                     ; LDA T1            ; Fetch the result from T1 into A

       socb @T,ra                      ; ORA T             ; Give A the sign of the result that we stored above

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DV42
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (P R) = 256 * DELTA / z_hi
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following division and remainder:
* 
* P = DELTA / (the Y-th stardust particle's z_hi coordinate)
* 
* R = remainder as a fraction of A, where 1.0 = 255
* 
* Another way of saying the above is this:
* 
* (P R) = 256 * DELTA / z_hi
* 
* DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
* are removed at lower values than this), so this means P is between 0 and 2
* (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
* 
* This uses the same shift-and-subtract algorithm as TIS2, but this time we
* keep the remainder.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The number of the stardust particle to process
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is cleared
* 
* ******************************************************************************

DV42:
       movb @SZ(ry),ra                 ; LDA SZ,Y          ; Fetch the Y-th dust particle's z_hi coordinate into A

                                                           ; Fall through into DV41 to do:
                                                           ; 
                                                           ; (P R) = 256 * DELTA / A
                                                           ; = 256 * DELTA / Y-th stardust particle's z_hi

* ******************************************************************************
* 
* Name: DV41
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (P R) = 256 * DELTA / A
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following division and remainder:
* 
* P = DELTA / A
* 
* R = remainder as a fraction of A, where 1.0 = 255
* 
* Another way of saying the above is this:
* 
* (P R) = 256 * DELTA / A
* 
* This uses the same shift-and-subtract algorithm as TIS2, but this time we
* keep the remainder.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is cleared
* 
* ******************************************************************************

DV41:
       movb ra,@Q                      ; STA Q             ; Store A in Q

       movb @DELTA,ra                  ; LDA DELTA         ; Fetch the speed from DELTA into A

                                                           ; Fall through into DVID4 to do:
                                                           ; 
                                                           ; (P R) = 256 * A / Q
                                                           ; = 256 * DELTA / A

* ******************************************************************************
* 
* Name: DVID4
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (P R) = 256 * A / Q
* Deep dive: Shift-and-subtract division
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following division and remainder:
* 
* P = A / Q
* 
* R = remainder as a fraction of Q, where 1.0 = 255
* 
* Another way of saying the above is this:
* 
* (P R) = 256 * A / Q
* 
* This uses the same shift-and-subtract algorithm as TIS2, but this time we
* keep the remainder.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is cleared
* 
* ******************************************************************************

DVID4:
       li   rx,>08*256                 ; LDX #8            ; Set a counter in X to count the 8 bits in A

       .asla                           ; ASL A             ; Shift A left and store in P (we will build the result
       movb ra,@P                      ; STA P             ; in P)

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a remainder

DVL4:
       .rola                           ; ROL A             ; Shift A to the left

       joc  DV8                        ; BCS DV8           ; If the C flag is set (i.e. bit 7 of A was set) then
                                                           ; skip straight to the subtraction

       cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
       jnc  DV5                        ; BCC DV5           

DV8:
       .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q

       .sec                            ; SEC               ; Set the C flag, so that P gets a 1 shifted into bit 0

DV5:
       .rol @P                         ; ROL P             ; Shift P to the left, pulling the C flag into bit 0

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  DVL4                       ; BNE DVL4          ; Loop back for the next bit until we have done all 8
                                                           ; bits of P

       b    @LL28+4                    ; JMP LL28+4        ; Jump to LL28+4 to convert the remainder in A into an
                                                           ; integer representation of the fractional value A / Q,
                                                           ; in R, where 1.0 = 255. LL28+4 always returns with the
                                                           ; C flag cleared, and we return from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: DVID3B2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
* Deep dive: Shift-and-subtract division
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
* 
* The actual division here is done as an 8-bit calculation using LL31, but this
* routine shifts both the numerator (the top part of the division) and the
* denominator (the bottom part of the division) around to get the multi-byte
* result we want.
* 
* Specifically, it shifts both of them to the left as far as possible, keeping a
* tally of how many shifts get done in each one - and specifically, the
* difference in the number of shifts between the top and bottom (as shifting
* both of them once in the same direction won't change the result). It then
* divides the two highest bytes with the simple 8-bit routine in LL31, and
* shifts the result by the difference in the number of shifts, which acts as a
* scale factor to get the correct result.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* K(3 2 1 0)          The result of the division
* 
* X                   X is preserved
* 
* ******************************************************************************

DVID3B2:
       movb ra,@P+2                    ; STA P+2           ; Set P+2 = A

       movb @INWK+6,ra                 ; LDA INWK+6        ; Set Q = z_lo
       movb ra,@Q                      ; STA Q             

       movb @INWK+7,ra                 ; LDA INWK+7        ; Set R = z_hi
       movb ra,@R                      ; STA R             

       movb @INWK+8,ra                 ; LDA INWK+8        ; Set S = z_sign
       movb ra,@S                      ; STA S             

DVID3B:
                                                           ; Given the above assignments, we now want to calculate
                                                           ; the following to get the result we want:
                                                           ; 
                                                           ; K(3 2 1 0) = P(2 1 0) / (S R Q)
       movb @P,ra                      ; LDA P             ; Make sure P(2 1 0) is at least 1
       ori  ra,>01*256                 ; ORA #1            
       movb ra,@P                      ; STA P             

       movb @P+2,ra                    ; LDA P+2           ; Set T to the sign of P+2 * S (i.e. the sign of the
       .eor @S                         ; EOR S             ; result) and store it in T
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@T                      ; STA T             

       li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to store the scale factor

       movb @P+2,ra                    ; LDA P+2           ; Clear the sign bit of P+2, so the division can be done
       andi ra,>7f*256                 ; AND #%01111111    ; with positive numbers and we'll set the correct sign
                                                           ; below, once all the maths is done
                                                           ; 
                                                           ; This also leaves A = P+2, which we use below

DVL9:
                                                           ; We now shift (A P+1 P) left until A >= 64, counting
                                                           ; the number of shifts in Y. This makes the top part of
                                                           ; the division as large as possible, thus retaining as
                                                           ; much accuracy as we can.  When we come to return the
                                                           ; final result, we shift the result by the number of
                                                           ; places in Y, and in the correct direction
       ci   ra,>40*256                 ; CMP #64           ; If A >= 64, jump down to DV14
       joc  DV14                       ; BCS DV14          

       .asl @P                         ; ASL P             ; Shift (A P+1 P) to the left
       .rol @P+1                       ; ROL P+1           
       .rola                           ; ROL A             

       ab   rone,ry                    ; INY               ; Increment the scale factor in Y

       jne  DVL9                       ; BNE DVL9          ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
                                                           ; will never be zero)

DV14:
                                                           ; If we get here, A >= 64 and contains the highest byte
                                                           ; of the numerator, scaled up by the number of left
                                                           ; shifts in Y
       movb ra,@P+2                    ; STA P+2           ; Store A in P+2, so we now have the scaled value of
                                                           ; the numerator in P(2 1 0)

       movb @S,ra                      ; LDA S             ; Set A = |S|
       andi ra,>7f*256                 ; AND #%01111111    

       jlt  DV9                        ; BMI DV9           ; If bit 7 of A is set, jump down to DV9 to skip the
                                                           ; left-shifting of the denominator (though this branch
                                                           ; instruction has no effect as bit 7 of the above AND
                                                           ; can never be set, which is why this instruction was
                                                           ; removed from later versions)

DVL6:
                                                           ; We now shift (S R Q) left until bit 7 of S is set,
                                                           ; reducing Y by the number of shifts. This makes the
                                                           ; bottom part of the division as large as possible, thus
                                                           ; retaining as much accuracy as we can. When we come to
                                                           ; return the final result, we shift the result by the
                                                           ; total number of places in Y, and in the correct
                                                           ; direction, to give us the correct result
                                                           ; 
                                                           ; We set A to |S| above, so the following actually
                                                           ; shifts (A R Q)
       sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y

       .asl @Q                         ; ASL Q             ; Shift (A R Q) to the left
       .rol @R                         ; ROL R             
       .rola                           ; ROL A             

       jgt  DVL6                       ; BPL DVL6          ; Loop up to DVL6 to do another shift, until bit 7 of A
                                                           ; is set and we can't shift left any further

DV9:
                                                           ; We have now shifted both the numerator and denominator
                                                           ; left as far as they will go, keeping a tally of the
                                                           ; overall scale factor of the various shifts in Y. We
                                                           ; can now divide just the two highest bytes to get our
                                                           ; result
       movb ra,@Q                      ; STA Q             ; Set Q = A, the highest byte of the denominator

       li   ra,>fe*256                 ; LDA #254          ; Set R to have bits 1-7 set, so we can pass this to
       movb ra,@R                      ; STA R             ; LL31 to act as the bit counter in the division

       movb @P+2,ra                    ; LDA P+2           ; Set A to the highest byte of the numerator

       .jsr @LL31                      ; JSR LL31          ; Call LL31 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; = 256 * numerator / denominator

                                                           ; The result of our division is now in R, so we just
                                                           ; need to shift it back by the scale factor in Y

       li   ra,>00*256                 ; LDA #0            ; Set K(3 2 1) = 0 to hold the result (we populate K
       movb ra,@K+1                    ; STA K+1           ; next)
       movb ra,@K+2                    ; STA K+2           
       movb ra,@K+3                    ; STA K+3           

       movb ry,ra                      ; TYA               ; If Y is positive, jump to DV12
       jgt  DV12                       ; BPL DV12          

                                                           ; If we get here then Y is negative, so we need to shift
                                                           ; the result R to the left by Y places, and then set the
                                                           ; correct sign for the result

       movb @R,ra                      ; LDA R             ; Set A = R

DVL8:
       .asla                           ; ASL A             ; Shift (K+3 K+2 K+1 A) left
       .rol @K+1                       ; ROL K+1           
       .rol @K+2                       ; ROL K+2           
       .rol @K+3                       ; ROL K+3           

       ab   rone,ry                    ; INY               ; Increment the scale factor in Y

       jne  DVL8                       ; BNE DVL8          ; Loop back to DVL8 until we have shifted left by Y
                                                           ; places

       movb ra,@K                      ; STA K             ; Store A in K so the result is now in K(3 2 1 0)

       movb @K+3,ra                    ; LDA K+3           ; Set K+3 to the sign in T, which we set above to the
       socb @T,ra                      ; ORA T             ; correct sign for the result
       movb ra,@K+3                    ; STA K+3           

       .rts                            ; RTS               ; Return from the subroutine

DV13:
                                                           ; If we get here then Y is zero, so we don't need to
                                                           ; shift the result R, we just need to set the correct
                                                           ; sign for the result
       movb @R,ra                      ; LDA R             ; Store R in K so the result is now in K(3 2 1 0)
       movb ra,@K                      ; STA K             

       movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
       movb ra,@K+3                    ; STA K+3           ; correct sign for the result

       .rts                            ; RTS               ; Return from the subroutine

DV12:
       jeq  DV13                       ; BEQ DV13          ; We jumped here having set A to the scale factor in Y,
                                                           ; so this jumps up to DV13 if Y = 0

                                                           ; If we get here then Y is positive and non-zero, so we
                                                           ; need to shift the result R to the right by Y places
                                                           ; and then set the correct sign for the result. We also
                                                           ; know that K(3 2 1) will stay 0, as we are shifting the
                                                           ; lowest byte to the right, so no set bits will make
                                                           ; their way into the top three bytes

       movb @R,ra                      ; LDA R             ; Set A = R

DVL10:
       srl  ra,1                       ; LSR A             ; Shift A right

       sb   rone,ry                    ; DEY               ; Decrement the scale factor in Y

       jne  DVL10                      ; BNE DVL10         ; Loop back to DVL10 until we have shifted right by Y
                                                           ; places

       movb ra,@K                      ; STA K             ; Store the shifted A in K so the result is now in
                                                           ; K(3 2 1 0)

       movb @T,ra                      ; LDA T             ; Set K+3 to the sign in T, which we set above to the
       movb ra,@K+3                    ; STA K+3           ; correct sign for the result

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: cntr
* Type: Subroutine
* Category: Dashboard
* Summary: Apply damping to the pitch or roll dashboard indicator
* 
* ------------------------------------------------------------------------------
* 
* Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
* centre point (so X represents a position on a centre-based dashboard slider,
* such as pitch or roll). If the value is in the left-hand side of the slider
* (1-127) then it bumps the value up by 1 so it moves towards the centre, and
* if it's in the right-hand side, it reduces it by 1, also moving it towards the
* centre.
* 
* ******************************************************************************

cntr_:
       movb @DAMP,ra                   ; LDA DAMP          ; If DAMP is non-zero, then keyboard damping is not
       jne  RE1                        ; BNE RE1           ; enabled, so jump to RE1 to return from the subroutine

       movb rx,ra                      ; TXA               ; If X < 128, then it's in the left-hand side of the
       jgt  BUMP                       ; BPL BUMP          ; dashboard slider, so jump to BUMP to bump it up by 1,
                                                           ; to move it closer to the centre

       sb   rone,rx                    ; DEX               ; Otherwise X >= 128, so it's in the right-hand side
       jlt  RE1                        ; BMI RE1           ; of the dashboard slider, so decrement X by 1, and if
                                                           ; it's still >= 128, jump to RE1 to return from the
                                                           ; subroutine, otherwise fall through to BUMP to undo
                                                           ; the bump and then return

BUMP:
       ab   rone,rx                    ; INX               ; Bump X up by 1, and if it hasn't overshot the end of
       jne  RE1                        ; BNE RE1           ; the dashboard slider, jump to RE1 to return from the
                                                           ; subroutine, otherwise fall through to REDU to drop
                                                           ; it down by 1 again

REDU:
       sb   rone,rx                    ; DEX               ; Reduce X by 1, and if we have reached 0 jump up to
       jeq  BUMP                       ; BEQ BUMP          ; BUMP to add 1, because we need the value to be in the
                                                           ; range 1 to 255

RE1:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: BUMP2
* Type: Subroutine
* Category: Dashboard
* Summary: Bump up the value of the pitch or roll dashboard indicator
* 
* ------------------------------------------------------------------------------
* 
* Increase ("bump up") X by A, where X is either the current rate of pitch or
* the current rate of roll.
* 
* The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
* This is the amount by which the pitch or roll is currently changing, so 1
* means it is decreasing at the maximum rate, 128 means it is not changing,
* and 255 means it is increasing at the maximum rate. These values correspond
* to the line on the DC or RL indicators on the dashboard, with 1 meaning full
* left, 128 meaning the middle, and 255 meaning full right.
* 
* If bumping up X would push it past 255, then X is set to 255.
* 
* If keyboard auto-recentre is configured and the result is less than 128, we
* bump X up to the mid-point, 128. This is the equivalent of having a roll or
* pitch in the left half of the indicator, when increasing the roll or pitch
* should jump us straight to the mid-point.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* RE2+2               Restore A from T and return from the subroutine
* 
* ******************************************************************************

BUMP2:
       movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later

       movb rx,ra                      ; TXA               ; Copy argument X into A

       .clc                            ; CLC               ; Clear the C flag so we can do addition without the
                                                           ; C flag affecting the result

       .adc @T,ra                      ; ADC T             ; Set X = A = argument X + argument A
       movb ra,rx                      ; TAX               

       jnc  RE2                        ; BCC RE2           ; If the C flag is clear, then we didn't overflow, so
                                                           ; jump to RE2 to auto-recentre and return the result

       li   rx,>ff*256                 ; LDX #255          ; We have an overflow, so set X to the maximum possible
                                                           ; value of 255

RE2:
       jgt  RE3+2                      ; BPL RE3+2         ; If X has bit 7 clear (i.e. the result < 128), then
                                                           ; jump to RE3+2 in routine REDU2 to do an auto-recentre,
                                                           ; if configured, because the result is on the left side
                                                           ; of the centre point of 128

                                                           ; Jumps to RE2+2 end up here

       movb @T,ra                      ; LDA T             ; Restore the original argument A from T into A

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: REDU2
* Type: Subroutine
* Category: Dashboard
* Summary: Reduce the value of the pitch or roll dashboard indicator
* 
* ------------------------------------------------------------------------------
* 
* Reduce X by A, where X is either the current rate of pitch or the current
* rate of roll.
* 
* The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
* This is the amount by which the pitch or roll is currently changing, so 1
* means it is decreasing at the maximum rate, 128 means it is not changing,
* and 255 means it is increasing at the maximum rate. These values correspond
* to the line on the DC or RL indicators on the dashboard, with 1 meaning full
* left, 128 meaning the middle, and 255 meaning full right.
* 
* If reducing X would bring it below 1, then X is set to 1.
* 
* If keyboard auto-recentre is configured and the result is greater than 128, we
* reduce X down to the mid-point, 128. This is the equivalent of having a roll
* or pitch in the right half of the indicator, when decreasing the roll or pitch
* should jump us straight to the mid-point.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* RE3+2               Auto-recentre the value in X, if keyboard auto-recentre
* is configured
* 
* ******************************************************************************

REDU2:
       movb ra,@T                      ; STA T             ; Store argument A in T so we can restore it later

       movb rx,ra                      ; TXA               ; Copy argument X into A

       .sec                            ; SEC               ; Set the C flag so we can do subtraction without the
                                                           ; C flag affecting the result

       .sbc @T,ra                      ; SBC T             ; Set X = A = argument X - argument A
       movb ra,rx                      ; TAX               

       joc  RE3                        ; BCS RE3           ; If the C flag is set, then we didn't underflow, so
                                                           ; jump to RE3 to auto-recentre and return the result

       li   rx,>01*256                 ; LDX #1            ; We have an underflow, so set X to the minimum possible
                                                           ; value, 1

RE3:
       jgt  RE2+2                      ; BPL RE2+2         ; If X has bit 7 clear (i.e. the result < 128), then
                                                           ; jump to RE2+2 above to return the result as is,
                                                           ; because the result is on the left side of the centre
                                                           ; point of 128, so we don't need to auto-centre

                                                           ; Jumps to RE3+2 end up here

                                                           ; If we get here, then we need to apply auto-recentre,
                                                           ; if it is configured

       movb @DJD,ra                    ; LDA DJD           ; If keyboard auto-recentre is disabled, then
       jne  RE2+2                      ; BNE RE2+2         ; jump to RE2+2 to restore A and return

       li   rx,>80*256                 ; LDX #128          ; If we get here then keyboard auto-recentre is enabled,
       jlt  RE2+2                      ; BMI RE2+2         ; so set X to 128 (the middle of our range) and jump to
                                                           ; RE2+2 to restore A and return from the subroutine
                                                           ; (this BMI is effectively a JMP as bit 7 of X is always
                                                           ; set)

* ******************************************************************************
* 
* Name: ARCTAN
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate A = arctan(P / Q)
* Deep dive: The sine, cosine and arctan tables
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* A = arctan(P / Q)
* 
* In other words, this finds the angle in the right-angled triangle where the
* opposite side to angle A is length P and the adjacent side to angle A has
* length Q, so:
* 
* tan(A) = P / Q
* 
* The result in A is an integer representing the angle in radians. The routine
* returns values in the range 0 to 128, which covers 0 to 180 degrees (or 0 to
* PI radians).
* 
* ******************************************************************************

ARCTAN:
       movb @P,ra                      ; LDA P             ; Set T1 = P EOR Q, which will have the sign of P * Q
       .eor @Q                         ; EOR Q             ; 
* AND #%10000000         \ The AND is commented out in the original source
       movb ra,@T1                     ; STA T1            

       movb @Q,ra                      ; LDA Q             ; If Q = 0, jump to AR2 to return a right angle
       jeq  AR2                        ; BEQ AR2           

       .asla                           ; ASL A             ; Set Q = |Q| * 2 (this is a quick way of clearing the
       movb ra,@Q                      ; STA Q             ; sign bit, and we don't need to shift right again as we
                                                           ; only ever use this value in the division with |P| * 2,
                                                           ; which we set next)

       movb @P,ra                      ; LDA P             ; Set A = |P| * 2
       .asla                           ; ASL A             

       cb   @Q,ra                      ; CMP Q             ; If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
       joc  AR1                        ; BCS AR1           ; and Q around, so we can still use the lookup table

       .jsr @ARS1                      ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
                                                           ; 
                                                           ; A = arctan(A / Q)
                                                           ; = arctan(|P / Q|)

       .sec                            ; SEC               ; Set the C flag so the SBC instruction in AR3 will be
                                                           ; correct, should we jump there

AR4:
       movb @T1,rx                     ; LDX T1            ; If T1 is negative, i.e. P and Q have different signs,
       jlt  AR3                        ; BMI AR3           ; jump down to AR3 to return arctan(-|P / Q|)

       .rts                            ; RTS               ; Otherwise P and Q have the same sign, so our result is
                                                           ; correct and we can return from the subroutine

AR1:
                                                           ; We want to calculate arctan(t) where |t| > 1, so we
                                                           ; can use the calculation described in the documentation
                                                           ; for the ACT table, i.e. 64 - arctan(1 / t)
       movb @Q,rx                      ; LDX Q             ; Swap the values in Q and P, using the fact that we
       movb ra,@Q                      ; STA Q             ; called AR1 with A = P
       movb rx,@P                      ; STX P             ; 
       movb rx,ra                      ; TXA               ; This also sets A = P (which now contains the original
                                                           ; argument |Q|)

       .jsr @ARS1                      ; JSR ARS1          ; Call ARS1 to set the following from the lookup table:
                                                           ; 
                                                           ; A = arctan(A / Q)
                                                           ; = arctan(|Q / P|)
                                                           ; = arctan(1 / |P / Q|)

       movb ra,@T                      ; STA T             ; Set T = 64 - T
       li   ra,>40*256                 ; LDA #64           
       .sbc @T,ra                      ; SBC T             

       joc  AR4                        ; BCS AR4           ; Jump to AR4 to continue the calculation (this BCS is
                                                           ; effectively a JMP as the subtraction will never
                                                           ; underflow, as ARS1 returns values in the range 0-31)

AR2:
                                                           ; If we get here then Q = 0, so tan(A) = infinity and
                                                           ; A is a right angle, or 0.25 of a circle. We allocate
                                                           ; 255 to a full circle, so we should return 63 for a
                                                           ; right angle
       li   ra,>3f*256                 ; LDA #63           ; Set A to 63, to represent a right angle

       .rts                            ; RTS               ; Return from the subroutine

AR3:
                                                           ; A contains arctan(|P / Q|) but P and Q have different
                                                           ; signs, so we need to return arctan(-|P / Q|), using
                                                           ; the calculation described in the documentation for the
                                                           ; ACT table, i.e. 128 - A
       movb ra,@T                      ; STA T             ; Set A = 128 - A
       li   ra,>80*256                 ; LDA #128          ; 
* SEC                    \ The SEC instruction is commented out in the original
       .sbc @T,ra                      ; SBC T             ; source, and isn't required as we did a SEC before
                                                           ; calling AR3

       .rts                            ; RTS               ; Return from the subroutine

ARS1:
                                                           ; This routine fetches arctan(A / Q) from the ACT table,
                                                           ; so A will be set to an integer in the range 0 to 31
                                                           ; that represents an angle from 0 to 45 degrees (or 0 to
                                                           ; PI / 4 radians)
       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q

       movb @R,ra                      ; LDA R             ; Set X = R / 8
       srl  ra,1                       ; LSR A             ; = 32 * A / Q
       srl  ra,1                       ; LSR A             ; 
       srl  ra,1                       ; LSR A             ; so X has the value t * 32 where t = A / Q, which is
       movb ra,rx                      ; TAX               ; what we need to look up values in the ACT table

       movb @ACT(rx),ra                ; LDA ACT,X         ; Fetch ACT+X from the ACT table into A, so now:
                                                           ; 
                                                           ; A = value in ACT + X
                                                           ; = value in ACT + (32 * A / Q)
                                                           ; = arctan(A / Q)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ACT
* Type: Variable
* Category: Maths (Geometry)
* Summary: Arctan table
* Deep dive: The sine, cosine and arctan tables
* 
* ------------------------------------------------------------------------------
* 
* This table contains lookup values for arctangent calculations involving angles
* in the range 0 to 45 degrees (or 0 to PI / 4 radians).
* 
* To calculate the value of theta in the following:
* 
* theta = arctan(t)
* 
* where 0 <= t < 1, we look up the value in:
* 
* ACT + (t * 32)
* 
* The result will be an integer representing the angle in radians, where 256
* represents a full circle of 360 degrees (2 * PI radians). The result of the
* lookup will therefore be an integer in the range 0 to 31, as this represents
* 0 to 45 degrees (0 to PI / 4 radians).
* 
* The table does not support values of t >= 1 or t < 0 directly, so if we need
* to calculate the arctangent for an angle greater than 45 degrees, we can apply
* the following calculation to the result from the table:
* 
* * For t > 1, arctan(t) = 64 - arctan(1 / t)
* 
* For negative values of t where -1 < t < 0, we can apply the following
* calculation to the result from the table:
* 
* * For t < 0, arctan(-t) = 128 - arctan(t)
* 
* Finally, if t < -1, we can do the first calculation to get arctan(|t|), and
* the second to get arctan(-|t|).
* 
* ******************************************************************************

ACT:
       ;  FOR I%, 0, 31

       ; EQUB INT((128 / PI) * ATN(I% / 32) + 0.5) ;                   

       ;  NEXT

* ******************************************************************************
* 
* Name: WARP
* Type: Subroutine
* Category: Flight
* Summary: Perform an in-system jump
* 
* ------------------------------------------------------------------------------
* 
* This is called when we press "J" during flight. The following checks are
* performed:
* 
* * Make sure we don't have any ships or space stations in the vicinity
* 
* * Make sure we are not in witchspace
* 
* * If we are facing the planet, make sure we aren't too close
* 
* * If we are facing the sun, make sure we aren't too close
* 
* If the above checks are passed, then we perform an in-system jump by moving
* the sun and planet in the opposite direction to travel, so we appear to jump
* in space. This means that any asteroids, cargo canisters or escape pods get
* dragged along for the ride.
* 
* ******************************************************************************

WARP:
       movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
       .clc                            ; CLC               ; and cargo canisters in the vicinity
       .adc @MANY+ESC,ra               ; ADC MANY+ESC      
       .clc                            ; CLC               ; The second CLC instruction has no effect, as there is
       .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; no way that adding the number of asteroids and the
       movb ra,rx                      ; TAX               ; number escape pods will cause a carry


       movb @MANY+AST,ra               ; LDA MANY+AST      ; Set X to the total number of asteroids, escape pods
       .clc                            ; CLC               ; and cargo canisters in the vicinity
       .adc @MANY+ESC,ra               ; ADC MANY+ESC      ; 
       .adc @MANY+OIL,ra               ; ADC MANY+OIL      ; This code saves one byte of memory over the code in
       movb ra,rx                      ; TAX               ; the source disc version. The second CLC is not needed
                                                           ; as there is no way that adding the number of asteroids
                                                           ; and the number of escape pods will cause a carry


       movb @FRIN+2(rx),ra             ; LDA FRIN+2,X      ; If the slot at FRIN+2+X is non-zero, then we have
                                                           ; something else in the vicinity besides asteroids,
                                                           ; escape pods and cargo canisters, so to check whether
                                                           ; we can jump, we first grab the slot contents into A

       socb @SSPR,ra                   ; ORA SSPR          ; If there is a space station nearby, then SSPR will
                                                           ; be non-zero, so OR'ing with SSPR will produce a
                                                           ; non-zero result if either A or SSPR are non-zero

       socb @MJ,ra                     ; ORA MJ            ; If we are in witchspace, then MJ will be non-zero, so
                                                           ; OR'ing with MJ will produce a non-zero result if
                                                           ; either A or SSPR or MJ are non-zero

       jne  WA1                        ; BNE WA1           ; A is non-zero if we have either a ship or a space
                                                           ; station in the vicinity, or we are in witchspace, in
                                                           ; which case jump to WA1 to make a low beep to show that
                                                           ; we can't do an in-system jump

       movb @K.+8,ry                   ; LDY K%+8          ; Otherwise we can do an in-system jump, so now we fetch
                                                           ; the byte at K%+8, which contains the z_sign for the
                                                           ; first ship slot, i.e. the distance of the planet

       jlt  WA3                        ; BMI WA3           ; If the planet's z_sign is negative, then the planet
                                                           ; is behind us, so jump to WA3 to skip the following

       movb ra,ry                      ; TAY               ; Set A = Y = 0 (as we didn't BNE above) so the call
                                                           ; to MAS2 measures the distance to the planet

       .jsr @MAS2                      ; JSR MAS2          ; Call MAS2 to set A to the largest distance to the
                                                           ; planet in any of the three axes (we could also call
                                                           ; routine m to do the same thing, as A = 0)


       ci   ra,>02*256                 ; CMP #2            ; If A < 2 then jump to WA1 to abort the in-system jump
       jnc  WA1                        ; BCC WA1           ; with a low beep, as we are facing the planet and are
                                                           ; too close to jump in that direction


       srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
       jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
                                                           ; too close to jump in that direction
                                                           ; 
                                                           ; These instructions between them save one byte of
                                                           ; memory over the CMP-based code in the source disc
                                                           ; version, as LSR A is a one-byte opcode, while CMP #2
                                                           ; takes up two bytes (though the code does exactly the
                                                           ; same thing)


WA3:
       movb @K.+NI.+8,ry               ; LDY K%+NI%+8      ; Fetch the z_sign (byte #8) of the second ship in the
                                                           ; ship data workspace at K%, which is reserved for the
                                                           ; sun or the space station (in this case it's the
                                                           ; former, as we already confirmed there isn't a space
                                                           ; station in the vicinity)

       jlt  WA2                        ; BMI WA2           ; If the sun's z_sign is negative, then the sun is
                                                           ; behind us, so jump to WA2 to skip the following

       li   ry,(NI.)*256               ; LDY #NI%          ; Set Y to point to the offset of the ship data block
                                                           ; for the sun, which is NI% (as each block is NI% bytes
                                                           ; long, and the sun is the second block)

       .jsr @m_                        ; JSR m             ; Call m to set A to the largest distance to the sun
                                                           ; in any of the three axes


       ci   ra,>02*256                 ; CMP #2            ; If A < 2 then jump to WA1 to abort the in-system jump
       jnc  WA1                        ; BCC WA1           ; with a low beep, as we are facing the planet and are
                                                           ; too close to jump in that direction


       srl  ra,1                       ; LSR A             ; If A < 2 then jump to WA1 to abort the in-system jump
       jeq  WA1                        ; BEQ WA1           ; with a low beep, as we are facing the planet and are
                                                           ; too close to jump in that direction
                                                           ; 
                                                           ; These instructions between them save one byte of
                                                           ; memory over the CMP-based code in the source disc
                                                           ; version, as LSR A is a one-byte opcode, while CMP #2
                                                           ; takes up two bytes (though the code does exactly the
                                                           ; same thing)


WA2:
                                                           ; If we get here, then we can do an in-system jump, as
                                                           ; we don't have any ships or space stations in the
                                                           ; vicinity, we are not in witchspace, and if we are
                                                           ; facing the planet or the sun, we aren't too close to
                                                           ; jump towards it
                                                           ; 
                                                           ; We do an in-system jump by moving the sun and planet,
                                                           ; rather than moving our own local bubble (this is why
                                                           ; in-system jumps drag asteroids, cargo canisters and
                                                           ; escape pods along for the ride). Specifically, we move
                                                           ; them in the z-axis by a fixed amount in the opposite
                                                           ; direction to travel, thus performing a jump towards
                                                           ; our destination
       li   ra,>81*256                 ; LDA #&81          ; Set R = R = P = &81
       movb ra,@S                      ; STA S             
       movb ra,@R                      ; STA R             
       movb ra,@P                      ; STA P             

       movb @K.+8,ra                   ; LDA K%+8          ; Set A = z_sign for the planet

       .jsr @ADD                       ; JSR ADD           ; Set (A X) = (A P) + (S R)
                                                           ; = (z_sign &81) + &8181
                                                           ; = (z_sign &81) - &0181
                                                           ; 
                                                           ; This moves the planet against the direction of travel
                                                           ; by reducing z_sign by 1, as the above maths is:
                                                           ; 
                                                           ; z_sign 00000000
                                                           ; +   00000000 10000001
                                                           ; -   00000001 10000001
                                                           ; 
                                                           ; or:
                                                           ; 
                                                           ; z_sign 00000000
                                                           ; +   00000000 00000000
                                                           ; -   00000001 00000000
                                                           ; 
                                                           ; i.e. the high byte is z_sign - 1, making sure the sign
                                                           ; is preserved

       movb ra,@K.+8                   ; STA K%+8          ; Set the planet's z_sign to the high byte of the result

       movb @K.+NI.+8,ra               ; LDA K%+NI%+8      ; Set A = z_sign for the sun

       .jsr @ADD                       ; JSR ADD           ; Set (A X) = (A P) + (S R)
                                                           ; = (z_sign &81) + &8181
                                                           ; = (z_sign &81) - &0181
                                                           ; 
                                                           ; which moves the sun against the direction of travel
                                                           ; by reducing z_sign by 1

       movb ra,@K.+NI.+8               ; STA K%+NI%+8      ; Set the planet's z_sign to the high byte of the result

       li   ra,>01*256                 ; LDA #1            ; Temporarily set the view type to a non-zero value, so
       movb ra,@QQ11                   ; STA QQ11          ; the call to LOOK1 below clears the screen before
                                                           ; switching to the space view

       movb ra,@MCNT                   ; STA MCNT          ; Set the main loop counter to 1, so the next iteration
                                                           ; through the main loop will potentially spawn ships
                                                           ; (see part 2 of the main game loop at me3)

       srl  ra,1                       ; LSR A             ; Set EV, the extra vessels spawning counter, to 0
       movb ra,@EV                     ; STA EV            ; (the LSR produces a 0 as A was previously 1)

       movb @VIEW,rx                   ; LDX VIEW          ; Set X to the current view (front, rear, left or right)
       b    @LOOK1                     ; JMP LOOK1         ; and jump to LOOK1 to initialise that view, returning
                                                           ; from the subroutine using a tail call

WA1:
       li   ra,>28*256                 ; LDA #40           ; If we get here then we can't do an in-system jump, so
       b    @NOISE                     ; JMP NOISE         ; call the NOISE routine with A = 40 to make a long, low
                                                           ; beep and return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: LASLI
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw the laser lines for when we fire our lasers
* 
* ------------------------------------------------------------------------------
* 
* Draw the laser lines, aiming them to slightly different place each time so
* they appear to flicker and dance. Also heat up the laser temperature and drain
* some energy.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LASLI2              Just draw the current laser lines without moving the
* centre point, draining energy or heating up. This has
* the effect of removing the lines from the screen
* 
* LASLI-1             Contains an RTS
* 
* ******************************************************************************

LASLI:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7

       .adi ((Y-4)*256)                ; ADC #Y-4          ; Set LASY to four pixels above the centre of the
       movb ra,@LASY                   ; STA LASY          ; screen (#Y), plus our random number, so the laser
                                                           ; dances above and below the centre point

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       andi ra,>07*256                 ; AND #7            ; Restrict A to a random value in the range 0 to 7

       .adi ((X-4)*256)                ; ADC #X-4          ; Set LASX to four pixels left of the centre of the
       movb ra,@LASX                   ; STA LASX          ; screen (#X), plus our random number, so the laser
                                                           ; dances to the left and right of the centre point

       movb @GNTMP,ra                  ; LDA GNTMP         ; Add 8 to the laser temperature in GNTMP
       .adi (>08*256)                  ; ADC #8            
       movb ra,@GNTMP                  ; STA GNTMP         

       .jsr @DENGY                     ; JSR DENGY         ; Call DENGY to deplete our energy banks by 1

LASLI2:
       movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view (i.e. QQ11 is non-zero)
       jne  PU1-1                      ; BNE PU1-1         ; then jump to MA9 to return from the main flight loop
                                                           ; (as PU1-1 is an RTS)

       li   ra,>20*256                 ; LDA #32           ; Set A = 32 and Y = 224 for the first set of laser
       li   ry,>e0*256                 ; LDY #224          ; lines (the wider pair of lines)

       .jsr @las_                      ; JSR las           ; Call las below to draw the first set of laser lines

       li   ra,>30*256                 ; LDA #48           ; Fall through into las with A = 48 and Y = 208 to draw
       li   ry,>d0*256                 ; LDY #208          ; a second set of lines (the narrower pair)

                                                           ; The following routine draws two laser lines, one from
                                                           ; the centre point down to point A on the bottom row,
                                                           ; and the other from the centre point down to point Y
                                                           ; on the bottom row. We therefore get lines from the
                                                           ; centre point to points 32, 48, 208 and 224 along the
                                                           ; bottom row, giving us the triangular laser effect
                                                           ; we're after

las_:
       movb ra,@X2                     ; STA X2            ; Set X2 = A

       movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
       movb ra,@X1                     ; STA X1            
       movb @LASY,ra                   ; LDA LASY          
       movb ra,@Y1                     ; STA Y1            

       li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
       movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
                                                           ; this sets Y2 to 191, the y-coordinate of the bottom
                                                           ; pixel row of the space view

       .jsr @LOIN                      ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
                                                           ; the centre point to (A, 191)

       movb @LASX,ra                   ; LDA LASX          ; Set (X1, Y1) to the random centre point we set above
       movb ra,@X1                     ; STA X1            
       movb @LASY,ra                   ; LDA LASY          
       movb ra,@Y1                     ; STA Y1            

       movb ry,@X2                     ; STY X2            ; Set X2 = Y

       li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
       movb ra,@Y2                     ; STA Y2            ; pixel row of the space view (as before)

       b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
                                                           ; the centre point to (Y, 191), and return from
                                                           ; the subroutine using a tail call

* ******************************************************************************
* 
* Name: PLUT
* Type: Subroutine
* Category: Flight
* Summary: Flip the coordinate axes for the four different views
* Deep dive: Flipping axes between space views
* 
* ------------------------------------------------------------------------------
* 
* This routine flips the relevant geometric axes in INWK depending on which
* view we are looking through (front, rear, left, right).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* PU1-1               Contains an RTS
* 
* ******************************************************************************

PLUT:
       movb @VIEW,rx                   ; LDX VIEW          ; Load the current view into X:
                                                           ; 
                                                           ; 0 = front
                                                           ; 1 = rear
                                                           ; 2 = left
                                                           ; 3 = right

       jne  PU1                        ; BNE PU1           ; If the current view is the front view, return from the
       .rts                            ; RTS               ; subroutine, as the geometry in INWK is already correct

PU1:
       sb   rone,rx                    ; DEX               ; Decrement the view, so now:
                                                           ; 
                                                           ; 0 = rear
                                                           ; 1 = left
                                                           ; 2 = right

       jne  PU2                        ; BNE PU2           ; If the current view is left or right, jump to PU2,
                                                           ; otherwise this is the rear view, so continue on

       movb @INWK+2,ra                 ; LDA INWK+2        ; Flip the sign of x_sign
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+2                 ; STA INWK+2        

       movb @INWK+8,ra                 ; LDA INWK+8        ; Flip the sign of z_sign
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+8                 ; STA INWK+8        

       movb @INWK+10,ra                ; LDA INWK+10       ; Flip the sign of nosev_x_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+10                ; STA INWK+10       

       movb @INWK+14,ra                ; LDA INWK+14       ; Flip the sign of nosev_z_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+14                ; STA INWK+14       

       movb @INWK+16,ra                ; LDA INWK+16       ; Flip the sign of roofv_x_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+16                ; STA INWK+16       

       movb @INWK+20,ra                ; LDA INWK+20       ; Flip the sign of roofv_z_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+20                ; STA INWK+20       

       movb @INWK+22,ra                ; LDA INWK+22       ; Flip the sign of sidev_x_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+22                ; STA INWK+22       

       movb @INWK+26,ra                ; LDA INWK+26       ; Flip the sign of roofv_z_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@INWK+26                ; STA INWK+26       

       .rts                            ; RTS               ; Return from the subroutine

PU2:
                                                           ; We enter this with X set to the view, as follows:
                                                           ; 
                                                           ; 1 = left
                                                           ; 2 = right
       li   ra,>00*256                 ; LDA #0            ; Set RAT2 = 0 (left view) or -1 (right view)
       ci   rx,>02*256                 ; CPX #2            
       .rora                           ; ROR A             
       movb ra,@RAT2                   ; STA RAT2          

       .eoi (>80*256)                  ; EOR #%10000000    ; Set RAT = -1 (left view) or 0 (right view)
       movb ra,@RAT                    ; STA RAT           

       movb @INWK,ra                   ; LDA INWK          ; Swap x_lo and z_lo
       movb @INWK+6,rx                 ; LDX INWK+6        
       movb ra,@INWK+6                 ; STA INWK+6        
       movb rx,@INWK                   ; STX INWK          

       movb @INWK+1,ra                 ; LDA INWK+1        ; Swap x_hi and z_hi
       movb @INWK+7,rx                 ; LDX INWK+7        
       movb ra,@INWK+7                 ; STA INWK+7        
       movb rx,@INWK+1                 ; STX INWK+1        

       movb @INWK+2,ra                 ; LDA INWK+2        ; Swap x_sign and z_sign
       .eor @RAT                       ; EOR RAT           ; If left view, flip sign of new z_sign
       movb ra,rx                      ; TAX               ; If right view, flip sign of new x_sign
       movb @INWK+8,ra                 ; LDA INWK+8        
       .eor @RAT2                      ; EOR RAT2          
       movb ra,@INWK+2                 ; STA INWK+2        
       movb rx,@INWK+8                 ; STX INWK+8        

       li   ry,>09*256                 ; LDY #9            ; Swap nosev_x_lo and nosev_z_lo
       .jsr @PUS1                      ; JSR PUS1          ; Swap nosev_x_hi and nosev_z_hi
                                                           ; If left view, flip sign of new nosev_z_hi
                                                           ; If right view, flip sign of new nosev_x_hi

       li   ry,>0f*256                 ; LDY #15           ; Swap roofv_x_lo and roofv_z_lo
       .jsr @PUS1                      ; JSR PUS1          ; Swap roofv_x_hi and roofv_z_hi
                                                           ; If left view, flip sign of new roofv_z_hi
                                                           ; If right view, flip sign of new roofv_x_hi

       li   ry,>15*256                 ; LDY #21           ; Swap sidev_x_lo and sidev_z_lo
                                                           ; Swap sidev_x_hi and sidev_z_hi
                                                           ; If left view, flip sign of new sidev_z_hi
                                                           ; If right view, flip sign of new sidev_x_hi

PUS1:
       movb @INWK(ry),ra               ; LDA INWK,Y        ; Swap the low x and z bytes for the vector in Y:
       movb @INWK+4(ry),rx             ; LDX INWK+4,Y      ; 
       movb ra,@INWK+4(ry)             ; STA INWK+4,Y      ; * For Y =  9 swap nosev_x_lo and nosev_z_lo
       movb rx,@INWK(ry)               ; STX INWK,Y        ; * For Y = 15 swap roofv_x_lo and roofv_z_lo
                                                           ; * For Y = 21 swap sidev_x_lo and sidev_z_lo

       movb @INWK+1(ry),ra             ; LDA INWK+1,Y      ; Swap the high x and z bytes for the offset in Y:
       .eor @RAT                       ; EOR RAT           ; 
       movb ra,rx                      ; TAX               ; * If left view, flip sign of new z-coordinate
       movb @INWK+5(ry),ra             ; LDA INWK+5,Y      ; * If right view, flip sign of new x-coordinate
       .eor @RAT2                      ; EOR RAT2          
       movb ra,@INWK+1(ry)             ; STA INWK+1,Y      
       movb rx,@INWK+5(ry)             ; STX INWK+5,Y      

                                                           ; Fall through into LOOK1 to return from the subroutine

* ******************************************************************************
* 
* Name: LOOK1
* Type: Subroutine
* Category: Flight
* Summary: Initialise the space view
* 
* ------------------------------------------------------------------------------
* 
* Initialise the space view, with the direction of view given in X. This clears
* the upper screen and draws the laser crosshairs, if the view in X has lasers
* fitted. It also wipes all the ships from the scanner, so we can recalculate
* ship positions for the new view (they get put back in the main flight loop).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The space view to set:
* 
* * 0 = front
* * 1 = rear
* * 2 = left
* * 3 = right
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LO2                 Contains an RTS
* 
* ******************************************************************************

LO2:
       .rts                            ; RTS               ; Return from the subroutine

LQ:
       movb rx,@VIEW                   ; STX VIEW          ; Set the current space view to X

       .jsr @TT66                      ; JSR TT66          ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 0 (space
                                                           ; view)

       .jsr @SIGHT                     ; JSR SIGHT         ; Draw the laser crosshairs

       b    @NWSTARS                   ; JMP NWSTARS       ; Set up a new stardust field and return from the
                                                           ; subroutine using a tail call

LOOK1:
       li   ra,>00*256                 ; LDA #0            ; Set A = 0, the type number of a space view

       movb @QQ11,ry                   ; LDY QQ11          ; If the current view is not a space view, jump up to LQ
       jne  LQ                         ; BNE LQ            ; to set up a new space view

       cb   @VIEW,rx                   ; CPX VIEW          ; If the current view is already of type X, jump to LO2
       jeq  LO2                        ; BEQ LO2           ; to return from the subroutine (as LO2 contains an RTS)

       movb rx,@VIEW                   ; STX VIEW          ; Change the current space view to X

       .jsr @TT66                      ; JSR TT66          ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 0 (space
                                                           ; view)

       .jsr @FLIP                      ; JSR FLIP          ; Swap the x- and y-coordinates of all the stardust
                                                           ; particles and redraw the stardust field

       .jsr @WPSHPS                    ; JSR WPSHPS        ; Wipe all the ships from the scanner and mark them all
                                                           ; as not being shown on-screen

                                                           ; And fall through into SIGHT to draw the laser
                                                           ; crosshairs

* ******************************************************************************
* 
* Name: SIGHT
* Type: Subroutine
* Category: Flight
* Summary: Draw the laser crosshairs
* 
* ******************************************************************************

SIGHT:
       movb @VIEW,ry                   ; LDY VIEW          ; Fetch the laser power for our new view
       movb @LASER(ry),ra              ; LDA LASER,Y       

       jeq  LO2                        ; BEQ LO2           ; If it is zero (i.e. there is no laser fitted to this
                                                           ; view), jump to LO2 to return from the subroutine (as
                                                           ; LO2 contains an RTS)

       li   ra,>80*256                 ; LDA #128          ; Set QQ19 to the x-coordinate of the centre of the
       movb ra,@QQ19                   ; STA QQ19          ; screen

       li   ra,(Y-24)*256              ; LDA #Y-24         ; Set QQ19+1 to the y-coordinate of the centre of the
       movb ra,@QQ19+1                 ; STA QQ19+1        ; screen, minus 24 (because TT15 will add 24 to the
                                                           ; coordinate when it draws the crosshairs)

       li   ra,>14*256                 ; LDA #20           ; Set QQ19+2 to size 20 for the crosshairs size
       movb ra,@QQ19+2                 ; STA QQ19+2        

       .jsr @TT15                      ; JSR TT15          ; Call TT15 to draw crosshairs of size 20 just to the
                                                           ; left of the middle of the screen

       li   ra,>0a*256                 ; LDA #10           ; Set QQ19+2 to size 10 for the crosshairs size
       movb ra,@QQ19+2                 ; STA QQ19+2        

       b    @TT15                      ; JMP TT15          ; Call TT15 to draw crosshairs of size 10 at the same
                                                           ; location, which will remove the centre part from the
                                                           ; laser crosshairs, leaving a gap in the middle, and
                                                           ; return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TT66
* Type: Subroutine
* Category: Drawing the screen
* Summary: Clear the screen and set the current view type
* 
* ------------------------------------------------------------------------------
* 
* Clear the top part of the screen, draw a white border, and set the current
* view type in QQ11 to A.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The type of the new current view (see QQ11 for a list of
* view types)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT66-2              Call TT66 with A = 1
* 
* ******************************************************************************

       li   ra,>01*256                 ; LDA #1            ; Set the view type to 1 when this is called via the
                                                           ; TT66-2 entry point

TT66:
       movb ra,@QQ11                   ; STA QQ11          ; Set the current view type in QQ11 to A

                                                           ; Fall through into TTX66 to clear the screen and draw a
                                                           ; white border

* ******************************************************************************
* 
* Name: TTX66
* Type: Subroutine
* Category: Drawing the screen
* Summary: Clear the top part of the screen and draw a white border
* 
* ------------------------------------------------------------------------------
* 
* Clear the top part of the screen (the space view) and draw a white border
* along the top and sides.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* BOX                 Just draw the border and (if this is a space view) the
* view name. This can be used to remove the border and
* view name, as it is drawn using EOR logic
* 
* ******************************************************************************

TTX66:
       li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
       movb ra,@QQ17                   ; STA QQ17          


       .asla                           ; ASL A             ; Set LASCT to 0, as 128 << 1 = %10000000 << 1 = 0. This
       movb ra,@LASCT                  ; STA LASCT         ; stops any laser pulsing


       .asla                           ; ASL A             ; Set LAS2 to 0, as 128 << 1 = %10000000 << 1 = 0. This
       movb ra,@LAS2                   ; STA LAS2          ; stops any laser pulsing


       movb ra,@DLY                    ; STA DLY           ; Set the delay in DLY to 0, to indicate that we are
                                                           ; no longer showing an in-flight message, so any new
                                                           ; in-flight messages will be shown instantly

       movb ra,@de_                    ; STA de            ; Clear de, the flag that appends " DESTROYED" to the
                                                           ; end of the next text token, so that it doesn't

       li   rx,>60*256                 ; LDX #&60          ; Set X to the screen memory page for the top row of the
                                                           ; screen (as screen memory starts at &6000)

BOL1:
       .jsr @ZES1                      ; JSR ZES1          ; Call ZES1 to zero-fill the page in X, which clears
                                                           ; that character row on the screen

       ab   rone,rx                    ; INX               ; Increment X to point to the next page, i.e. the next
                                                           ; character row

       ci   rx,>78*256                 ; CPX #&78          ; Loop back to BOL1 until we have cleared page &7700,
       jne  BOL1                       ; BNE BOL1          ; the last character row in the space view part of the
                                                           ; screen (the top part)

       movb @QQ22+1,rx                 ; LDX QQ22+1        ; Fetch into X the number that's shown on-screen during
                                                           ; the hyperspace countdown

       jeq  BOX                        ; BEQ BOX           ; If the counter is zero then we are not counting down
                                                           ; to hyperspace, so jump to BOX to skip the next
                                                           ; instruction

       .jsr @ee3_                      ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
                                                           ; i.e. print the hyperspace countdown in the top-left
                                                           ; corner

BOX:
       li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
       movb ry,@YC                     ; STY YC            

       movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to tt66 to skip
       jne  tt66_                      ; BNE tt66          ; displaying the view name

       li   ry,>0b*256                 ; LDY #11           ; Move the text cursor to row 11
       movb ry,@XC                     ; STY XC            

       movb @VIEW,ra                   ; LDA VIEW          ; Load the current view into A:
                                                           ; 
                                                           ; 0 = front
                                                           ; 1 = rear
                                                           ; 2 = left
                                                           ; 3 = right

       ori  ra,>60*256                 ; ORA #&60          ; OR with &60 so we get a value of &60 to &63 (96 to 99)

       .jsr @TT27                      ; JSR TT27          ; Print recursive token 96 to 99, which will be in the
                                                           ; range "FRONT" to "RIGHT"

       .jsr @TT162                     ; JSR TT162         ; Print a space

       li   ra,>af*256                 ; LDA #175          ; Print recursive token 15 ("VIEW ")
       .jsr @TT27                      ; JSR TT27          

tt66_:
       li   rx,>00*256                 ; LDX #0            ; Set (X1, Y1) to (0, 0)
       movb rx,@X1                     ; STX X1            
       movb rx,@Y1                     ; STX Y1            

       movb rx,@QQ17                   ; STX QQ17          ; Set QQ17 = 0 to switch to ALL CAPS

       sb   rone,rx                    ; DEX               ; Set X2 = 255
       movb rx,@X2                     ; STX X2            

       .jsr @HLOIN                     ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1), so
                                                           ; that's (0, 0) to (255, 0), along the very top of the
                                                           ; screen

       li   ra,>02*256                 ; LDA #2            ; Set X1 = X2 = 2
       movb ra,@X1                     ; STA X1            
       movb ra,@X2                     ; STA X2            

       .jsr @BOS2                      ; JSR BOS2          ; Call BOS2 below, which will call BOS1 twice, and then
                                                           ; fall through into BOS2 again, so we effectively do
                                                           ; BOS1 four times, decrementing X1 and X2 each time
                                                           ; before calling LOIN, so this whole loop-within-a-loop
                                                           ; mind-bender ends up drawing these four lines:
                                                           ; 
                                                           ; (1, 0)   to (1, 191)
                                                           ; (0, 0)   to (0, 191)
                                                           ; (255, 0) to (255, 191)
                                                           ; (254, 0) to (254, 191)
                                                           ; 
                                                           ; So that's a 2-pixel wide vertical border along the
                                                           ; left edge of the upper part of the screen, and a
                                                           ; 2-pixel wide vertical border along the right edge

BOS2:
       .jsr @BOS1                      ; JSR BOS1          ; Call BOS1 below and then fall through into it, which
                                                           ; ends up running BOS1 twice. This is all part of the
                                                           ; loop-the-loop border-drawing mind-bender explained
                                                           ; above

BOS1:
       li   ra,>00*256                 ; LDA #0            ; Set Y1 = 0
       movb ra,@Y1                     ; STA Y1            

       li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
       movb ra,@Y2                     ; STA Y2            ; y-coordinate of the mid-point of the space view, so
                                                           ; this sets Y2 to 191, the y-coordinate of the bottom
                                                           ; pixel row of the space view

       sb   rone,ra                    ; DEC X1            ; Decrement X1 and X2
       sb   rone,ra                    ; DEC X2            

       b    @LOIN                      ; JMP LOIN          ; Draw a line from (X1, Y1) to (X2, Y2), and return from
                                                           ; the subroutine using a tail call

* ******************************************************************************
* 
* Name: DELAY
* Type: Subroutine
* Category: Utility routines
* Summary: Wait for a specified time, in 1/50s of a second
* 
* ------------------------------------------------------------------------------
* 
* Wait for the number of vertical syncs given in Y, so this effectively waits
* for Y/50 of a second (as the vertical sync occurs 50 times a second).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The number of vertical sync events to wait for
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* DEL8                Wait for 8/50 of a second (0.16 seconds)
* 
* DELAY-5             Wait for 2/50 of a second (0.04 seconds)
* 
* ******************************************************************************

       li   ry,>02*256                 ; LDY #2            ; Set Y to 2 vertical syncs

       byte >2c                                                      ; Skip the next instruction by turning it into
                                                                     ; &2C &A0 &08, or BIT &08A0, which does nothing apart
                                                                     ; from affect the flags

DEL8:
       li   ry,>08*256                 ; LDY #8            ; Set Y to 8 vertical syncs and fall through into DELAY
                                                           ; to wait for this long

DELAY:
       .jsr @WSCAN                     ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
                                                           ; screen gets drawn

       sb   rone,ry                    ; DEY               ; Decrement the counter in Y

       jne  DELAY                      ; BNE DELAY         ; If Y isn't yet at zero, jump back to DELAY to wait
                                                           ; for another vertical sync

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: hm
* Type: Subroutine
* Category: Charts
* Summary: Select the closest system and redraw the chart crosshairs
* 
* ------------------------------------------------------------------------------
* 
* Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
* system, redraw the crosshairs on the chart accordingly (if they are being
* shown), and, if this is not a space view, clear the bottom three text rows of
* the screen.
* 
* ******************************************************************************

hm_:
       .jsr @TT103                     ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
                                                           ; which will erase the crosshairs currently there

       .jsr @TT111                     ; JSR TT111         ; Select the system closest to galactic coordinates
                                                           ; (QQ9, QQ10)

       .jsr @TT103                     ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
                                                           ; which will draw the crosshairs at our current home
                                                           ; system

       movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, return from the subroutine
       jeq  SC5                        ; BEQ SC5           ; (as SC5 contains an RTS)

                                                           ; Otherwise fall through into CLYNS to clear space at
                                                           ; the bottom of the screen

* ******************************************************************************
* 
* Name: CLYNS
* Type: Subroutine
* Category: Drawing the screen
* Summary: Clear the bottom three text rows of the mode 4 screen
* 
* ------------------------------------------------------------------------------
* 
* This routine clears some space at the bottom of the screen and moves the text
* cursor to column 1, row 21.
* 
* Specifically, it zeroes the following screen locations:
* 
* &7507 to &75F0
* &7607 to &76F0
* &7707 to &77F0
* 
* which clears the three bottom text rows of the mode 4 screen (rows 21 to 23),
* clearing each row from text column 1 to 30 (so it doesn't overwrite the box
* border in columns 0 and 32, or the last usable column in column 31).
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A is set to 0
* 
* Y                   Y is set to 0
* 
* ******************************************************************************

CLYNS:
       li   ra,>14*256                 ; LDA #20           ; Move the text cursor to row 20, near the bottom of
       movb ra,@YC                     ; STA YC            ; the screen

       li   ra,>75*256                 ; LDA #&75          ; Set the two-byte value in SC to &7507
       movb ra,@SC+1                   ; STA SC+1          
       li   ra,>07*256                 ; LDA #7            
       movb ra,@SC                     ; STA SC            

       .jsr @TT67                      ; JSR TT67          ; Print a newline, which will move the text cursor down
                                                           ; a line (to row 21) and back to column 1

       li   ra,>00*256                 ; LDA #0            ; Call LYN to clear the pixels from &7507 to &75F0
       .jsr @LYN                       ; JSR LYN           

       ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7607

       .jsr @LYN                       ; JSR LYN           ; Call LYN to clear the pixels from &7607 to &76F0

       ab   rone,ra                    ; INC SC+1          ; Increment SC+1 so SC points to &7707

       ab   rone,ry                    ; INY               ; Move the text cursor to column 1 (as LYN sets Y to 0)
       movb ry,@XC                     ; STY XC            

                                                           ; Fall through into LYN to clear the pixels from &7707
                                                           ; to &77F0

* ******************************************************************************
* 
* Name: LYN
* Type: Subroutine
* Category: Drawing the screen
* Summary: Clear most of a row of pixels
* 
* ------------------------------------------------------------------------------
* 
* Set pixels 0-233 to the value in A, starting at the pixel pointed to by SC.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The value to store in pixels 1-233 (the only value that
* is actually used is A = 0, which clears those pixels)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is set to 0
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* SC5                 Contains an RTS
* 
* ******************************************************************************

LYN:
       li   ry,>e9*256                 ; LDY #233          ; Set up a counter in Y to count down from pixel 233

EE2:
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Store A in the Y-th byte after the address pointed to
                                                           ; by SC

       sb   rone,ry                    ; DEY               ; Decrement Y

       jne  EE2                        ; BNE EE2           ; Loop back until Y is zero

SC5:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SCAN
* Type: Subroutine
* Category: Dashboard
* Summary: Display the current ship on the scanner
* Deep dive: The 3D scanner
* 
* ------------------------------------------------------------------------------
* 
* This is used both to display a ship on the scanner, and to erase it again.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* INWK                The ship's data block
* 
* ******************************************************************************

SCAN:
       movb @INWK+31,ra                ; LDA INWK+31       ; Fetch the ship's scanner flag from byte #31

       andi ra,>10*256                 ; AND #%00010000    ; If bit 4 is clear then the ship should not be shown
       jeq  SC5                        ; BEQ SC5           ; on the scanner, so return from the subroutine (as SC5
                                                           ; contains an RTS)

       movb @TYPE,ra                   ; LDA TYPE          ; Fetch the ship's type from TYPE into A

       jlt  SC5                        ; BMI SC5           ; If this is the planet or the sun, then the type will
                                                           ; have bit 7 set and we don't want to display it on the
                                                           ; scanner, so return from the subroutine (as SC5
                                                           ; contains an RTS)

       li   rx,>ff*256                 ; LDX #&FF          ; Set X to the default scanner colour of green/cyan
                                                           ; (a 4-pixel mode 5 byte in colour 3)

* CMP #TGL               \ These instructions are commented out in the original
* BEQ SC49               \ source. Along with the block just below, they would
                                                           ; set X to colour 1 (red) for asteroids, cargo canisters
                                                           ; and escape pods, rather than green/cyan. Presumably
                                                           ; they decided it didn't work that well against the red
                                                           ; ellipse and took this code out for release

       ci   ra,(MSL)*256               ; CMP #MSL          ; If this is not a missile, skip the following
       jne  B47                        ; BNE B47           ; instruction

       li   rx,>f0*256                 ; LDX #&F0          ; This is a missile, so set X to colour 2 (yellow/white)

B47:
* CMP #AST               \ These instructions are commented out in the original
* BCC P%+4               \ source. See above for an explanation of what they do
* LDX #&0F
* .SC49
       movb rx,@COL                    ; STX COL           ; Store X, the colour of this ship on the scanner, in
                                                           ; COL

       movb @INWK+1,ra                 ; LDA INWK+1        ; If any of x_hi, y_hi and z_hi have a 1 in bit 6 or 7,
       socb @INWK+4,ra                 ; ORA INWK+4        ; then the ship is too far away to be shown on the
       socb @INWK+7,ra                 ; ORA INWK+7        ; scanner, so return from the subroutine (as SC5
       andi ra,>c0*256                 ; AND #%11000000    ; contains an RTS)
       jne  SC5                        ; BNE SC5           

                                                           ; If we get here, we know x_hi, y_hi and z_hi are all
                                                           ; 63 (%00111111) or less

                                                           ; Now, we convert the x_hi coordinate of the ship into
                                                           ; the screen x-coordinate of the dot on the scanner,
                                                           ; using the following (see the deep dive on "The 3D
                                                           ; scanner" for an explanation):
                                                           ; 
                                                           ; X1 = 123 + (x_sign x_hi)

       movb @INWK+1,ra                 ; LDA INWK+1        ; Set A = x_hi

       .clc                            ; CLC               ; Clear the C flag so we can do addition below

       movb @INWK+2,rx                 ; LDX INWK+2        ; Set X = x_sign

       jgt  SC2                        ; BPL SC2           ; If x_sign is positive, skip the following

       .eoi (>ff*256)                  ; EOR #%11111111    ; x_sign is negative, so flip the bits in A and add 1
       .adi (>01*256)                  ; ADC #1            ; to make it a negative number (bit 7 will now be set
                                                           ; as we confirmed above that bits 6 and 7 are clear). So
                                                           ; this gives A the sign of x_sign and gives it a value
                                                           ; range of -63 (%11000001) to 0

SC2:
       .adi (>7b*256)                  ; ADC #123          ; Set X1 = 123 + (x_sign x_hi)
       movb ra,@X1                     ; STA X1            

                                                           ; Next, we convert the z_hi coordinate of the ship into
                                                           ; the y-coordinate of the base of the ship's stick,
                                                           ; like this (see the deep dive on "The 3D scanner" for
                                                           ; an explanation):
                                                           ; 
                                                           ; SC = 220 - (z_sign z_hi) / 4
                                                           ; 
                                                           ; though the following code actually does it like this:
                                                           ; 
                                                           ; SC = 255 - (35 + z_hi / 4)

       movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi / 4
       srl  ra,1                       ; LSR A             ; 
       srl  ra,1                       ; LSR A             ; So A is in the range 0-15

       .clc                            ; CLC               ; Clear the C flag for the addition below

       movb @INWK+8,rx                 ; LDX INWK+8        ; Set X = z_sign

       jgt  SC3                        ; BPL SC3           ; If z_sign is positive, skip the following

       .eoi (>ff*256)                  ; EOR #%11111111    ; z_sign is negative, so flip the bits in A and set the
       .sec                            ; SEC               ; C flag. As above, this makes A negative, this time
                                                           ; with a range of -16 (%11110000) to -1 (%11111111). And
                                                           ; as we are about to do an ADC, the SEC effectively adds
                                                           ; another 1 to that value, giving a range of -15 to 0

SC3:
       .adi (>23*256)                  ; ADC #35           ; Set A = 35 + A to give a number in the range 20 to 50

       .eoi (>ff*256)                  ; EOR #%11111111    ; Flip all the bits and store in SC, so SC is in the
       movb ra,@SC                     ; STA SC            ; range 205 to 235, with a higher z_hi giving a lower SC

                                                           ; Now for the stick height, which we calculate using the
                                                           ; following (see the deep dive on "The 3D scanner" for
                                                           ; an explanation):
                                                           ; 
                                                           ; A = - (y_sign y_hi) / 2

       movb @INWK+4,ra                 ; LDA INWK+4        ; Set A = y_hi / 2
       srl  ra,1                       ; LSR A             

       .clc                            ; CLC               ; Clear the C flag

       movb @INWK+5,rx                 ; LDX INWK+5        ; Set X = y_sign

       jlt  SCD6                       ; BMI SCD6          ; If y_sign is negative, skip the following, as we
                                                           ; already have a positive value in A

       .eoi (>ff*256)                  ; EOR #%11111111    ; y_sign is positive, so flip the bits in A and set the
       .sec                            ; SEC               ; C flag. This makes A negative, and as we are about to
                                                           ; do an ADC below, the SEC effectively adds another 1 to
                                                           ; that value to implement two's complement negation, so
                                                           ; we don't need to add another 1 here

SCD6:
                                                           ; We now have all the information we need to draw this
                                                           ; ship on the scanner, namely:
                                                           ; 
                                                           ; X1 = the screen x-coordinate of the ship's dot
                                                           ; 
                                                           ; SC = the screen y-coordinate of the base of the
                                                           ; stick
                                                           ; 
                                                           ; A = the screen height of the ship's stick, with the
                                                           ; correct sign for adding to the base of the stick
                                                           ; to get the dot's y-coordinate
                                                           ; 
                                                           ; First, though, we have to make sure the dot is inside
                                                           ; the dashboard, by moving it if necessary
       .adc @SC,ra                     ; ADC SC            ; Set A = SC + A, so A now contains the y-coordinate of
                                                           ; the end of the stick, plus the length of the stick, to
                                                           ; give us the screen y-coordinate of the dot

       jgt  ld246_                     ; BPL ld246         ; If the result has bit 0 clear, then the result has
                                                           ; overflowed and is bigger than 256, so jump to ld246 to
                                                           ; set A to the maximum allowed value of 246 (this
                                                           ; instruction isn't required as we test both the maximum
                                                           ; and minimum below, but it might save a few cycles)

       ci   ra,>c2*256                 ; CMP #194          ; If A >= 194, skip the following instruction, as 194 is
       joc  B48                        ; BCS B48           ; the minimum allowed value of A

       li   ra,>c2*256                 ; LDA #194          ; A < 194, so set A to 194, the minimum allowed value
                                                           ; for the y-coordinate of our ship's dot

B48:
       ci   ra,>f7*256                 ; CMP #247          ; If A < 247, skip the following instruction, as 246 is
       jnc  B49                        ; BCC B49           ; the maximum allowed value of A

ld246_:
       equ  $
B49:
       li   ra,>f6*256                 ; LDA #246          ; A >= 247, so set A to 246, the maximum allowed value
                                                           ; for the y-coordinate of our ship's dot

       movb ra,@Y1                     ; STA Y1            ; Store A in Y1, as it now contains the screen
                                                           ; y-coordinate for the ship's dot, clipped so that it
                                                           ; fits within the dashboard

       .sec                            ; SEC               ; Set A = A - SC to get the stick length, by reversing
       .sbc @SC,ra                     ; SBC SC            ; the ADC SC we did above. This clears the C flag if the
                                                           ; result is negative (i.e. the stick length is negative)
                                                           ; and sets it if the result is positive (i.e. the stick
                                                           ; length is negative)

                                                           ; So now we have the following:
                                                           ; 
                                                           ; X1 = the screen x-coordinate of the ship's dot,
                                                           ; clipped to fit into the dashboard
                                                           ; 
                                                           ; Y1 = the screen y-coordinate of the ship's dot,
                                                           ; clipped to fit into the dashboard
                                                           ; 
                                                           ; SC = the screen y-coordinate of the base of the
                                                           ; stick
                                                           ; 
                                                           ; A = the screen height of the ship's stick, with the
                                                           ; correct sign for adding to the base of the stick
                                                           ; to get the dot's y-coordinate
                                                           ; 
                                                           ; C = 0 if A is negative, 1 if A is positive
                                                           ; 
                                                           ; and we can get on with drawing the dot and stick

       .php                            ; PHP               ; Store the flags (specifically the C flag) from the
                                                           ; above subtraction

* BCS SC48               \ These instructions are commented out in the original
* EOR #&FF               \ source. They would negate A if the C flag were set,
* ADC #1                 \ which would reverse the direction of all the sticks,
                                                           ; so you could turn your joystick around. Perhaps one of
                                                           ; the authors' test sticks was easier to use upside
                                                           ; down? Who knows...

SC48:
       .pha                            ; PHA               ; Store the stick height in A on the stack

       .jsr @CPIX4                     ; JSR CPIX4         ; Draw a double-height dot at (X1, Y1). This also leaves
                                                           ; the following variables set up for the dot's top-right
                                                           ; pixel, the last pixel to be drawn (as the dot gets
                                                           ; drawn from the bottom up):
                                                           ; 
                                                           ; SC(1 0) = screen address of the pixel's character
                                                           ; block
                                                           ; 
                                                           ; Y = number of the character row containing the pixel
                                                           ; 
                                                           ; X = the pixel's number (0-3) in that row
                                                           ; 
                                                           ; We can use there as the starting point for drawing the
                                                           ; stick, if there is one

       movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Load the same mode 5 1-pixel byte that we just used
       .and @COL                       ; AND COL           ; for the top-right pixel, and mask it with the same
       movb ra,@X1                     ; STA X1            ; colour, storing the result in X1, so we can use it as
                                                           ; the character row byte for the stick

       .pla                            ; PLA               ; Restore the stick height from the stack into A

       .plp                            ; PLP               ; Restore the flags from above, so the C flag once again
                                                           ; reflects the sign of the stick height

       movb ra,rx                      ; TAX               ; Copy the stick height into X

       jeq  RTS                        ; BEQ RTS           ; If the stick height is zero, then there is no stick to
                                                           ; draw, so return from the subroutine (as RTS contains
                                                           ; an RTS)

       jnc  RTS+1                      ; BCC RTS+1         ; If the C flag is clear then the stick height in A is
                                                           ; negative, so jump down to RTS+1

VLL1:
                                                           ; If we get here then the stick length is positive (so
                                                           ; the dot is below the ellipse and the stick is above
                                                           ; the dot, and we need to draw the stick upwards from
                                                           ; the dot)
       sb   rone,ry                    ; DEY               ; We want to draw the stick upwards, so decrement the
                                                           ; pixel row in Y

       jgt  VL1                        ; BPL VL1           ; If Y is still positive then it correctly points at the
                                                           ; line above, so jump to VL1 to skip the following

       li   ry,>07*256                 ; LDY #7            ; We just decremented Y up through the top of the
                                                           ; character block, so we need to move it to the last row
                                                           ; in the character above, so set Y to 7, the number of
                                                           ; the last row

       sb   rone,ra                    ; DEC SC+1          ; Decrement the high byte of the screen address to move
                                                           ; to the character block above

VL1:
       movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
                                                           ; we stored in X1 above, and which has the same pixel
                                                           ; pattern as the bottom-right pixel of the dot (so the
                                                           ; stick comes out of the right side of the dot)

       .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic

       sb   rone,rx                    ; DEX               ; Decrement the (positive) stick height in X

       jne  VLL1                       ; BNE VLL1          ; If we still have more stick to draw, jump up to VLL1
                                                           ; to draw the next pixel

RTS:
       .rts                            ; RTS               ; Return from the subroutine

                                                           ; If we get here then the stick length is negative (so
                                                           ; the dot is above the ellipse and the stick is below
                                                           ; the dot, and we need to draw the stick downwards from
                                                           ; the dot)

       ab   rone,ry                    ; INY               ; We want to draw the stick downwards, so we first
                                                           ; increment the row counter so that it's pointing to the
                                                           ; bottom-right pixel in the dot (as opposed to the top-
                                                           ; right pixel that the call to CPIX4 finished on)

       ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
       jne  VLL2                       ; BNE VLL2          ; correctly points at the next line down, so jump to
                                                           ; VLL2 to skip the following

       li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
                                                           ; character block, so we need to move it to the first
                                                           ; row in the character below, so set Y to 0, the number
                                                           ; of the first row

       ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
                                                           ; to the character block above

VLL2:
       ab   rone,ry                    ; INY               ; We want to draw the stick itself, heading downwards,
                                                           ; so increment the pixel row in Y

       ci   ry,>08*256                 ; CPY #8            ; If the row number in Y is less than 8, then it
       jne  VL2                        ; BNE VL2           ; correctly points at the next line down, so jump to
                                                           ; VL2 to skip the following

       li   ry,>00*256                 ; LDY #0            ; We just incremented Y down through the bottom of the
                                                           ; character block, so we need to move it to the first
                                                           ; row in the character below, so set Y to 0, the number
                                                           ; of the first row

       ab   rone,ra                    ; INC SC+1          ; Increment the high byte of the screen address to move
                                                           ; to the character block above

VL2:
       movb @X1,ra                     ; LDA X1            ; Set A to the character row byte for the stick, which
                                                           ; we stored in X1 above, and which has the same pixel
                                                           ; pattern as the bottom-right pixel of the dot (so the
                                                           ; stick comes out of the right side of the dot)

       .eor @SC                        ; EOR (SC),Y        ; Draw the stick on row Y of the character block using
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; EOR logic

       ab   rone,rx                    ; INX               ; Increment the (negative) stick height in X

       jne  VLL2                       ; BNE VLL2          ; If we still have more stick to draw, jump up to VLL2
                                                           ; to draw the next pixel

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: WSCAN
* Type: Subroutine
* Category: Drawing the screen
* Summary: Wait for the vertical sync
* 
* ------------------------------------------------------------------------------
* 
* Wait for vertical sync to occur on the video system - in other words, wait
* for the screen to start its refresh cycle, which it does 50 times a second
* (50Hz).
* 
* ******************************************************************************

WSCAN:
       li   ra,>00*256                 ; LDA #0            ; Set DL to 0
       movb ra,@DL                     ; STA DL            

B50:
       movb @DL,ra                     ; LDA DL            ; Loop round these two instructions until DL is no
       jeq  B50                        ; BEQ B50           ; longer 0 (DL gets set to 30 in the LINSCN routine,
                                                           ; which is run when vertical sync has occurred on the
                                                           ; video system, so DL will change to a non-zero value
                                                           ; at the start of each screen refresh)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Save ELTC.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE D FILE
* 
* Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_D.:
       equ $

LOAD_D.:
       equ LOAD. + $ - CODE.

* ******************************************************************************
* 
* Name: tnpr
* Type: Subroutine
* Category: Market
* Summary: Work out if we have space for a specific amount of cargo
* 
* ------------------------------------------------------------------------------
* 
* Given a market item and an amount, work out whether there is room in the
* cargo hold for this item.
* 
* For standard tonne canisters, the limit is given by the type of cargo hold we
* have, with a standard cargo hold having a capacity of 20t and an extended
* cargo bay being 35t.
* 
* For items measured in kg (gold, platinum), g (gem-stones) and alien items,
* the individual limit on each of these is 200 units.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The number of units of this market item
* 
* QQ29                The type of market item (see QQ23 for a list of market
* item numbers)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A is preserved
* 
* C flag              Returns the result:
* 
* * Set if there is no room for this item
* 
* * Clear if there is room for this item
* 
* ******************************************************************************

tnpr_:
       .pha                            ; PHA               ; Store A on the stack

       li   rx,>0c*256                 ; LDX #12           ; If QQ29 > 12 then jump to kg below, as this cargo
       cb   @QQ29,rx                   ; CPX QQ29          ; type is gold, platinum, gem-stones or alien items,
       jnc  kg_                        ; BCC kg            ; and they have different cargo limits to the standard
                                                           ; tonne canisters

Tml:
                                                           ; Here we count the tonne canisters we have in the hold
                                                           ; and add to A to see if we have enough room for A more
                                                           ; tonnes of cargo, using X as the loop counter, starting
                                                           ; with X = 12
       .adc @QQ20(rx),ra               ; ADC QQ20,X        ; Set A = A + the number of tonnes we have in the hold
                                                           ; of market item number X. Note that the first time we
                                                           ; go round this loop, the C flag is set (as we didn't
                                                           ; branch with the BCC above, so the effect of this loop
                                                           ; is to count the number of tonne canisters in the hold,
                                                           ; and add 1

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  Tml                        ; BPL Tml           ; Loop back to add in the next market item in the hold,
                                                           ; until we have added up all market items from 12
                                                           ; (minerals) down to 0 (food)

       cb   @CRGO,ra                   ; CMP CRGO          ; If A < CRGO then the C flag will be clear (we have
                                                           ; room in the hold)
                                                           ; 
                                                           ; If A >= CRGO then the C flag will be set (we do not
                                                           ; have room in the hold)
                                                           ; 
                                                           ; This works because A contains the number of canisters
                                                           ; plus 1, while CRGO contains our cargo capacity plus 2,
                                                           ; so if we actually have "a" canisters and a capacity
                                                           ; of "c", then:
                                                           ; 
                                                           ; A < CRGO means: a+1 <  c+2
                                                           ; a   <  c+1
                                                           ; a   <= c
                                                           ; 
                                                           ; So this is why the value in CRGO is 2 higher than the
                                                           ; actual cargo bay size, i.e. it's 22 for the standard
                                                           ; 20-tonne bay, and 37 for the large 35-tonne bay

       .pla                            ; PLA               ; Restore A from the stack

       .rts                            ; RTS               ; Return from the subroutine

kg_:
                                                           ; Here we count the number of items of this type that
                                                           ; we already have in the hold, and add to A to see if
                                                           ; we have enough room for A more units
       movb @QQ29,ry                   ; LDY QQ29          ; Set Y to the item number we want to add

       .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; Set A = A + the number of units of this item that we
                                                           ; already have in the hold

       ci   ra,>c8*256                 ; CMP #200          ; Is the result greater than 200 (the limit on
                                                           ; individual stocks of gold, platinum, gem-stones and
                                                           ; alien items)?
                                                           ; 
                                                           ; If so, this sets the C flag (no room)
                                                           ; 
                                                           ; Otherwise it is clear (we have room)

       .pla                            ; PLA               ; Restore A from the stack

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT20
* Type: Subroutine
* Category: Universe
* Summary: Twist the selected system's seeds four times
* Deep dive: Twisting the system seeds
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Twist the three 16-bit seeds in QQ15 (selected system) four times, to
* generate the next system.
* 
* ******************************************************************************

TT20:
       .jsr @B51                       ; JSR B51           ; This line calls the line below as a subroutine, which
                                                           ; does two twists before returning here, and then we
                                                           ; fall through to the line below for another two
                                                           ; twists, so the net effect of these two consecutive
                                                           ; JSR calls is four twists, not counting the ones
                                                           ; inside your head as you try to follow this process

B51:
       .jsr @TT54                      ; JSR TT54          ; This line calls TT54 as a subroutine to do a twist,
                                                           ; and then falls through into TT54 to do another twist
                                                           ; before returning from the subroutine

* ******************************************************************************
* 
* Name: TT54
* Type: Subroutine
* Category: Universe
* Summary: Twist the selected system's seeds
* Deep dive: Twisting the system seeds
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* This routine twists the three 16-bit seeds in QQ15 once.
* 
* If we start with seeds s0, s1 and s2 and we want to work out their new values
* after we perform a twist (let's call the new values s0´, s1´ and s2´), then:
* 
* s0´ = s1
* s1´ = s2
* s2´ = s0 + s1 + s2
* 
* So given an existing set of seeds in s0, s1 and s2, we can get the new values
* s0´, s1´ and s2´ simply by doing the above sums. And if we want to do the
* above in-place without creating three new s´ variables, then we can do the
* following:
* 
* tmp = s0 + s1
* s0 = s1
* s1 = s2
* s2 = tmp + s1
* 
* So this is what we do in this routine, where each seed is a 16-bit number.
* 
* ******************************************************************************

TT54:
       movb @QQ15,ra                   ; LDA QQ15          ; X = tmp_lo = s0_lo + s1_lo
       .clc                            ; CLC               
       .adc @QQ15+2,ra                 ; ADC QQ15+2        
       movb ra,rx                      ; TAX               

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Y = tmp_hi = s1_hi + s1_hi + C
       .adc @QQ15+3,ra                 ; ADC QQ15+3        
       movb ra,ry                      ; TAY               

       movb @QQ15+2,ra                 ; LDA QQ15+2        ; s0_lo = s1_lo
       movb ra,@QQ15                   ; STA QQ15          

       movb @QQ15+3,ra                 ; LDA QQ15+3        ; s0_hi = s1_hi
       movb ra,@QQ15+1                 ; STA QQ15+1        

       movb @QQ15+5,ra                 ; LDA QQ15+5        ; s1_hi = s2_hi
       movb ra,@QQ15+3                 ; STA QQ15+3        

       movb @QQ15+4,ra                 ; LDA QQ15+4        ; s1_lo = s2_lo
       movb ra,@QQ15+2                 ; STA QQ15+2        

       .clc                            ; CLC               ; s2_lo = X + s1_lo
       movb rx,ra                      ; TXA               
       .adc @QQ15+2,ra                 ; ADC QQ15+2        
       movb ra,@QQ15+4                 ; STA QQ15+4        

       movb ry,ra                      ; TYA               ; s2_hi = Y + s1_hi + C
       .adc @QQ15+3,ra                 ; ADC QQ15+3        
       movb ra,@QQ15+5                 ; STA QQ15+5        

       .rts                            ; RTS               ; The twist is complete so return from the subroutine

* ******************************************************************************
* 
* Name: TT146
* Type: Subroutine
* Category: Universe
* Summary: Print the distance to the selected system in light years
* 
* ------------------------------------------------------------------------------
* 
* If it is non-zero, print the distance to the selected system in light years.
* If it is zero, just move the text cursor down a line.
* 
* Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
* then a colon, then the distance to one decimal place, then token 35 ("LIGHT
* YEARS"). If the distance is zero, move the cursor down one line.
* 
* ******************************************************************************

TT146:
       movb @QQ8,ra                    ; LDA QQ8           ; Take the two bytes of the 16-bit value in QQ8 and
       socb @QQ8+1,ra                  ; ORA QQ8+1         ; OR them together to check whether there are any
       jne  TT63                       ; BNE TT63          ; non-zero bits, and if so, jump to TT63 to print the
                                                           ; distance

       ab   rone,ra                    ; INC YC            ; The distance is zero, so we just move the text cursor
       .rts                            ; RTS               ; in YC down by one line and return from the subroutine

TT63:
       li   ra,>bf*256                 ; LDA #191          ; Print recursive token 31 ("DISTANCE") followed by
       .jsr @TT68                      ; JSR TT68          ; a colon

       movb @QQ8,rx                    ; LDX QQ8           ; Load (Y X) from QQ8, which contains the 16-bit
       movb @QQ8+1,ry                  ; LDY QQ8+1         ; distance we want to show

       .sec                            ; SEC               ; Set the C flag so that the call to pr5 will include a
                                                           ; decimal point, and display the value as (Y X) / 10

       .jsr @pr5_                      ; JSR pr5           ; Print (Y X) to 5 digits, including a decimal point

       li   ra,>c3*256                 ; LDA #195          ; Set A to the recursive token 35 (" LIGHT YEARS") and
                                                           ; fall through into TT60 to print the token followed
                                                           ; by a paragraph break

* ******************************************************************************
* 
* Name: TT60
* Type: Subroutine
* Category: Text
* Summary: Print a text token and a paragraph break
* 
* ------------------------------------------------------------------------------
* 
* Print a text token (i.e. a character, control code, two-letter token or
* recursive token). Then print a paragraph break (a blank line between
* paragraphs) by moving the cursor down a line, setting Sentence Case, and then
* printing a newline.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

TT60:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A and fall through into TTX69
                                                           ; to print the paragraph break

* ******************************************************************************
* 
* Name: TTX69
* Type: Subroutine
* Category: Text
* Summary: Print a paragraph break
* 
* ------------------------------------------------------------------------------
* 
* Print a paragraph break (a blank line between paragraphs) by moving the cursor
* down a line, setting Sentence Case, and then printing a newline.
* 
* ******************************************************************************

TTX69:
       ab   rone,ra                    ; INC YC            ; Move the text cursor down a line

                                                           ; Fall through into TT69 to set Sentence Case and print
                                                           ; a newline

* ******************************************************************************
* 
* Name: TT69
* Type: Subroutine
* Category: Text
* Summary: Set Sentence Case and print a newline
* 
* ******************************************************************************

TT69:
       li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
       movb ra,@QQ17                   ; STA QQ17          

                                                           ; Fall through into TT67 to print a newline

* ******************************************************************************
* 
* Name: TT67
* Type: Subroutine
* Category: Text
* Summary: Print a newline
* 
* ******************************************************************************

TT67:
       li   ra,>0d*256                 ; LDA #13           ; Load a newline character into A

       b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: TT70
* Type: Subroutine
* Category: Universe
* Summary: Display "MAINLY " and jump to TT72
* 
* ------------------------------------------------------------------------------
* 
* This subroutine is called by TT25 when displaying a system's economy.
* 
* ******************************************************************************

TT70:
       li   ra,>ad*256                 ; LDA #173          ; Print recursive token 13 ("MAINLY ")
       .jsr @TT27                      ; JSR TT27          

       b    @TT72                      ; JMP TT72          ; Jump to TT72 to continue printing system data as part
                                                           ; of routine TT25

* ******************************************************************************
* 
* Name: spc
* Type: Subroutine
* Category: Text
* Summary: Print a text token followed by a space
* 
* ------------------------------------------------------------------------------
* 
* Print a text token (i.e. a character, control code, two-letter token or
* recursive token) followed by a space.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

spc_:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A

       b    @TT162                     ; JMP TT162         ; Print a space and return from the subroutine using a
                                                           ; tail call

* ******************************************************************************
* 
* Name: TT25
* Type: Subroutine
* Category: Universe
* Summary: Show the Data on System screen (red key f6)
* Deep dive: Generating system data
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT72                Used by TT70 to re-enter the routine after displaying
* "MAINLY" for the economy type
* 
* ******************************************************************************

TT25:
       .jsr @TT66-2                    ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 1

       li   ra,>09*256                 ; LDA #9            ; Move the text cursor to column 9
       movb ra,@XC                     ; STA XC            

       li   ra,>a3*256                 ; LDA #163          ; Print recursive token 3 as a title in capitals at
       .jsr @TT27                      ; JSR TT27          ; the top ("DATA ON {selected system name}")

       .jsr @NLIN                      ; JSR NLIN          ; Draw a horizontal line underneath the title

       .jsr @TTX69                     ; JSR TTX69         ; Print a paragraph break and set Sentence Case

       ab   rone,ra                    ; INC YC            ; Move the text cursor down one more line

       .jsr @TT146                     ; JSR TT146         ; If the distance to this system is non-zero, print
                                                           ; "DISTANCE", then the distance, "LIGHT YEARS" and a
                                                           ; paragraph break, otherwise just move the cursor down
                                                           ; a line

       li   ra,>c2*256                 ; LDA #194          ; Print recursive token 34 ("ECONOMY") followed by
       .jsr @TT68                      ; JSR TT68          ; a colon

       movb @QQ3,ra                    ; LDA QQ3           ; The system economy is determined by the value in QQ3,
                                                           ; so fetch it into A. First we work out the system's
                                                           ; prosperity as follows:
                                                           ; 
                                                           ; QQ3 = 0 or 5 = %000 or %101 = Rich
                                                           ; QQ3 = 1 or 6 = %001 or %110 = Average
                                                           ; QQ3 = 2 or 7 = %010 or %111 = Poor
                                                           ; QQ3 = 3 or 4 = %011 or %100 = Mainly

       .clc                            ; CLC               ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
       .adi (>01*256)                  ; ADC #1            ; (3 or 4), then call TT70, which prints "MAINLY " and
       srl  ra,1                       ; LSR A             ; jumps down to TT72 to print the type of economy
       ci   ra,>02*256                 ; CMP #%00000010    
       jeq  TT70                       ; BEQ TT70          

       movb @QQ3,ra                    ; LDA QQ3           ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
       jnc  TT71                       ; BCC TT71          ; %010 (0, 1 or 2), then jump to TT71 with A set to the
                                                           ; original value of QQ3

       .sbi (>05*256)                  ; SBC #5            ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
       .clc                            ; CLC               ; 5 to bring it down to 0, 1 or 2 (the C flag is already
                                                           ; set so the SBC will be correct)

TT71:
       .adi (>aa*256)                  ; ADC #170          ; A is now 0, 1 or 2, so print recursive token 10 + A.
       .jsr @TT27                      ; JSR TT27          ; This means that:
                                                           ; 
                                                           ; QQ3 = 0 or 5 prints token 10 ("RICH ")
                                                           ; QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
                                                           ; QQ3 = 2 or 7 prints token 12 ("POOR ")

TT72:
       movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the type of economy, which is
       srl  ra,1                       ; LSR A             ; determined by bit 2 of QQ3, as follows:
       srl  ra,1                       ; LSR A             ; 
                                                           ; QQ3 bit 2 = 0 = Industrial
                                                           ; QQ3 bit 2 = 1 = Agricultural
                                                           ; 
                                                           ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
                                                           ; two right shifts (which will work as QQ3 is only a
                                                           ; 3-bit number)

       .clc                            ; CLC               ; Print recursive token 8 + A, followed by a paragraph
       .adi (>a8*256)                  ; ADC #168          ; break and Sentence Case, so:
       .jsr @TT60                      ; JSR TT60          ; 
                                                           ; QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
                                                           ; QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")

       li   ra,>a2*256                 ; LDA #162          ; Print recursive token 2 ("GOVERNMENT") followed by
       .jsr @TT68                      ; JSR TT68          ; a colon

       movb @QQ4,ra                    ; LDA QQ4           ; The system's government is determined by the value in
                                                           ; QQ4, so fetch it into A

       .clc                            ; CLC               ; Print recursive token 17 + A, followed by a paragraph
       .adi (>b1*256)                  ; ADC #177          ; break and Sentence Case, so:
       .jsr @TT60                      ; JSR TT60          ; 
                                                           ; QQ4 = 0 prints token 17 ("ANARCHY")
                                                           ; QQ4 = 1 prints token 18 ("FEUDAL")
                                                           ; QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
                                                           ; QQ4 = 3 prints token 20 ("DICTATORSHIP")
                                                           ; QQ4 = 4 prints token 21 ("COMMUNIST")
                                                           ; QQ4 = 5 prints token 22 ("CONFEDERACY")
                                                           ; QQ4 = 6 prints token 23 ("DEMOCRACY")
                                                           ; QQ4 = 7 prints token 24 ("CORPORATE STATE")

       li   ra,>c4*256                 ; LDA #196          ; Print recursive token 36 ("TECH.LEVEL") followed by a
       .jsr @TT68                      ; JSR TT68          ; colon

       movb @QQ5,rx                    ; LDX QQ5           ; Fetch the tech level from QQ5 and increment it, as it
       ab   rone,rx                    ; INX               ; is stored in the range 0-14 but the displayed range
                                                           ; should be 1-15

       .clc                            ; CLC               ; Call pr2 to print the technology level as a 3-digit
       .jsr @pr2_                      ; JSR pr2           ; number without a decimal point (by clearing the C
                                                           ; flag)

       .jsr @TTX69                     ; JSR TTX69         ; Print a paragraph break and set Sentence Case

       li   ra,>c0*256                 ; LDA #192          ; Print recursive token 32 ("POPULATION") followed by a
       .jsr @TT68                      ; JSR TT68          ; colon

       .sec                            ; SEC               ; Call pr2 to print the population as a 3-digit number
       movb @QQ6,rx                    ; LDX QQ6           ; with a decimal point (by setting the C flag), so the
       .jsr @pr2_                      ; JSR pr2           ; number printed will be population / 10

       li   ra,>c6*256                 ; LDA #198          ; Print recursive token 38 (" BILLION"), followed by a
       .jsr @TT60                      ; JSR TT60          ; paragraph break and Sentence Case

       li   ra,('(')*256               ; LDA #'('          ; Print an opening bracket
       .jsr @TT27                      ; JSR TT27          

       movb @QQ15+4,ra                 ; LDA QQ15+4        ; Now to calculate the species, so first check bit 7 of
       jlt  TT75                       ; BMI TT75          ; s2_lo, and if it is set, jump to TT75 as this is an
                                                           ; alien species

       li   ra,>bc*256                 ; LDA #188          ; Bit 7 of s2_lo is clear, so print recursive token 28
       .jsr @TT27                      ; JSR TT27          ; ("HUMAN COLONIAL")

       b    @TT76                      ; JMP TT76          ; Jump to TT76 to print "S)" and a paragraph break, so
                                                           ; the whole species string is "(HUMAN COLONIALS)"

TT75:
       movb @QQ15+5,ra                 ; LDA QQ15+5        ; This is an alien species, and we start with the first
       srl  ra,1                       ; LSR A             ; adjective, so fetch bits 2-7 of s2_hi into A and push
       srl  ra,1                       ; LSR A             ; onto the stack so we can use this later
       .pha                            ; PHA               

       andi ra,>07*256                 ; AND #%00000111    ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)

       ci   ra,>03*256                 ; CMP #3            ; If A >= 3, jump to TT205 to skip the first adjective,
       joc  TT205                      ; BCS TT205         

       .adi (>e3*256)                  ; ADC #227          ; Otherwise A = 0, 1 or 2, so print recursive token
       .jsr @spc_                      ; JSR spc           ; 67 + A, followed by a space, so:
                                                           ; 
                                                           ; A = 0 prints token 67 ("LARGE") and a space
                                                           ; A = 1 prints token 68 ("FIERCE") and a space
                                                           ; A = 2 prints token 69 ("SMALL") and a space

TT205:
       .pla                            ; PLA               ; Now for the second adjective, so restore A to bits
       srl  ra,1                       ; LSR A             ; 2-7 of s2_hi, and throw away bits 2-4 to leave
       srl  ra,1                       ; LSR A             ; A = bits 5-7 of s2_hi
       srl  ra,1                       ; LSR A             

       ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT206 to skip the second adjective
       joc  TT206                      ; BCS TT206         

       .adi (>e6*256)                  ; ADC #230          ; Otherwise A = 0 to 5, so print recursive token
       .jsr @spc_                      ; JSR spc           ; 70 + A, followed by a space, so:
                                                           ; 
                                                           ; A = 0 prints token 70 ("GREEN") and a space
                                                           ; A = 1 prints token 71 ("RED") and a space
                                                           ; A = 2 prints token 72 ("YELLOW") and a space
                                                           ; A = 3 prints token 73 ("BLUE") and a space
                                                           ; A = 4 prints token 74 ("BLACK") and a space
                                                           ; A = 5 prints token 75 ("HARMLESS") and a space

TT206:
       movb @QQ15+3,ra                 ; LDA QQ15+3        ; Now for the third adjective, so EOR the high bytes of
       .eor @QQ15+1                    ; EOR QQ15+1        ; s0 and s1 and extract bits 0-2 of the result:
       andi ra,>07*256                 ; AND #%00000111    ; 
       movb ra,@QQ19                   ; STA QQ19          ; A = (s0_hi EOR s1_hi) AND %111
                                                           ; 
                                                           ; storing the result in QQ19 so we can use it later

       ci   ra,>06*256                 ; CMP #6            ; If A >= 6, jump to TT207 to skip the third adjective
       joc  TT207                      ; BCS TT207         

       .adi (>ec*256)                  ; ADC #236          ; Otherwise A = 0 to 5, so print recursive token
       .jsr @spc_                      ; JSR spc           ; 76 + A, followed by a space, so:
                                                           ; 
                                                           ; A = 0 prints token 76 ("SLIMY") and a space
                                                           ; A = 1 prints token 77 ("BUG-EYED") and a space
                                                           ; A = 2 prints token 78 ("HORNED") and a space
                                                           ; A = 3 prints token 79 ("BONY") and a space
                                                           ; A = 4 prints token 80 ("FAT") and a space
                                                           ; A = 5 prints token 81 ("FURRY") and a space

TT207:
       movb @QQ15+5,ra                 ; LDA QQ15+5        ; Now for the actual species, so take bits 0-1 of
       andi ra,>03*256                 ; AND #%00000011    ; s2_hi, add this to the value of A that we used for
       .clc                            ; CLC               ; the third adjective, and take bits 0-2 of the result
       .adc @QQ19,ra                   ; ADC QQ19          
       andi ra,>07*256                 ; AND #%00000111    

       .adi (>f2*256)                  ; ADC #242          ; A = 0 to 7, so print recursive token 82 + A, so:
       .jsr @TT27                      ; JSR TT27          ; 
                                                           ; A = 0 prints token 82 ("RODENT")
                                                           ; A = 1 prints token 83 ("FROG")
                                                           ; A = 2 prints token 84 ("LIZARD")
                                                           ; A = 3 prints token 85 ("LOBSTER")
                                                           ; A = 4 prints token 86 ("BIRD")
                                                           ; A = 5 prints token 87 ("HUMANOID")
                                                           ; A = 6 prints token 88 ("FELINE")
                                                           ; A = 7 prints token 89 ("INSECT")

TT76:
       li   ra,('S')*256               ; LDA #'S'          ; Print an "S" to pluralise the species
       .jsr @TT27                      ; JSR TT27          

       li   ra,(')')*256               ; LDA #')'          ; And finally, print a closing bracket, followed by a
       .jsr @TT60                      ; JSR TT60          ; paragraph break and Sentence Case, to end the species
                                                           ; section

       li   ra,>c1*256                 ; LDA #193          ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
       .jsr @TT68                      ; JSR TT68          ; followed by a colon

       movb @QQ7,rx                    ; LDX QQ7           ; Fetch the 16-bit productivity value from QQ7 into
       movb @QQ7+1,ry                  ; LDY QQ7+1         ; (Y X)

       .jsr @pr6_                      ; JSR pr6           ; Print (Y X) to 5 digits with no decimal point

       .jsr @TT162                     ; JSR TT162         ; Print a space

       li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
       movb ra,@QQ17                   ; STA QQ17          

       li   ra,('M')*256               ; LDA #'M'          ; Print "M"
       .jsr @TT27                      ; JSR TT27          

       li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR"), followed by a
       .jsr @TT60                      ; JSR TT60          ; paragraph break and Sentence Case

       li   ra,>fa*256                 ; LDA #250          ; Print recursive token 90 ("AVERAGE RADIUS"), followed
       .jsr @TT68                      ; JSR TT68          ; by a colon

                                                           ; The average radius is calculated like this:
                                                           ; 
                                                           ; ((s2_hi AND %1111) + 11) * 256 + s1_hi
                                                           ; 
                                                           ; or, in terms of memory locations:
                                                           ; 
                                                           ; ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
                                                           ; 
                                                           ; Because the multiplication is by 256, this is the
                                                           ; same as saying a 16-bit number, with high byte:
                                                           ; 
                                                           ; (QQ15+5 AND %1111) + 11
                                                           ; 
                                                           ; and low byte:
                                                           ; 
                                                           ; QQ15+3
                                                           ; 
                                                           ; so we can set this up in (Y X) and call the pr5
                                                           ; routine to print it out

       movb @QQ15+5,ra                 ; LDA QQ15+5        ; Set A = QQ15+5
       movb @QQ15+3,rx                 ; LDX QQ15+3        ; Set X = QQ15+3

       andi ra,>0f*256                 ; AND #%00001111    ; Set Y = (A AND %1111) + 11
       .clc                            ; CLC               
       .adi (>0b*256)                  ; ADC #11           
       movb ra,ry                      ; TAY               

       .jsr @pr5_                      ; JSR pr5           ; Print (Y X) to 5 digits, not including a decimal
                                                           ; point, as the C flag will be clear (as the maximum
                                                           ; radius will always fit into 16 bits)

       .jsr @TT162                     ; JSR TT162         ; Print a space

       li   ra,('k')*256               ; LDA #'k'          ; Print "km", returning from the subroutine using a
       .jsr @TT26                      ; JSR TT26          ; tail call
       li   ra,('m')*256               ; LDA #'m'          
       b    @TT26                      ; JMP TT26          

* ******************************************************************************
* 
* Name: TT24
* Type: Subroutine
* Category: Universe
* Summary: Calculate system data from the system seeds
* Deep dive: Generating system data
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Calculate system data from the seeds in QQ15 and store them in the relevant
* locations. Specifically, this routine calculates the following from the three
* 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
* 
* QQ3 = economy (0-7)
* QQ4 = government (0-7)
* QQ5 = technology level (0-14)
* QQ6 = population * 10 (1-71)
* QQ7 = productivity (96-62480)
* 
* The ranges of the various values are shown in brackets. Note that the radius
* and type of inhabitant are calculated on-the-fly in the TT25 routine when
* the system data gets displayed, so they aren't calculated here.
* 
* ******************************************************************************

TT24:
       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi and extract bits 0-2 to determine the
       andi ra,>07*256                 ; AND #%00000111    ; system's economy, and store in QQ3
       movb ra,@QQ3                    ; STA QQ3           

       movb @QQ15+2,ra                 ; LDA QQ15+2        ; Fetch s1_lo and extract bits 3-5 to determine the
       srl  ra,1                       ; LSR A             ; system's government, and store in QQ4
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       andi ra,>07*256                 ; AND #%00000111    
       movb ra,@QQ4                    ; STA QQ4           

       srl  ra,1                       ; LSR A             ; If government isn't anarchy or feudal, skip to TT77,
       jne  TT77                       ; BNE TT77          ; as we need to fix the economy of anarchy and feudal
                                                           ; systems so they can't be rich

       movb @QQ3,ra                    ; LDA QQ3           ; Set bit 1 of the economy in QQ3 to fix the economy
       ori  ra,>02*256                 ; ORA #%00000010    ; for anarchy and feudal governments
       movb ra,@QQ3                    ; STA QQ3           

TT77:
       movb @QQ3,ra                    ; LDA QQ3           ; Now to work out the tech level, which we do like this:
       .eoi (>07*256)                  ; EOR #%00000111    ; 
       .clc                            ; CLC               ; flipped_economy + (s1_hi AND %11) + (government / 2)
       movb ra,@QQ5                    ; STA QQ5           ; 
                                                           ; or, in terms of memory locations:
                                                           ; 
                                                           ; QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
                                                           ; 
                                                           ; We start by setting QQ5 = QQ3 EOR %111

       movb @QQ15+3,ra                 ; LDA QQ15+3        ; We then take the first 2 bits of s1_hi (QQ15+3) and
       andi ra,>03*256                 ; AND #%00000011    ; add it into QQ5
       .adc @QQ5,ra                    ; ADC QQ5           
       movb ra,@QQ5                    ; STA QQ5           

       movb @QQ4,ra                    ; LDA QQ4           ; And finally we add QQ4 / 2 and store the result in
       srl  ra,1                       ; LSR A             ; QQ5, using LSR then ADC to divide by 2, which rounds
       .adc @QQ5,ra                    ; ADC QQ5           ; up the result for odd-numbered government types
       movb ra,@QQ5                    ; STA QQ5           

       .asla                           ; ASL A             ; Now to work out the population, like so:
       .asla                           ; ASL A             ; 
       .adc @QQ3,ra                    ; ADC QQ3           ; (tech level * 4) + economy + government + 1
       .adc @QQ4,ra                    ; ADC QQ4           ; 
       .adi (>01*256)                  ; ADC #1            ; or, in terms of memory locations:
       movb ra,@QQ6                    ; STA QQ6           ; 
                                                           ; QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1

       movb @QQ3,ra                    ; LDA QQ3           ; Finally, we work out productivity, like this:
       .eoi (>07*256)                  ; EOR #%00000111    ; 
       .adi (>03*256)                  ; ADC #3            ; (flipped_economy + 3) * (government + 4)
       movb ra,@P                      ; STA P             ; * population
       movb @QQ4,ra                    ; LDA QQ4           ; * 8
       .adi (>04*256)                  ; ADC #4            ; 
       movb ra,@Q                      ; STA Q             ; or, in terms of memory locations:
       .jsr @MULTU                     ; JSR MULTU         ; 
                                                           ; QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
                                                           ; 
                                                           ; We do the first step by setting P to the first
                                                           ; expression in brackets and Q to the second, and
                                                           ; calling MULTU, so now (A P) = P * Q. The highest this
                                                           ; can be is 10 * 11 (as the maximum values of economy
                                                           ; and government are 7), so the high byte of the result
                                                           ; will always be 0, so we actually have:
                                                           ; 
                                                           ; P = P * Q
                                                           ; = (flipped_economy + 3) * (government + 4)

       movb @QQ6,ra                    ; LDA QQ6           ; We now take the result in P and multiply by the
       movb ra,@Q                      ; STA Q             ; population to get the productivity, by setting Q to
       .jsr @MULTU                     ; JSR MULTU         ; the population from QQ6 and calling MULTU again, so
                                                           ; now we have:
                                                           ; 
                                                           ; (A P) = P * population

       .asl @P                         ; ASL P             ; Next we multiply the result by 8, as a 16-bit number,
       .rola                           ; ROL A             ; so we shift both bytes to the left three times, using
       .asl @P                         ; ASL P             ; the C flag to carry bits from bit 7 of the low byte
       .rola                           ; ROL A             ; into bit 0 of the high byte
       .asl @P                         ; ASL P             
       .rola                           ; ROL A             

       movb ra,@QQ7+1                  ; STA QQ7+1         ; Finally, we store the productivity in two bytes, with
       movb @P,ra                      ; LDA P             ; the low byte in QQ7 and the high byte in QQ7+1
       movb ra,@QQ7                    ; STA QQ7           

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT22
* Type: Subroutine
* Category: Charts
* Summary: Show the Long-range Chart (red key f4)
* 
* ******************************************************************************

TT22:
       li   ra,>40*256                 ; LDA #64           ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 32 (Long-
                                                           ; range Chart)

       li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
       movb ra,@XC                     ; STA XC            

       .jsr @TT81                      ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
                                                           ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

       li   ra,>c7*256                 ; LDA #199          ; Print recursive token 39 ("GALACTIC CHART{galaxy
       .jsr @TT27                      ; JSR TT27          ; number right-aligned to width 3}")

       .jsr @NLIN                      ; JSR NLIN          ; Draw a horizontal line at pixel row 23 to box in the
                                                           ; title and act as the top frame of the chart, and move
                                                           ; the text cursor down one line

       li   ra,>98*256                 ; LDA #152          ; Draw a screen-wide horizontal line at pixel row 152
       .jsr @NLIN2                     ; JSR NLIN2         ; for the bottom edge of the chart, so the chart itself
                                                           ; is 128 pixels high, starting on row 24 and ending on
                                                           ; row 151

       .jsr @TT14                      ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
                                                           ; current system's galactic coordinates

       li   rx,>00*256                 ; LDX #0            ; We're now going to plot each of the galaxy's systems,
                                                           ; so set up a counter in X for each system, starting at
                                                           ; 0 and looping through to 255

TT83:
       movb rx,@XSAV                   ; STX XSAV          ; Store the counter in XSAV

       movb @QQ15+3,rx                 ; LDX QQ15+3        ; Fetch the s1_hi seed into X, which gives us the
                                                           ; galactic x-coordinate of this system

       movb @QQ15+4,ry                 ; LDY QQ15+4        ; Fetch the s2_lo seed and set bits 4 and 6, storing the
       movb ry,ra                      ; TYA               ; result in ZZ to give a random number between 80 and
       ori  ra,>50*256                 ; ORA #%01010000    ; (but which will always be the same for this system).
       movb ra,@ZZ                     ; STA ZZ            ; We use this value to determine the size of the point
                                                           ; for this system on the chart by passing it as the
                                                           ; distance argument to the PIXEL routine below

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch the s0_hi seed into A, which gives us the
                                                           ; galactic y-coordinate of this system

       srl  ra,1                       ; LSR A             ; We halve the y-coordinate because the galaxy in
                                                           ; in Elite is rectangular rather than square, and is
                                                           ; twice as wide (x-axis) as it is high (y-axis), so the
                                                           ; chart is 256 pixels wide and 128 high

       .clc                            ; CLC               ; Add 24 to the halved y-coordinate and store in XX15+1
       .adi (>18*256)                  ; ADC #24           ; (as the top of the chart is on pixel row 24, just
       movb ra,@XX15+1                 ; STA XX15+1        ; below the line we drew on row 23 above)

       .jsr @PIXEL                     ; JSR PIXEL         ; Call PIXEL to draw a point at (X, A), with the size of
                                                           ; the point dependent on the distance specified in ZZ
                                                           ; (so a high value of ZZ will produce a 1-pixel point,
                                                           ; a medium value will produce a 2-pixel dash, and a
                                                           ; small value will produce a 4-pixel square)

       .jsr @TT20                      ; JSR TT20          ; We want to move on to the next system, so call TT20
                                                           ; to twist the three 16-bit seeds in QQ15

       movb @XSAV,rx                   ; LDX XSAV          ; Restore the loop counter from XSAV

       ab   rone,rx                    ; INX               ; Increment the counter

       jne  TT83                       ; BNE TT83          ; If X > 0 then we haven't done all 256 systems yet, so
                                                           ; loop back up to TT83

       movb @QQ9,ra                    ; LDA QQ9           ; Set QQ19 to the selected system's x-coordinate
       movb ra,@QQ19                   ; STA QQ19          

       movb @QQ10,ra                   ; LDA QQ10          ; Set QQ19+1 to the selected system's y-coordinate,
       srl  ra,1                       ; LSR A             ; halved to fit it into the chart
       movb ra,@QQ19+1                 ; STA QQ19+1        

       li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to size 4 for the crosshairs size
       movb ra,@QQ19+2                 ; STA QQ19+2        

                                                           ; Fall through into TT15 to draw crosshairs of size 4 at
                                                           ; the selected system's coordinates

* ******************************************************************************
* 
* Name: TT15
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a set of crosshairs
* 
* ------------------------------------------------------------------------------
* 
* For all views except the Short-range Chart, the centre is drawn 24 pixels to
* the right of the y-coordinate given.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* QQ19                The pixel x-coordinate of the centre of the crosshairs
* 
* QQ19+1              The pixel y-coordinate of the centre of the crosshairs
* 
* QQ19+2              The size of the crosshairs
* 
* ******************************************************************************

TT15:
       li   ra,>18*256                 ; LDA #24           ; Set A to 24, which we will use as the minimum
                                                           ; screen indent for the crosshairs (i.e. the minimum
                                                           ; distance from the top-left corner of the screen)

       movb @QQ11,rx                   ; LDX QQ11          ; If the current view is not the Short-range Chart,
       jgt  B52                        ; BPL B52           ; which is the only view with bit 7 set, then skip the
                                                           ; following instruction

       li   ra,>00*256                 ; LDA #0            ; This is the Short-range Chart, so set A to 0, so the
                                                           ; crosshairs can go right up against the screen edges

B52:
       movb ra,@QQ19+5                 ; STA QQ19+5        ; Set QQ19+5 to A, which now contains the correct indent
                                                           ; for this view

       movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate - crosshairs size
       .sec                            ; SEC               ; to get the x-coordinate of the left edge of the
       .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs

       joc  TT84                       ; BCS TT84          ; If the above subtraction didn't underflow, then A is
                                                           ; positive, so skip the next instruction

       li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
                                                           ; crosshairs don't spill out of the left of the screen

TT84:
                                                           ; In the following, the authors have used XX15 for
                                                           ; temporary storage. XX15 shares location with X1, Y1,
                                                           ; X2 and Y2, so in the following, you can consider
                                                           ; the variables like this:
                                                           ; 
                                                           ; XX15   is the same as X1
                                                           ; XX15+1 is the same as Y1
                                                           ; XX15+2 is the same as X2
                                                           ; XX15+3 is the same as Y2
                                                           ; 
                                                           ; Presumably this routine was written at a different
                                                           ; time to the line-drawing routine, before the two
                                                           ; workspaces were merged to save space
       movb ra,@XX15                   ; STA XX15          ; Set XX15 (X1) = A (the x-coordinate of the left edge
                                                           ; of the crosshairs)

       movb @QQ19,ra                   ; LDA QQ19          ; Set A = crosshairs x-coordinate + crosshairs size
       .clc                            ; CLC               ; to get the x-coordinate of the right edge of the
       .adc @QQ19+2,ra                 ; ADC QQ19+2        ; crosshairs

       jnc  B53                        ; BCC B53           ; If the above addition didn't overflow, then A is
                                                           ; correct, so skip the next instruction

       li   ra,>ff*256                 ; LDA #255          ; The addition overflowed, so set A to 255 so the
                                                           ; crosshairs don't spill out of the right of the screen
                                                           ; (as 255 is the x-coordinate of the rightmost pixel
                                                           ; on-screen)

B53:
       movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = A (the x-coordinate of the right
                                                           ; edge of the crosshairs)

       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set XX15+1 (Y1) = crosshairs y-coordinate + indent
       .clc                            ; CLC               ; to get the y-coordinate of the centre of the
       .adc @QQ19+5,ra                 ; ADC QQ19+5        ; crosshairs
       movb ra,@XX15+1                 ; STA XX15+1        

       .jsr @HLOIN                     ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
                                                           ; which will draw from the left edge of the crosshairs
                                                           ; to the right edge, through the centre of the
                                                           ; crosshairs

       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate - crosshairs size
       .sec                            ; SEC               ; to get the y-coordinate of the top edge of the
       .sbc @QQ19+2,ra                 ; SBC QQ19+2        ; crosshairs

       joc  TT86                       ; BCS TT86          ; If the above subtraction didn't underflow, then A is
                                                           ; correct, so skip the next instruction

       li   ra,>00*256                 ; LDA #0            ; The subtraction underflowed, so set A to 0 so the
                                                           ; crosshairs don't spill out of the top of the screen

TT86:
       .clc                            ; CLC               ; Set XX15+1 (Y1) = A + indent to get the y-coordinate
       .adc @QQ19+5,ra                 ; ADC QQ19+5        ; of the top edge of the indented crosshairs
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set A = crosshairs y-coordinate + crosshairs size
       .clc                            ; CLC               ; + indent to get the y-coordinate of the bottom edge
       .adc @QQ19+2,ra                 ; ADC QQ19+2        ; of the indented crosshairs
       .adc @QQ19+5,ra                 ; ADC QQ19+5        

       ci   ra,>98*256                 ; CMP #152          ; If A < 152 then skip the following, as the crosshairs
       jnc  TT87                       ; BCC TT87          ; won't spill out of the bottom of the screen

       movb @QQ11,rx                   ; LDX QQ11          ; A >= 152, so we need to check whether this will fit in
                                                           ; this view, so fetch the view type

       jlt  TT87                       ; BMI TT87          ; If this is the Short-range Chart then the y-coordinate
                                                           ; is fine, so skip to TT87

       li   ra,>97*256                 ; LDA #151          ; Otherwise this is the Long-range Chart, so we need to
                                                           ; clip the crosshairs at a maximum y-coordinate of 151

TT87:
       movb ra,@XX15+3                 ; STA XX15+3        ; Set XX15+3 (Y2) = A (the y-coordinate of the bottom
                                                           ; edge of the crosshairs)

       movb @QQ19,ra                   ; LDA QQ19          ; Set XX15 (X1) = the x-coordinate of the centre of the
       movb ra,@XX15                   ; STA XX15          ; crosshairs

       movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 (X2) = the x-coordinate of the centre of
                                                           ; the crosshairs

       b    @LL30                      ; JMP LL30          ; Draw a vertical line (X1, Y1) to (X2, Y2), which will
                                                           ; draw from the top edge of the crosshairs to the bottom
                                                           ; edge, through the centre of the crosshairs, returning
                                                           ; from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TT14
* Type: Subroutine
* Category: Drawing circles
* Summary: Draw a circle with crosshairs on a chart
* 
* ------------------------------------------------------------------------------
* 
* Draw a circle with crosshairs at the current system's galactic coordinates.
* 
* ******************************************************************************

TT126:
       li   ra,>68*256                 ; LDA #104          ; Set QQ19 = 104, for the x-coordinate of the centre of
       movb ra,@QQ19                   ; STA QQ19          ; the fixed circle on the Short-range Chart

       li   ra,>5a*256                 ; LDA #90           ; Set QQ19+1 = 90, for the y-coordinate of the centre of
       movb ra,@QQ19+1                 ; STA QQ19+1        ; the fixed circle on the Short-range Chart

       li   ra,>10*256                 ; LDA #16           ; Set QQ19+2 = 16, the size of the crosshairs on the
       movb ra,@QQ19+2                 ; STA QQ19+2        ; Short-range Chart

       .jsr @TT15                      ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, at the
                                                           ; exact coordinates as this is the Short-range Chart

       movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14, so this can act as
       movb ra,@K                      ; STA K             ; the circle's radius (70 being a full tank)

       b    @TT128                     ; JMP TT128         ; Jump to TT128 to draw a circle with the centre at the
                                                           ; same coordinates as the crosshairs, (QQ19, QQ19+1),
                                                           ; and radius K that reflects the current fuel levels,
                                                           ; returning from the subroutine using a tail call

TT14:
       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is the Short-range Chart, which
       jlt  TT126                      ; BMI TT126         ; is the only view with bit 7 set, then jump up to TT126
                                                           ; to draw the crosshairs and circle for that view

                                                           ; Otherwise this is the Long-range Chart, so we draw the
                                                           ; crosshairs and circle for that view instead

       movb @QQ14,ra                   ; LDA QQ14          ; Set K to the fuel level from QQ14 divided by 4, so
       srl  ra,1                       ; LSR A             ; this can act as the circle's radius (70 being a full
       srl  ra,1                       ; LSR A             ; tank, which divides down to a radius of 17)
       movb ra,@K                      ; STA K             

       movb @QQ0,ra                    ; LDA QQ0           ; Set QQ19 to the x-coordinate of the current system,
       movb ra,@QQ19                   ; STA QQ19          ; which will be the centre of the circle and crosshairs
                                                           ; we draw

       movb @QQ1,ra                    ; LDA QQ1           ; Set QQ19+1 to the y-coordinate of the current system,
       srl  ra,1                       ; LSR A             ; halved because the galactic chart is half as high as
       movb ra,@QQ19+1                 ; STA QQ19+1        ; it is wide, which will again be the centre of the
                                                           ; circle and crosshairs we draw

       li   ra,>07*256                 ; LDA #7            ; Set QQ19+2 = 7, the size of the crosshairs on the
       movb ra,@QQ19+2                 ; STA QQ19+2        ; Long-range Chart

       .jsr @TT15                      ; JSR TT15          ; Draw the set of crosshairs defined in QQ19, which will
                                                           ; be drawn 24 pixels to the right of QQ19+1

       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Add 24 to the y-coordinate of the crosshairs in QQ19+1
       .clc                            ; CLC               ; so that the centre of the circle matches the centre
       .adi (>18*256)                  ; ADC #24           ; of the crosshairs
       movb ra,@QQ19+1                 ; STA QQ19+1        

                                                           ; Fall through into TT128 to draw a circle with the
                                                           ; centre at the same coordinates as the crosshairs,
                                                           ; (QQ19, QQ19+1), and radius K that reflects the
                                                           ; current fuel levels

* ******************************************************************************
* 
* Name: TT128
* Type: Subroutine
* Category: Drawing circles
* Summary: Draw a circle on a chart
* Deep dive: Drawing circles
* 
* ------------------------------------------------------------------------------
* 
* Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* QQ19                The x-coordinate of the centre of the circle
* 
* QQ19+1              The y-coordinate of the centre of the circle
* 
* K                   The radius of the circle
* 
* ******************************************************************************

TT128:
       movb @QQ19,ra                   ; LDA QQ19          ; Set K3 = the x-coordinate of the centre
       movb ra,@K3                     ; STA K3            

       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Set K4 = the y-coordinate of the centre
       movb ra,@K4                     ; STA K4            

       li   rx,>00*256                 ; LDX #0            ; Set the high bytes of K3(1 0) and K4(1 0) to 0
       movb rx,@K4+1                   ; STX K4+1          
       movb rx,@K3+1                   ; STX K3+1          

* STX LSX                \ This instruction is commented out in the original
                                                           ; source

       ab   rone,rx                    ; INX               ; Set LSP = 1 to reset the ball line heap
       movb rx,@LSP                    ; STX LSP           

       li   rx,>02*256                 ; LDX #2            ; Set STP = 2, the step size for the circle
       movb rx,@STP                    ; STX STP           

       .jsr @CIRCLE2                   ; JSR CIRCLE2       ; Call CIRCLE2 to draw a circle with the centre at
                                                           ; (K3(1 0), K4(1 0)) and radius K

* LDA #&FF               \ These instructions are commented out in the original
* STA LSX                \ source

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT219
* Type: Subroutine
* Category: Market
* Summary: Show the Buy Cargo screen (red key f1)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* BAY2                Jump into the main loop at FRCE, setting the key
* "pressed" to red key f9 (so we show the Inventory
* screen)
* 
* ******************************************************************************

TT219:
* LDA #2                 \ This instruction is commented out in the original
                                                           ; source. Perhaps this view originally had a QQ11 value
                                                           ; of 2, but it turned out not to need its own unique ID,
                                                           ; so the authors found they could just use a view value
                                                           ; of 1 and save an instruction at the same time?
       .jsr @TT66-2                    ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 1

       .jsr @TT163                     ; JSR TT163         ; Print the column headers for the prices table

       li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
       movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals

* JSR FLKB               \ This instruction is commented out in the original
                                                           ; source. It calls a routine to flush the keyboard
                                                           ; buffer (FLKB) that isn't present in the cassette
                                                           ; version but is in other versions

       li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
       movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
                                                           ; current item and start it at 0

TT220:
       .jsr @TT151                     ; JSR TT151         ; Call TT151 to print the item name, market price and
                                                           ; availability of the current item, and set QQ24 to the
                                                           ; item's price / 4, QQ25 to the quantity available and
                                                           ; QQ19+1 to byte #1 from the market prices table for
                                                           ; this item

       movb @QQ25,ra                   ; LDA QQ25          ; If there are some of the current item available, jump
       jne  TT224                      ; BNE TT224         ; to TT224 below to see if we want to buy any

       b    @TT222                     ; JMP TT222         ; Otherwise there are none available, so jump down to
                                                           ; TT222 to skip this item

TQ4:
       li   ry,>b0*256                 ; LDY #176          ; Set Y to the recursive token 16 ("QUANTITY")

Tc:
       .jsr @TT162                     ; JSR TT162         ; Print a space

       movb ry,ra                      ; TYA               ; Print the recursive token in Y followed by a question
       .jsr @prq_                      ; JSR prq           ; mark

TTX224:
       .jsr @dn2_                      ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
                                                           ; second

TT224:
       .jsr @CLYNS                     ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
                                                           ; and move the text cursor to column 1 on row 21, i.e.
                                                           ; the start of the top row of the three bottom rows

       li   ra,>cc*256                 ; LDA #204          ; Print recursive token 44 ("QUANTITY OF ")
       .jsr @TT27                      ; JSR TT27          

       movb @QQ29,ra                   ; LDA QQ29          ; Print recursive token 48 + QQ29, which will be in the
       .clc                            ; CLC               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
       .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
       .jsr @TT27                      ; JSR TT27          

       li   ra,('/')*256               ; LDA #'/'          ; Print "/"
       .jsr @TT27                      ; JSR TT27          

       .jsr @TT152                     ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the current item
                                                           ; (as the call to TT151 above set QQ19+1 with the
                                                           ; appropriate value)

       li   ra,('?')*256               ; LDA #'?'          ; Print "?"
       .jsr @TT27                      ; JSR TT27          

       .jsr @TT67                      ; JSR TT67          ; Print a newline

       li   rx,>00*256                 ; LDX #0            ; These instructions have no effect, as they are
       movb rx,@R                      ; STX R             ; repeated at the start of gnum, which we call next.
       li   rx,>0c*256                 ; LDX #12           ; Perhaps they were left behind when code was moved from
       movb rx,@T1                     ; STX T1            ; here into gnum, and weren't deleted?

* .TT223                 \ This label is commented out in the original source,
                                                           ; and is a duplicate of a label in gnum, so this could
                                                           ; also be a remnant if the code in gnum was originally
                                                           ; here, but got moved into the gnum subroutine

       .jsr @gnum_                     ; JSR gnum          ; Call gnum to get a number from the keyboard, which
                                                           ; will be the quantity of this item we want to purchase,
                                                           ; returning the number entered in A and R

       joc  TQ4                        ; BCS TQ4           ; If gnum set the C flag, the number entered is greater
                                                           ; than the quantity available, so jump up to TQ4 to
                                                           ; display a "Quantity?" error, beep, clear the number
                                                           ; and try again

       movb ra,@P                      ; STA P             ; Otherwise we have a valid purchase quantity entered,
                                                           ; so store the amount we want to purchase in P

       .jsr @tnpr_                     ; JSR tnpr          ; Call tnpr to work out whether there is room in the
                                                           ; cargo hold for this item

       li   ry,>ce*256                 ; LDY #206          ; Set Y to recursive token 46 (" CARGO{sentence case}")
                                                           ; to pass to the Tc routine if we call it

       joc  Tc                         ; BCS Tc            ; If the C flag is set, then there is no room in the
                                                           ; cargo hold, jump up to Tc to print a "Cargo?" error,
                                                           ; beep, clear the number and try again

       movb @QQ24,ra                   ; LDA QQ24          ; There is room in the cargo hold, so now to check
       movb ra,@Q                      ; STA Q             ; whether we have enough cash, so fetch the item's
                                                           ; price / 4, which was returned in QQ24 by the call
                                                           ; to TT151 above and store it in Q

       .jsr @GCASH                     ; JSR GCASH         ; Call GCASH to calculate:
                                                           ; 
                                                           ; (Y X) = P * Q * 4
                                                           ; 
                                                           ; which will be the total price of this transaction
                                                           ; (as P contains the purchase quantity and Q contains
                                                           ; the item's price / 4)

       .jsr @LCASH                     ; JSR LCASH         ; Subtract (Y X) cash from the cash pot in CASH

       li   ry,>c5*256                 ; LDY #197          ; If the C flag is clear, we didn't have enough cash,
       jnc  Tc                         ; BCC Tc            ; so set Y to the recursive token 37 ("CASH") and jump
                                                           ; up to Tc to print a "Cash?" error, beep, clear the
                                                           ; number and try again

       movb @QQ29,ry                   ; LDY QQ29          ; Fetch the current market item number from QQ29 into Y

       movb @R,ra                      ; LDA R             ; Set A to the number of items we just purchased (this
                                                           ; was set by gnum above)

       .pha                            ; PHA               ; Store the quantity just purchased on the stack

       .clc                            ; CLC               ; Add the number purchased to the Y-th byte of QQ20,
       .adc @QQ20(ry),ra               ; ADC QQ20,Y        ; which contains the number of items of this type in
       movb ra,@QQ20(ry)               ; STA QQ20,Y        ; our hold (so this transfers the bought items into our
                                                           ; cargo hold)

       movb @AVL(ry),ra                ; LDA AVL,Y         ; Subtract the number of items from the Y-th byte of
       .sec                            ; SEC               ; AVL, which contains the number of items of this type
       .sbc @R,ra                      ; SBC R             ; that are available on the market
       movb ra,@AVL(ry)                ; STA AVL,Y         

       .pla                            ; PLA               ; Restore the quantity just purchased

       jeq  TT222                      ; BEQ TT222         ; If we didn't buy anything, jump to TT222 to skip the
                                                           ; following instruction

       .jsr @dn_                       ; JSR dn            ; Call dn to print the amount of cash left in the cash
                                                           ; pot, then make a short, high beep to confirm the
                                                           ; purchase, and delay for 1 second

TT222:
       movb @QQ29,ra                   ; LDA QQ29          ; Move the text cursor to row QQ29 + 5 (where QQ29 is
       .clc                            ; CLC               ; the item number, starting from 0)
       .adi (>05*256)                  ; ADC #5            
       movb ra,@YC                     ; STA YC            

       li   ra,>00*256                 ; LDA #0            ; Move the text cursor to column 0
       movb ra,@XC                     ; STA XC            

       ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item

       movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to BAY2 as we have done the
       ci   ra,>11*256                 ; CMP #17           ; last item
       joc  BAY2                       ; BCS BAY2          

       b    @TT220                     ; JMP TT220         ; Otherwise loop back to TT220 to print the next market
                                                           ; item

BAY2:
       li   ra,(f9_)*256               ; LDA #f9           ; Jump into the main loop at FRCE, setting the key
       b    @FRCE                      ; JMP FRCE          ; "pressed" to red key f9 (so we show the Inventory
                                                           ; screen)

* ******************************************************************************
* 
* Name: gnum
* Type: Subroutine
* Category: Market
* Summary: Get a number from the keyboard
* 
* ------------------------------------------------------------------------------
* 
* Get a number from the keyboard, up to the maximum number in QQ25, for the
* buying and selling of cargo and equipment.
* 
* Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
* that includes pressing Space or Return), while pressing a key with an ASCII
* code greater than ASCII "9" will jump to the Inventory screen (so that
* includes all letters and most punctuation).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* QQ25                The maximum number allowed
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The number entered
* 
* R                   Also contains the number entered
* 
* C flag              Set if the number is too large (> QQ25), clear otherwise
* 
* ******************************************************************************

gnum_:
       li   rx,>00*256                 ; LDX #0            ; We will build the number entered in R, so initialise
       movb rx,@R                      ; STX R             ; it with 0

       li   rx,>0c*256                 ; LDX #12           ; We will check for up to 12 key presses, so set a
       movb rx,@T1                     ; STX T1            ; counter in T1

TT223:
       .jsr @TT217                     ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
                                                           ; the key's ASCII code in A (and X)

       movb ra,@Q                      ; STA Q             ; Store the key pressed in Q

       .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
       .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)

       jnc  OUT                        ; BCC OUT           ; If A < 0, jump to OUT to load the current number and
                                                           ; return from the subroutine, as the key pressed was
                                                           ; RETURN (or some other ncharacter with a value less
                                                           ; than ASCII "0")

       ci   ra,>0a*256                 ; CMP #10           ; If A >= 10, jump to BAY2 to display the Inventory
       joc  BAY2                       ; BCS BAY2          ; screen, as the key pressed was a letter or other
                                                           ; non-digit and is greater than ASCII "9"

       movb ra,@S                      ; STA S             ; Store the numeric value of the key pressed in S

       movb @R,ra                      ; LDA R             ; Fetch the result so far into A

       ci   ra,>1a*256                 ; CMP #26           ; If A >= 26, where A is the number entered so far, then
       joc  OUT                        ; BCS OUT           ; adding a further digit will make it bigger than 256,
                                                           ; so jump to OUT to return from the subroutine with the
                                                           ; result in R (i.e. ignore the last key press)

       .asla                           ; ASL A             ; Set A = (A * 2) + (A * 8) = A * 10
       movb ra,@T                      ; STA T             
       .asla                           ; ASL A             
       .asla                           ; ASL A             
       .adc @T,ra                      ; ADC T             

       .adc @S,ra                      ; ADC S             ; Add the pressed digit to A and store in R, so R now
       movb ra,@R                      ; STA R             ; contains its previous value with the new key press
                                                           ; tacked onto the end

       cb   @QQ25,ra                   ; CMP QQ25          ; If the result in R = the maximum allowed in QQ25, jump
       jeq  TT226                      ; BEQ TT226         ; to TT226 to print the key press and keep looping (the
                                                           ; BEQ is needed because the BCS below would jump to OUT
                                                           ; if R >= QQ25, which we don't want)

       joc  OUT                        ; BCS OUT           ; If the result in R > QQ25, jump to OUT to return from
                                                           ; the subroutine with the result in R

TT226:
       movb @Q,ra                      ; LDA Q             ; Print the character in Q (i.e. the key that was
       .jsr @TT26                      ; JSR TT26          ; pressed, as we stored the ASCII value in Q earlier)

       sb   rone,ra                    ; DEC T1            ; Decrement the loop counter

       jne  TT223                      ; BNE TT223         ; Loop back to TT223 until we have checked for 12 digits

OUT:
       movb @R,ra                      ; LDA R             ; Set A to the result we have been building in R

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT208
* Type: Subroutine
* Category: Market
* Summary: Show the Sell Cargo screen (red key f2)
* 
* ******************************************************************************

TT208:
       li   ra,>04*256                 ; LDA #4            ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 4 (Sell
                                                           ; Cargo screen)

       li   ra,>04*256                 ; LDA #4            ; Move the text cursor to row 4, column 4
       movb ra,@YC                     ; STA YC            
       movb ra,@XC                     ; STA XC            

* JSR FLKB               \ This instruction is commented out in the original
                                                           ; source. It calls a routine to flush the keyboard
                                                           ; buffer (FLKB) that isn't present in the cassette
                                                           ; version but is in other versions

       li   ra,>cd*256                 ; LDA #205          ; Print recursive token 45 ("SELL")
       .jsr @TT27                      ; JSR TT27          

       li   ra,>ce*256                 ; LDA #206          ; Print recursive token 46 (" CARGO{sentence case}")
       .jsr @TT68                      ; JSR TT68          ; followed by a colon

                                                           ; Fall through into TT210 to show the Inventory screen
                                                           ; with the option to sell

* ******************************************************************************
* 
* Name: TT210
* Type: Subroutine
* Category: Market
* Summary: Show a list of current cargo in our hold, optionally to sell
* 
* ------------------------------------------------------------------------------
* 
* Show a list of current cargo in our hold, either with the ability to sell (the
* Sell Cargo screen) or without (the Inventory screen), depending on the current
* view.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* QQ11                The current view:
* 
* * 4 = Sell Cargo
* 
* * 8 = Inventory
* 
* ******************************************************************************

TT210:
       li   ry,>00*256                 ; LDY #0            ; We're going to loop through all the available market
                                                           ; items and check whether we have any in the hold (and,
                                                           ; if we are in the Sell Cargo screen, whether we want
                                                           ; to sell any items), so we set up a counter in Y to
                                                           ; denote the current item and start it at 0

TT211:
       movb ry,@QQ29                   ; STY QQ29          ; Store the current item number in QQ29

       movb @QQ20(ry),rx               ; LDX QQ20,Y        ; Fetch into X the amount of the current item that we
       jeq  TT212                      ; BEQ TT212         ; have in our cargo hold, which is stored in QQ20+Y,
                                                           ; and if there are no items of this type in the hold,
                                                           ; jump down to TT212 to skip to the next item

       movb ry,ra                      ; TYA               ; Set Y = Y * 4, so this will act as an index into the
       .asla                           ; ASL A             ; market prices table at QQ23 for this item (as there
       .asla                           ; ASL A             ; are four bytes per item in the table)
       movb ra,ry                      ; TAY               

       movb @QQ23+1(ry),ra             ; LDA QQ23+1,Y      ; Fetch byte #1 from the market prices table for the
       movb ra,@QQ19+1                 ; STA QQ19+1        ; current item and store it in QQ19+1, for use by the
                                                           ; call to TT152 below

       movb rx,ra                      ; TXA               ; Store the amount of item in the hold (in X) on the
       .pha                            ; PHA               ; stack

       .jsr @TT69                      ; JSR TT69          ; Call TT69 to set Sentence Case and print a newline

       .clc                            ; CLC               ; Print recursive token 48 + QQ29, which will be in the
       movb @QQ29,ra                   ; LDA QQ29          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
       .adi (>d0*256)                  ; ADC #208          ; prints the current item's name
       .jsr @TT27                      ; JSR TT27          

       li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the item's
       movb ra,@XC                     ; STA XC            ; quantity

       .pla                            ; PLA               ; Restore the amount of item in the hold into X
       movb ra,rx                      ; TAX               

       .clc                            ; CLC               ; Print the 8-bit number in X to 3 digits, without a
       .jsr @pr2_                      ; JSR pr2           ; decimal point

       .jsr @TT152                     ; JSR TT152         ; Print the unit ("t", "kg" or "g") for the market item
                                                           ; whose byte #1 from the market prices table is in
                                                           ; QQ19+1 (which we set up above)

       movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
       ci   ra,>04*256                 ; CMP #4            ; screen), jump to TT212 to skip the option to sell
       jne  TT212                      ; BNE TT212         ; items

       li   ra,>cd*256                 ; LDA #205          ; Set A to recursive token 45 ("SELL")

       .jsr @TT214                     ; JSR TT214         ; Call TT214 to print "Sell(Y/N)?" and return the
                                                           ; response in the C flag

       jnc  TT212                      ; BCC TT212         ; If the response was "no", jump to TT212 to move on to
                                                           ; the next item

       movb @QQ29,ra                   ; LDA QQ29          ; We are selling this item, so fetch the item number
                                                           ; from QQ29

       li   rx,>ff*256                 ; LDX #255          ; Set QQ17 = 255 to disable printing
       movb rx,@QQ17                   ; STX QQ17          

       .jsr @TT151                     ; JSR TT151         ; Call TT151 to set QQ24 to the item's price / 4 (the
                                                           ; routine doesn't print the item details, as we just
                                                           ; disabled printing)

       movb @QQ29,ry                   ; LDY QQ29          ; Set P to the amount of this item we have in our cargo
       movb @QQ20(ry),ra               ; LDA QQ20,Y        ; hold (which is the amount to sell)
       movb ra,@P                      ; STA P             

       movb @QQ24,ra                   ; LDA QQ24          ; Set Q to the item's price / 4
       movb ra,@Q                      ; STA Q             

       .jsr @GCASH                     ; JSR GCASH         ; Call GCASH to calculate
                                                           ; 
                                                           ; (Y X) = P * Q * 4
                                                           ; 
                                                           ; which will be the total price we make from this sale
                                                           ; (as P contains the quantity we're selling and Q
                                                           ; contains the item's price / 4)

       .jsr @MCASH                     ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH

       li   ra,>00*256                 ; LDA #0            ; We've made the sale, so set the amount
       movb @QQ29,ry                   ; LDY QQ29          
       movb ra,@QQ20(ry)               ; STA QQ20,Y        

       movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0, which enables printing again

TT212:
       movb @QQ29,ry                   ; LDY QQ29          ; Fetch the item number from QQ29 into Y, and increment
       ab   rone,ry                    ; INY               ; Y to point to the next item

       ci   ry,>11*256                 ; CPY #17           ; If Y >= 17 then skip the next instruction as we have
       joc  B54                        ; BCS B54           ; done the last item

       b    @TT211                     ; JMP TT211         ; Otherwise loop back to TT211 to print the next item
                                                           ; in the hold

B54:
       movb @QQ11,ra                   ; LDA QQ11          ; If the current view type in QQ11 is not 4 (Sell Cargo
       ci   ra,>04*256                 ; CMP #4            ; screen), skip the next two instructions and just
       jne  B55                        ; BNE B55           ; return from the subroutine

       .jsr @dn2_                      ; JSR dn2           ; This is the Sell Cargo screen, so call dn2 to make a
                                                           ; short, high beep and delay for 1 second

       b    @BAY2                      ; JMP BAY2          ; And then jump to BAY2 to display the Inventory
                                                           ; screen, as we have finished selling cargo

B55:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT213
* Type: Subroutine
* Category: Market
* Summary: Show the Inventory screen (red key f9)
* 
* ******************************************************************************

TT213:
       li   ra,>08*256                 ; LDA #8            ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 8 (Inventory
                                                           ; screen)

       li   ra,>0b*256                 ; LDA #11           ; Move the text cursor to column 11 to print the screen
       movb ra,@XC                     ; STA XC            ; title

       li   ra,>a4*256                 ; LDA #164          ; Print recursive token 4 ("INVENTORY{crlf}") followed
       .jsr @TT60                      ; JSR TT60          ; by a paragraph break and Sentence Case

       .jsr @NLIN4                     ; JSR NLIN4         ; Draw a horizontal line at pixel row 19 to box in the
                                                           ; title. The authors could have used a call to NLIN3
                                                           ; instead and saved the above call to TT60, but you
                                                           ; just can't optimise everything

       .jsr @fwl_                      ; JSR fwl           ; Call fwl to print the fuel and cash levels on two
                                                           ; separate lines

       movb @CRGO,ra                   ; LDA CRGO          ; If our ship's cargo capacity is < 26 (i.e. we do not
       ci   ra,>1a*256                 ; CMP #26           ; have a cargo bay extension), skip the following two
       jnc  B56                        ; BCC B56           ; instructions

       li   ra,>6b*256                 ; LDA #107          ; We do have a cargo bay extension, so print recursive
       .jsr @TT27                      ; JSR TT27          ; token 107 ("LARGE CARGO{sentence case} BAY")

B56:
       b    @TT210                     ; JMP TT210         ; Jump to TT210 to print the contents of our cargo bay
                                                           ; and return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TT214
* Type: Subroutine
* Category: Keyboard
* Summary: Ask a question with a "Y/N?" prompt and return the response
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to print before the "Y/N?" prompt
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the response was "yes", clear otherwise
* 
* ******************************************************************************

TT214:
       .pha                            ; PHA               ; Print a space, using the stack to preserve the value
       .jsr @TT162                     ; JSR TT162         ; of A
       .pla                            ; PLA               

TT221:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A

       li   ra,>e1*256                 ; LDA #225          ; Print recursive token 65 ("(Y/N)?")
       .jsr @TT27                      ; JSR TT27          

       .jsr @TT217                     ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
                                                           ; the key's ASCII code in A and X

       ori  ra,>20*256                 ; ORA #%00100000    ; Set bit 5 in the value of the key pressed, which
                                                           ; converts it to lower case

       ci   ra,('y')*256               ; CMP #'y'          ; If "y" was pressed, jump to TT218
       jeq  TT218                      ; BEQ TT218         

       li   ra,('n')*256               ; LDA #'n'          ; Otherwise jump to TT26 to print "n" and return from
       b    @TT26                      ; JMP TT26          ; the subroutine using a tail call (so all other
                                                           ; responses apart from "y" indicate a no)

TT218:
       .jsr @TT26                      ; JSR TT26          ; Print the character in A, i.e. print "y"

       .sec                            ; SEC               ; Set the C flag to indicate a "yes" response

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT16
* Type: Subroutine
* Category: Charts
* Summary: Move the crosshairs on a chart
* 
* ------------------------------------------------------------------------------
* 
* Move the chart crosshairs by the amount in X and Y.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The amount to move the crosshairs in the x-axis
* 
* Y                   The amount to move the crosshairs in the y-axis
* 
* ******************************************************************************

TT16:
       movb rx,ra                      ; TXA               ; Push the change in X onto the stack (let's call this
       .pha                            ; PHA               ; the x-delta)

       sb   rone,ry                    ; DEY               ; Negate the change in Y and push it onto the stack
       movb ry,ra                      ; TYA               ; (let's call this the y-delta)
       .eoi (>ff*256)                  ; EOR #&FF          
       .pha                            ; PHA               

       .jsr @WSCAN                     ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
                                                           ; screen gets drawn and we can move the crosshairs with
                                                           ; no screen flicker

       .jsr @TT103                     ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
                                                           ; which will erase the crosshairs currently there

       .pla                            ; PLA               ; Store the y-delta in QQ19+3 and fetch the current
       movb ra,@QQ19+3                 ; STA QQ19+3        ; y-coordinate of the crosshairs from QQ10 into A, ready
       movb @QQ10,ra                   ; LDA QQ10          ; for the call to TT123

       .jsr @TT123                     ; JSR TT123         ; Call TT123 to move the selected system's galactic
                                                           ; y-coordinate by the y-delta, putting the new value in
                                                           ; QQ19+4

       movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated y-coordinate in QQ10 (the current
       movb ra,@QQ10                   ; STA QQ10          ; y-coordinate of the crosshairs)

       movb ra,@QQ19+1                 ; STA QQ19+1        ; This instruction has no effect, as QQ19+1 is
                                                           ; overwritten below, both in TT103 and TT105

       .pla                            ; PLA               ; Store the x-delta in QQ19+3 and fetch the current
       movb ra,@QQ19+3                 ; STA QQ19+3        ; x-coordinate of the crosshairs from QQ10 into A, ready
       movb @QQ9,ra                    ; LDA QQ9           ; for the call to TT123

       .jsr @TT123                     ; JSR TT123         ; Call TT123 to move the selected system's galactic
                                                           ; x-coordinate by the x-delta, putting the new value in
                                                           ; QQ19+4

       movb @QQ19+4,ra                 ; LDA QQ19+4        ; Store the updated x-coordinate in QQ9 (the current
       movb ra,@QQ9                    ; STA QQ9           ; x-coordinate of the crosshairs)

       movb ra,@QQ19                   ; STA QQ19          ; This instruction has no effect, as QQ19 is overwritten
                                                           ; below, both in TT103 and TT105

                                                           ; Now we've updated the coordinates of the crosshairs,
                                                           ; fall through into TT103 to redraw them at their new
                                                           ; location

* ******************************************************************************
* 
* Name: TT103
* Type: Subroutine
* Category: Charts
* Summary: Draw a small set of crosshairs on a chart
* 
* ------------------------------------------------------------------------------
* 
* Draw a small set of crosshairs on a galactic chart at the coordinates in
* (QQ9, QQ10).
* 
* ******************************************************************************

TT103:
       movb @QQ11,ra                   ; LDA QQ11          ; Fetch the current view type into A

       jeq  TT180                      ; BEQ TT180         ; If this is a space view, return from the subroutine
                                                           ; (as TT180 contains an RTS), as there are no moveable
                                                           ; crosshairs in space

       jlt  TT105                      ; BMI TT105         ; If this is the Short-range Chart screen, jump to TT105

       movb @QQ9,ra                    ; LDA QQ9           ; Store the crosshairs x-coordinate in QQ19
       movb ra,@QQ19                   ; STA QQ19          

       movb @QQ10,ra                   ; LDA QQ10          ; Halve the crosshairs y-coordinate and store it in QQ19
       srl  ra,1                       ; LSR A             ; (we halve it because the Long-range Chart is half as
       movb ra,@QQ19+1                 ; STA QQ19+1        ; high as it is wide)

       li   ra,>04*256                 ; LDA #4            ; Set QQ19+2 to 4 denote crosshairs of size 4
       movb ra,@QQ19+2                 ; STA QQ19+2        

       b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 4 at the
                                                           ; crosshairs coordinates, returning from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: TT123
* Type: Subroutine
* Category: Charts
* Summary: Move galactic coordinates by a signed delta
* 
* ------------------------------------------------------------------------------
* 
* Move an 8-bit galactic coordinate by a certain distance in either direction
* (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
* overflow. The coordinate is in a single axis, so it's either an x-coordinate
* or a y-coordinate.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The galactic coordinate to update
* 
* QQ19+3              The delta (can be positive or negative)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* QQ19+4              The updated coordinate after moving by the delta (this
* will be the same as A if moving by the delta overflows)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT180               Contains an RTS
* 
* ******************************************************************************

TT123:
       movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the original coordinate in temporary storage at
                                                           ; QQ19+4

       .clc                            ; CLC               ; Set A = A + QQ19+3, so A now contains the original
       .adc @QQ19+3,ra                 ; ADC QQ19+3        ; coordinate, moved by the delta

       movb @QQ19+3,rx                 ; LDX QQ19+3        ; If the delta is negative, jump to TT124
       jlt  TT124                      ; BMI TT124         

       jnc  TT125                      ; BCC TT125         ; If the C flag is clear, then the above addition didn't
                                                           ; overflow, so jump to TT125 to return the updated value

       .rts                            ; RTS               ; Otherwise the C flag is set and the above addition
                                                           ; overflowed, so do not update the return value

TT124:
       jnc  TT180                      ; BCC TT180         ; If the C flag is clear, then because the delta is
                                                           ; negative, this indicates the addition (which is
                                                           ; effectively a subtraction) underflowed, so jump to
                                                           ; TT180 to return from the subroutine without updating
                                                           ; the return value

TT125:
       movb ra,@QQ19+4                 ; STA QQ19+4        ; Store the updated coordinate in QQ19+4

TT180:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT105
* Type: Subroutine
* Category: Charts
* Summary: Draw crosshairs on the Short-range Chart, with clipping
* 
* ------------------------------------------------------------------------------
* 
* Check whether the crosshairs are close enough to the current system to appear
* on the Short-range Chart, and if so, draw them.
* 
* ******************************************************************************

TT105:
       movb @QQ9,ra                    ; LDA QQ9           ; Set A = QQ9 - QQ0, the horizontal distance between the
       .sec                            ; SEC               ; crosshairs (QQ9) and the current system (QQ0)
       .sbc @QQ0,ra                    ; SBC QQ0           

       ci   ra,>26*256                 ; CMP #38           ; If the horizontal distance in A < 38, then the
       jnc  TT179                      ; BCC TT179         ; crosshairs are close enough to the current system to
                                                           ; appear in the Short-range Chart, so jump to TT179 to
                                                           ; check the vertical distance

       ci   ra,>e6*256                 ; CMP #230          ; If the horizontal distance in A < -26, then the
       jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
                                                           ; appear in the Short-range Chart, so jump to TT180 to
                                                           ; return from the subroutine (as TT180 contains an RTS)

TT179:
       .asla                           ; ASL A             ; Set QQ19 = 104 + A * 4
       .asla                           ; ASL A             ; 
       .clc                            ; CLC               ; 104 is the x-coordinate of the centre of the chart,
       .adi (>68*256)                  ; ADC #104          ; so this sets QQ19 to the screen pixel x-coordinate
       movb ra,@QQ19                   ; STA QQ19          ; of the crosshairs

       movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
       .sec                            ; SEC               ; crosshairs (QQ10) and the current system (QQ1)
       .sbc @QQ1,ra                    ; SBC QQ1           

       ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is < 38, then the
       jnc  B57                        ; BCC B57           ; crosshairs are close enough to the current system to
                                                           ; appear in the Short-range Chart, so skip the next two
                                                           ; instructions

       ci   ra,>dc*256                 ; CMP #220          ; If the horizontal distance in A is < -36, then the
       jnc  TT180                      ; BCC TT180         ; crosshairs are too far from the current system to
                                                           ; appear in the Short-range Chart, so jump to TT180 to
                                                           ; return from the subroutine (as TT180 contains an RTS)

B57:
       .asla                           ; ASL A             ; Set QQ19+1 = 90 + A * 2
       .clc                            ; CLC               ; 
       .adi (>5a*256)                  ; ADC #90           ; 90 is the y-coordinate of the centre of the chart,
       movb ra,@QQ19+1                 ; STA QQ19+1        ; so this sets QQ19+1 to the screen pixel x-coordinate
                                                           ; of the crosshairs

       li   ra,>08*256                 ; LDA #8            ; Set QQ19+2 to 8 denote crosshairs of size 8
       movb ra,@QQ19+2                 ; STA QQ19+2        

       b    @TT15                      ; JMP TT15          ; Jump to TT15 to draw crosshairs of size 8 at the
                                                           ; crosshairs coordinates, returning from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: TT23
* Type: Subroutine
* Category: Charts
* Summary: Show the Short-range Chart (red key f5)
* 
* ******************************************************************************

TT23:
       li   ra,>80*256                 ; LDA #128          ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 128 (Short-
                                                           ; range Chart)

       li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7
       movb ra,@XC                     ; STA XC            

       li   ra,>be*256                 ; LDA #190          ; Print recursive token 30 ("SHORT RANGE CHART") and
       .jsr @NLIN3                     ; JSR NLIN3         ; draw a horizontal line at pixel row 19 to box in the
                                                           ; title

       .jsr @TT14                      ; JSR TT14          ; Call TT14 to draw a circle with crosshairs at the
                                                           ; current system's galactic coordinates

       .jsr @TT103                     ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
                                                           ; i.e. at the selected system

       .jsr @TT81                      ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
                                                           ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

       li   ra,>00*256                 ; LDA #0            ; Set A = 0, which we'll use below to zero out the INWK
                                                           ; workspace

       movb ra,@XX20                   ; STA XX20          ; We're about to start working our way through each of
                                                           ; the galaxy's systems, so set up a counter in XX20 for
                                                           ; each system, starting at 0 and looping through to 255

       li   rx,>18*256                 ; LDX #24           ; First, though, we need to zero out the 25 bytes at
                                                           ; INWK so we can use them to work out which systems have
                                                           ; room for a label, so set a counter in X for 25 bytes

EE3:
       movb ra,@INWK(rx)               ; STA INWK,X        ; Set the X-th byte of INWK to zero

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  EE3                        ; BPL EE3           ; Loop back to EE3 for the next byte until we've zeroed
                                                           ; all 25 bytes

                                                           ; We now loop through every single system in the galaxy
                                                           ; and check the distance from the current system whose
                                                           ; coordinates are in (QQ0, QQ1). We get the galactic
                                                           ; coordinates of each system from the system's seeds,
                                                           ; like this:
                                                           ; 
                                                           ; x = s1_hi (which is stored in QQ15+3)
                                                           ; y = s0_hi (which is stored in QQ15+1)
                                                           ; 
                                                           ; so the following loops through each system in the
                                                           ; galaxy in turn and calculates the distance between
                                                           ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one

TT182:
       movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
       .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
       .sbc @QQ0,ra                    ; SBC QQ0           

       joc  TT184                      ; BCS TT184         ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
                                                           ; result is positive, so jump to TT184 and skip the
                                                           ; following two instructions

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
       .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ0|)

TT184:
       ci   ra,>14*256                 ; CMP #20           ; If the horizontal distance in A is >= 20, then this
       joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
                                                           ; appear in the Short-range Chart, so jump to TT187 to
                                                           ; move on to the next system

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
       .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ0, QQ1)
       .sbc @QQ1,ra                    ; SBC QQ1           

       joc  TT186                      ; BCS TT186         ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
                                                           ; result is positive, so jump to TT186 and skip the
                                                           ; following two instructions

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
       .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ1|)

TT186:
       ci   ra,>26*256                 ; CMP #38           ; If the vertical distance in A is >= 38, then this
       joc  TT187                      ; BCS TT187         ; system is too far away from the current system to
                                                           ; appear in the Short-range Chart, so jump to TT187 to
                                                           ; move on to the next system

                                                           ; This system should be shown on the Short-range Chart,
                                                           ; so now we need to work out where the label should go,
                                                           ; and set up the various variables we need to draw the
                                                           ; system's filled circle on the chart

       movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ0, the horizontal distance between
       .sec                            ; SEC               ; this system and the current system, where |A| < 20.
       .sbc @QQ0,ra                    ; SBC QQ0           ; Let's call this the x-delta, as it's the horizontal
                                                           ; difference between the current system at the centre of
                                                           ; the chart, and this system (and this time we keep the
                                                           ; sign of A, so it can be negative if it's to the left
                                                           ; of the chart's centre, or positive if it's to the
                                                           ; right)

       .asla                           ; ASL A             ; Set XX12 = 104 + x-delta * 4
       .asla                           ; ASL A             ; 
       .adi (>68*256)                  ; ADC #104          ; 104 is the x-coordinate of the centre of the chart,
       movb ra,@XX12                   ; STA XX12          ; so this sets XX12 to the centre 104 +/- 76, the pixel
                                                           ; x-coordinate of this system

       srl  ra,1                       ; LSR A             ; Move the text cursor to column x-delta / 2 + 1
       srl  ra,1                       ; LSR A             ; which will be in the range 1-10
       srl  ra,1                       ; LSR A             
       movb ra,@XC                     ; STA XC            
       ab   rone,ra                    ; INC XC            

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ1, the vertical distance between
       .sec                            ; SEC               ; this system and the current system, where |A| < 38.
       .sbc @QQ1,ra                    ; SBC QQ1           ; Let's call this the y-delta, as it's the vertical
                                                           ; difference between the current system at the centre of
                                                           ; the chart, and this system (and this time we keep the
                                                           ; sign of A, so it can be negative if it's above the
                                                           ; chart's centre, or positive if it's below)

       .asla                           ; ASL A             ; Set K4 = 90 + y-delta * 2
       .adi (>5a*256)                  ; ADC #90           ; 
       movb ra,@K4                     ; STA K4            ; 90 is the y-coordinate of the centre of the chart,
                                                           ; so this sets K4 to the centre 90 +/- 74, the pixel
                                                           ; y-coordinate of this system

       srl  ra,1                       ; LSR A             ; Set Y = K4 / 8, so Y contains the number of the text
       srl  ra,1                       ; LSR A             ; row that contains this system
       srl  ra,1                       ; LSR A             
       movb ra,ry                      ; TAY               

                                                           ; Now to see if there is room for this system's label.
                                                           ; Ideally we would print the system name on the same
                                                           ; text row as the system, but we only want to print one
                                                           ; label per row, to prevent overlap, so now we check
                                                           ; this system's row, and if that's already occupied,
                                                           ; the row above, and if that's already occupied, the
                                                           ; row below... and if that's already occupied, we give
                                                           ; up and don't print a label for this system

       movb @INWK(ry),rx               ; LDX INWK,Y        ; If the value in INWK+Y is 0 (i.e. the text row
       jeq  EE4                        ; BEQ EE4           ; containing this system does not already have another
                                                           ; system's label on it), jump to EE4 to store this
                                                           ; system's label on this row

       ab   rone,ry                    ; INY               ; If the value in INWK+Y+1 is 0 (i.e. the text row below
       movb @INWK(ry),rx               ; LDX INWK,Y        ; the one containing this system does not already have
       jeq  EE4                        ; BEQ EE4           ; another system's label on it), jump to EE4 to store
                                                           ; this system's label on this row

       sb   rone,ry                    ; DEY               ; If the value in INWK+Y-1 is 0 (i.e. the text row above
       sb   rone,ry                    ; DEY               ; the one containing this system does not already have
       movb @INWK(ry),rx               ; LDX INWK,Y        ; another system's label on it), fall through into to
       jne  ee1_                       ; BNE ee1           ; EE4 to store this system's label on this row,
                                                           ; otherwise jump to ee1 to skip printing a label for
                                                           ; this system (as there simply isn't room)

EE4:
       movb ry,@YC                     ; STY YC            ; Now to print the label, so move the text cursor to row
                                                           ; Y (which contains the row where we can print this
                                                           ; system's label)

       ci   ry,>03*256                 ; CPY #3            ; If Y < 3, then the system would clash with the chart
       jnc  TT187                      ; BCC TT187         ; title, so jump to TT187 to skip showing the system

       sb   rone,rx                    ; DEX               ; We entered the EE4 routine with X = 0, so this stores
       movb rx,@INWK(ry)               ; STX INWK,Y        ; &FF in INWK+Y, to denote that this row is now occupied
                                                           ; so we don't try to print another system's label on
                                                           ; this row

       li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case
       movb ra,@QQ17                   ; STA QQ17          

       .jsr @cpl_                      ; JSR cpl           ; Call cpl to print out the system name for the seeds
                                                           ; in QQ15 (which now contains the seeds for the current
                                                           ; system)

ee1_:
       li   ra,>00*256                 ; LDA #0            ; Now to plot the star, so set the high bytes of K, K3
       movb ra,@K3+1                   ; STA K3+1          ; and K4 to 0
       movb ra,@K4+1                   ; STA K4+1          
       movb ra,@K+1                    ; STA K+1           

       movb @XX12,ra                   ; LDA XX12          ; Set the low byte of K3 to XX12, the pixel x-coordinate
       movb ra,@K3                     ; STA K3            ; of this system

       movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi for this system from QQ15+5, extract bit 0
       andi ra,>01*256                 ; AND #1            ; and add 2 to get the size of the star, which we store
       .adi (>02*256)                  ; ADC #2            ; in K. This will be either 2, 3 or 4, depending on the
       movb ra,@K                      ; STA K             ; value of bit 0, and whether the C flag is set (which
                                                           ; will vary depending on what happens in the above call
                                                           ; to cpl). Incidentally, the planet's average radius
                                                           ; also uses s2_hi, bits 0-3 to be precise, but that
                                                           ; doesn't mean the two sizes affect each other

                                                           ; We now have the following:
                                                           ; 
                                                           ; K(1 0)  = radius of star (2, 3 or 4)
                                                           ; 
                                                           ; K3(1 0) = pixel x-coordinate of system
                                                           ; 
                                                           ; K4(1 0) = pixel y-coordinate of system
                                                           ; 
                                                           ; which we can now pass to the SUN routine to draw a
                                                           ; small "sun" on the Short-range Chart for this system

       .jsr @FLFLLS                    ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block

       .jsr @SUN                       ; JSR SUN           ; Call SUN to plot a sun with radius K at pixel
                                                           ; coordinate (K3, K4)

       .jsr @FLFLLS                    ; JSR FLFLLS        ; Call FLFLLS to reset the LSO block

TT187:
       .jsr @TT20                      ; JSR TT20          ; We want to move on to the next system, so call TT20
                                                           ; to twist the three 16-bit seeds in QQ15

       ab   rone,ra                    ; INC XX20          ; Increment the counter

       jeq  TT111-1                    ; BEQ TT111-1       ; If X = 0 then we have done all 256 systems, so return
                                                           ; from the subroutine (as TT111-1 contains an RTS)

       b    @TT182                     ; JMP TT182         ; Otherwise jump back up to TT182 to process the next
                                                           ; system

* ******************************************************************************
* 
* Name: TT81
* Type: Subroutine
* Category: Universe
* Summary: Set the selected system's seeds to those of system 0
* 
* ------------------------------------------------------------------------------
* 
* Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
* seeds for the selected system (QQ15) - in other words, set the selected
* system's seeds to those of system 0.
* 
* ******************************************************************************

TT81:
       li   rx,>05*256                 ; LDX #5            ; Set up a counter in X to copy six bytes (for three
                                                           ; 16-bit numbers)

       movb @QQ21(rx),ra               ; LDA QQ21,X        ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
       movb ra,@QQ15(rx)               ; STA QQ15,X        

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  TT81+2                     ; BPL TT81+2        ; Loop back up to the LDA instruction if we still have
                                                           ; more bytes to copy

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT111
* Type: Subroutine
* Category: Universe
* Summary: Set the current system to the nearest system to a point
* 
* ------------------------------------------------------------------------------
* 
* Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
* to this point in the galaxy, and set this as the currently selected system.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* QQ9                 The x-coordinate near which we want to find a system
* 
* QQ10                The y-coordinate near which we want to find a system
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* QQ8(1 0)            The distance from the current system to the nearest
* system to the original coordinates
* 
* QQ9                 The x-coordinate of the nearest system to the original
* coordinates
* 
* QQ10                The y-coordinate of the nearest system to the original
* coordinates
* 
* QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
* original coordinates
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT111-1             Contains an RTS
* 
* ******************************************************************************

TT111:
       .jsr @TT81                      ; JSR TT81          ; Set the seeds in QQ15 to those of system 0 in the
                                                           ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

                                                           ; We now loop through every single system in the galaxy
                                                           ; and check the distance from (QQ9, QQ10). We get the
                                                           ; galactic coordinates of each system from the system's
                                                           ; seeds, like this:
                                                           ; 
                                                           ; x = s1_hi (which is stored in QQ15+3)
                                                           ; y = s0_hi (which is stored in QQ15+1)
                                                           ; 
                                                           ; so the following loops through each system in the
                                                           ; galaxy in turn and calculates the distance between
                                                           ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one

       li   ry,>7f*256                 ; LDY #127          ; Set Y = T = 127 to hold the shortest distance we've
       movb ry,@T                      ; STY T             ; found so far, which we initially set to half the
                                                           ; distance across the galaxy, or 127, as our coordinate
                                                           ; system ranges from (0,0) to (255, 255)

       li   ra,>00*256                 ; LDA #0            ; Set A = U = 0 to act as a counter for each system in
       movb ra,@U                      ; STA U             ; the current galaxy, which we start at system 0 and
                                                           ; loop through to 255, the last system

TT130:
       movb @QQ15+3,ra                 ; LDA QQ15+3        ; Set A = s1_hi - QQ9, the horizontal distance between
       .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
       .sbc @QQ9,ra                    ; SBC QQ9           

       joc  TT132                      ; BCS TT132         ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
                                                           ; result is positive, so jump to TT132 and skip the
                                                           ; following two instructions

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
       .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s1_hi - QQ9|)

TT132:
       srl  ra,1                       ; LSR A             ; Set S = A / 2
       movb ra,@S                      ; STA S             ; = |s1_hi - QQ9| / 2

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Set A = s0_hi - QQ10, the vertical distance between
       .sec                            ; SEC               ; (s1_hi, s0_hi) and (QQ9, QQ10)
       .sbc @QQ10,ra                   ; SBC QQ10          

       joc  TT134                      ; BCS TT134         ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
                                                           ; result is positive, so jump to TT134 and skip the
                                                           ; following two instructions

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
       .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |s0_hi - QQ10|)

TT134:
       srl  ra,1                       ; LSR A             ; Set A = S + A / 2
       .clc                            ; CLC               ; = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
       .adc @S,ra                      ; ADC S             ; 
                                                           ; So A now contains the sum of the horizontal and
                                                           ; vertical distances, both divided by 2 so the result
                                                           ; fits into one byte, and although this doesn't contain
                                                           ; the actual distance between the systems, it's a good
                                                           ; enough approximation to use for comparing distances

       cb   @T,ra                      ; CMP T             ; If A >= T, then this system's distance is bigger than
       joc  TT135                      ; BCS TT135         ; our "minimum distance so far" stored in T, so it's no
                                                           ; closer than the systems we have already found, so
                                                           ; skip to TT135 to move on to the next system

       movb ra,@T                      ; STA T             ; This system is the closest to (QQ9, QQ10) so far, so
                                                           ; update T with the new "distance" approximation

       li   rx,>05*256                 ; LDX #5            ; As this system is the closest we have found yet, we
                                                           ; want to store the system's seeds in case it ends up
                                                           ; being the closest of all, so we set up a counter in X
                                                           ; to copy six bytes (for three 16-bit numbers)

TT136:
       movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
       movb ra,@QQ19(rx)               ; STA QQ19,X        ; where QQ15 contains the seeds for the system we just
                                                           ; found to be the closest so far, and QQ19 is temporary
                                                           ; storage

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  TT136                      ; BPL TT136         ; Loop back to TT136 if we still have more bytes to
                                                           ; copy

TT135:
       .jsr @TT20                      ; JSR TT20          ; We want to move on to the next system, so call TT20
                                                           ; to twist the three 16-bit seeds in QQ15

       ab   rone,ra                    ; INC U             ; Increment the system counter in U

       jne  TT130                      ; BNE TT130         ; If U > 0 then we haven't done all 256 systems yet, so
                                                           ; loop back up to TT130

                                                           ; We have now finished checking all the systems in the
                                                           ; galaxy, and the seeds for the closest system are in
                                                           ; QQ19, so now we want to copy these seeds to QQ15,
                                                           ; to set the selected system to this closest system

       li   rx,>05*256                 ; LDX #5            ; So we set up a counter in X to copy six bytes (for
                                                           ; three 16-bit numbers)

TT137:
       movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
       movb ra,@QQ15(rx)               ; STA QQ15,X        

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  TT137                      ; BPL TT137         ; Loop back to TT137 if we still have more bytes to
                                                           ; copy

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; The y-coordinate of the system described by the seeds
       movb ra,@QQ10                   ; STA QQ10          ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
                                                           ; as this is where we store the selected system's
                                                           ; y-coordinate

       movb @QQ15+3,ra                 ; LDA QQ15+3        ; The x-coordinate of the system described by the seeds
       movb ra,@QQ9                    ; STA QQ9           ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
                                                           ; as this is where we store the selected system's
                                                           ; x-coordinate

                                                           ; We have now found the closest system to (QQ9, QQ10)
                                                           ; and have set it as the selected system, so now we
                                                           ; need to work out the distance between the selected
                                                           ; system and the current system

       .sec                            ; SEC               ; Set A = QQ9 - QQ0, the horizontal distance between
       .sbc @QQ0,ra                    ; SBC QQ0           ; the selected system's x-coordinate (QQ9) and the
                                                           ; current system's x-coordinate (QQ0)

       joc  TT139                      ; BCS TT139         ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
                                                           ; result is positive, so jump to TT139 and skip the
                                                           ; following two instructions

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
       .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ9 - QQ0|)

                                                           ; A now contains the difference between the two
                                                           ; systems' x-coordinates, with the sign removed. We
                                                           ; will refer to this as the x-delta ("delta" means
                                                           ; change or difference in maths)

TT139:
       .jsr @SQUA2                     ; JSR SQUA2         ; Set (A P) = A * A
                                                           ; = |QQ9 - QQ0| ^ 2
                                                           ; = x_delta ^ 2

       movb ra,@K+1                    ; STA K+1           ; Store (A P) in K(1 0)
       movb @P,ra                      ; LDA P             
       movb ra,@K                      ; STA K             

       movb @QQ10,ra                   ; LDA QQ10          ; Set A = QQ10 - QQ1, the vertical distance between the
       .sec                            ; SEC               ; selected system's y-coordinate (QQ10) and the current
       .sbc @QQ1,ra                    ; SBC QQ1           ; system's y-coordinate (QQ1)

       joc  TT141                      ; BCS TT141         ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
                                                           ; result is positive, so jump to TT141 and skip the
                                                           ; following two instructions

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise negate the result in A, so A is always
       .adi (>01*256)                  ; ADC #1            ; positive (i.e. A = |QQ10 - QQ1|)

TT141:
       srl  ra,1                       ; LSR A             ; Set A = A / 2

                                                           ; A now contains the difference between the two
                                                           ; systems' y-coordinates, with the sign removed, and
                                                           ; halved. We halve the value because the galaxy in
                                                           ; in Elite is rectangular rather than square, and is
                                                           ; twice as wide (x-axis) as it is high (y-axis), so to
                                                           ; get a distance that matches the shape of the
                                                           ; long-range galaxy chart, we need to halve the
                                                           ; distance between the vertical y-coordinates. We will
                                                           ; refer to this as the y-delta

       .jsr @SQUA2                     ; JSR SQUA2         ; Set (A P) = A * A
                                                           ; = (|QQ10 - QQ1| / 2) ^ 2
                                                           ; = y_delta ^ 2

                                                           ; By this point we have the following results:
                                                           ; 
                                                           ; K(1 0) = x_delta ^ 2
                                                           ; (A P) = y_delta ^ 2
                                                           ; 
                                                           ; so to find the distance between the two points, we
                                                           ; can use Pythagoras - so first we need to add the two
                                                           ; results together, and then take the square root

       .pha                            ; PHA               ; Store the high byte of the y-axis value on the stack,
                                                           ; so we can use A for another purpose

       movb @P,ra                      ; LDA P             ; Set Q = P + K, which adds the low bytes of the two
       .clc                            ; CLC               ; calculated values
       .adc @K,ra                      ; ADC K             
       movb ra,@Q                      ; STA Q             

       .pla                            ; PLA               ; Restore the high byte of the y-axis value from the
                                                           ; stack into A again

       .adc @K+1,ra                    ; ADC K+1           ; Set R = A + K+1, which adds the high bytes of the two
       movb ra,@R                      ; STA R             ; calculated values, so we now have:
                                                           ; 
                                                           ; (R Q) = K(1 0) + (A P)
                                                           ; = (x_delta ^ 2) + (y_delta ^ 2)

       .jsr @LL5                       ; JSR LL5           ; Set Q = SQRT(R Q), so Q now contains the distance
                                                           ; between the two systems, in terms of coordinates

                                                           ; We now store the distance to the selected system * 4
                                                           ; in the two-byte location QQ8, by taking (0 Q) and
                                                           ; shifting it left twice, storing it in QQ8(1 0)

       movb @Q,ra                      ; LDA Q             ; First we shift the low byte left by setting
       .asla                           ; ASL A             ; A = Q * 2, with bit 7 of A going into the C flag

       li   rx,>00*256                 ; LDX #0            ; Now we set the high byte in QQ8+1 to 0 and rotate
       movb rx,@QQ8+1                  ; STX QQ8+1         ; the C flag into bit 0 of QQ8+1
       .rol @QQ8+1                     ; ROL QQ8+1         

       .asla                           ; ASL A             ; And then we repeat the shift left of (QQ8+1 A)
       .rol @QQ8+1                     ; ROL QQ8+1         

       movb ra,@QQ8                    ; STA QQ8           ; And store A in the low byte, QQ8, so QQ8(1 0) now
                                                           ; contains Q * 4. Given that the width of the galaxy is
                                                           ; 256 in coordinate terms, the width of the galaxy
                                                           ; would be 1024 in the units we store in QQ8

       b    @TT24                      ; JMP TT24          ; Call TT24 to calculate system data from the seeds in
                                                           ; QQ15 and store them in the relevant locations, so our
                                                           ; new selected system is fully set up, and return from
                                                           ; the subroutine using a tail call

* ******************************************************************************
* 
* Name: hy6
* Type: Subroutine
* Category: Flight
* Summary: Print a message to say there is no hyperspacing allowed inside the
* station
* 
* ------------------------------------------------------------------------------
* 
* Print "Docked" at the bottom of the screen to indicate we can't hyperspace
* when docked.
* 
* ******************************************************************************

hy6_:
       .jsr @CLYNS                     ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
                                                           ; and move the text cursor to column 1 on row 21, i.e.
                                                           ; the start of the top row of the three bottom rows

       li   ra,>0f*256                 ; LDA #15           ; Move the text cursor to column 15 (the middle of the
       movb ra,@XC                     ; STA XC            ; screen), setting A to 15 at the same time for the
                                                           ; following call to TT27

       b    @TT27                      ; JMP TT27          ; Print recursive token 129 ("{sentence case}DOCKED")
                                                           ; and return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: hyp
* Type: Subroutine
* Category: Flight
* Summary: Start the hyperspace process
* 
* ------------------------------------------------------------------------------
* 
* Called when "H" or CTRL-H is pressed during flight. Checks the following:
* 
* * We are in space
* 
* * We are not already in a hyperspace countdown
* 
* If CTRL is being held down, we jump to Ghy to engage the galactic hyperdrive,
* otherwise we check that:
* 
* * The selected system is not the current system
* 
* * We have enough fuel to make the jump
* 
* and if all the pre-jump checks are passed, we print the destination on-screen
* and start the countdown.
* 
* ******************************************************************************

hyp_:
       movb @QQ12,ra                   ; LDA QQ12          ; If we are docked (QQ12 = &FF) then jump to hy6 to
       jne  hy6_                       ; BNE hy6           ; print an error message and return from the subroutine
                                                           ; using a tail call (as we can't hyperspace when docked)

       movb @QQ22+1,ra                 ; LDA QQ22+1        ; Fetch QQ22+1, which contains the number that's shown
                                                           ; on-screen during hyperspace countdown

       jne  zZ_+1                      ; BNE zZ_+1         ; If it is non-zero, return from the subroutine (as zZ+1
                                                           ; contains an RTS), as there is already a countdown in
                                                           ; progress

       .jsr @CTRL                      ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed

       jlt  Ghy                        ; BMI Ghy           ; If it is, then the galactic hyperdrive has been
                                                           ; activated, so jump to Ghy to process it

       .jsr @hm_                       ; JSR hm            ; This is a chart view, so call hm to redraw the chart
                                                           ; crosshairs

       movb @QQ8,ra                    ; LDA QQ8           ; If both bytes of the distance to the selected system
       socb @QQ8+1,ra                  ; ORA QQ8+1         ; in QQ8 are zero, return from the subroutine (as zZ+1
       jeq  zZ_+1                      ; BEQ zZ_+1         ; contains an RTS), as the selected system is the
                                                           ; current system

       li   ra,>07*256                 ; LDA #7            ; Move the text cursor to column 7, row 23 (in the
       movb ra,@XC                     ; STA XC            ; middle of the bottom text row)
       li   ra,>17*256                 ; LDA #23           
       movb ra,@YC                     ; STA YC            

       li   ra,>00*256                 ; LDA #0            ; Set QQ17 = 0 to switch to ALL CAPS
       movb ra,@QQ17                   ; STA QQ17          

       li   ra,>bd*256                 ; LDA #189          ; Print recursive token 29 ("HYPERSPACE ")
       .jsr @TT27                      ; JSR TT27          

       movb @QQ8+1,ra                  ; LDA QQ8+1         ; If the high byte of the distance to the selected
       jne  TT147                      ; BNE TT147         ; system in QQ8 is > 0, then it is definitely too far to
                                                           ; jump (as our maximum range is 7.0 light years, or a
                                                           ; value of 70 in QQ8(1 0)), so jump to TT147 to print
                                                           ; "RANGE?" and return from the subroutine using a tail
                                                           ; call

       movb @QQ14,ra                   ; LDA QQ14          ; Fetch our current fuel level from Q114 into A

       cb   @QQ8,ra                    ; CMP QQ8           ; If our fuel reserves are less than the distance to the
       jnc  TT147                      ; BCC TT147         ; selected system, then we don't have enough fuel for
                                                           ; this jump, so jump to TT147 to print "RANGE?" and
                                                           ; return from the subroutine using a tail call

       li   ra,('-')*256               ; LDA #'-'          ; Print a hyphen
       .jsr @TT27                      ; JSR TT27          

       .jsr @cpl_                      ; JSR cpl           ; Call cpl to print the name of the selected system

                                                           ; Fall through into wW to start the hyperspace countdown

* ******************************************************************************
* 
* Name: wW
* Type: Subroutine
* Category: Flight
* Summary: Start a hyperspace countdown
* 
* ------------------------------------------------------------------------------
* 
* Start the hyperspace countdown (for both inter-system hyperspace and the
* galactic hyperdrive).
* 
* ******************************************************************************

wW:
       li   ra,>0f*256                 ; LDA #15           ; The hyperspace countdown starts from 15, so set A to
                                                           ; 15 so we can set the two hyperspace counters

       movb ra,@QQ22+1                 ; STA QQ22+1        ; Set the number in QQ22+1 to A, which is the number
                                                           ; that's shown on-screen during the hyperspace countdown

       movb ra,@QQ22                   ; STA QQ22          ; Set the number in QQ22 to 15, which is the internal
                                                           ; counter that counts down by 1 each iteration of the
                                                           ; main game loop, and each time it reaches zero, the
                                                           ; on-screen counter gets decremented, and QQ22 gets set
                                                           ; to 5, so setting QQ22 to 15 here makes the first tick
                                                           ; of the hyperspace counter longer than subsequent ticks

       movb ra,rx                      ; TAX               ; Print the 8-bit number in X (i.e. 15) at text location
       b    @ee3_                      ; JMP ee3           ; (0, 1), padded to 5 digits, so it appears in the top
                                                           ; left corner of the screen, and return from the
                                                           ; subroutine using a tail call

* .hy5                   \ This instruction and the hy5 label are commented out
* RTS                    \ in the original - they can actually be found at the
                                                           ; end of the jmp routine below, so perhaps this is where
                                                           ; they were originally, but the authors realised they
                                                           ; could save a byte by using a tail call instead of an
                                                           ; RTS?

* ******************************************************************************
* 
* Name: Ghy
* Type: Subroutine
* Category: Flight
* Summary: Perform a galactic hyperspace jump
* Deep dive: Twisting the system seeds
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
* being pressed.
* 
* This routine also updates the galaxy seeds to point to the next galaxy. Using
* a galactic hyperdrive rotates each seed byte to the left, rolling each byte
* left within itself like this:
* 
* 01234567 -> 12345670
* 
* to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
* roll round to those of the first galaxy again.
* 
* We always arrive in a new galaxy at galactic coordinates (96, 96), and then
* find the nearest system and set that as our location.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* zZ+1                Contains an RTS
* 
* ******************************************************************************

Ghy:
       .jsr @TT111                     ; JSR TT111         ; Call TT111 to set the current system to the nearest
                                                           ; system to (QQ9, QQ10), and put the seeds of the
                                                           ; nearest system into QQ15 to QQ15+5
                                                           ; 
                                                           ; This appears to be a failed attempt to fix a bug in
                                                           ; the cassette version, where the galactic hyperdrive
                                                           ; will take us to coordinates (96, 96) in the new
                                                           ; galaxy, even if there isn't actually a system there,
                                                           ; so if we jump when you are low on fuel, it is
                                                           ; possible to get stuck in the middle of nowhere when
                                                           ; changing galaxy
                                                           ; 
                                                           ; All the other versions contain a fix for this bug that
                                                           ; involves adding an extra JSR TT111 instruction after
                                                           ; the coordinates are set to (96, 96) below, which finds
                                                           ; the nearest system to those coordinates  and sets that
                                                           ; as the current system
                                                           ; 
                                                           ; The cassette version on the original source disc
                                                           ; doesn't contain this instruction, and although the
                                                           ; text sources do, it's in the wrong place at the start
                                                           ; of the Ghy routine, as the fix only works if it's done
                                                           ; after the new coordinates are set, not before


       movb @GHYP,rx                   ; LDX GHYP          ; Fetch GHYP, which tells us whether we own a galactic
       jeq  hy5_                       ; BEQ hy5           ; hyperdrive, and if it is zero, which means we don't,
                                                           ; return from the subroutine (as hy5 contains an RTS)

       ab   rone,rx                    ; INX               ; We own a galactic hyperdrive, so X is &FF, so this
                                                           ; instruction sets X = 0


       movb rx,@QQ8                    ; STX QQ8           ; Set the distance to the selected system in QQ8(1 0)
       movb rx,@QQ8+1                  ; STX QQ8+1         ; to 0


       movb rx,@GHYP                   ; STX GHYP          ; The galactic hyperdrive is a one-use item, so set GHYP
                                                           ; to 0 so we no longer have one fitted

       movb rx,@FIST                   ; STX FIST          ; Changing galaxy also clears our criminal record, so
                                                           ; set our legal status in FIST to 0 ("clean")

       .jsr @wW                        ; JSR wW            ; Call wW to start the hyperspace countdown

       li   rx,>05*256                 ; LDX #5            ; To move galaxy, we rotate the galaxy's seeds left, so
                                                           ; set a counter in X for the 6 seed bytes

       ab   rone,ra                    ; INC GCNT          ; Increment the current galaxy number in GCNT

       movb @GCNT,ra                   ; LDA GCNT          ; Set GCNT = GCNT mod 8, so we jump from galaxy 7 back
       andi ra,>07*256                 ; AND #7            ; to galaxy 0 (shown in-game as going from galaxy 8 back
       movb ra,@GCNT                   ; STA GCNT          ; to the starting point in galaxy 1)

G1:
       movb @QQ21(rx),ra               ; LDA QQ21,X        ; Load the X-th seed byte into A

       .asla                           ; ASL A             ; Set the C flag to bit 7 of the seed

       .rol @QQ21(rx)                  ; ROL QQ21,X        ; Rotate the seed in memory, which will add bit 7 back
                                                           ; in as bit 0, so this rolls the seed around on itself

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  G1                         ; BPL G1            ; Loop back for the next seed byte, until we have
                                                           ; rotated them all

* JSR DORND              \ This instruction is commented out in the original
                                                           ; source, and would set A and X to random numbers, so
                                                           ; perhaps the original plan was to arrive in each new
                                                           ; galaxy in a random place?

zZ_:
       li   ra,>60*256                 ; LDA #96           ; Set (QQ9, QQ10) to (96, 96), which is where we always
       movb ra,@QQ9                    ; STA QQ9           ; arrive in a new galaxy (the selected system will be
       movb ra,@QQ10                   ; STA QQ10          ; set to the nearest actual system later on)

       .jsr @TT110                     ; JSR TT110         ; Call TT110 to show the front space view


       .jsr @TT111                     ; JSR TT111         ; Call TT111 to set the current system to the nearest
                                                           ; system to (QQ9, QQ10), and put the seeds of the
                                                           ; nearest system into QQ15 to QQ15+5
                                                           ; 
                                                           ; This call fixes a bug in the early cassette versions,
                                                           ; where the galactic hyperdrive will take us to
                                                           ; coordinates (96, 96) in the new galaxy, even if there
                                                           ; isn't actually a system there, so if we jump when we
                                                           ; are low on fuel, it is possible to get stuck in the
                                                           ; middle of nowhere when changing galaxy
                                                           ; 
                                                           ; This call sets the current system correctly, so we
                                                           ; always arrive at the nearest system to (96, 96)



       li   rx,>00*256                 ; LDX #0            ; Set the distance to the selected system in QQ8(1 0)
       movb rx,@QQ8                    ; STX QQ8           ; to 0
       movb rx,@QQ8+1                  ; STX QQ8+1         


       li   ra,>74*256                 ; LDA #116          ; Print recursive token 116 ("GALACTIC HYPERSPACE")
       .jsr @MESS                      ; JSR MESS          ; as an in-flight message

                                                           ; Fall through into jmp to set the system to the
                                                           ; current system and return from the subroutine there

* ******************************************************************************
* 
* Name: jmp
* Type: Subroutine
* Category: Universe
* Summary: Set the current system to the selected system
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* (QQ0, QQ1)          The galactic coordinates of the new system
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* hy5                 Contains an RTS
* 
* ******************************************************************************

jmp_:
       movb @QQ9,ra                    ; LDA QQ9           ; Set the current system's galactic x-coordinate to the
       movb ra,@QQ0                    ; STA QQ0           ; x-coordinate of the selected system

       movb @QQ10,ra                   ; LDA QQ10          ; Set the current system's galactic y-coordinate to the
       movb ra,@QQ1                    ; STA QQ1           ; y-coordinate of the selected system

hy5_:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ee3
* Type: Subroutine
* Category: Flight
* Summary: Print the hyperspace countdown in the top-left of the screen
* 
* ------------------------------------------------------------------------------
* 
* Print the 8-bit number in X at text location (0, 1). Print the number to
* 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
* numbers < 10000 are right-aligned), with no decimal point.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The number to print
* 
* ******************************************************************************

ee3_:
       li   ry,>01*256                 ; LDY #1            ; Move the text cursor to row 1
       movb ry,@YC                     ; STY YC            

       sb   rone,ry                    ; DEY               ; Decrement Y to 0 for the high byte in pr6

       movb ry,@XC                     ; STY XC            ; Move the text cursor to column 0

                                                           ; Fall through into pr6 to print X to 5 digits, as the
                                                           ; high byte in Y is 0

* ******************************************************************************
* 
* Name: pr6
* Type: Subroutine
* Category: Text
* Summary: Print 16-bit number, left-padded to 5 digits, no point
* 
* ------------------------------------------------------------------------------
* 
* Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
* numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
* with no decimal point.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The low byte of the number to print
* 
* Y                   The high byte of the number to print
* 
* ******************************************************************************

pr6_:
       .clc                            ; CLC               ; Do not display a decimal point when printing

                                                           ; Fall through into pr5 to print X to 5 digits

* ******************************************************************************
* 
* Name: pr5
* Type: Subroutine
* Category: Text
* Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
* 
* ------------------------------------------------------------------------------
* 
* Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
* numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
* Optionally include a decimal point.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The low byte of the number to print
* 
* Y                   The high byte of the number to print
* 
* C flag              If set, include a decimal point
* 
* ******************************************************************************

pr5_:
       li   ra,>05*256                 ; LDA #5            ; Set the number of digits to print to 5

       b    @TT11                      ; JMP TT11          ; Call TT11 to print (Y X) to 5 digits and return from
                                                           ; the subroutine using a tail call

* ******************************************************************************
* 
* Name: TT147
* Type: Subroutine
* Category: Flight
* Summary: Print an error when a system is out of hyperspace range
* 
* ------------------------------------------------------------------------------
* 
* Print "RANGE?" for when the hyperspace distance is too far
* 
* ******************************************************************************

TT147:
       li   ra,>ca*256                 ; LDA #202          ; Load A with token 42 ("RANGE") and fall through into
                                                           ; prq to print it, followed by a question mark

* ******************************************************************************
* 
* Name: prq
* Type: Subroutine
* Category: Text
* Summary: Print a text token followed by a question mark
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* prq+3               Print a question mark
* 
* ******************************************************************************

prq_:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A

       li   ra,('?')*256               ; LDA #'?'          ; Print a question mark and return from the
       b    @TT27                      ; JMP TT27          ; subroutine using a tail call

* ******************************************************************************
* 
* Name: TT151
* Type: Subroutine
* Category: Market
* Summary: Print the name, price and availability of a market item
* Deep dive: Market item prices and availability
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The number of the market item to print, 0-16 (see QQ23
* for details of item numbers)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* QQ19+1              Byte #1 from the market prices table for this item
* 
* QQ24                The item's price / 4
* 
* QQ25                The item's availability
* 
* ******************************************************************************

TT151:
       .pha                            ; PHA               ; Store the item number on the stack and in QQ19+4
       movb ra,@QQ19+4                 ; STA QQ19+4        

       .asla                           ; ASL A             ; Store the item number * 4 in QQ19, so this will act as
       .asla                           ; ASL A             ; an index into the market prices table at QQ23 for this
       movb ra,@QQ19                   ; STA QQ19          ; item (as there are four bytes per item in the table)

       li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1, for the item's name
       movb ra,@XC                     ; STA XC            

       .pla                            ; PLA               ; Restore the item number

       .adi (>d0*256)                  ; ADC #208          ; Print recursive token 48 + A, which will be in the
       .jsr @TT27                      ; JSR TT27          ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
                                                           ; prints the item's name

       li   ra,>0e*256                 ; LDA #14           ; Move the text cursor to column 14, for the price
       movb ra,@XC                     ; STA XC            

       movb @QQ19,rx                   ; LDX QQ19          ; Fetch byte #1 from the market prices table (units and
       movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; economic_factor) for this item and store in QQ19+1
       movb ra,@QQ19+1                 ; STA QQ19+1        

       movb @QQ26,ra                   ; LDA QQ26          ; Fetch the random number for this system visit and
       .and @QQ23+3(rx)                ; AND QQ23+3,X      ; AND with byte #3 from the market prices table (mask)
                                                           ; to give:
                                                           ; 
                                                           ; A = random AND mask

       .clc                            ; CLC               ; Add byte #0 from the market prices table (base_price),
       .adc @QQ23(rx),ra               ; ADC QQ23,X        ; so we now have:
       movb ra,@QQ24                   ; STA QQ24          ; 
                                                           ; A = base_price + (random AND mask)

       .jsr @TT152                     ; JSR TT152         ; Call TT152 to print the item's unit ("t", "kg" or
                                                           ; "g"), padded to a width of two characters

       .jsr @var_                      ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
                                                           ; (and set the availability of alien items to 0)

       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the byte #1 that we stored above and jump to
       jlt  TT155                      ; BMI TT155         ; TT155 if it is negative (i.e. if the economic_factor
                                                           ; is negative)

       movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 + QQ19+3
       .adc @QQ19+3,ra                 ; ADC QQ19+3        ; 
                                                           ; = base_price + (random AND mask)
                                                           ; + (economy * |economic_factor|)
                                                           ; 
                                                           ; which is the result we want, as the economic_factor
                                                           ; is positive

       b    @TT156                     ; JMP TT156         ; Jump to TT156 to multiply the result by 4

TT155:
       movb @QQ24,ra                   ; LDA QQ24          ; Set A = QQ24 - QQ19+3
       .sec                            ; SEC               ; 
       .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; = base_price + (random AND mask)
                                                           ; - (economy * |economic_factor|)
                                                           ; 
                                                           ; which is the result we want, as economic_factor
                                                           ; is negative

TT156:
       movb ra,@QQ24                   ; STA QQ24          ; Store the result in QQ24 and P
       movb ra,@P                      ; STA P             

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
       .jsr @GC2                       ; JSR GC2           ; which is the same as (Y X) = P * 4 because A = 0

       .sec                            ; SEC               ; We now have our final price, * 10, so we can call pr5
       .jsr @pr5_                      ; JSR pr5           ; to print (Y X) to 5 digits, including a decimal
                                                           ; point, as the C flag is set

       movb @QQ19+4,ry                 ; LDY QQ19+4        ; We now move on to availability, so fetch the market
                                                           ; item number that we stored in QQ19+4 at the start

       li   ra,>05*256                 ; LDA #5            ; Set A to 5 so we can print the availability to 5
                                                           ; digits (right-padded with spaces)

       movb @AVL(ry),rx                ; LDX AVL,Y         ; Set X to the item's availability, which is given in
                                                           ; the AVL table

       movb rx,@QQ25                   ; STX QQ25          ; Store the availability in QQ25

       .clc                            ; CLC               ; Clear the C flag

       jeq  TT172                      ; BEQ TT172         ; If none are available, jump to TT172 to print a tab
                                                           ; and a "-"

       .jsr @pr2_+2                    ; JSR pr2+2         ; Otherwise print the 8-bit number in X to 5 digits,
                                                           ; right-aligned with spaces. This works because we set
                                                           ; A to 5 above, and we jump into the pr2 routine just
                                                           ; after the first instruction, which would normally
                                                           ; set the number of digits to 3

       b    @TT152                     ; JMP TT152         ; Print the unit ("t", "kg" or "g") for the market item,
                                                           ; with a following space if required to make it two
                                                           ; characters long, and return from the subroutine using
                                                           ; a tail call

TT172:
       movb @XC,ra                     ; LDA XC            ; Move the text cursor in XC to the right by 4 columns,
       .adi (>04*256)                  ; ADC #4            ; so the cursor is where the last digit would be if we
       movb ra,@XC                     ; STA XC            ; were printing a 5-digit availability number

       li   ra,('-')*256               ; LDA #'-'          ; Print a "-" character by jumping to TT162+2, which
       jne  TT162+2                    ; BNE TT162+2       ; contains JMP TT27 (this BNE is effectively a JMP as A
                                                           ; will never be zero), and return from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: TT152
* Type: Subroutine
* Category: Market
* Summary: Print the unit ("t", "kg" or "g") for a market item
* 
* ------------------------------------------------------------------------------
* 
* Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
* market prices table is in QQ19+1, right-padded with spaces to a width of two
* characters (so that's "t ", "kg" or "g ").
* 
* ******************************************************************************

TT152:
       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Fetch the economic_factor from QQ19+1

       andi ra,>60*256                 ; AND #96           ; If bits 5 and 6 are both clear, jump to TT160 to
       jeq  TT160                      ; BEQ TT160         ; print "t" for tonne, followed by a space, and return
                                                           ; from the subroutine using a tail call

       ci   ra,>20*256                 ; CMP #32           ; If bit 5 is set, jump to TT161 to print "kg" for
       jeq  TT161                      ; BEQ TT161         ; kilograms, and return from the subroutine using a tail
                                                           ; call

       .jsr @TT16a                     ; JSR TT16a         ; Otherwise call TT16a to print "g" for grams, and fall
                                                           ; through into TT162 to print a space and return from
                                                           ; the subroutine

* ******************************************************************************
* 
* Name: TT162
* Type: Subroutine
* Category: Text
* Summary: Print a space
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT162+2             Jump to TT27 to print the text token in A
* 
* ******************************************************************************

TT162:
       li   ra,(' ')*256               ; LDA #' '          ; Load a space character into A

       b    @TT27                      ; JMP TT27          ; Print the text token in A and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: TT160
* Type: Subroutine
* Category: Market
* Summary: Print "t" (for tonne) and a space
* 
* ******************************************************************************

TT160:
       li   ra,('t')*256               ; LDA #'t'          ; Load a "t" character into A

       .jsr @TT26                      ; JSR TT26          ; Print the character, using TT216 so that it doesn't
                                                           ; change the character case

       jnc  TT162                      ; BCC TT162         ; Jump to TT162 to print a space and return from the
                                                           ; subroutine using a tail call (this BCC is effectively
                                                           ; a JMP as the C flag is cleared by TT26)

* ******************************************************************************
* 
* Name: TT161
* Type: Subroutine
* Category: Market
* Summary: Print "kg" (for kilograms)
* 
* ******************************************************************************

TT161:
       li   ra,('k')*256               ; LDA #'k'          ; Load a "k" character into A

       .jsr @TT26                      ; JSR TT26          ; Print the character, using TT216 so that it doesn't
                                                           ; change the character case, and fall through into
                                                           ; TT16a to print a "g" character

* ******************************************************************************
* 
* Name: TT16a
* Type: Subroutine
* Category: Market
* Summary: Print "g" (for grams)
* 
* ******************************************************************************

TT16a:
       li   ra,('g')*256               ; LDA #'g'          ; Load a "g" character into A

       b    @TT26                      ; JMP TT26          ; Print the character, using TT216 so that it doesn't
                                                           ; change the character case, and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: TT163
* Type: Subroutine
* Category: Market
* Summary: Print the headers for the table of market prices
* 
* ------------------------------------------------------------------------------
* 
* Print the column headers for the prices table in the Buy Cargo and Market
* Price screens.
* 
* ******************************************************************************

TT163:
       li   ra,>11*256                 ; LDA #17           ; Move the text cursor in XC to column 17
       movb ra,@XC                     ; STA XC            

       li   ra,>ff*256                 ; LDA #255          ; Print recursive token 95 token ("UNIT  QUANTITY
       jne  TT162+2                    ; BNE TT162+2       ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
                                                           ; jumping to TT162+2, which contains JMP TT27 (this BNE
                                                           ; is effectively a JMP as A will never be zero), and
                                                           ; return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TT167
* Type: Subroutine
* Category: Market
* Summary: Show the Market Price screen (red key f7)
* 
* ******************************************************************************

TT167:
       li   ra,>10*256                 ; LDA #16           ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 16 (Market
                                                           ; Price screen)

       li   ra,>05*256                 ; LDA #5            ; Move the text cursor to column 5
       movb ra,@XC                     ; STA XC            

       li   ra,>a7*256                 ; LDA #167          ; Print recursive token 7 ("{current system name} MARKET
       .jsr @NLIN3                     ; JSR NLIN3         ; PRICES") and draw a horizontal line at pixel row 19
                                                           ; to box in the title

       li   ra,>03*256                 ; LDA #3            ; Move the text cursor to row 3
       movb ra,@YC                     ; STA YC            

       .jsr @TT163                     ; JSR TT163         ; Print the column headers for the prices table

       li   ra,>00*256                 ; LDA #0            ; We're going to loop through all the available market
       movb ra,@QQ29                   ; STA QQ29          ; items, so we set up a counter in QQ29 to denote the
                                                           ; current item and start it at 0

TT168:
       li   rx,>80*256                 ; LDX #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
       movb rx,@QQ17                   ; STX QQ17          ; next letter in capitals

       .jsr @TT151                     ; JSR TT151         ; Call TT151 to print the item name, market price and
                                                           ; availability of the current item, and set QQ24 to the
                                                           ; item's price / 4, QQ25 to the quantity available and
                                                           ; QQ19+1 to byte #1 from the market prices table for
                                                           ; this item

       ab   rone,ra                    ; INC YC            ; Move the text cursor down one row

       ab   rone,ra                    ; INC QQ29          ; Increment QQ29 to point to the next item

       movb @QQ29,ra                   ; LDA QQ29          ; If QQ29 >= 17 then jump to TT168 as we have done the
       ci   ra,>11*256                 ; CMP #17           ; last item
       jnc  TT168                      ; BCC TT168         

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: var
* Type: Subroutine
* Category: Market
* Summary: Calculate QQ19+3 = economy * |economic_factor|
* 
* ------------------------------------------------------------------------------
* 
* Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
* table for an item. Also sets the availability of alien items to 0.
* 
* This routine forms part of the calculations for market item prices (TT151)
* and availability (GVL).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* QQ19+1              Byte #1 of the market prices table for this market item
* (which contains the economic_factor in bits 0-5, and the
* sign of the economic_factor in bit 7)
* 
* ******************************************************************************

var_:
       movb @QQ19+1,ra                 ; LDA QQ19+1        ; Extract bits 0-5 from QQ19+1 into A, to get the
       andi ra,>1f*256                 ; AND #31           ; economic_factor without its sign, in other words:
                                                           ; 
                                                           ; A = |economic_factor|

       movb @QQ28,ry                   ; LDY QQ28          ; Set Y to the economy byte of the current system

       movb ra,@QQ19+2                 ; STA QQ19+2        ; Store A in QQ19+2

       .clc                            ; CLC               ; Clear the C flag so we can do additions below

       li   ra,>00*256                 ; LDA #0            ; Set AVL+16 (availability of alien items) to 0,
       movb ra,@AVL+16                 ; STA AVL+16        ; setting A to 0 in the process

TT153:
                                                           ; We now do the multiplication by doing a series of
                                                           ; additions in a loop, building the result in A. Each
                                                           ; loop adds QQ19+2 (|economic_factor|) to A, and it
                                                           ; loops the number of times given by the economy byte;
                                                           ; in other words, because A starts at 0, this sets:
                                                           ; 
                                                           ; A = economy * |economic_factor|
       sb   rone,ry                    ; DEY               ; Decrement the economy in Y, exiting the loop when it
       jlt  TT154                      ; BMI TT154         ; becomes negative

       .adc @QQ19+2,ra                 ; ADC QQ19+2        ; Add QQ19+2 to A

       b    @TT153                     ; JMP TT153         ; Loop back to TT153 to do another addition

TT154:
       movb ra,@QQ19+3                 ; STA QQ19+3        ; Store the result in QQ19+3

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: hyp1
* Type: Subroutine
* Category: Universe
* Summary: Process a jump to the system closest to (QQ9, QQ10)
* 
* ------------------------------------------------------------------------------
* 
* Do a hyperspace jump to the system closest to galactic coordinates
* (QQ9, QQ10), and set up the current system's state to those of the new system.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* (QQ0, QQ1)          The galactic coordinates of the new system
* 
* QQ2 to QQ2+6        The seeds of the new system
* 
* EV                  Set to 0
* 
* QQ28                The new system's economy
* 
* tek                 The new system's tech level
* 
* gov                 The new system's government
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* hyp1+3              Jump straight to the system at (QQ9, QQ10) without
* first calculating which system is closest. We do this
* if we already know that (QQ9, QQ10) points to a system
* 
* ******************************************************************************

hyp1_:
       .jsr @TT111                     ; JSR TT111         ; Select the system closest to galactic coordinates
                                                           ; (QQ9, QQ10)

       .jsr @jmp_                      ; JSR jmp           ; Set the current system to the selected system

       li   rx,>05*256                 ; LDX #5            ; We now want to copy the seeds for the selected system
                                                           ; in QQ15 into QQ2, where we store the seeds for the
                                                           ; current system, so set up a counter in X for copying
                                                           ; 6 bytes (for three 16-bit seeds)

TT112:
       movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy the X-th byte in QQ15 to the X-th byte in QQ2, to
       movb ra,@QQ2(rx)                ; STA QQ2,X         ; update the selected system to the new one. Note that
                                                           ; this approach has a minor bug associated with it: if
                                                           ; your hyperspace counter hits 0 just as you're docking,
                                                           ; then you will magically appear in the station in your
                                                           ; hyperspace destination, without having to go to the
                                                           ; effort of actually flying there. This bug was fixed in
                                                           ; later versions by saving the destination seeds in a
                                                           ; separate location called safehouse, and using those
                                                           ; instead... but that isn't the case in this version

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  TT112                      ; BPL TT112         ; Loop back to TT112 if we still have more bytes to
                                                           ; copy

       ab   rone,rx                    ; INX               ; Set X = 0 (as we ended the above loop with X = &FF)

       movb rx,@EV                     ; STX EV            ; Set EV, the extra vessels spawning counter, to 0, as
                                                           ; we are entering a new system with no extra vessels
                                                           ; spawned

       movb @QQ3,ra                    ; LDA QQ3           ; Set the current system's economy in QQ28 to the
       movb ra,@QQ28                   ; STA QQ28          ; selected system's economy from QQ3

       movb @QQ5,ra                    ; LDA QQ5           ; Set the current system's tech level in tek to the
       movb ra,@tek_                   ; STA tek           ; selected system's economy from QQ5

       movb @QQ4,ra                    ; LDA QQ4           ; Set the current system's government in gov to the
       movb ra,@gov_                   ; STA gov           ; selected system's government from QQ4

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: GVL
* Type: Subroutine
* Category: Universe
* Summary: Calculate the availability of market items
* Deep dive: Market item prices and availability
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Calculate the availability for each market item and store it in AVL. This is
* called on arrival in a new system.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* hyR                 Contains an RTS
* 
* ******************************************************************************

GVL:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@QQ26                   ; STA QQ26          ; Set QQ26 to the random byte that's used in the market
                                                           ; calculations

       li   rx,>00*256                 ; LDX #0            ; We are now going to loop through the market item
       movb rx,@XX4                    ; STX XX4           ; availability table in AVL, so set a counter in XX4
                                                           ; (and X) for the market item number, starting with 0

hy9_:
       movb @QQ23+1(rx),ra             ; LDA QQ23+1,X      ; Fetch byte #1 from the market prices table (units and
       movb ra,@QQ19+1                 ; STA QQ19+1        ; economic_factor) for item number X and store it in
                                                           ; QQ19+1

       .jsr @var_                      ; JSR var           ; Call var to set QQ19+3 = economy * |economic_factor|
                                                           ; (and set the availability of alien items to 0)

       movb @QQ23+3(rx),ra             ; LDA QQ23+3,X      ; Fetch byte #3 from the market prices table (mask) and
       .and @QQ26                      ; AND QQ26          ; AND with the random number for this system visit
                                                           ; to give:
                                                           ; 
                                                           ; A = random AND mask

       .clc                            ; CLC               ; Add byte #2 from the market prices table
       .adc @QQ23+2(rx),ra             ; ADC QQ23+2,X      ; (base_quantity) so we now have:
                                                           ; 
                                                           ; A = base_quantity + (random AND mask)

       movb @QQ19+1,ry                 ; LDY QQ19+1        ; Fetch the byte #1 that we stored above and jump to
       jlt  TT157                      ; BMI TT157         ; TT157 if it is negative (i.e. if the economic_factor
                                                           ; is negative)

       .sec                            ; SEC               ; Set A = A - QQ19+3
       .sbc @QQ19+3,ra                 ; SBC QQ19+3        ; 
                                                           ; = base_quantity + (random AND mask)
                                                           ; - (economy * |economic_factor|)
                                                           ; 
                                                           ; which is the result we want, as the economic_factor
                                                           ; is positive

       b    @TT158                     ; JMP TT158         ; Jump to TT158 to skip TT157

TT157:
       .clc                            ; CLC               ; Set A = A + QQ19+3
       .adc @QQ19+3,ra                 ; ADC QQ19+3        ; 
                                                           ; = base_quantity + (random AND mask)
                                                           ; + (economy * |economic_factor|)
                                                           ; 
                                                           ; which is the result we want, as the economic_factor
                                                           ; is negative

TT158:
       jgt  TT159                      ; BPL TT159         ; If A < 0, then set A = 0, so we don't have negative
       li   ra,>00*256                 ; LDA #0            ; availability

TT159:
       movb @XX4,ry                    ; LDY XX4           ; Fetch the counter (the market item number) into Y

       andi ra,>3f*256                 ; AND #%00111111    ; Take bits 0-5 of A, i.e. A mod 64, and store this as
       movb ra,@AVL(ry)                ; STA AVL,Y         ; this item's availability in the Y=th byte of AVL, so
                                                           ; each item has a maximum availability of 63t

       ab   rone,ry                    ; INY               ; Increment the counter into XX44, Y and A
       movb ry,ra                      ; TYA               
       movb ra,@XX4                    ; STA XX4           

       .asla                           ; ASL A             ; Set X = counter * 4, so that X points to the next
       .asla                           ; ASL A             ; item's entry in the four-byte market prices table,
       movb ra,rx                      ; TAX               ; ready for the next loop

       ci   ra,>3f*256                 ; CMP #63           ; If A < 63, jump back up to hy9 to set the availability
       jnc  hy9_                       ; BCC hy9           ; for the next market item

hyR:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: GTHG
* Type: Subroutine
* Category: Universe
* Summary: Spawn a Thargoid ship and a Thargon companion
* Deep dive: Fixing ship positions
* 
* ******************************************************************************

GTHG:
       .jsr @Ze                        ; JSR Ze            ; Call Ze to initialise INWK
                                                           ; 
                                                           ; Note that because Ze uses the value of X returned by
                                                           ; DORND, and X contains the value of A returned by the
                                                           ; previous call to DORND, this does not set the new ship
                                                           ; to a totally random location. See the deep dive on
                                                           ; "Fixing ship positions" for details

       li   ra,>ff*256                 ; LDA #%11111111    ; Set the AI flag in byte #32 so that the ship has AI,
       movb ra,@INWK+32                ; STA INWK+32       ; is extremely and aggressively hostile, and has E.C.M.

       li   ra,(THG)*256               ; LDA #THG          ; Call NWSHP to add a new Thargoid ship to our local
       .jsr @NWSHP                     ; JSR NWSHP         ; bubble of universe

       li   ra,(TGL)*256               ; LDA #TGL          ; Call NWSHP to add a new Thargon ship to our local
       b    @NWSHP                     ; JMP NWSHP         ; bubble of universe, and return from the subroutine
                                                           ; using a tail call

* ******************************************************************************
* 
* Name: MJP
* Type: Subroutine
* Category: Flight
* Summary: Process a mis-jump into witchspace
* 
* ------------------------------------------------------------------------------
* 
* Process a mis-jump into witchspace (which happens very rarely). Witchspace has
* a strange, almost dust-free aspect to it, and it is populated by hostile
* Thargoids. Using our escape pod will be fatal, and our position on the
* galactic chart is in-between systems. It is a scary place...
* 
* There is a 0.78% chance that this routine is called from TT18 instead of doing
* a normal hyperspace, or we can manually trigger a mis-jump by holding down
* CTRL after first enabling the "author display" configuration option ("X") when
* paused.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* ptg                 Called when the user manually forces a mis-jump
* 
* ******************************************************************************

ptg_:
       .lsr @COK                       ; LSR COK           ; Set bit 0 of the competition flags in COK, so that the
       .sec                            ; SEC               ; competition code will include the fact that we have
       .rol @COK                       ; ROL COK           ; manually forced a mis-jump into witchspace

MJP:
* LDA #1                 \ This instruction is commented out in the original
                                                           ; source - it is not required as a call to TT66-2 sets
                                                           ; A to 1 for us. This is presumably an example of the
                                                           ; authors saving a couple of bytes by calling TT66-2
                                                           ; instead of TT66, while leaving the original LDA
                                                           ; instruction in place
       .jsr @TT66-2                    ; JSR TT66-2        ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 1

       .jsr @LL164                     ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
                                                           ; hyperspace sound for a second time (as we already
                                                           ; called LL164 in TT18)

       .jsr @RES2                      ; JSR RES2          ; Reset a number of flight variables and workspaces, as
                                                           ; well as setting Y to &FF

       movb ry,@MJ                     ; STY MJ            ; Set the mis-jump flag in MJ to &FF, to indicate that
                                                           ; we are now in witchspace

MJP1:
       .jsr @GTHG                      ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
                                                           ; companion

       li   ra,>03*256                 ; LDA #3            ; Fetch the number of Thargoid ships from MANY+THG, and
       cb   @MANY+THG,ra               ; CMP MANY+THG      ; if it is less than or equal to 3, loop back to MJP1 to
       joc  MJP1                       ; BCS MJP1          ; spawn another one, until we have four Thargoids

       movb ra,@NOSTM                  ; STA NOSTM         ; Set NOSTM (the maximum number of stardust particles)
                                                           ; to 3, so there are fewer bits of stardust in
                                                           ; witchspace (normal space has a maximum of 18)

       li   rx,>00*256                 ; LDX #0            ; Initialise the front space view
       .jsr @LOOK1                     ; JSR LOOK1         

       movb @QQ1,ra                    ; LDA QQ1           ; Fetch the current system's galactic y-coordinate in
       .eoi (>1f*256)                  ; EOR #%00011111    ; QQ1 and flip bits 0-5, so we end up somewhere in the
       movb ra,@QQ1                    ; STA QQ1           ; vicinity of our original destination, but above or
                                                           ; below it in the galactic chart

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT18
* Type: Subroutine
* Category: Flight
* Summary: Try to initiate a jump into hyperspace
* 
* ------------------------------------------------------------------------------
* 
* Try to go through hyperspace. Called from TT102 in the main loop when the
* hyperspace countdown has finished.
* 
* ******************************************************************************

TT18:
       movb @QQ14,ra                   ; LDA QQ14          ; Subtract the distance to the selected system (in QQ8)
       .sec                            ; SEC               ; from the amount of fuel in our tank (in QQ14) into A
       .sbc @QQ8,ra                    ; SBC QQ8           

       movb ra,@QQ14                   ; STA QQ14          ; Store the updated fuel amount in QQ14

       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is not a space view, jump to ee5
       jne  ee5_                       ; BNE ee5           ; to skip the following

       .jsr @TT66                      ; JSR TT66          ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 0 (space
                                                           ; view)

       .jsr @LL164                     ; JSR LL164         ; Call LL164 to show the hyperspace tunnel and make the
                                                           ; hyperspace sound

ee5_:
       .jsr @CTRL                      ; JSR CTRL          ; Scan the keyboard to see if CTRL is currently pressed,
                                                           ; returning a negative value in A if it is

       .and @PATG                      ; AND PATG          ; If the game is configured to show the author's names
                                                           ; on the start-up screen, then PATG will contain &FF,
                                                           ; otherwise it will be 0

       jlt  ptg_                       ; BMI ptg           ; By now, A will be negative if we are holding down CTRL
                                                           ; and author names are configured, which is what we have
                                                           ; to do in order to trigger a manual mis-jump, so jump
                                                           ; to ptg to do a mis-jump (ptg not only mis-jumps, but
                                                           ; updates the competition flags, so Acornsoft could tell
                                                           ; from the competition code whether this feature had
                                                           ; been used)

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>fd*256                 ; CMP #253          ; If A >= 253 (0.78% chance) then jump to MJP to trigger
       joc  MJP                        ; BCS MJP           ; a mis-jump into witchspace

* JSR TT111              \ This instruction is commented out in the original
                                                           ; source. It finds the closest system to coordinates
                                                           ; (QQ9, QQ10), but we don't need to do this as the
                                                           ; crosshairs will already be on a system by this point

       .jsr @hyp1_+3                   ; JSR hyp1+3        ; Jump straight to the system at (QQ9, QQ10) without
                                                           ; first calculating which system is closest

       .jsr @GVL                       ; JSR GVL           ; Calculate the availability for each market item in the
                                                           ; new system

       .jsr @RES2                      ; JSR RES2          ; Reset a number of flight variables and workspaces

       .jsr @SOLAR                     ; JSR SOLAR         ; Halve our legal status, update the missile indicators,
                                                           ; and set up data blocks and slots for the planet and
                                                           ; sun

       movb @QQ11,ra                   ; LDA QQ11          ; If the current view in QQ11 is not a space view (0) or
       andi ra,>3f*256                 ; AND #%00111111    ; one of the charts (64 or 128), return from the
       jne  hyR                        ; BNE hyR           ; subroutine (as hyR contains an RTS)

       .jsr @TTX66                     ; JSR TTX66         ; Otherwise clear the screen and draw a white border

       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is one of the charts, jump to
       jne  TT114                      ; BNE TT114         ; TT114 (from which we jump to the correct routine to
                                                           ; display the chart)

       ab   rone,ra                    ; INC QQ11          ; This is a space view, so increment QQ11 to 1

                                                           ; Fall through into TT110 to show the front space view

* ******************************************************************************
* 
* Name: TT110
* Type: Subroutine
* Category: Flight
* Summary: Launch from a station or show the front space view
* 
* ------------------------------------------------------------------------------
* 
* Launch the ship (if we are docked), or show the front space view (if we are
* already in space).
* 
* Called when red key f0 is pressed while docked (launch), after we arrive in a
* new galaxy, or after a hyperspace if the current view is a space view.
* 
* ******************************************************************************

TT110:
       movb @QQ12,rx                   ; LDX QQ12          ; If we are not docked (QQ12 = 0) then jump to NLUNCH
       jeq  NLUNCH                     ; BEQ NLUNCH        ; to skip the launch tunnel and setup process

       .jsr @LAUN                      ; JSR LAUN          ; Show the space station launch tunnel

       .jsr @RES2                      ; JSR RES2          ; Reset a number of flight variables and workspaces

       .jsr @TT111                     ; JSR TT111         ; Select the system closest to galactic coordinates
                                                           ; (QQ9, QQ10)

       ab   rone,ra                    ; INC INWK+8        ; Increment z_sign ready for the call to SOS, so the
                                                           ; planet appears at a z_sign of 1 in front of us when
                                                           ; we launch

       .jsr @SOS1                      ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
                                                           ; to FRIN, where it will get put in the first slot as
                                                           ; it's the first one to be added to our local bubble of
                                                           ; universe following the call to RES2 above

       li   ra,>80*256                 ; LDA #128          ; For the space station, set z_sign to &80, so it's
       movb ra,@INWK+8                 ; STA INWK+8        ; behind us (&80 is negative)

       ab   rone,ra                    ; INC INWK+7        ; And increment z_hi, so it's only just behind us

       .jsr @NWSPS                     ; JSR NWSPS         ; Add a new space station to our local bubble of
                                                           ; universe

       li   ra,>0c*256                 ; LDA #12           ; Set our launch speed in DELTA to 12
       movb ra,@DELTA                  ; STA DELTA         

       .jsr @BAD                       ; JSR BAD           ; Call BAD to work out how much illegal contraband we
                                                           ; are carrying in our hold (A is up to 40 for a
                                                           ; standard hold crammed with contraband, up to 70 for
                                                           ; an extended cargo hold full of narcotics and slaves)

       socb @FIST,ra                   ; ORA FIST          ; OR the value in A with our legal status in FIST to
                                                           ; get a new value that is at least as high as both
                                                           ; values, to reflect the fact that launching with a
                                                           ; hold full of contraband can only make matters worse

       movb ra,@FIST                   ; STA FIST          ; Update our legal status with the new value

NLUNCH:
       li   rx,>00*256                 ; LDX #0            ; Set QQ12 to 0 to indicate we are not docked
       movb rx,@QQ12                   ; STX QQ12          

       b    @LOOK1                     ; JMP LOOK1         ; Jump to LOOK1 to switch to the front view (X = 0),
                                                           ; returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: TT114
* Type: Subroutine
* Category: Charts
* Summary: Display either the Long-range or Short-range Chart
* 
* ------------------------------------------------------------------------------
* 
* Display either the Long-range or Short-range Chart, depending on the current
* view setting. Called from TT18 once we know the current view is one of the
* charts.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The current view, loaded from QQ11
* 
* ******************************************************************************

TT114:
       jlt  TT115                      ; BMI TT115         ; If bit 7 of the current view is set (i.e. the view is
                                                           ; the Short-range Chart, 128), skip to TT115 below to
                                                           ; jump to TT23 to display the chart

       b    @TT22                      ; JMP TT22          ; Otherwise the current view is the Long-range Chart, so
                                                           ; jump to TT22 to display it

TT115:
       b    @TT23                      ; JMP TT23          ; Jump to TT23 to display the Short-range Chart

* ******************************************************************************
* 
* Name: LCASH
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Subtract an amount of cash from the cash pot
* 
* ------------------------------------------------------------------------------
* 
* Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
* cash in the pot. As CASH is a four-byte number, this calculates:
* 
* CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              If set, there was enough cash to do the subtraction
* 
* If clear, there was not enough cash to do the
* subtraction
* 
* ******************************************************************************

LCASH:
       movb rx,@T1                     ; STX T1            ; Subtract the least significant bytes:
       movb @CASH+3,ra                 ; LDA CASH+3        ; 
       .sec                            ; SEC               ; CASH+3 = CASH+3 - X
       .sbc @T1,ra                     ; SBC T1            
       movb ra,@CASH+3                 ; STA CASH+3        

       movb ry,@T1                     ; STY T1            ; Then the second most significant bytes:
       movb @CASH+2,ra                 ; LDA CASH+2        ; 
       .sbc @T1,ra                     ; SBC T1            ; CASH+2 = CASH+2 - Y
       movb ra,@CASH+2                 ; STA CASH+2        

       movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
       .sbi (>00*256)                  ; SBC #0            ; 
       movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 - 0

       movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
       .sbi (>00*256)                  ; SBC #0            ; 
       movb ra,@CASH                   ; STA CASH          ; CASH = CASH - 0

       joc  TT113                      ; BCS TT113         ; If the C flag is set then the subtraction didn't
                                                           ; underflow, so the value in CASH is correct and we can
                                                           ; jump to TT113 to return from the subroutine with the
                                                           ; C flag set to indicate success (as TT113 contains an
                                                           ; RTS)

                                                           ; Otherwise we didn't have enough cash in CASH to
                                                           ; subtract (Y X) from it, so fall through into
                                                           ; MCASH to reverse the sum and restore the original
                                                           ; value in CASH, and returning with the C flag clear

* ******************************************************************************
* 
* Name: MCASH
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Add an amount of cash to the cash pot
* 
* ------------------------------------------------------------------------------
* 
* Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
* calculates:
* 
* CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT113               Contains an RTS
* 
* ******************************************************************************

MCASH:
       movb rx,ra                      ; TXA               ; Add the least significant bytes:
       .clc                            ; CLC               ; 
       .adc @CASH+3,ra                 ; ADC CASH+3        ; CASH+3 = CASH+3 + X
       movb ra,@CASH+3                 ; STA CASH+3        

       movb ry,ra                      ; TYA               ; Then the second most significant bytes:
       .adc @CASH+2,ra                 ; ADC CASH+2        ; 
       movb ra,@CASH+2                 ; STA CASH+2        ; CASH+2 = CASH+2 + Y

       movb @CASH+1,ra                 ; LDA CASH+1        ; Then the third most significant bytes (which are 0):
       .adi (>00*256)                  ; ADC #0            ; 
       movb ra,@CASH+1                 ; STA CASH+1        ; CASH+1 = CASH+1 + 0

       movb @CASH,ra                   ; LDA CASH          ; And finally the most significant bytes (which are 0):
       .adi (>00*256)                  ; ADC #0            ; 
       movb ra,@CASH                   ; STA CASH          ; CASH = CASH + 0

       .clc                            ; CLC               ; Clear the C flag, so if the above was done following
                                                           ; a failed LCASH call, the C flag correctly indicates
                                                           ; failure

TT113:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: GCASH
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (Y X) = P * Q * 4
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following multiplication of unsigned 8-bit numbers:
* 
* (Y X) = P * Q * 4
* 
* ******************************************************************************

GCASH:
       .jsr @MULTU                     ; JSR MULTU         ; Call MULTU to calculate (A P) = P * Q

* ******************************************************************************
* 
* Name: GC2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (Y X) = (A P) * 4
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following multiplication of unsigned 16-bit numbers:
* 
* (Y X) = (A P) * 4
* 
* ******************************************************************************

GC2:
       .asl @P                         ; ASL P             ; Set (A P) = (A P) * 4
       .rola                           ; ROL A             
       .asl @P                         ; ASL P             
       .rola                           ; ROL A             

       movb ra,ry                      ; TAY               ; Set (Y X) = (A P)
       movb @P,rx                      ; LDX P             

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: EQSHP
* Type: Subroutine
* Category: Equipment
* Summary: Show the Equip Ship screen (red key f3)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* err                 Beep, pause and go to the docking bay (i.e. show the
* Status Mode screen)
* 
* pres                Given an item number A with the item name in recursive
* token Y, show an error to say that the item is already
* present, refund the cost of the item, and then beep and
* exit to the docking bay (i.e. show the Status Mode
* screen)
* 
* ******************************************************************************

bay_:
       b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show the Status Mode
                                                           ; screen)

EQSHP:
       .jsr @DIALS                     ; JSR DIALS         ; Call DIALS to update the dashboard

       li   ra,>20*256                 ; LDA #32           ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 32 (Equip
                                                           ; Ship screen)

       li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12
       movb ra,@XC                     ; STA XC            

       li   ra,>cf*256                 ; LDA #207          ; Print recursive token 47 ("EQUIP") followed by a space
       .jsr @spc_                      ; JSR spc           

       li   ra,>b9*256                 ; LDA #185          ; Print recursive token 25 ("SHIP") and draw a
       .jsr @NLIN3                     ; JSR NLIN3         ; horizontal line at pixel row 19 to box in the title

       li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
       movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals

       ab   rone,ra                    ; INC YC            ; Move the text cursor down one line

       movb @tek_,ra                   ; LDA tek           ; Fetch the tech level of the current system from tek
       .clc                            ; CLC               ; and add 3 (the tech level is stored as 0-14, so A is
       .adi (>03*256)                  ; ADC #3            ; now set to between 3 and 17)

       ci   ra,>0c*256                 ; CMP #12           ; If A >= 12 then set A = 12, so A is now set to between
       jnc  B58                        ; BCC B58           ; 3 and 12
       li   ra,>0c*256                 ; LDA #12           

B58:
       movb ra,@Q                      ; STA Q             ; Set QQ25 = A (so QQ25 is in the range 3-12 and
       movb ra,@QQ25                   ; STA QQ25          ; represents number of the most advanced item available
       ab   rone,ra                    ; INC Q             ; in this system, which we can pass to gnum below when
                                                           ; asking which item we want to buy)
                                                           ; 
                                                           ; Set Q = A + 1 (so Q is in the range 4-13 and contains
                                                           ; QQ25 + 1, i.e. the highest item number on sale + 1)

       li   ra,>46*256                 ; LDA #70           ; Set A = 70 - QQ14, where QQ14 contains the current
       .sec                            ; SEC               ; fuel in light years * 10, so this leaves the amount
       .sbc @QQ14,ra                   ; SBC QQ14          ; of fuel we need to fill 'er up (in light years * 10)

       .asla                           ; ASL A             ; The price of fuel is always 2 Cr per light year, so we
       movb ra,@PRXS                   ; STA PRXS          ; double A and store it in PRXS, as the first price in
                                                           ; the price list (which is reserved for fuel), and
                                                           ; because the table contains prices as price * 10, it's
                                                           ; in the right format (so tank containing 7.0 light
                                                           ; years of fuel would be 14.0 Cr, or a PRXS value of
                                                           ; 140)

       li   rx,>01*256                 ; LDX #1            ; We are now going to work our way through the equipment
                                                           ; price list at PRXS, printing out the equipment that is
                                                           ; available at this station, so set a counter in X,
                                                           ; starting at 1, to hold the number of the current item
                                                           ; plus 1 (so the item number in X loops through 1-13)

EQL1:
       movb rx,@XX13                   ; STX XX13          ; Store the current item number + 1 in XX13

       .jsr @TT67                      ; JSR TT67          ; Print a newline

       movb @XX13,rx                   ; LDX XX13          ; Print the current item number + 1 to 3 digits, left-
       .clc                            ; CLC               ; padding with spaces, and with no decimal point, so the
       .jsr @pr2_                      ; JSR pr2           ; items are numbered from 1

       .jsr @TT162                     ; JSR TT162         ; Print a space

       movb @XX13,ra                   ; LDA XX13          ; Print recursive token 104 + XX13, which will be in the
       .clc                            ; CLC               ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
       .adi (>68*256)                  ; ADC #104          ; so this prints the current item's name
       .jsr @TT27                      ; JSR TT27          

       movb @XX13,ra                   ; LDA XX13          ; Call prx-3 to set (Y X) to the price of the item with
       .jsr @prx_-3                    ; JSR prx-3         ; number XX13 - 1 (as XX13 contains the item number + 1)

       .sec                            ; SEC               ; Set the C flag so we will print a decimal point when
                                                           ; we print the price

       li   ra,>19*256                 ; LDA #25           ; Move the text cursor to column 25
       movb ra,@XC                     ; STA XC            

       li   ra,>06*256                 ; LDA #6            ; Print the number in (Y X) to 6 digits, left-padding
       .jsr @TT11                      ; JSR TT11          ; with spaces and including a decimal point, which will
                                                           ; be the correct price for this item as (Y X) contains
                                                           ; the price * 10, so the trailing zero will go after the
                                                           ; decimal point (i.e. 5250 will be printed as 525.0)

       movb @XX13,rx                   ; LDX XX13          ; Increment the current item number in XX13
       ab   rone,rx                    ; INX               

       cb   @Q,rx                      ; CPX Q             ; If X < Q, loop back up to print the next item on the
       jnc  EQL1                       ; BCC EQL1          ; list of equipment available at this station

       .jsr @CLYNS                     ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
                                                           ; and move the text cursor to column 1 on row 21, i.e.
                                                           ; the start of the top row of the three bottom rows

       li   ra,>7f*256                 ; LDA #127          ; Print recursive token 127 ("ITEM") followed by a
       .jsr @prq_                      ; JSR prq           ; question mark

       .jsr @gnum_                     ; JSR gnum          ; Call gnum to get a number from the keyboard, which
                                                           ; will be the number of the item we want to purchase,
                                                           ; returning the number entered in A and R, and setting
                                                           ; the C flag if the number is bigger than the highest
                                                           ; item number in QQ25

       jeq  bay_                       ; BEQ bay           ; If no number was entered, jump up to bay to go to the
                                                           ; docking bay (i.e. show the Status Mode screen)

       joc  bay_                       ; BCS bay           ; If the number entered was too big, jump up to bay to
                                                           ; go to the docking bay (i.e. show the Status Mode
                                                           ; screen)

       .sbi (>00*256)                  ; SBC #0            ; Set A to the number entered - 1 (because the C flag is
                                                           ; clear), which will be the actual item number we want
                                                           ; to buy

       li   rx,>02*256                 ; LDX #2            ; Move the text cursor to column 2
       movb rx,@XC                     ; STX XC            

       ab   rone,ra                    ; INC YC            ; Move the text cursor down one line

       .pha                            ; PHA               ; While preserving the value in A, call eq to subtract
       .jsr @eq_                       ; JSR eq            ; the price of the item we want to buy (which is in A)
       .pla                            ; PLA               ; from our cash pot, but only if we have enough cash in
                                                           ; the pot. If we don't have enough cash, exit to the
                                                           ; docking bay (i.e. show the Status Mode screen)

       jne  et0_                       ; BNE et0           ; If A is not 0 (i.e. the item we've just bought is not
                                                           ; fuel), skip to et0

       movb ra,@MCNT                   ; STA MCNT          ; We just bought fuel, so we zero the main loop counter

       li   rx,>46*256                 ; LDX #70           ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
       movb rx,@QQ14                   ; STX QQ14          ; light years (a full tank)

et0_:
       ci   ra,>01*256                 ; CMP #1            ; If A is not 1 (i.e. the item we've just bought is not
       jne  et1_                       ; BNE et1           ; a missile), skip to et1

       movb @NOMSL,rx                  ; LDX NOMSL         ; Fetch the current number of missiles from NOMSL into X

       ab   rone,rx                    ; INX               ; Increment X to the new number of missiles

       li   ry,>75*256                 ; LDY #117          ; Set Y to recursive token 117 ("ALL")

       ci   rx,>05*256                 ; CPX #5            ; If buying this missile would give us 5 missiles, this
       joc  pres_                      ; BCS pres          ; is more than the maximum of 4 missiles that we can
                                                           ; fit, so jump to pres to show the error "All Present",
                                                           ; beep and exit to the docking bay (i.e. show the Status
                                                           ; Mode screen)

       movb rx,@NOMSL                  ; STX NOMSL         ; Otherwise update the number of missiles in NOMSL

       .jsr @msblob_                   ; JSR msblob        ; Reset the dashboard's missile indicators so none of
                                                           ; them are targeted

et1_:
       li   ry,>6b*256                 ; LDY #107          ; Set Y to recursive token 107 ("LARGE CARGO{sentence
                                                           ; case} BAY")

       ci   ra,>02*256                 ; CMP #2            ; If A is not 2 (i.e. the item we've just bought is not
       jne  et2_                       ; BNE et2           ; a large cargo bay), skip to et2

       li   rx,>25*256                 ; LDX #37           ; If our current cargo capacity in CRGO is 37, then we
       cb   @CRGO,rx                   ; CPX CRGO          ; already have a large cargo bay fitted, so jump to pres
       jeq  pres_                      ; BEQ pres          ; to show the error "Large Cargo Bay Present", beep and
                                                           ; exit to the docking bay (i.e. show the Status Mode
                                                           ; screen)

       movb rx,@CRGO                   ; STX CRGO          ; Otherwise we just scored ourselves a large cargo bay,
                                                           ; so update our current cargo capacity in CRGO to 37

et2_:
       ci   ra,>03*256                 ; CMP #3            ; If A is not 3 (i.e. the item we've just bought is not
       jne  et3_                       ; BNE et3           ; an E.C.M. system), skip to et3

       ab   rone,ry                    ; INY               ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")

       movb @ECM,rx                    ; LDX ECM           ; If we already have an E.C.M. fitted (i.e. ECM is
       jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "E.C.M.
                                                           ; System Present", beep and exit to the docking bay
                                                           ; (i.e. show the Status Mode screen)

       sb   rone,ra                    ; DEC ECM           ; Otherwise we just took delivery of a brand new E.C.M.
                                                           ; system, so set ECM to &FF (as ECM was 0 before the DEC
                                                           ; instruction)

et3_:
       ci   ra,>04*256                 ; CMP #4            ; If A is not 4 (i.e. the item we've just bought is not
       jne  et4_                       ; BNE et4           ; an extra pulse laser), skip to et4

       .jsr @qv_                       ; JSR qv            ; Print a menu listing the four views, with a "View ?"
                                                           ; prompt, and ask for a view number, which is returned
                                                           ; in X (which now contains 0-3)

       li   ra,>04*256                 ; LDA #4            ; This instruction doesn't appear to do anything, as we
                                                           ; either don't need it (if we already have this laser)
                                                           ; or we set A to 4 below (if we buy it)

       movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
       jeq  ed4_                       ; BEQ ed4           ; LASER+X, which contains the laser power for view X, is
                                                           ; zero), jump to ed4 to buy a pulse laser

ed7_:
       li   ry,>bb*256                 ; LDY #187          ; Otherwise we already have a laser mounted in this
       jne  pres_                      ; BNE pres          ; view, so jump to pres with Y set to token 27
                                                           ; (" LASER") to show the error "Laser Present", beep
                                                           ; and exit to the docking bay (i.e. show the Status
                                                           ; Mode screen)

ed4_:
       li   ra,(POW)*256               ; LDA #POW          ; We just bought a pulse laser for view X, so we need
       movb ra,@LASER(rx)              ; STA LASER,X       ; to fit it by storing the laser power for a pulse laser
                                                           ; (given in POW) in LASER+X

       li   ra,>04*256                 ; LDA #4            ; Set A to 4 as we just overwrote the original value,
                                                           ; and we still need it set correctly so we can continue
                                                           ; through the conditional statements for all the other
                                                           ; equipment

et4_:
       ci   ra,>05*256                 ; CMP #5            ; If A is not 5 (i.e. the item we've just bought is not
       jne  et5_                       ; BNE et5           ; an extra beam laser), skip to et5

       .jsr @qv_                       ; JSR qv            ; Print a menu listing the four views, with a "View ?"
                                                           ; prompt, and ask for a view number, which is returned
                                                           ; in X (which now contains 0-3)

       movb rx,@T1                     ; STX T1            ; Store the view in T1 so we can retrieve it below

       li   ra,>05*256                 ; LDA #5            ; Set A to 5 as the call to qv will have overwritten
                                                           ; the original value, and we still need it set
                                                           ; correctly so we can continue through the conditional
                                                           ; statements for all the other equipment

       movb @LASER(rx),ry              ; LDY LASER,X       ; If there is no laser mounted in the chosen view (i.e.
       jeq  ed5_                       ; BEQ ed5           ; LASER+X, which contains the laser power for view X,
                                                           ; is zero), jump to ed5 to buy a beam laser

* BPL P%+4               \ This instruction is commented out in the original
                                                           ; source, though it would have no effect (it would
                                                           ; simply skip the BMI if A is positive, which is what
                                                           ; BMI does anyway)

       jlt  ed7_                       ; BMI ed7           ; If there is a beam laser already mounted in the chosen
                                                           ; view (i.e. LASER+X has bit 7 set, which indicates a
                                                           ; beam laser rather than a pulse laser), skip back to
                                                           ; ed7 to print a "Laser Present" error, beep and exit
                                                           ; to the docking bay (i.e. show the Status Mode screen)

       li   ra,>04*256                 ; LDA #4            ; If we get here then we already have a pulse laser in
       .jsr @prx_                      ; JSR prx           ; the selected view, so we call prx to set (Y X) to the
                                                           ; price of equipment item number 4 (extra pulse laser)
                                                           ; so we can give a refund of the pulse laser

       .jsr @MCASH                     ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, so we refund
                                                           ; the price of the pulse laser we are exchanging for a
                                                           ; new beam laser

ed5_:
       li   ra,(POW+128)*256           ; LDA #POW+128      ; We just bought a beam laser for view X, so we need
       movb @T1,rx                     ; LDX T1            ; to fit it by storing the laser power for a beam laser
       movb ra,@LASER(rx)              ; STA LASER,X       ; (given in POW+128) in LASER+X, using the view number
                                                           ; we stored in T1 earlier, as the call to prx will have
                                                           ; overwritten the original value in X

et5_:
       li   ry,>6f*256                 ; LDY #111          ; Set Y to recursive token 107 ("FUEL SCOOPS")

       ci   ra,>06*256                 ; CMP #6            ; If A is not 6 (i.e. the item we've just bought is not
       jne  et6_                       ; BNE et6           ; a fuel scoop), skip to et6

       movb @BST,rx                    ; LDX BST           ; If we already have fuel scoops fitted (i.e. BST is
       jeq  ed9_                       ; BEQ ed9           ; zero), jump to ed9, otherwise fall through into pres
                                                           ; to show the error "Fuel Scoops Present", beep and
                                                           ; exit to the docking bay (i.e. show the Status Mode
                                                           ; screen)

pres_:
                                                           ; If we get here we need to show an error to say that
                                                           ; the item whose name is in recursive token Y is already
                                                           ; present, and then process a refund for the cost of
                                                           ; item number A
       movb ry,@K                      ; STY K             ; Store the item's name in K

       .jsr @prx_                      ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
                                                           ; number A

       .jsr @MCASH                     ; JSR MCASH         ; Add (Y X) cash to the cash pot in CASH, as the station
                                                           ; already took the money for this item in the JSR eq
                                                           ; instruction above, but we can't fit the item, so need
                                                           ; our money back

       movb @K,ra                      ; LDA K             ; Print the recursive token in K (the item's name)
       .jsr @spc_                      ; JSR spc           ; followed by a space

       li   ra,>1f*256                 ; LDA #31           ; Print recursive token 145 ("PRESENT")
       .jsr @TT27                      ; JSR TT27          

err_:
       .jsr @dn2_                      ; JSR dn2           ; Call dn2 to make a short, high beep and delay for 1
                                                           ; second

       b    @BAY                       ; JMP BAY           ; Jump to BAY to go to the docking bay (i.e. show the
                                                           ; Status Mode screen)

ed9_:
       sb   rone,ra                    ; DEC BST           ; We just bought a shiny new fuel scoop, so set BST to
                                                           ; &FF (as BST was 0 before the jump to ed9 above)

et6_:
       ab   rone,ry                    ; INY               ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")

       ci   ra,>07*256                 ; CMP #7            ; If A is not 7 (i.e. the item we've just bought is not
       jne  et7_                       ; BNE et7           ; an escape pod), skip to et7

       movb @ESCP,rx                   ; LDX ESCP          ; If we already have an escape pod fitted (i.e. ESCP is
       jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Escape Pod
                                                           ; Present", beep and exit to the docking bay (i.e. show
                                                           ; the Status Mode screen)

       sb   rone,ra                    ; DEC ESCP          ; Otherwise we just bought an escape pod, so set ESCP
                                                           ; to &FF (as ESCP was 0 before the DEC instruction)

et7_:
       ab   rone,ry                    ; INY               ; Increment Y to recursive token 113 ("ENERGY BOMB")

       ci   ra,>08*256                 ; CMP #8            ; If A is not 8 (i.e. the item we've just bought is not
       jne  et8_                       ; BNE et8           ; an energy bomb), skip to et8

       movb @BOMB,rx                   ; LDX BOMB          ; If we already have an energy bomb fitted (i.e. BOMB
       jne  pres_                      ; BNE pres          ; is non-zero), jump to pres to show the error "Energy
                                                           ; Bomb Present", beep and exit to the docking bay (i.e.
                                                           ; show the Status Mode screen)

       li   rx,>7f*256                 ; LDX #&7F          ; Otherwise we just bought an energy bomb, so set BOMB
       movb rx,@BOMB                   ; STX BOMB          ; to &7F

et8_:
       ab   rone,ry                    ; INY               ; Increment Y to recursive token 114 ("ENERGY UNIT")

       ci   ra,>09*256                 ; CMP #9            ; If A is not 9 (i.e. the item we've just bought is not
       jne  etA                        ; BNE etA           ; an energy unit), skip to etA

       movb @ENGY,rx                   ; LDX ENGY          ; If we already have an energy unit fitted (i.e. ENGY is
       jne  pres_                      ; BNE pres          ; non-zero), jump to pres to show the error "Energy Unit
                                                           ; Present", beep and exit to the docking bay (i.e. show
                                                           ; the Status Mode screen)

       ab   rone,ra                    ; INC ENGY          ; Otherwise we just picked up an energy unit, so set
                                                           ; ENGY to 1 (as ENGY was 0 before the INC instruction)

etA:
       ab   rone,ry                    ; INY               ; Increment Y to recursive token 115 ("DOCKING
                                                           ; COMPUTERS")

       ci   ra,>0a*256                 ; CMP #10           ; If A is not 10 (i.e. the item we've just bought is not
       jne  etB                        ; BNE etB           ; a docking computer), skip to etB

       movb @DKCMP,rx                  ; LDX DKCMP         ; If we already have a docking computer fitted (i.e.
       jne  pres_                      ; BNE pres          ; DKCMP is non-zero), jump to pres to show the error
                                                           ; "Docking Computer Present", beep and exit to the
                                                           ; docking bay (i.e. show the Status Mode screen)

       sb   rone,ra                    ; DEC DKCMP         ; Otherwise we just got hold of a docking computer, so
                                                           ; set DKCMP to &FF (as DKCMP was 0 before the DEC
                                                           ; instruction)

etB:
       ab   rone,ry                    ; INY               ; Increment Y to recursive token 116 ("GALACTIC
                                                           ; HYPERSPACE ")

       ci   ra,>0b*256                 ; CMP #11           ; If A is not 11 (i.e. the item we've just bought is not
       jne  et9_                       ; BNE et9           ; a galactic hyperdrive), skip to et9

       movb @GHYP,rx                   ; LDX GHYP          ; If we already have a galactic hyperdrive fitted (i.e.
       jne  pres_                      ; BNE pres          ; GHYP is non-zero), jump to pres to show the error
                                                           ; "Galactic Hyperspace Present", beep and exit to the
                                                           ; docking bay (i.e. show the Status Mode screen)

       sb   rone,ra                    ; DEC GHYP          ; Otherwise we just splashed out on a galactic
                                                           ; hyperdrive, so set GHYP to &FF (as GHYP was 0 before
                                                           ; the DEC instruction)

et9_:
       .jsr @dn_                       ; JSR dn            ; We are done buying equipment, so print the amount of
                                                           ; cash left in the cash pot, then make a short, high
                                                           ; beep to confirm the purchase, and delay for 1 second

       b    @EQSHP                     ; JMP EQSHP         ; Jump back up to EQSHP to show the Equip Ship screen
                                                           ; again and see if we can't track down another bargain

* ******************************************************************************
* 
* Name: dn
* Type: Subroutine
* Category: Market
* Summary: Print the amount of money we have left in the cash pot, then make
* a short, high beep and delay for 1 second
* 
* ******************************************************************************

dn_:
       .jsr @TT162                     ; JSR TT162         ; Print a space

       li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
       .jsr @spc_                      ; JSR spc           ; followed by a space

                                                           ; Fall through into dn2 to make a beep and delay for
                                                           ; 1 second before returning from the subroutine

* ******************************************************************************
* 
* Name: dn2
* Type: Subroutine
* Category: Text
* Summary: Make a short, high beep and delay for 1 second
* 
* ******************************************************************************

dn2_:
       .jsr @BEEP                      ; JSR BEEP          ; Call the BEEP subroutine to make a short, high beep

       li   ry,>32*256                 ; LDY #50           ; Delay for 50 vertical syncs (50/50 = 1 second) and
       b    @DELAY                     ; JMP DELAY         ; return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: eq
* Type: Subroutine
* Category: Equipment
* Summary: Subtract the price of equipment from the cash pot
* 
* ------------------------------------------------------------------------------
* 
* If we have enough cash, subtract the price of a specified piece of equipment
* from our cash pot and return from the subroutine. If we don't have enough
* cash, exit to the docking bay (i.e. show the Status Mode screen).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The item number of the piece of equipment (0-11) as
* shown in the table at PRXS
* 
* ******************************************************************************

eq_:
       .jsr @prx_                      ; JSR prx           ; Call prx to set (Y X) to the price of equipment item
                                                           ; number A

       .jsr @LCASH                     ; JSR LCASH         ; Subtract (Y X) cash from the cash pot, but only if
                                                           ; we have enough cash

       joc  c_                         ; BCS c             ; If the C flag is set then we did have enough cash for
                                                           ; the transaction, so jump to c to return from the
                                                           ; subroutine (as c contains an RTS)

       li   ra,>c5*256                 ; LDA #197          ; Otherwise we don't have enough cash to buy this piece
       .jsr @prq_                      ; JSR prq           ; of equipment, so print recursive token 37 ("CASH")
                                                           ; followed by a question mark

       b    @err_                      ; JMP err           ; Jump to err to beep, pause and go to the docking bay
                                                           ; (i.e. show the Status Mode screen)

* ******************************************************************************
* 
* Name: prx
* Type: Subroutine
* Category: Equipment
* Summary: Return the price of a piece of equipment
* 
* ------------------------------------------------------------------------------
* 
* This routine returns the price of equipment as listed in the table at PRXS.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The item number of the piece of equipment (0-11) as
* shown in the table at PRXS
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* prx-3               Return the price of the item with number A - 1
* 
* c                   Contains an RTS
* 
* ******************************************************************************

       .sec                            ; SEC               ; Decrement A (for when this routine is called via
       .sbi (>01*256)                  ; SBC #1            ; prx-3)

prx_:
       .asla                           ; ASL A             ; Set Y = A * 2, so it can act as an index into the
       movb ra,ry                      ; TAY               ; PRXS table, which has two bytes per entry

       movb @PRXS(ry),rx               ; LDX PRXS,Y        ; Fetch the low byte of the price into X

       movb @PRXS+1(ry),ra             ; LDA PRXS+1,Y      ; Fetch the high byte of the price into A and transfer
       movb ra,ry                      ; TAY               ; it to X, so the price is now in (Y X)

c_:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: qv
* Type: Subroutine
* Category: Equipment
* Summary: Print a menu of the four space views, for buying lasers
* 
* ------------------------------------------------------------------------------
* 
* Print a menu in the bottom-middle of the screen, at row 16, column 12, that
* lists the four available space views, like this:
* 
* 0 Front
* 1 Rear
* 2 Left
* 3 Right
* 
* Also print a "View ?" prompt and ask for a view number. The menu is shown
* when we choose to buy a new laser in the Equip Ship screen.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   The chosen view number (0-3)
* 
* ******************************************************************************

qv_:
       li   ry,>10*256                 ; LDY #16           ; Move the text cursor to row 16, and at the same time
       movb ry,@YC                     ; STY YC            ; set Y to a counter going from 16 to 19 in the loop
                                                           ; below

qv1_:
       li   rx,>0c*256                 ; LDX #12           ; Move the text cursor to column 12
       movb rx,@XC                     ; STX XC            

       movb ry,ra                      ; TYA               ; Transfer the counter value from Y to A

       .clc                            ; CLC               ; Print ASCII character "0" - 16 + A, so as A goes from
       .adc #'0'-16,ra                 ; ADC #'0'-16       ; 16 to 19, this prints "0" through "3" followed by a
       .jsr @spc_                      ; JSR spc           ; space

       movb @YC,ra                     ; LDA YC            ; Print recursive text token 80 + YC, so as YC goes from
       .clc                            ; CLC               ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
       .adi (>50*256)                  ; ADC #80           ; "RIGHT"
       .jsr @TT27                      ; JSR TT27          

       ab   rone,ra                    ; INC YC            ; Move the text cursor down a row, and increment the
                                                           ; counter in YC at the same time

       movb @YC,ry                     ; LDY YC            ; Update Y with the incremented counter in YC

       ci   ry,>14*256                 ; CPY #20           ; If Y < 20 then loop back up to qv1 to print the next
       jnc  qv1_                       ; BCC qv1           ; view in the menu

qv3_:
       .jsr @CLYNS                     ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
                                                           ; and move the text cursor to column 1 on row 21, i.e.
                                                           ; the start of the top row of the three bottom rows

qv2_:
       li   ra,>af*256                 ; LDA #175          ; Print recursive text token 15 ("VIEW ") followed by
       .jsr @prq_                      ; JSR prq           ; a question mark

       .jsr @TT217                     ; JSR TT217         ; Scan the keyboard until a key is pressed, and return
                                                           ; the key's ASCII code in A (and X)

       .sec                            ; SEC               ; Subtract ASCII "0" from the key pressed, to leave the
       .sbi (('0')*256)                ; SBC #'0'          ; numeric value of the key in A (if it was a number key)

       ci   ra,>04*256                 ; CMP #4            ; If the number entered in A >= 4, then it is not a
       joc  qv3_                       ; BCS qv3           ; valid view number, so jump back to qv3 to try again

       movb ra,rx                      ; TAX               ; We have a valid view number, so transfer it to X

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Save ELTD.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE E FILE
* 
* Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_E.:
       equ $

LOAD_E.:
       equ LOAD. + $ - CODE.

* ******************************************************************************
* 
* Name: Authors' names
* Type: Variable
* Category: Copy protection
* Summary: The authors' names and a copyright notice, buried in the code
* 
* ------------------------------------------------------------------------------
* 
* This copyright notice is not used anywhere and it is obfuscated by EOR'ing
* each character with 164, but presumably the authors wanted their names buried
* in the code somewhere. Though they do also have recursive token 94, which
* reads "BY D.BRABEN & I.BELL" and can be displayed on the title screen using
* the "X" configuration option, so this isn't the only author name easter egg
* in the game. It contains the following text:
* 
* (C)Bell/Braben1984
* 
* ******************************************************************************

       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00
       byte >00

* ******************************************************************************
* 
* Name: cpl
* Type: Subroutine
* Category: Universe
* Summary: Print the selected system name
* Deep dive: Generating system names
* Galaxy and system seeds
* 
* ------------------------------------------------------------------------------
* 
* Print control code 3 (the selected system name, i.e. the one in the crosshairs
* in the Short-range Chart).
* 
* ******************************************************************************

cpl_:
       li   rx,>05*256                 ; LDX #5            ; First we need to back up the seeds in QQ15, so set up
                                                           ; a counter in X to cover three 16-bit seeds (i.e.
                                                           ; 6 bytes)

TT53:
       movb @QQ15(rx),ra               ; LDA QQ15,X        ; Copy byte X from QQ15 to QQ19
       movb ra,@QQ19(rx)               ; STA QQ19,X        

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  TT53                       ; BPL TT53          ; Loop back for the next byte to back up

       li   ry,>03*256                 ; LDY #3            ; Step 1: Now that the seeds are backed up, we can
                                                           ; start the name-generation process. We will either
                                                           ; need to loop three or four times, so for now set
                                                           ; up a counter in Y to loop four times

       .bit @QQ15                      ; BIT QQ15          ; Check bit 6 of s0_lo, which is stored in QQ15

       .bvs B59                        ; BVS B59           ; If bit 6 is set then skip over the next instruction

       sb   rone,ry                    ; DEY               ; Bit 6 is clear, so we only want to loop three times,
                                                           ; so decrement the loop counter in Y

B59:
       movb ry,@T                      ; STY T             ; Store the loop counter in T

TT55:
       movb @QQ15+5,ra                 ; LDA QQ15+5        ; Step 2: Load s2_hi, which is stored in QQ15+5, and
       andi ra,>1f*256                 ; AND #%00011111    ; extract bits 0-4 by AND'ing with %11111

       jeq  B60                        ; BEQ B60           ; If all those bits are zero, then skip the following
                                                           ; two instructions to go to step 3

       ori  ra,>80*256                 ; ORA #%10000000    ; We now have a number in the range 1-31, which we can
                                                           ; easily convert into a two-letter token, but first we
                                                           ; need to add 128 (or set bit 7) to get a range of
                                                           ; 129-159

       .jsr @TT27                      ; JSR TT27          ; Print the two-letter token in A

B60:
       .jsr @TT54                      ; JSR TT54          ; Step 3: twist the seeds in QQ15

       sb   rone,ra                    ; DEC T             ; Decrement the loop counter

       jgt  TT55                       ; BPL TT55          ; Loop back for the next two letters

       li   rx,>05*256                 ; LDX #5            ; We have printed the system name, so we can now
                                                           ; restore the seeds we backed up earlier. Set up a
                                                           ; counter in X to cover three 16-bit seeds (i.e. 6
                                                           ; bytes)

TT56:
       movb @QQ19(rx),ra               ; LDA QQ19,X        ; Copy byte X from QQ19 to QQ15
       movb ra,@QQ15(rx)               ; STA QQ15,X        

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  TT56                       ; BPL TT56          ; Loop back for the next byte to restore

       .rts                            ; RTS               ; Once all the seeds are restored, return from the
                                                           ; subroutine

* ******************************************************************************
* 
* Name: cmn
* Type: Subroutine
* Category: Status
* Summary: Print the commander's name
* 
* ------------------------------------------------------------------------------
* 
* Print control code 4 (the commander's name).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* cmn-1               Contains an RTS
* 
* ******************************************************************************

cmn_:
       li   ry,>00*256                 ; LDY #0            ; Set up a counter in Y, starting from 0

QUL4:
       movb @NA.(ry),ra                ; LDA NA%,Y         ; The commander's name is stored at NA%, so load the
                                                           ; Y-th character from NA%

       ci   ra,>0d*256                 ; CMP #13           ; If we have reached the end of the name, return from
       jeq  ypl_-1                     ; BEQ ypl-1         ; the subroutine (ypl-1 points to the RTS below)

       .jsr @TT26                      ; JSR TT26          ; Print the character we just loaded

       ab   rone,ry                    ; INY               ; Increment the loop counter

       jne  QUL4                       ; BNE QUL4          ; Loop back for the next character

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ypl
* Type: Subroutine
* Category: Universe
* Summary: Print the current system name
* 
* ------------------------------------------------------------------------------
* 
* Print control code 2 (the current system name).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* ypl-1               Contains an RTS
* 
* ******************************************************************************

ypl_:
       movb @MJ,ra                     ; LDA MJ            ; Check the mis-jump flag at MJ, and if it is non-zero
       jne  cmn_-1                     ; BNE cmn-1         ; then we are in witchspace, and witchspace doesn't have
                                                           ; a system name, so return from the subroutine (cmn-1
                                                           ; contains an RTS)

       .jsr @TT62                      ; JSR TT62          ; Call TT62 below to swap the three 16-bit seeds in
                                                           ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
                                                           ; for the current system, while QQ15 contains the seeds
                                                           ; for the selected system)

       .jsr @cpl_                      ; JSR cpl           ; Call cpl to print out the system name for the seeds
                                                           ; in QQ15 (which now contains the seeds for the current
                                                           ; system)

                                                           ; Now we fall through into the TT62 subroutine, which
                                                           ; will swap QQ2 and QQ15 once again, so everything goes
                                                           ; back into the right place, and the RTS at the end of
                                                           ; TT62 will return from the subroutine

TT62:
       li   rx,>05*256                 ; LDX #5            ; Set up a counter in X for the three 16-bit seeds we
                                                           ; want to swap (i.e. 6 bytes)

TT78:
       movb @QQ15(rx),ra               ; LDA QQ15,X        ; Swap byte X between QQ2 and QQ15
       movb @QQ2(rx),ry                ; LDY QQ2,X         
       movb ra,@QQ2(rx)                ; STA QQ2,X         
       movb ry,@QQ15(rx)               ; STY QQ15,X        

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  TT78                       ; BPL TT78          ; Loop back for the next byte to swap

       .rts                            ; RTS               ; Once all bytes are swapped, return from the
                                                           ; subroutine

* ******************************************************************************
* 
* Name: tal
* Type: Subroutine
* Category: Universe
* Summary: Print the current galaxy number
* 
* ------------------------------------------------------------------------------
* 
* Print control code 1 (the current galaxy number, right-aligned to width 3).
* 
* ******************************************************************************

tal_:
       .clc                            ; CLC               ; We don't want to print the galaxy number with a
                                                           ; decimal point, so clear the C flag for pr2 to take as
                                                           ; an argument

       movb @GCNT,rx                   ; LDX GCNT          ; Load the current galaxy number from GCNT into X

       ab   rone,rx                    ; INX               ; Add 1 to the galaxy number, as the galaxy numbers
                                                           ; are 0-7 internally, but we want to display them as
                                                           ; galaxy 1 through 8

       b    @pr2_                      ; JMP pr2           ; Jump to pr2, which prints the number in X to a width
                                                           ; of 3 figures, left-padding with spaces to a width of
                                                           ; 3, and return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: fwl
* Type: Subroutine
* Category: Status
* Summary: Print fuel and cash levels
* 
* ------------------------------------------------------------------------------
* 
* Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
* control code 0).
* 
* ******************************************************************************

fwl_:
       li   ra,>69*256                 ; LDA #105          ; Print recursive token 105 ("FUEL") followed by a
       .jsr @TT68                      ; JSR TT68          ; colon

       movb @QQ14,rx                   ; LDX QQ14          ; Load the current fuel level from QQ14

       .sec                            ; SEC               ; We want to print the fuel level with a decimal point,
                                                           ; so set the C flag for pr2 to take as an argument

       .jsr @pr2_                      ; JSR pr2           ; Call pr2, which prints the number in X to a width of
                                                           ; 3 figures (i.e. in the format x.x, which will always
                                                           ; be exactly 3 characters as the maximum fuel is 7.0)

       li   ra,>c3*256                 ; LDA #195          ; Print recursive token 35 ("LIGHT YEARS") followed by
       .jsr @plf_                      ; JSR plf           ; a newline

PCASH:
       li   ra,>77*256                 ; LDA #119          ; Print recursive token 119 ("CASH:" then control code
       jne  TT27                       ; BNE TT27          ; 0, which prints cash levels, then " CR" and newline)

* ******************************************************************************
* 
* Name: csh
* Type: Subroutine
* Category: Status
* Summary: Print the current amount of cash
* 
* ------------------------------------------------------------------------------
* 
* Print control code 0 (the current amount of cash, right-aligned to width 9,
* followed by " CR" and a newline).
* 
* ******************************************************************************

csh_:
       li   rx,>03*256                 ; LDX #3            ; We are going to use the BPRNT routine to print out
                                                           ; the current amount of cash, which is stored as a
                                                           ; 32-bit number at location CASH. BPRNT prints out
                                                           ; the 32-bit number stored in K, so before we call
                                                           ; BPRNT, we need to copy the four bytes from CASH into
                                                           ; K, so first we set up a counter in X for the 4 bytes

pc1_:
       movb @CASH(rx),ra               ; LDA CASH,X        ; Copy byte X from CASH to K
       movb ra,@K(rx)                  ; STA K,X           

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  pc1_                       ; BPL pc1           ; Loop back for the next byte to copy

       li   ra,>09*256                 ; LDA #9            ; We want to print the cash amount using up to 9 digits
       movb ra,@U                      ; STA U             ; (including the decimal point), so store this in U
                                                           ; for BRPNT to take as an argument

       .sec                            ; SEC               ; We want to print the cash amount with a decimal point,
                                                           ; so set the C flag for BRPNT to take as an argument

       .jsr @BPRNT                     ; JSR BPRNT         ; Print the amount of cash to 9 digits with a decimal
                                                           ; point

       li   ra,>e2*256                 ; LDA #226          ; Print recursive token 66 (" CR") followed by a
                                                           ; newline by falling through into plf

* ******************************************************************************
* 
* Name: plf
* Type: Subroutine
* Category: Text
* Summary: Print a text token followed by a newline
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

plf_:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A

       b    @TT67                      ; JMP TT67          ; Jump to TT67 to print a newline and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: TT68
* Type: Subroutine
* Category: Text
* Summary: Print a text token followed by a colon
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

TT68:
       .jsr @TT27                      ; JSR TT27          ; Print the text token in A and fall through into TT73
                                                           ; to print a colon

* ******************************************************************************
* 
* Name: TT73
* Type: Subroutine
* Category: Text
* Summary: Print a colon
* 
* ******************************************************************************

TT73:
       li   ra,(':')*256               ; LDA #':'          ; Set A to ASCII ":" and fall through into TT27 to
                                                           ; actually print the colon

* ******************************************************************************
* 
* Name: TT27
* Type: Subroutine
* Category: Text
* Summary: Print a text token
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* Print a text token (i.e. a character, control code, two-letter token or
* recursive token).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

TT27:
       movb ra,rx                      ; TAX               ; Copy the token number from A to X. We can then keep
                                                           ; decrementing X and testing it against zero, while
                                                           ; keeping the original token number intact in A; this
                                                           ; effectively implements a switch statement on the
                                                           ; value of the token

       jeq  csh_                       ; BEQ csh           ; If token = 0, this is control code 0 (current amount
                                                           ; of cash and newline), so jump to csh to print the
                                                           ; amount of cash and return from the subroutine using
                                                           ; a tail call

       jlt  TT43                       ; BMI TT43          ; If token > 127, this is either a two-letter token
                                                           ; (128-159) or a recursive token (160-255), so jump
                                                           ; to TT43 to process tokens

       sb   rone,rx                    ; DEX               ; If token = 1, this is control code 1 (current galaxy
       jeq  tal_                       ; BEQ tal           ; number), so jump to tal to print the galaxy number and
                                                           ; return from the subroutine using a tail call

       sb   rone,rx                    ; DEX               ; If token = 2, this is control code 2 (current system
       jeq  ypl_                       ; BEQ ypl           ; name), so jump to ypl to print the current system name
                                                           ; and return from the subroutine using a tail call

       sb   rone,rx                    ; DEX               ; If token > 3, skip the following instruction
       jne  B61                        ; BNE B61           

       b    @cpl_                      ; JMP cpl           ; This token is control code 3 (selected system name)
                                                           ; so jump to cpl to print the selected system name
                                                           ; and return from the subroutine using a tail call

B61:
       sb   rone,rx                    ; DEX               ; If token = 4, this is control code 4 (commander
       jeq  cmn_                       ; BEQ cmn           ; name), so jump to cmm to print the commander name
                                                           ; and return from the subroutine using a tail call

       sb   rone,rx                    ; DEX               ; If token = 5, this is control code 5 (fuel, newline,
       jeq  fwl_                       ; BEQ fwl           ; cash, newline), so jump to fwl to print the fuel level
                                                           ; and return from the subroutine using a tail call

       sb   rone,rx                    ; DEX               ; If token > 6, skip the following three instructions
       jne  B62                        ; BNE B62           

       li   ra,>80*256                 ; LDA #%10000000    ; This token is control code 6 (switch to Sentence
       movb ra,@QQ17                   ; STA QQ17          ; Case), so set bit 7 of QQ17 to switch to Sentence Case
       .rts                            ; RTS               ; and return from the subroutine as we are done

B62:
       sb   rone,rx                    ; DEX               ; If token > 8, skip the following two instructions
       sb   rone,rx                    ; DEX               
       jne  B63                        ; BNE B63           

       movb rx,@QQ17                   ; STX QQ17          ; This token is control code 8 (switch to ALL CAPS), so
       .rts                            ; RTS               ; set QQ17 to 0 to switch to ALL CAPS and return from
                                                           ; the subroutine as we are done

B63:
       sb   rone,rx                    ; DEX               ; If token = 9, this is control code 9 (tab to column
       jeq  crlf_                      ; BEQ crlf          ; 21 and print a colon), so jump to crlf

       ci   ra,>60*256                 ; CMP #96           ; By this point, token is either 7, or in 10-127.
       joc  ex_                        ; BCS ex            ; Check token number in A and if token >= 96, then the
                                                           ; token is in 96-127, which is a recursive token, so
                                                           ; jump to ex, which prints recursive tokens in this
                                                           ; range (i.e. where the recursive token number is
                                                           ; correct and doesn't need correcting)

       ci   ra,>0e*256                 ; CMP #14           ; If token < 14, skip the following two instructions
       jnc  B64                        ; BCC B64           

       ci   ra,>20*256                 ; CMP #32           ; If token < 32, then this means token is in 14-31, so
       jnc  qw_                        ; BCC qw            ; this is a recursive token that needs 114 adding to it
                                                           ; to get the recursive token number, so jump to qw
                                                           ; which will do this

                                                           ; By this point, token is either 7 (beep) or in 10-13
                                                           ; (line feeds and carriage returns), or in 32-95
                                                           ; (ASCII letters, numbers and punctuation)

B64:
       movb @QQ17,rx                   ; LDX QQ17          ; Fetch QQ17, which controls letter case, into X

       jeq  TT74                       ; BEQ TT74          ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
                                                           ; to print this character as is (i.e. as a capital)

       jlt  TT41                       ; BMI TT41          ; If QQ17 has bit 7 set, then we are using Sentence
                                                           ; Case, so jump to TT41, which will print the
                                                           ; character in upper or lower case, depending on
                                                           ; whether this is the first letter in a word

       .bit @QQ17                      ; BIT QQ17          ; If we get here, QQ17 is not 0 and bit 7 is clear, so
       .bvs TT46                       ; BVS TT46          ; either it is bit 6 that is set, or some other flag in
                                                           ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
                                                           ; If it is, then ALL CAPS has been set (as bit 7 is
                                                           ; clear) but bit 6 is still indicating that the next
                                                           ; character should be printed in lower case, so we need
                                                           ; to fix this. We do this with a jump to TT46, which
                                                           ; will print this character in upper case and clear bit
                                                           ; 6, so the flags are consistent with ALL CAPS going
                                                           ; forward

                                                           ; If we get here, some other flag is set in QQ17 (one
                                                           ; of bits 0-5 is set), which shouldn't happen in this
                                                           ; version of Elite. If this were the case, then we
                                                           ; would fall through into TT42 to print in lower case,
                                                           ; which is how printing all words in lower case could
                                                           ; be supported (by setting QQ17 to 1, say)

* ******************************************************************************
* 
* Name: TT42
* Type: Subroutine
* Category: Text
* Summary: Print a letter in lower case
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The character to be printed. Can be one of the
* following:
* 
* * 7 (beep)
* 
* * 10-13 (line feeds and carriage returns)
* 
* * 32-95 (ASCII capital letters, numbers and
* punctuation)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT44                Jumps to TT26 to print the character in A (used to
* enable us to use a branch instruction to jump to TT26)
* 
* ******************************************************************************

TT42:
       ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
       jnc  TT44                       ; BCC TT44          ; to TT26 (via TT44) to print the character as is, as
                                                           ; we don't care about the character's case

       ci   ra,('Z'+1)*256             ; CMP #'Z'+1        ; If A >= (ASCII "Z" + 1), then this is also
       joc  TT44                       ; BCS TT44          ; punctuation, so jump to TT26 (via TT44) to print the
                                                           ; character as is, as we don't care about the
                                                           ; character's case

       .adi (>20*256)                  ; ADC #32           ; Add 32 to the character, to convert it from upper to
                                                           ; lower case

TT44:
       b    @TT26                      ; JMP TT26          ; Print the character in A

* ******************************************************************************
* 
* Name: TT41
* Type: Subroutine
* Category: Text
* Summary: Print a letter according to Sentence Case
* 
* ------------------------------------------------------------------------------
* 
* The rules for printing in Sentence Case are as follows:
* 
* * If QQ17 bit 6 is set, print lower case (via TT45)
* 
* * If QQ17 bit 6 is clear, then:
* 
* * If character is punctuation, just print it
* 
* * If character is a letter, set QQ17 bit 6 and print letter as a capital
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The character to be printed. Can be one of the
* following:
* 
* * 7 (beep)
* 
* * 10-13 (line feeds and carriage returns)
* 
* * 32-95 (ASCII capital letters, numbers and
* punctuation)
* 
* X                   Contains the current value of QQ17
* 
* QQ17                Bit 7 is set
* 
* ******************************************************************************

TT41:
                                                           ; If we get here, then QQ17 has bit 7 set, so we are in
                                                           ; Sentence Case
       .bit @QQ17                      ; BIT QQ17          ; If QQ17 also has bit 6 set, jump to TT45 to print
       .bvs TT45                       ; BVS TT45          ; this character in lower case

                                                           ; If we get here, then QQ17 has bit 6 clear and bit 7
                                                           ; set, so we are in Sentence Case and we need to print
                                                           ; the next letter in upper case

       ci   ra,('A')*256               ; CMP #'A'          ; If A < ASCII "A", then this is punctuation, so jump
       jnc  TT74                       ; BCC TT74          ; to TT26 (via TT44) to print the character as is, as
                                                           ; we don't care about the character's case

       .pha                            ; PHA               ; Otherwise this is a letter, so store the token number

       movb rx,ra                      ; TXA               ; Set bit 6 in QQ17 (X contains the current QQ17)
       ori  ra,>40*256                 ; ORA #%1000000     ; so the next letter after this one is printed in lower
       movb ra,@QQ17                   ; STA QQ17          ; case

       .pla                            ; PLA               ; Restore the token number into A

       jne  TT44                       ; BNE TT44          ; Jump to TT26 (via TT44) to print the character in A
                                                           ; (this BNE is effectively a JMP as A will never be
                                                           ; zero)

* ******************************************************************************
* 
* Name: qw
* Type: Subroutine
* Category: Text
* Summary: Print a recursive token in the range 128-145
* 
* ------------------------------------------------------------------------------
* 
* Print a recursive token where the token number is in 128-145 (so the value
* passed to TT27 is in the range 14-31).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   A value from 128-145, which refers to a recursive token
* in the range 14-31
* 
* ******************************************************************************

qw_:
       .adi (>72*256)                  ; ADC #114          ; This is a recursive token in the range 0-95, so add
       jne  ex_                        ; BNE ex            ; 114 to the argument to get the token number 128-145
                                                           ; and jump to ex to print it

* ******************************************************************************
* 
* Name: crlf
* Type: Subroutine
* Category: Text
* Summary: Tab to column 21 and print a colon
* 
* ------------------------------------------------------------------------------
* 
* Print control code 9 (tab to column 21 and print a colon). The subroutine
* name is pretty misleading, as it doesn't have anything to do with carriage
* returns or line feeds.
* 
* ******************************************************************************

crlf_:
       li   ra,>15*256                 ; LDA #21           ; Set the X-column in XC to 21
       movb ra,@XC                     ; STA XC            

       jne  TT73                       ; BNE TT73          ; Jump to TT73, which prints a colon (this BNE is
                                                           ; effectively a JMP as A will never be zero)

* ******************************************************************************
* 
* Name: TT45
* Type: Subroutine
* Category: Text
* Summary: Print a letter in lower case
* 
* ------------------------------------------------------------------------------
* 
* This routine prints a letter in lower case. Specifically:
* 
* * If QQ17 = 255, abort printing this character as printing is disabled
* 
* * If this is a letter then print in lower case
* 
* * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The character to be printed. Can be one of the
* following:
* 
* * 7 (beep)
* 
* * 10-13 (line feeds and carriage returns)
* 
* * 32-95 (ASCII capital letters, numbers and
* punctuation)
* 
* X                   Contains the current value of QQ17
* 
* QQ17                Bits 6 and 7 are set
* 
* ******************************************************************************

TT45:
                                                           ; If we get here, then QQ17 has bit 6 and 7 set, so we
                                                           ; are in Sentence Case and we need to print the next
                                                           ; letter in lower case
       ci   rx,>ff*256                 ; CPX #255          ; If QQ17 = 255 then printing is disabled, so return
       jeq  TT48                       ; BEQ TT48          ; from the subroutine (as TT48 contains an RTS)

       ci   ra,('A')*256               ; CMP #'A'          ; If A >= ASCII "A", then jump to TT42, which will
       joc  TT42                       ; BCS TT42          ; print the letter in lowercase

                                                           ; Otherwise this is not a letter, it's punctuation, so
                                                           ; this is effectively a word break. We therefore fall
                                                           ; through to TT46 to print the character and set QQ17
                                                           ; to ensure the next word starts with a capital letter

* ******************************************************************************
* 
* Name: TT46
* Type: Subroutine
* Category: Text
* Summary: Print a character and switch to capitals
* 
* ------------------------------------------------------------------------------
* 
* Print a character and clear bit 6 in QQ17, so that the next letter that gets
* printed after this will start with a capital letter.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The character to be printed. Can be one of the
* following:
* 
* * 7 (beep)
* 
* * 10-13 (line feeds and carriage returns)
* 
* * 32-95 (ASCII capital letters, numbers and
* punctuation)
* 
* X                   Contains the current value of QQ17
* 
* QQ17                Bits 6 and 7 are set
* 
* ******************************************************************************

TT46:
       .pha                            ; PHA               ; Store the token number

       movb rx,ra                      ; TXA               ; Clear bit 6 in QQ17 (X contains the current QQ17) so
       andi ra,>bf*256                 ; AND #%10111111    ; the next letter after this one is printed in upper
       movb ra,@QQ17                   ; STA QQ17          ; case

       .pla                            ; PLA               ; Restore the token number into A

                                                           ; Now fall through into TT74 to print the character

* ******************************************************************************
* 
* Name: TT74
* Type: Subroutine
* Category: Text
* Summary: Print a character
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The character to be printed
* 
* ******************************************************************************

TT74:
       b    @TT26                      ; JMP TT26          ; Print the character in A

* ******************************************************************************
* 
* Name: TT43
* Type: Subroutine
* Category: Text
* Summary: Print a two-letter token or recursive token 0-95
* 
* ------------------------------------------------------------------------------
* 
* Print a two-letter token, or a recursive token where the token number is in
* 0-95 (so the value passed to TT27 is in the range 160-255).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   One of the following:
* 
* * 128-159 (two-letter token)
* 
* * 160-255 (the argument to TT27 that refers to a
* recursive token in the range 0-95)
* 
* ******************************************************************************

TT43:
       ci   ra,>a0*256                 ; CMP #160          ; If token >= 160, then this is a recursive token, so
       joc  TT47                       ; BCS TT47          ; jump to TT47 below to process it

       andi ra,>7f*256                 ; AND #127          ; This is a two-letter token with number 128-159. The
       .asla                           ; ASL A             ; set of two-letter tokens is stored in a lookup table
                                                           ; at QQ16, with each token taking up two bytes, so to
                                                           ; convert this into the token's position in the table,
                                                           ; we subtract 128 (or just clear bit 7) and multiply
                                                           ; by 2 (or shift left)

       movb ra,ry                      ; TAY               ; Transfer the token's position into Y so we can look
                                                           ; up the token using absolute indexed mode

       movb @QQ16(ry),ra               ; LDA QQ16,Y        ; Get the first letter of the token and print it
       .jsr @TT27                      ; JSR TT27          

       movb @QQ16+1(ry),ra             ; LDA QQ16+1,Y      ; Get the second letter of the token

       ci   ra,('?')*256               ; CMP #'?'          ; If the second letter of the token is a question mark
       jeq  TT48                       ; BEQ TT48          ; then this is a one-letter token, so just return from
                                                           ; the subroutine without printing (as TT48 contains an
                                                           ; RTS)

       b    @TT27                      ; JMP TT27          ; Print the second letter and return from the
                                                           ; subroutine

TT47:
       .sbi (>a0*256)                  ; SBC #160          ; This is a recursive token in the range 160-255, so
                                                           ; subtract 160 from the argument to get the token
                                                           ; number 0-95 and fall through into ex to print it

* ******************************************************************************
* 
* Name: ex
* Type: Subroutine
* Category: Text
* Summary: Print a recursive token
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* This routine works its way through the recursive text tokens that are stored
* in tokenised form in the table at QQ18, and when it finds token number A,
* it prints it. Tokens are null-terminated in memory and fill three pages,
* but there is no lookup table as that would consume too much memory, so the
* only way to find the correct token is to start at the beginning and look
* through the table byte by byte, counting tokens as we go until we are in the
* right place. This approach might not be terribly speed efficient, but it is
* certainly memory-efficient.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The recursive token to be printed, in the range 0-148
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT48                Contains an RTS
* 
* ******************************************************************************

ex_:
       movb ra,rx                      ; TAX               ; Copy the token number into X

       li   ra,((QQ18)%256)*256        ; LDA #LO(QQ18)     ; Set V(1 0) to point to the recursive token table at
       movb ra,@V                      ; STA V             ; location QQ18
       li   ra,((QQ18)/256)*256        ; LDA #HI(QQ18)     
       movb ra,@V+1                    ; STA V+1           

       li   ry,>00*256                 ; LDY #0            ; Set a counter Y to point to the character offset
                                                           ; as we scan through the table

       movb rx,ra                      ; TXA               ; Copy the token number back into A, so both A and X
                                                           ; now contain the token number we want to print

       jeq  TT50                       ; BEQ TT50          ; If the token number we want is 0, then we have
                                                           ; already found the token we are looking for, so jump
                                                           ; to TT50, otherwise start working our way through the
                                                           ; null-terminated token table until we find the X-th
                                                           ; token

TT51:
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch the Y-th character from the token table page
                                                           ; we are currently scanning

       jeq  TT49                       ; BEQ TT49          ; If the character is null, we've reached the end of
                                                           ; this token, so jump to TT49

       ab   rone,ry                    ; INY               ; Increment character pointer and loop back around for
       jne  TT51                       ; BNE TT51          ; the next character in this token, assuming Y hasn't
                                                           ; yet wrapped around to 0

       ab   rone,ra                    ; INC V+1           ; If it has wrapped round to 0, we have just crossed
       jne  TT51                       ; BNE TT51          ; into a new page, so increment V+1 so that V points
                                                           ; to the start of the new page

TT49:
       ab   rone,ry                    ; INY               ; Increment the character pointer

       jne  TT59                       ; BNE TT59          ; If Y hasn't just wrapped around to 0, skip the next
                                                           ; instruction

       ab   rone,ra                    ; INC V+1           ; We have just crossed into a new page, so increment
                                                           ; V+1 so that V points to the start of the new page

TT59:
       sb   rone,rx                    ; DEX               ; We have just reached a new token, so decrement the
                                                           ; token number we are looking for

       jne  TT51                       ; BNE TT51          ; Assuming we haven't yet reached the token number in
                                                           ; X, look back up to keep fetching characters

TT50:
                                                           ; We have now reached the correct token in the token
                                                           ; table, with Y pointing to the start of the token as
                                                           ; an offset within the page pointed to by V, so let's
                                                           ; print the recursive token. Because recursive tokens
                                                           ; can contain other recursive tokens, we need to store
                                                           ; our current state on the stack, so we can retrieve
                                                           ; it after printing each character in this token
       movb ry,ra                      ; TYA               ; Store the offset in Y on the stack
       .pha                            ; PHA               

       movb @V+1,ra                    ; LDA V+1           ; Store the high byte of V (the page containing the
       .pha                            ; PHA               ; token we have found) on the stack, so the stack now
                                                           ; contains the address of the start of this token

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the character at offset Y in the token table,
                                                           ; which is the next character of this token that we
                                                           ; want to print

       .eoi ((RE)*256)                 ; EOR #RE           ; Tokens are stored in memory having been EOR'd with the
                                                           ; value of RE - which is 35 for all versions of Elite
                                                           ; except for NES, where RE is 62 - so we repeat the
                                                           ; EOR to get the actual character to print

       .jsr @TT27                      ; JSR TT27          ; Print the text token in A, which could be a letter,
                                                           ; number, control code, two-letter token or another
                                                           ; recursive token

       .pla                            ; PLA               ; Restore the high byte of V (the page containing the
       movb ra,@V+1                    ; STA V+1           ; token we have found) into V+1

       .pla                            ; PLA               ; Restore the offset into Y
       movb ra,ry                      ; TAY               

       ab   rone,ry                    ; INY               ; Increment Y to point to the next character in the
                                                           ; token we are printing

       jne  B65                        ; BNE B65           ; If Y is zero then we have just crossed into a new
       ab   rone,ra                    ; INC V+1           ; page, so increment V+1 so that V points to the start
                                                           ; of the new page

B65:
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Load the next character we want to print into A

       jne  TT50                       ; BNE TT50          ; If this is not the null character at the end of the
                                                           ; token, jump back up to TT50 to print the next
                                                           ; character, otherwise we are done printing

TT48:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DOEXP
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw an exploding ship
* Deep dive: Drawing explosion clouds
* Generating random numbers
* 
* ******************************************************************************

EX2:
       movb @INWK+31,ra                ; LDA INWK+31       ; Set bits 5 and 7 of the ship's byte #31 to denote that
       ori  ra,>a0*256                 ; ORA #%10100000    ; the ship is exploding and has been killed
       movb ra,@INWK+31                ; STA INWK+31       

       .rts                            ; RTS               ; Return from the subroutine

DOEXP:
       movb @INWK+31,ra                ; LDA INWK+31       ; If bit 6 of the ship's byte #31 is clear, then the
       andi ra,>40*256                 ; AND #%01000000    ; ship is not already exploding so there is no existing
       jeq  B66                        ; BEQ B66           ; explosion cloud to remove, so skip the following
                                                           ; instruction

       .jsr @PTCLS                     ; JSR PTCLS         ; Call PTCLS to remove the existing cloud by drawing it
                                                           ; again

B66:
       movb @INWK+6,ra                 ; LDA INWK+6        ; Set T = z_lo
       movb ra,@T                      ; STA T             

       movb @INWK+7,ra                 ; LDA INWK+7        ; Set A = z_hi, so (A T) = z

       ci   ra,>20*256                 ; CMP #32           ; If z_hi < 32, skip the next two instructions
       jnc  B67                        ; BCC B67           

       li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and jump to yy (this BNE is effectively a
       jne  yy_                        ; BNE yy            ; JMP, as A is never zero)

B67:
       .asl @T                         ; ASL T             ; Shift (A T) left twice
       .rola                           ; ROL A             
       .asl @T                         ; ASL T             
       .rola                           ; ROL A             

       .sec                            ; SEC               ; And then shift A left once more, inserting a 1 into
       .rola                           ; ROL A             ; bit 0

                                                           ; Overall, the above multiplies A by 8 and makes sure it
                                                           ; is at least 1, to leave a one-byte distance in A. We
                                                           ; can use this as the distance for our cloud, to ensure
                                                           ; that the explosion cloud is visible even for ships
                                                           ; that blow up a long way away

yy_:
       movb ra,@Q                      ; STA Q             ; Store the distance to the explosion in Q

       li   ry,>01*256                 ; LDY #1            ; Fetch byte #1 of the ship line heap, which contains
       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud counter

       .adi (>04*256)                  ; ADC #4            ; Add 4 to the cloud counter, so it ticks onwards every
                                                           ; we redraw it

       joc  EX2                        ; BCS EX2           ; If the addition overflowed, jump up to EX2 to update
                                                           ; the explosion flags and return from the subroutine

       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the updated cloud counter in byte #1 of the ship
                                                           ; line heap

       .jsr @DVID4                     ; JSR DVID4         ; Calculate the following:
                                                           ; 
                                                           ; (P R) = 256 * A / Q
                                                           ; = 256 * cloud counter / distance
                                                           ; 
                                                           ; We are going to use this as our cloud size, so the
                                                           ; further away the cloud, the smaller it is, and as the
                                                           ; cloud counter ticks onward, the cloud expands

       movb @P,ra                      ; LDA P             ; Set A = P, so we now have:
                                                           ; 
                                                           ; (A R) = 256 * cloud counter / distance

       ci   ra,>1c*256                 ; CMP #&1C          ; If A < 28, skip the next two instructions
       jnc  B68                        ; BCC B68           

       li   ra,>fe*256                 ; LDA #&FE          ; Set A = 254 and skip the following (this BNE is
       jne  LABEL_1                    ; BNE LABEL_1       ; effectively a JMP as A is never zero)

B68:
       .asl @R                         ; ASL R             ; Shift (A R) left three times to multiply by 8
       .rola                           ; ROL A             
       .asl @R                         ; ASL R             
       .rola                           ; ROL A             
       .asl @R                         ; ASL R             
       .rola                           ; ROL A             

                                                           ; Overall, the above multiplies (A R) by 8 to leave a
                                                           ; one-byte cloud size in A, given by the following:
                                                           ; 
                                                           ; A = 8 * cloud counter / distance

LABEL_1:
       sb   rone,ry                    ; DEY               ; Decrement Y to 0

       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store the cloud size in byte #0 of the ship line heap

       movb @INWK+31,ra                ; LDA INWK+31       ; Clear bit 6 of the ship's byte #31 to denote that the
       andi ra,>bf*256                 ; AND #%10111111    ; explosion has not yet been drawn
       movb ra,@INWK+31                ; STA INWK+31       

       andi ra,>08*256                 ; AND #%00001000    ; If bit 3 of the ship's byte #31 is clear, then nothing
       jeq  TT48                       ; BEQ TT48          ; is being drawn on-screen for this ship anyway, so
                                                           ; return from the subroutine (as TT48 contains an RTS)

       li   ry,>02*256                 ; LDY #2            ; Otherwise it's time to draw an explosion cloud, so
       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; fetch byte #2 of the ship line heap into Y, which we
       movb ra,ry                      ; TAY               ; set to the explosion count for this ship (i.e. the
                                                           ; number of vertices used as origins for explosion
                                                           ; clouds)
                                                           ; 
                                                           ; The explosion count is stored as 4 * n + 6, where n is
                                                           ; the number of vertices, so the following loop copies
                                                           ; the coordinates of the first n vertices from the heap
                                                           ; at XX3, which is where we stored all the visible
                                                           ; vertex coordinates in part 8 of the LL9 routine, and
                                                           ; sticks them in the ship line heap pointed to by XX19,
                                                           ; starting at byte #7 (so it leaves the first 6 bytes of
                                                           ; the ship line heap alone)

EXL1:
       movb @XX3-7(ry),ra              ; LDA XX3-7,Y       ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the ship line heap

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       ci   ry,>06*256                 ; CPY #6            ; Keep copying vertex coordinates into the ship line
       jne  EXL1                       ; BNE EXL1          ; heap until Y = 6 (which will copy n vertices, where n
                                                           ; is the number of vertices we should be exploding)

       movb @INWK+31,ra                ; LDA INWK+31       ; Set bit 6 of the ship's byte #31 to denote that the
       ori  ra,>40*256                 ; ORA #%01000000    ; explosion has been drawn (as it's about to be)
       movb ra,@INWK+31                ; STA INWK+31       

PTCLS:
                                                           ; This part of the routine actually draws the explosion
                                                           ; cloud
       li   ry,>00*256                 ; LDY #0            ; Fetch byte #0 of the ship line heap, which contains
       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; the cloud size we stored above, and store it in Q
       movb ra,@Q                      ; STA Q             

       ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #1

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #1 of the ship line heap, which contains
                                                           ; the cloud counter. We are now going to process this
                                                           ; into the number of particles in each vertex's cloud

       jgt  B69                        ; BPL B69           ; If the cloud counter < 128, then we are in the first
                                                           ; half of the cloud's existence, so skip the next
                                                           ; instruction

       .eoi (>ff*256)                  ; EOR #&FF          ; Flip the value of A so that in the second half of the
                                                           ; cloud's existence, A counts down instead of up

B69:
       srl  ra,1                       ; LSR A             ; Divide A by 8 so that is has a maximum value of 15
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             

       ori  ra,>01*256                 ; ORA #1            ; Make sure A is at least 1 and store it in U, to
       movb ra,@U                      ; STA U             ; give us the number of particles in the explosion for
                                                           ; each vertex

       ab   rone,ry                    ; INY               ; Increment the index in Y to point to byte #2

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch byte #2 of the ship line heap, which contains
       movb ra,@TGT                    ; STA TGT           ; the explosion count for this ship (i.e. the number of
                                                           ; vertices used as origins for explosion clouds) and
                                                           ; store it in TGT

       movb @RAND+1,ra                 ; LDA RAND+1        ; Fetch the current random number seed in RAND+1 and
       .pha                            ; PHA               ; store it on the stack, so we can re-randomise the
                                                           ; seeds when we are done

       li   ry,>06*256                 ; LDY #6            ; Set Y = 6 to point to the byte before the first vertex
                                                           ; coordinate we stored on the ship line heap above (we
                                                           ; increment it below so it points to the first vertex)

EXL5:
       li   rx,>03*256                 ; LDX #3            ; We are about to fetch a pair of coordinates from the
                                                           ; ship line heap, so set a counter in X for 4 bytes

EXL3:
       ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next byte
                                                           ; from the coordinate we are copying

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Copy the Y-th byte from the ship line heap to the X-th
       movb ra,@K3(rx)                 ; STA K3,X          ; byte of K3

       sb   rone,rx                    ; DEX               ; Decrement the X index

       jgt  EXL3                       ; BPL EXL3          ; Loop back to EXL3 until we have copied all four bytes

                                                           ; The above loop copies the vertex coordinates from the
                                                           ; ship line heap to K3, reversing them as we go, so it
                                                           ; sets the following:
                                                           ; 
                                                           ; K3+3 = x_lo
                                                           ; K3+2 = x_hi
                                                           ; K3+1 = y_lo
                                                           ; K3+0 = y_hi

       movb ry,@CNT                    ; STY CNT           ; Set CNT to the index that points to the next vertex on
                                                           ; the ship line heap

       li   ry,>02*256                 ; LDY #2            ; Set Y = 2, which we will use to point to bytes #3 to
                                                           ; #6, after incrementing it

                                                           ; This next loop copies bytes #3 to #6 from the ship
                                                           ; line heap into the four random number seeds in RAND to
                                                           ; RAND+3, EOR'ing them with the vertex index so they are
                                                           ; different for every vertex. This enables us to
                                                           ; generate random numbers for drawing each vertex that
                                                           ; are random but repeatable, which we need when we
                                                           ; redraw the cloud to remove it
                                                           ; 
                                                           ; Note that we haven't actually set the values of bytes
                                                           ; #3 to #6 in the ship line heap, so we have no idea
                                                           ; what they are, we just use what's already there. But
                                                           ; the fact that those bytes are stored for this ship
                                                           ; means we can repeat the random generation of the
                                                           ; cloud, which is the important bit

EXL2:
       ab   rone,ry                    ; INY               ; Increment the index in Y so it points to the next
                                                           ; random number seed to copy

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y-th byte from the ship line heap

       .eor @CNT                       ; EOR CNT           ; EOR with the vertex index, so the seeds are different
                                                           ; for each vertex

       movb ra,@>FFFD(ry)              ; STA &FFFD,Y       ; Y is going from 3 to 6, so this stores the four bytes
                                                           ; in memory locations &00, &01, &02 and &03, which are
                                                           ; the memory locations of RAND through RAND+3

       ci   ry,>06*256                 ; CPY #6            ; Loop back to EXL2 until Y = 6, which means we have
       jne  EXL2                       ; BNE EXL2          ; copied four bytes

       movb @U,ry                      ; LDY U             ; Set Y to the number of particles in the explosion for
                                                           ; each vertex, which we stored in U above. We will now
                                                           ; use this as a loop counter to iterate through all the
                                                           ; particles in the explosion

EXL4:
       .jsr @DORND2                    ; JSR DORND2        ; Set ZZ to a random number, making sure the C flag
       movb ra,@ZZ                     ; STA ZZ            ; doesn't affect the outcome

       movb @K3+1,ra                   ; LDA K3+1          ; Set (A R) = (y_hi y_lo)
       movb ra,@R                      ; STA R             ; = y
       movb @K3,ra                     ; LDA K3            

       .jsr @EXS1                      ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
                                                           ; = y +/- random * cloud size

       jne  EX11                       ; BNE EX11          ; If A is non-zero, the particle is off-screen as the
                                                           ; coordinate is bigger than 255), so jump to EX11 to do
                                                           ; the next particle

       ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If X > the y-coordinate of the bottom of the screen,
       joc  EX11                       ; BCS EX11          ; the particle is off the bottom of the screen, so jump
                                                           ; to EX11 to do the next particle

                                                           ; Otherwise X contains a random y-coordinate within the
                                                           ; cloud

       movb rx,@Y1                     ; STX Y1            ; Set Y1 = our random y-coordinate within the cloud

       movb @K3+3,ra                   ; LDA K3+3          ; Set (A R) = (x_hi x_lo)
       movb ra,@R                      ; STA R             
       movb @K3+2,ra                   ; LDA K3+2          

       .jsr @EXS1                      ; JSR EXS1          ; Set (A X) = (A R) +/- random * cloud size
                                                           ; = x +/- random * cloud size

       jne  EX4                        ; BNE EX4           ; If A is non-zero, the particle is off-screen as the
                                                           ; coordinate is bigger than 255), so jump to EX11 to do
                                                           ; the next particle

                                                           ; Otherwise X contains a random x-coordinate within the
                                                           ; cloud

       movb @Y1,ra                     ; LDA Y1            ; Set A = our random y-coordinate within the cloud

       .jsr @PIXEL                     ; JSR PIXEL         ; Draw a point at screen coordinate (X, A) with the
                                                           ; point size determined by the distance in ZZ

EX4:
       sb   rone,ry                    ; DEY               ; Decrement the loop counter for the next particle

       jgt  EXL4                       ; BPL EXL4          ; Loop back to EXL4 until we have done all the particles
                                                           ; in the cloud

       movb @CNT,ry                    ; LDY CNT           ; Set Y to the index that points to the next vertex on
                                                           ; the ship line heap

       cb   @TGT,ry                    ; CPY TGT           ; If Y < TGT, which we set to the explosion count for
       jnc  EXL5                       ; BCC EXL5          ; this ship (i.e. the number of vertices used as origins
                                                           ; for explosion clouds), loop back to EXL5 to do a cloud
                                                           ; for the next vertex

       .pla                            ; PLA               ; Restore the current random number seed to RAND+1 that
       movb ra,@RAND+1                 ; STA RAND+1        ; we stored at the start of the routine

       movb @K.+6,ra                   ; LDA K%+6          ; Store the z_lo coordinate for the planet (which will
       movb ra,@RAND+3                 ; STA RAND+3        ; be pretty random) in the RAND+3 seed

       .rts                            ; RTS               ; Return from the subroutine

EX11:
       .jsr @DORND2                    ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
                                                           ; doesn't affect the outcome

       b    @EX4                       ; JMP EX4           ; We just skipped a particle, so jump up to EX4 to do
                                                           ; the next one

EXS1:
                                                           ; This routine calculates the following:
                                                           ; 
                                                           ; (A X) = (A R) +/- random * cloud size
                                                           ; 
                                                           ; returning with the flags set for the high byte in A
       movb ra,@S                      ; STA S             ; Store A in S so we can use it later

       .jsr @DORND2                    ; JSR DORND2        ; Set A and X to random numbers, making sure the C flag
                                                           ; doesn't affect the outcome

       .rola                           ; ROL A             ; Set A = A * 2

       joc  EX5                        ; BCS EX5           ; If bit 7 of A was set (50% chance), jump to EX5

       .jsr @FMLTU                     ; JSR FMLTU         ; Set A = A * Q / 256
                                                           ; = random << 1 * projected cloud size / 256

       .adc @R,ra                      ; ADC R             ; Set (A X) = (S R) + A
       movb ra,rx                      ; TAX               ; = (S R) + random * projected cloud size
                                                           ; 
                                                           ; where S contains the argument A, starting with the low
                                                           ; bytes

       movb @S,ra                      ; LDA S             ; And then the high bytes
       .adi (>00*256)                  ; ADC #0            

       .rts                            ; RTS               ; Return from the subroutine

EX5:
       .jsr @FMLTU                     ; JSR FMLTU         ; Set T = A * Q / 256
       movb ra,@T                      ; STA T             ; = random << 1 * projected cloud size / 256

       movb @R,ra                      ; LDA R             ; Set (A X) = (S R) - T
       .sbc @T,ra                      ; SBC T             ; 
       movb ra,rx                      ; TAX               ; where S contains the argument A, starting with the low
                                                           ; bytes

       movb @S,ra                      ; LDA S             ; And then the high bytes
       .sbi (>00*256)                  ; SBC #0            

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SOS1
* Type: Subroutine
* Category: Universe
* Summary: Update the missile indicators, set up the planet data block
* 
* ------------------------------------------------------------------------------
* 
* Update the missile indicators, and set up a data block for the planet, but
* only setting the pitch and roll counters to 127 (no damping).
* 
* ******************************************************************************

SOS1:
       .jsr @msblob_                   ; JSR msblob        ; Reset the dashboard's missile indicators so none of
                                                           ; them are targeted

       li   ra,>7f*256                 ; LDA #127          ; Set the pitch and roll counters to 127, so that's a
       movb ra,@INWK+29                ; STA INWK+29       ; clockwise roll and a diving pitch with no damping, so
       movb ra,@INWK+30                ; STA INWK+30       ; the planet's rotation doesn't slow down

       movb @tek_,ra                   ; LDA tek           ; Set A = 128 or 130 depending on bit 1 of the system's
       andi ra,>02*256                 ; AND #%00000010    ; tech level in tek
       ori  ra,>80*256                 ; ORA #%10000000    

       b    @NWSHP                     ; JMP NWSHP         ; Add a new planet to our local bubble of universe,
                                                           ; with the planet type defined by A (128 is a planet
                                                           ; with an equator and meridian, 130 is a planet with
                                                           ; a crater)

* ******************************************************************************
* 
* Name: SOLAR
* Type: Subroutine
* Category: Universe
* Summary: Set up various aspects of arriving in a new system
* 
* ------------------------------------------------------------------------------
* 
* Halve our legal status, update the missile indicators, and set up data blocks
* and slots for the planet and sun.
* 
* ******************************************************************************

SOLAR:
       .lsr @FIST                      ; LSR FIST          ; Halve our legal status in FIST, making us less bad,
                                                           ; and moving bit 0 into the C flag (so every time we
                                                           ; arrive in a new system, our legal status improves a
                                                           ; bit)

       .jsr @ZINF                      ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace, which
                                                           ; doesn't affect the C flag

       movb @QQ15+1,ra                 ; LDA QQ15+1        ; Fetch s0_hi

       andi ra,>07*256                 ; AND #%00000111    ; Extract bits 0-2 (which also happen to determine the
                                                           ; economy), which will be between 0 and 7

       .adi (>06*256)                  ; ADC #6            ; Add 6 + C, and divide by 2, to get a result between 3
       srl  ra,1                       ; LSR A             ; and 7, at the same time shifting bit 0 of the result
                                                           ; of the addition into the C flag

       movb ra,@INWK+8                 ; STA INWK+8        ; Store the result in z_sign in byte #6

       .rora                           ; ROR A             ; Halve A, rotating in the C flag, which was previously
       movb ra,@INWK+2                 ; STA INWK+2        ; bit 0 of s0_hi + 6 + C, so when this is stored in both
       movb ra,@INWK+5                 ; STA INWK+5        ; x_sign and y_sign, it moves the planet to the upper
                                                           ; right or lower left

       .jsr @SOS1                      ; JSR SOS1          ; Call SOS1 to set up the planet's data block and add it
                                                           ; to FRIN, where it will get put in the first slot as
                                                           ; it's the first one to be added to our local bubble of
                                                           ; this new system's universe

       movb @QQ15+3,ra                 ; LDA QQ15+3        ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
       andi ra,>07*256                 ; AND #%00000111    ; store in z_sign, so the sun is behind us at a distance
       ori  ra,>81*256                 ; ORA #%10000001    ; of 1 to 7
       movb ra,@INWK+8                 ; STA INWK+8        

       movb @QQ15+5,ra                 ; LDA QQ15+5        ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
       andi ra,>03*256                 ; AND #%00000011    ; y_sign, so the sun is either dead centre in our rear
       movb ra,@INWK+2                 ; STA INWK+2        ; laser crosshairs, or off to the top left by a distance
       movb ra,@INWK+1                 ; STA INWK+1        ; of 1 or 2 when we look out the back

       li   ra,>00*256                 ; LDA #0            ; Set the pitch and roll counters to 0 (no rotation)
       movb ra,@INWK+29                ; STA INWK+29       
       movb ra,@INWK+30                ; STA INWK+30       

       li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun

       .jsr @NWSHP                     ; JSR NWSHP         ; Call NWSHP to set up the sun's data block and add it
                                                           ; to FRIN, where it will get put in the second slot as
                                                           ; it's the second one to be added to our local bubble
                                                           ; of this new system's universe

* ******************************************************************************
* 
* Name: NWSTARS
* Type: Subroutine
* Category: Stardust
* Summary: Initialise the stardust field
* 
* ------------------------------------------------------------------------------
* 
* This routine is called when the space view is initialised in routine LOOK1.
* 
* ******************************************************************************

NWSTARS:
       movb @QQ11,ra                   ; LDA QQ11          ; If this is not a space view, jump to WPSHPS to skip
* ORA MJ                 \ the initialisation of the SX, SY and SZ tables. The OR
       jne  WPSHPS                     ; BNE WPSHPS        ; instruction is commented out in the original source,
                                                           ; but it would have the effect of also skipping the
                                                           ; initialisation if we had mis-jumped into witchspace

* ******************************************************************************
* 
* Name: nWq
* Type: Subroutine
* Category: Stardust
* Summary: Create a random cloud of stardust
* 
* ------------------------------------------------------------------------------
* 
* Create a random cloud of stardust containing the correct number of dust
* particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
* normal space. Also clears the scanner and initialises the LSO block.
* 
* This is called by the DEATH routine when it displays our untimely demise.
* 
* ******************************************************************************

nWq:
       movb @NOSTM,ry                  ; LDY NOSTM         ; Set Y to the current number of stardust particles, so
                                                           ; we can use it as a counter through all the stardust

SAL4:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ori  ra,>08*256                 ; ORA #8            ; Set A so that it's at least 8

       movb ra,@SZ(ry)                 ; STA SZ,Y          ; Store A in the Y-th particle's z_hi coordinate at
                                                           ; SZ+Y, so the particle appears in front of us

       movb ra,@ZZ                     ; STA ZZ            ; Set ZZ to the particle's z_hi coordinate

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@SX(ry)                 ; STA SX,Y          ; Store A in the Y-th particle's x_hi coordinate at
                                                           ; SX+Y, so the particle appears in front of us

       movb ra,@X1                     ; STA X1            ; Set X1 to the particle's x_hi coordinate

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@SY(ry)                 ; STA SY,Y          ; Store A in the Y-th particle's y_hi coordinate at
                                                           ; SY+Y, so the particle appears in front of us

       movb ra,@Y1                     ; STA Y1            ; Set Y1 to the particle's y_hi coordinate

       .jsr @PIXEL2                    ; JSR PIXEL2        ; Draw a stardust particle at (X1,Y1) with distance ZZ

       sb   rone,ry                    ; DEY               ; Decrement the counter to point to the next particle of
                                                           ; stardust

       jne  SAL4                       ; BNE SAL4          ; Loop back to SAL4 until we have randomised all the
                                                           ; stardust particles

                                                           ; Fall through into WPSHPS to clear the scanner and
                                                           ; reset the LSO block

* ******************************************************************************
* 
* Name: WPSHPS
* Type: Subroutine
* Category: Dashboard
* Summary: Clear the scanner, reset the ball line and sun line heaps
* 
* ------------------------------------------------------------------------------
* 
* Remove all ships from the scanner, reset the sun line heap at LSO, and reset
* the ball line heap at LSX2 and LSY2.
* 
* ******************************************************************************

WPSHPS:
       li   rx,>00*256                 ; LDX #0            ; Set up a counter in X to work our way through all the
                                                           ; ship slots in FRIN

WSL1:
       movb @FRIN(rx),ra               ; LDA FRIN,X        ; Fetch the ship type in slot X

       jeq  WS2                        ; BEQ WS2           ; If the slot contains 0 then it is empty and we have
                                                           ; checked all the slots (as they are always shuffled
                                                           ; down in the main loop to close up and gaps), so jump
                                                           ; to WS2 as we are done

       jlt  WS1                        ; BMI WS1           ; If the slot contains a ship type with bit 7 set, then
                                                           ; it contains the planet or the sun, so jump down to WS1
                                                           ; to skip this slot, as the planet and sun don't appear
                                                           ; on the scanner

       movb ra,@TYPE                   ; STA TYPE          ; Store the ship type in TYPE

       .jsr @GINF                      ; JSR GINF          ; Call GINF to get the address of the data block for
                                                           ; ship slot X and store it in INF

       li   ry,>1f*256                 ; LDY #31           ; We now want to copy the first 32 bytes from the ship's
                                                           ; data block into INWK, so set a counter in Y

WSL2:
       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; Copy the Y-th byte from the data block pointed to by
       movb ra,@INWK(ry)               ; STA INWK,Y        ; INF into the Y-th byte of INWK workspace

       sb   rone,ry                    ; DEY               ; Decrement the counter to point at the next byte

       jgt  WSL2                       ; BPL WSL2          ; Loop back to WSL2 until we have copied all 32 bytes

       movb rx,@XSAV                   ; STX XSAV          ; Store the ship slot number in XSAV while we call SCAN

       .jsr @SCAN                      ; JSR SCAN          ; Call SCAN to plot this ship on the scanner, which will
                                                           ; remove it as it's plotted with EOR logic

       movb @XSAV,rx                   ; LDX XSAV          ; Restore the ship slot number from XSAV into X

       li   ry,>1f*256                 ; LDY #31           ; Clear bits 3, 4 and 6 in the ship's byte #31, which
       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; stops drawing the ship on-screen (bit 3), hides it
       andi ra,>a7*256                 ; AND #%10100111    ; from the scanner (bit 4) and stops any lasers firing
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; (bit 6)

WS1:
       ab   rone,rx                    ; INX               ; Increment X to point to the next ship slot

       jne  WSL1                       ; BNE WSL1          ; Loop back up to process the next slot (this BNE is
                                                           ; effectively a JMP as X will never be zero)

WS2:
       li   rx,>ff*256                 ; LDX #&FF          ; Set LSX2 = LSY2 = &FF to clear the ball line heap
       movb rx,@LSX2                   ; STX LSX2          
       movb rx,@LSY2                   ; STX LSY2          

                                                           ; Fall through into FLFLLS to reset the LSO block

* ******************************************************************************
* 
* Name: FLFLLS
* Type: Subroutine
* Category: Drawing suns
* Summary: Reset the sun line heap
* 
* ------------------------------------------------------------------------------
* 
* Reset the sun line heap at LSO by zero-filling it and setting the first byte
* to &FF.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A is set to 0
* 
* ******************************************************************************

FLFLLS:
       li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
                                                           ; view, so this sets Y as a counter for the number of
                                                           ; lines in the space view (i.e. 191), which is also the
                                                           ; number of lines in the LSO block

       li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the LSO block

SAL6:
       movb ra,@LSO(ry)                ; STA LSO,Y         ; Set the Y-th byte of the LSO block to 0

       sb   rone,ry                    ; DEY               ; Decrement the counter

       jne  SAL6                       ; BNE SAL6          ; Loop back until we have filled all the way to LSO+1

       sb   rone,ry                    ; DEY               ; Decrement Y to value of &FF (as we exit the above loop
                                                           ; with Y = 0)

       movb ry,@LSX                    ; STY LSX           ; Set the first byte of the LSO block, which has its own
                                                           ; label LSX, to &FF, to indicate that the sun line heap
                                                           ; is empty

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DET1
* Type: Subroutine
* Category: Drawing the screen
* Summary: Show or hide the dashboard (for when we die)
* 
* ------------------------------------------------------------------------------
* 
* This routine sets the screen to show the number of text rows given in X.
* 
* It is used when we are killed, as reducing the number of rows from the usual
* 31 to 24 has the effect of hiding the dashboard, leaving a monochrome image
* of ship debris and explosion clouds. Increasing the rows back up to 31 makes
* the dashboard reappear, as the dashboard's screen memory doesn't get touched
* by this process.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The number of text rows to display on the screen (24
* will hide the dashboard, 31 will make it reappear)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A is set to 6
* 
* ******************************************************************************

DET1:
       li   ra,>06*256                 ; LDA #6            ; Set A to 6 so we can update 6845 register R6 below

       limi 0                          ; SEI               ; Disable interrupts so we can update the 6845

       movb ra,@VIA+>00                ; STA VIA+&00       ; Set 6845 register R6 to the value in X. Register R6
       movb rx,@VIA+>01                ; STX VIA+&01       ; is the "vertical displayed" register, which sets the
                                                           ; number of rows shown on the screen

       limi 2                          ; CLI               ; Re-enable interrupts

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SHD
* Type: Subroutine
* Category: Flight
* Summary: Charge a shield and drain some energy from the energy banks
* 
* ------------------------------------------------------------------------------
* 
* Charge up a shield, and if it needs charging, drain some energy from the
* energy banks.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The value of the shield to recharge
* 
* ******************************************************************************

       sb   rone,rx                    ; DEX               ; Increment the shield value so that it doesn't go past
                                                           ; a maximum of 255

       .rts                            ; RTS               ; Return from the subroutine

SHD:
       ab   rone,rx                    ; INX               ; Increment the shield value

       jeq  SHD-2                      ; BEQ SHD-2         ; If the shield value is 0 then this means it was 255
                                                           ; before, which is the maximum value, so jump to SHD-2
                                                           ; to bring it back down to 258 and return

                                                           ; Otherwise fall through into DENGY to drain our energy
                                                           ; to pay for all this shield charging

* ******************************************************************************
* 
* Name: DENGY
* Type: Subroutine
* Category: Flight
* Summary: Drain some energy from the energy banks
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Z flag              Set if we have no energy left, clear otherwise
* 
* ******************************************************************************

DENGY:
       sb   rone,ra                    ; DEC ENERGY        ; Decrement the energy banks in ENERGY

       .php                            ; PHP               ; Save the flags on the stack

       jne  B70                        ; BNE B70           ; If the energy levels are not yet zero, skip the
                                                           ; following instruction

       ab   rone,ra                    ; INC ENERGY        ; The minimum allowed energy level is 1, and we just
                                                           ; reached 0, so increment ENERGY back to 1

B70:
       .plp                            ; PLP               ; Restore the flags from the stack, so we return with
                                                           ; the Z flag from the DEC instruction above

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: COMPAS
* Type: Subroutine
* Category: Dashboard
* Summary: Update the compass
* 
* ******************************************************************************

COMPAS:
       .jsr @DOT                       ; JSR DOT           ; Call DOT to redraw (i.e. remove) the current compass
                                                           ; dot

       movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump to
       jne  SP1                        ; BNE SP1           ; SP1 to draw the space station on the compass

       .jsr @SPS1                      ; JSR SPS1          ; Otherwise we need to draw the planet on the compass,
                                                           ; so first call SPS1 to calculate the vector to the
                                                           ; planet and store it in XX15

       b    @SP2                       ; JMP SP2           ; Jump to SP2 to draw XX15 on the compass, returning
                                                           ; from the subroutine using a tail call

* ******************************************************************************
* 
* Name: SPS2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (Y X) = A / 10
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following, where A is a sign-magnitude 8-bit integer and the
* result is a signed 16-bit integer:
* 
* (Y X) = A / 10
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is cleared
* 
* ******************************************************************************

SPS2:
       .asla                           ; ASL A             ; Set X = |A| * 2, and set the C flag to the sign bit of
       movb ra,rx                      ; TAX               ; A

       li   ra,>00*256                 ; LDA #0            ; Set Y to have the sign bit from A in bit 7, with the
       .rora                           ; ROR A             ; rest of its bits zeroed, so Y now contains the sign of
       movb ra,ry                      ; TAY               ; the original argument

       li   ra,>14*256                 ; LDA #20           ; Set Q = 20
       movb ra,@Q                      ; STA Q             

       movb rx,ra                      ; TXA               ; Copy X into A, so A now contains the argument A * 2

       .jsr @DVID4                     ; JSR DVID4         ; Calculate the following:
                                                           ; 
                                                           ; P = A / Q
                                                           ; = |argument A| * 2 / 20
                                                           ; = |argument A| / 10

       movb @P,rx                      ; LDX P             ; Set X to the result

       movb ry,ra                      ; TYA               ; If the sign of the original argument A is negative,
       jlt  LL163                      ; BMI LL163         ; jump to LL163 to flip the sign of the result

       li   ry,>00*256                 ; LDY #0            ; Set the high byte of the result to 0, as the result is
                                                           ; positive

       .rts                            ; RTS               ; Return from the subroutine

LL163:
       li   ry,>ff*256                 ; LDY #&FF          ; The result is negative, so set the high byte to &FF

       movb rx,ra                      ; TXA               ; Flip the low byte and add 1 to get the negated low
       .eoi (>ff*256)                  ; EOR #&FF          ; byte, using two's complement
       movb ra,rx                      ; TAX               
       ab   rone,rx                    ; INX               

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SPS4
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate the vector to the space station
* 
* ------------------------------------------------------------------------------
* 
* Calculate the vector between our ship and the space station and store it in
* XX15.
* 
* ******************************************************************************

SPS4:
       li   rx,>08*256                 ; LDX #8            ; First we need to copy the space station's coordinates
                                                           ; into K3, so set a counter to copy the first 9 bytes
                                                           ; (the 3-byte x, y and z coordinates) from the station's
                                                           ; data block at K% + NI% into K3

SPL1:
       movb @K.+NI.(rx),ra             ; LDA K%+NI%,X      ; Copy the X-th byte from the station's data block at
       movb ra,@K3(rx)                 ; STA K3,X          ; K% + NI% to the X-th byte of K3

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  SPL1                       ; BPL SPL1          ; Loop back to SPL1 until we have copied all 9 bytes

       b    @TAS2                      ; JMP TAS2          ; Call TAS2 to build XX15 from K3, returning from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: SP1
* Type: Subroutine
* Category: Dashboard
* Summary: Draw the space station on the compass
* 
* ******************************************************************************

SP1:
       .jsr @SPS4                      ; JSR SPS4          ; Call SPS4 to calculate the vector to the space station
                                                           ; and store it in XX15

                                                           ; Fall through into SP2 to draw XX15 on the compass

* ******************************************************************************
* 
* Name: SP2
* Type: Subroutine
* Category: Dashboard
* Summary: Draw a dot on the compass, given the planet/station vector
* 
* ------------------------------------------------------------------------------
* 
* Draw a dot on the compass to represent the planet or station, whose normalised
* vector is in XX15.
* 
* XX15 to XX15+2      The normalised vector to the planet or space station,
* stored as x in XX15, y in XX15+1 and z in XX15+2
* 
* ******************************************************************************

SP2:
       movb @XX15,ra                   ; LDA XX15          ; Set A to the x-coordinate of the planet or station to
                                                           ; show on the compass, which will be in the range -96 to
                                                           ; +96 as the vector has been normalised

       .jsr @SPS2                      ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
                                                           ; is the x-offset from the centre of the compass of the
                                                           ; dot we want to draw. Returns with the C flag clear

       movb rx,ra                      ; TXA               ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
       .adi (>c3*256)                  ; ADC #195          ; of the leftmost dot possible on the compass, and X can
       movb ra,@COMX                   ; STA COMX          ; be -9, which would be 195 - 9 = 186. This also means
                                                           ; that the highest value for COMX is 195 + 9 = 204,
                                                           ; which is the pixel x-coordinate of the rightmost dot
                                                           ; in the compass... but the compass dot is actually two
                                                           ; pixels wide, so the compass dot can overlap the right
                                                           ; edge of the compass, but not the left edge

       movb @XX15+1,ra                 ; LDA XX15+1        ; Set A to the y-coordinate of the planet or station to
                                                           ; show on the compass, which will be in the range -96 to
                                                           ; +96 as the vector has been normalised

       .jsr @SPS2                      ; JSR SPS2          ; Set (Y X) = A / 10, so X will be from -9 to +9, which
                                                           ; is the x-offset from the centre of the compass of the
                                                           ; dot we want to draw. Returns with the C flag clear

       movb rx,@T                      ; STX T             ; Set COMY = 204 - X, as 203 is the pixel y-coordinate
       li   ra,>cc*256                 ; LDA #204          ; of the centre of the compass, the C flag is clear,
       .sbc @T,ra                      ; SBC T             ; and the y-axis needs to be flipped around (because
       movb ra,@COMY                   ; STA COMY          ; when the planet or station is above us, and the
                                                           ; vector is therefore positive, we want to show the dot
                                                           ; higher up on the compass, which has a smaller pixel
                                                           ; y-coordinate). So this calculation does this:
                                                           ; 
                                                           ; COMY = 204 - X - (1 - 0) = 203 - X

       li   ra,>f0*256                 ; LDA #&F0          ; Set A to a 4-pixel mode 5 byte row in colour 2
                                                           ; (yellow/white), the colour for when the planet or
                                                           ; station in the compass is in front of us

       movb @XX15+2,rx                 ; LDX XX15+2        ; If the z-coordinate of the XX15 vector is positive,
       jgt  B71                        ; BPL B71           ; skip the following instruction

       li   ra,>ff*256                 ; LDA #&FF          ; The z-coordinate of XX15 is negative, so the planet or
                                                           ; station is behind us and the compass dot should be in
                                                           ; green/cyan, so set A to a 4-pixel mode 5 byte row in
                                                           ; colour 3

B71:
       movb ra,@COMC                   ; STA COMC          ; Store the compass colour in COMC

                                                           ; Fall through into DOT to draw the dot on the compass

* ******************************************************************************
* 
* Name: DOT
* Type: Subroutine
* Category: Dashboard
* Summary: Draw a dash on the compass
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* COMX                The screen pixel x-coordinate of the dash
* 
* COMY                The screen pixel y-coordinate of the dash
* 
* COMC                The colour and thickness of the dash:
* 
* * &F0 = a double-height dash in yellow/white, for when
* the object in the compass is in front of us
* 
* * &FF = a single-height dash in green/cyan, for when
* the object in the compass is behind us
* 
* ******************************************************************************

DOT:
       movb @COMY,ra                   ; LDA COMY          ; Set Y1 = COMY, the y-coordinate of the dash
       movb ra,@Y1                     ; STA Y1            

       movb @COMX,ra                   ; LDA COMX          ; Set X1 = COMX, the x-coordinate of the dash
       movb ra,@X1                     ; STA X1            

       movb @COMC,ra                   ; LDA COMC          ; Set COL = COMC, the mode 5 colour byte for the dash
       movb ra,@COL                    ; STA COL           

       ci   ra,>f0*256                 ; CMP #&F0          ; If COL is &F0 then the planet/station is in front of
       jne  CPIX2                      ; BNE CPIX2         ; us and we want to draw a double-height dash, so if it
                                                           ; isn't &F0 jump to CPIX2 to draw a single-height dash

                                                           ; Otherwise fall through into CPIX4 to draw a double-
                                                           ; height dash

* ******************************************************************************
* 
* Name: CPIX4
* Type: Subroutine
* Category: Drawing pixels
* Summary: Draw a double-height dot on the dashboard
* 
* ------------------------------------------------------------------------------
* 
* Draw a double-height mode 5 dot (2 pixels high, 2 pixels wide).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X1                  The screen pixel x-coordinate of the bottom-left corner
* of the dot
* 
* Y1                  The screen pixel y-coordinate of the bottom-left corner
* of the dot
* 
* COL                 The colour of the dot as a mode 5 character row byte
* 
* ******************************************************************************

CPIX4:
       .jsr @CPIX2                     ; JSR CPIX2         ; Call CPIX2 to draw a single-height dash at (X1, Y1)

       sb   rone,ra                    ; DEC Y1            ; Decrement Y1

                                                           ; Fall through into CPIX2 to draw a second single-height
                                                           ; dash on the pixel row above the first one, to create a
                                                           ; double-height dot

* ******************************************************************************
* 
* Name: CPIX2
* Type: Subroutine
* Category: Drawing pixels
* Summary: Draw a single-height dash on the dashboard
* Deep dive: Drawing colour pixels in mode 5
* 
* ------------------------------------------------------------------------------
* 
* Draw a single-height mode 5 dash (1 pixel high, 2 pixels wide).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X1                  The screen pixel x-coordinate of the dash
* 
* Y1                  The screen pixel y-coordinate of the dash
* 
* COL                 The colour of the dash as a mode 5 character row byte
* 
* ******************************************************************************

CPIX2:
       movb @Y1,ra                     ; LDA Y1            ; Fetch the y-coordinate into A

* .CPIX                  \ This label is commented out in the original source. It
                                                           ; would provide a new entry point with A specifying the
                                                           ; y-coordinate instead of Y1, but it isn't used anywhere

       movb ra,ry                      ; TAY               ; Store the y-coordinate in Y

       srl  ra,1                       ; LSR A             ; Set A = A / 8, so A now contains the character row we
       srl  ra,1                       ; LSR A             ; need to draw in (as each character row contains 8
       srl  ra,1                       ; LSR A             ; pixel rows)

       ori  ra,>60*256                 ; ORA #&60          ; Each character row in Elite's screen mode takes up one
                                                           ; page in memory (256 bytes), so we now OR with &60 to
                                                           ; get the page containing the dash (see the comments in
                                                           ; routine TT26 for more discussion about calculating
                                                           ; screen memory addresses)

       movb ra,@SCH                    ; STA SCH           ; Store the screen page in the high byte of SC(1 0)

       movb @X1,ra                     ; LDA X1            ; Each character block contains 8 pixel rows, so to get
       andi ra,>f8*256                 ; AND #%11111000    ; the address of the first byte in the character block
                                                           ; that we need to draw into, as an offset from the start
                                                           ; of the row, we clear bits 0-2

       movb ra,@SC                     ; STA SC            ; Store the address of the character block in the low
                                                           ; byte of SC(1 0), so now SC(1 0) points to the
                                                           ; character block we need to draw into

       movb ry,ra                      ; TYA               ; Set Y to just bits 0-2 of the y-coordinate, which will
       andi ra,>07*256                 ; AND #%00000111    ; be the number of the pixel row we need to draw into
       movb ra,ry                      ; TAY               ; within the character block

       movb @X1,ra                     ; LDA X1            ; Copy bits 0-1 of X1 to bits 1-2 of X, and clear the C
       andi ra,>06*256                 ; AND #%00000110    ; flag in the process (using the LSR). X will now be
       srl  ra,1                       ; LSR A             ; a value between 0 and 3, and will be the pixel number
       movb ra,rx                      ; TAX               ; in the character row for the left pixel in the dash.
                                                           ; This is because each character row is one byte that
                                                           ; contains 4 pixels, but covers 8 screen coordinates, so
                                                           ; this effectively does the division by 2 that we need

       movb @CTWOS(rx),ra              ; LDA CTWOS,X       ; Fetch a mode 5 1-pixel byte with the pixel position
       .and @COL                       ; AND COL           ; at X, and AND with the colour byte so that pixel takes
                                                           ; on the colour we want to draw (i.e. A is acting as a
                                                           ; mask on the colour byte)

       .eor @SC                        ; EOR (SC),Y        ; Draw the pixel on-screen using EOR logic, so we can
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; remove it later without ruining the background that's
                                                           ; already on-screen

       movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Fetch a mode 5 1-pixel byte with the pixel position
                                                           ; at X+1, so we can draw the right pixel of the dash

       jgt  CP1                        ; BPL CP1           ; The CTWOS table has an extra row at the end of it that
                                                           ; repeats the first value, %10001000, so if we have not
                                                           ; fetched that value, then the right pixel of the dash
                                                           ; is in the same character block as the left pixel, so
                                                           ; jump to CP1 to draw it

       movb @SC,ra                     ; LDA SC            ; Otherwise the left pixel we drew was at the last
       .adi (>08*256)                  ; ADC #8            ; position of four in this character block, so we add
       movb ra,@SC                     ; STA SC            ; 8 to the screen address to move onto the next block
                                                           ; along (as there are 8 bytes in a character block).
                                                           ; The C flag was cleared above, so this ADC is correct

       movb @CTWOS+1(rx),ra            ; LDA CTWOS+1,X     ; Re-fetch the mode 5 1-pixel byte, as we just overwrote
                                                           ; A (the byte will still be the fifth byte from the
                                                           ; table, which is correct as we want to draw the
                                                           ; leftmost pixel in the next character along as the
                                                           ; dash's right pixel)

CP1:
       .and @COL                       ; AND COL           ; Apply the colour mask to the pixel byte, as above

       .eor @SC                        ; EOR (SC),Y        ; Draw the dash's right pixel according to the mask in
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; A, with the colour in COL, using EOR logic, just as
                                                           ; above

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: OOPS
* Type: Subroutine
* Category: Flight
* Summary: Take some damage
* 
* ------------------------------------------------------------------------------
* 
* We just took some damage, so reduce the shields if we have any, or reduce the
* energy levels and potentially take some damage to the cargo if we don't.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The amount of damage to take
* 
* INF                 The address of the ship block for the ship that attacked
* us, or the ship that we just ran into
* 
* ******************************************************************************

OOPS:
       movb ra,@T                      ; STA T             ; Store the amount of damage in T

       li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 (z_sign) for the ship attacking us, and
       li   rx,>00*256                 ; LDX #0            ; set X = 0
       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       

       jlt  OO1                        ; BMI OO1           ; If A is negative, then we got hit in the rear, so jump
                                                           ; to OO1 to process damage to the aft shield

       movb @FSH,ra                    ; LDA FSH           ; Otherwise the forward shield was damaged, so fetch the
       .sbc @T,ra                      ; SBC T             ; shield strength from FSH and subtract the damage in T

       jnc  OO2                        ; BCC OO2           ; If the C flag is clear then this amount of damage was
                                                           ; too much for the shields, so jump to OO2 to set the
                                                           ; shield level to 0 and start taking damage directly
                                                           ; from the energy banks

       movb ra,@FSH                    ; STA FSH           ; Store the new value of the forward shield in FSH

       .rts                            ; RTS               ; Return from the subroutine

OO2:
* LDX #0                 \ This instruction is commented out in the original
                                                           ; source, and isn't required as X is set to 0 above
       movb rx,@FSH                    ; STX FSH           ; Set the forward shield to 0

       jnc  OO3                        ; BCC OO3           ; Jump to OO3 to start taking damage directly from the
                                                           ; energy banks (this BCC is effectively a JMP as the C
                                                           ; flag is clear, as we jumped to OO2 with a BCC)

OO1:
       movb @ASH,ra                    ; LDA ASH           ; The aft shield was damaged, so fetch the shield
       .sbc @T,ra                      ; SBC T             ; strength from ASH and subtract the damage in T

       jnc  OO5                        ; BCC OO5           ; If the C flag is clear then this amount of damage was
                                                           ; too much for the shields, so jump to OO5 to set the
                                                           ; shield level to 0 and start taking damage directly
                                                           ; from the energy banks

       movb ra,@ASH                    ; STA ASH           ; Store the new value of the aft shield in ASH

       .rts                            ; RTS               ; Return from the subroutine

OO5:
* LDX #0                 \ This instruction is commented out in the original
                                                           ; source, and isn't required as X is set to 0 above
       movb rx,@ASH                    ; STX ASH           ; Set the aft shield to 0

OO3:
       .adc @ENERGY,ra                 ; ADC ENERGY        ; A is negative and contains the amount by which the
       movb ra,@ENERGY                 ; STA ENERGY        ; damage overwhelmed the shields, so this drains the
                                                           ; energy banks by that amount (and because the energy
                                                           ; banks are shown over four indicators rather than one,
                                                           ; but with the same value range of 0-255, energy will
                                                           ; appear to drain away four times faster than the
                                                           ; shields did)

       jeq  B72                        ; BEQ B72           ; If we have just run out of energy, skip the next
                                                           ; instruction to jump straight to our death

       joc  B73                        ; BCS B73           ; If the C flag is set, then subtracting the damage from
                                                           ; the energy banks didn't underflow, so we had enough
                                                           ; energy to survive, and we can skip the next
                                                           ; instruction to make a sound and take some damage

B72:
       b    @DEATH                     ; JMP DEATH         ; Otherwise our energy levels are either 0 or negative,
                                                           ; and in either case that means we jump to our DEATH,
                                                           ; returning from the subroutine using a tail call

B73:
       .jsr @EXNO3                     ; JSR EXNO3         ; We didn't die, so call EXNO3 to make the sound of a
                                                           ; collision

       b    @OUCH                      ; JMP OUCH          ; And jump to OUCH to take damage and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: SPS3
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Copy a space coordinate from the K% block into K3
* 
* ------------------------------------------------------------------------------
* 
* Copy one of the planet's coordinates into the corresponding location in the
* temporary variable K3. The high byte and absolute value of the sign byte are
* copied into the first two K3 bytes, and the sign of the sign byte is copied
* into the highest K3 byte.
* 
* The comments below are written for copying the planet's x-coordinate into
* K3(2 1 0).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   Determines which coordinate to copy, and to where:
* 
* * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
* 
* * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
* 
* * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
* 
* ******************************************************************************

SPS3:
       movb @K.+1(rx),ra               ; LDA K%+1,X        ; Copy x_hi into K3+X
       movb ra,@K3(rx)                 ; STA K3,X          

       movb @K.+2(rx),ra               ; LDA K%+2,X        ; Set A = Y = x_sign
       movb ra,ry                      ; TAY               

       andi ra,>7f*256                 ; AND #%01111111    ; Set K3+1 = |x_sign|
       movb ra,@K3+1(rx)               ; STA K3+1,X        

       movb ry,ra                      ; TYA               ; Set K3+2 = the sign of x_sign
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@K3+2(rx)               ; STA K3+2,X        

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: GINF
* Type: Subroutine
* Category: Universe
* Summary: Fetch the address of a ship's data block into INF
* 
* ------------------------------------------------------------------------------
* 
* Get the address of the data block for ship slot X and store it in INF. This
* address is fetched from the UNIV table, which stores the addresses of the 13
* ship data blocks in workspace K%.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The ship slot number for which we want the data block
* address
* 
* ******************************************************************************

GINF:
       movb rx,ra                      ; TXA               ; Set Y = X * 2
       .asla                           ; ASL A             
       movb ra,ry                      ; TAY               

       movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Get the high byte of the address of the X-th ship
       movb ra,@INF                    ; STA INF           ; from UNIV and store it in INF

       movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      ; Get the low byte of the address of the X-th ship
       movb ra,@INF+1                  ; STA INF+1         ; from UNIV and store it in INF

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: NWSPS
* Type: Subroutine
* Category: Universe
* Summary: Add a new space station to our local bubble of universe
* 
* ******************************************************************************

NWSPS:
       .jsr @SPBLB                     ; JSR SPBLB         ; Light up the space station bulb on the dashboard

       li   rx,>01*256                 ; LDX #%00000001    ; Set the AI flag in byte #32 to %00000001 (friendly, no
       movb rx,@INWK+32                ; STX INWK+32       ; AI, has an E.C.M.)

       sb   rone,rx                    ; DEX               ; Set pitch counter to 0 (no pitch, roll only)
       movb rx,@INWK+30                ; STX INWK+30       

* STX INWK+31            \ This instruction is commented out in the original
                                                           ; source. It would set the exploding state and missile
                                                           ; count to 0

       movb rx,@FRIN+1                 ; STX FRIN+1        ; Set the second slot in the FRIN table to 0, so when we
                                                           ; fall through into NWSHP below, the new station that
                                                           ; gets created will go into slot FRIN+1, as this will be
                                                           ; the first empty slot that the routine finds

       sb   rone,rx                    ; DEX               ; Set the roll counter to 255 (maximum anti-clockwise
       movb rx,@INWK+29                ; STX INWK+29       ; roll with no damping)

       li   rx,>0a*256                 ; LDX #10           ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
       .jsr @NwS1                      ; JSR NwS1          

       .jsr @NwS1                      ; JSR NwS1          ; And again to flip the sign of nosev_y_hi (byte #12)

       .jsr @NwS1                      ; JSR NwS1          ; And again to flip the sign of nosev_z_hi (byte #14)

       li   ra,((LSO)%256)*256         ; LDA #LO(LSO)      ; Set bytes #33 and #34 to point to LSO for the ship
       movb ra,@INWK+33                ; STA INWK+33       ; line heap for the space station
       li   ra,((LSO)/256)*256         ; LDA #HI(LSO)      
       movb ra,@INWK+34                ; STA INWK+34       

       li   ra,(SST)*256               ; LDA #SST          ; Set A to the space station type, and fall through
                                                           ; into NWSHP to finish adding the space station to the
                                                           ; universe

* ******************************************************************************
* 
* Name: NWSHP
* Type: Subroutine
* Category: Universe
* Summary: Add a new ship to our local bubble of universe
* 
* ------------------------------------------------------------------------------
* 
* This creates a new block of ship data in the K% workspace, allocates a new
* block in the ship line heap at WP, adds the new ship's type into the first
* empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
* isn't enough free memory for the new ship, it isn't added.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The type of the ship to add (see variable XX21 for a
* list of ship types)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the ship was successfully added, clear if it
* wasn't (as there wasn't enough free memory)
* 
* INF                 Points to the new ship's data block in K%
* 
* ******************************************************************************

NWSHP:
       movb ra,@T                      ; STA T             ; Store the ship type in location T

       li   rx,>00*256                 ; LDX #0            ; Before we can add a new ship, we need to check
                                                           ; whether we have an empty slot we can put it in. To do
                                                           ; this, we need to loop through all the slots to look
                                                           ; for an empty one, so set a counter in X that starts
                                                           ; from the first slot at 0. When ships are killed, then
                                                           ; the slots are shuffled down by the KILLSHP routine, so
                                                           ; the first empty slot will always come after the last
                                                           ; filled slot. This allows us to tack the new ship's
                                                           ; data block and ship line heap onto the end of the
                                                           ; existing ship data and heap, as shown in the memory
                                                           ; map below

NWL1:
       movb @FRIN(rx),ra               ; LDA FRIN,X        ; Load the ship type for the X-th slot

       jeq  NW1                        ; BEQ NW1           ; If it is zero, then this slot is empty and we can use
                                                           ; it for our new ship, so jump down to NW1

       ab   rone,rx                    ; INX               ; Otherwise increment X to point to the next slot

       ci   rx,(NOSH)*256              ; CPX #NOSH         ; If we haven't reached the last slot yet, loop back up
       jnc  NWL1                       ; BCC NWL1          ; to NWL1 to check the next slot (note that this means
                                                           ; only slots from 0 to #NOSH - 1 are populated by this
                                                           ; routine, but there is one more slot reserved in FRIN,
                                                           ; which is used to identify the end of the slot list
                                                           ; when shuffling the slots down in the KILLSHP routine)

NW3:
       .clc                            ; CLC               ; Otherwise we don't have an empty slot, so we can't
       .rts                            ; RTS               ; add a new ship, so clear the C flag to indicate that
                                                           ; we have not managed to create the new ship, and return
                                                           ; from the subroutine

NW1:
                                                           ; If we get here, then we have found an empty slot at
                                                           ; index X, so we can go ahead and create our new ship.
                                                           ; We do that by creating a ship data block at INWK and,
                                                           ; when we are done, copying the block from INWK into
                                                           ; the K% workspace (specifically, to INF)
       .jsr @GINF                      ; JSR GINF          ; Get the address of the data block for ship slot X
                                                           ; (which is in workspace K%) and store it in INF

       movb @T,ra                      ; LDA T             ; If the type of ship that we want to create is
       jlt  NW2                        ; BMI NW2           ; negative, then this indicates a planet or sun, so
                                                           ; jump down to NW2, as the next section sets up a ship
                                                           ; data block, which doesn't apply to planets and suns,
                                                           ; as they don't have things like shields, missiles,
                                                           ; vertices and edges

                                                           ; This is a ship, so first we need to set up various
                                                           ; pointers to the ship blueprint we will need. The
                                                           ; blueprints for each ship type in Elite are stored
                                                           ; in a table at location XX21, so refer to the comments
                                                           ; on that variable for more details on the data we're
                                                           ; about to access

       .asla                           ; ASL A             ; Set Y = ship type * 2
       movb ra,ry                      ; TAY               

       movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; The ship blueprints at XX21 start with a lookup
       movb ra,@XX0                    ; STA XX0           ; table that points to the individual ship blueprints,
                                                           ; so this fetches the low byte of this particular ship
                                                           ; type's blueprint and stores it in XX0

       movb @XX21-1(ry),ra             ; LDA XX21-1,Y      ; Fetch the high byte of this particular ship type's
       movb ra,@XX0+1                  ; STA XX0+1         ; blueprint and store it in XX0+1, so XX0(1 0) now
                                                           ; contains the address of this ship's blueprint

       ci   ry,(2*SST)*256             ; CPY #2*SST        ; If the ship type is a space station (SST), then jump
       jeq  NW6                        ; BEQ NW6           ; to NW6, skipping the heap space steps below, as the
                                                           ; space station has its own line heap at LSO (which it
                                                           ; shares with the sun)

                                                           ; We now want to allocate space for a heap that we can
                                                           ; use to store the lines we draw for our new ship (so it
                                                           ; can easily be erased from the screen again). SLSP
                                                           ; points to the start of the current heap space, and we
                                                           ; can extend it downwards with the heap for our new ship
                                                           ; (as the heap space always ends just before the WP
                                                           ; workspace)

       li   ry,>05*256                 ; LDY #5            ; Fetch ship blueprint byte #5, which contains the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; maximum heap size required for plotting the new ship,
       movb ra,@T1                     ; STA T1            ; and store it in T1

       movb @SLSP,ra                   ; LDA SLSP          ; Take the 16-bit address in SLSP and subtract T1,
       .sec                            ; SEC               ; storing the 16-bit result in INWK(34 33), so this now
       .sbc @T1,ra                     ; SBC T1            ; points to the start of the line heap for our new ship
       movb ra,@INWK+33                ; STA INWK+33       
       movb @SLSP+1,ra                 ; LDA SLSP+1        
       .sbi (>00*256)                  ; SBC #0            
       movb ra,@INWK+34                ; STA INWK+34       

                                                           ; We now need to check that there is enough free space
                                                           ; for both this new line heap and the new data block
                                                           ; for our ship. In memory, this is the layout of the
                                                           ; ship data blocks and ship line heaps:
                                                           ; 
                                                           ; +-----------------------------------+   &0F34
                                                           ; |                                   |
                                                           ; | WP workspace                      |
                                                           ; |                                   |
                                                           ; +-----------------------------------+   &0D40 = WP
                                                           ; |                                   |
                                                           ; | Current ship line heap            |
                                                           ; |                                   |
                                                           ; +-----------------------------------+   SLSP
                                                           ; |                                   |
                                                           ; | Proposed heap for new ship        |
                                                           ; |                                   |
                                                           ; +-----------------------------------+   INWK(34 33)
                                                           ; |                                   |
                                                           ; .                                   .
                                                           ; .                                   .
                                                           ; .                                   .
                                                           ; .                                   .
                                                           ; .                                   .
                                                           ; |                                   |
                                                           ; +-----------------------------------+   INF + NI%
                                                           ; |                                   |
                                                           ; | Proposed data block for new ship  |
                                                           ; |                                   |
                                                           ; +-----------------------------------+   INF
                                                           ; |                                   |
                                                           ; | Existing ship data blocks         |
                                                           ; |                                   |
                                                           ; +-----------------------------------+   &0900 = K%
                                                           ; 
                                                           ; So, to work out if we have enough space, we have to
                                                           ; make sure there is room between the end of our new
                                                           ; ship data block at INF + NI%, and the start of the
                                                           ; proposed heap for our new ship at the address we
                                                           ; stored in INWK(34 33). Or, to put it another way, we
                                                           ; and to make sure that:
                                                           ; 
                                                           ; INWK(34 33) > INF + NI%
                                                           ; 
                                                           ; which is the same as saying:
                                                           ; 
                                                           ; INWK+33 - INF > NI%
                                                           ; 
                                                           ; because INWK is in zero page, so INWK+34 = 0

       movb @INWK+33,ra                ; LDA INWK+33       ; Calculate INWK+33 - INF, again using 16-bit
* SEC                    \ arithmetic, and put the result in (A Y), so the high
       .sbc @INF,ra                    ; SBC INF           ; byte is in A and the low byte in Y. The SEC
       movb ra,ry                      ; TAY               ; instruction is commented out in the original source;
       movb @INWK+34,ra                ; LDA INWK+34       ; as the previous subtraction will never underflow, it
       .sbc @INF+1,ra                  ; SBC INF+1         ; is superfluous

       jnc  NW3+1                      ; BCC NW3+1         ; If we have an underflow from the subtraction, then
                                                           ; INF > INWK+33 and we definitely don't have enough
                                                           ; room for this ship, so jump to NW3+1, which returns
                                                           ; from the subroutine (with the C flag already cleared)

       jne  NW4                        ; BNE NW4           ; If the subtraction of the high bytes in A is not
                                                           ; zero, and we don't have underflow, then we definitely
                                                           ; have enough space, so jump to NW4 to continue setting
                                                           ; up the new ship

       ci   ry,(NI.)*256               ; CPY #NI%          ; Otherwise the high bytes are the same in our
       jnc  NW3+1                      ; BCC NW3+1         ; subtraction, so now we compare the low byte of the
                                                           ; result (which is in Y) with NI%. This is the same as
                                                           ; doing INWK+33 - INF > NI% (see above). If this isn't
                                                           ; true, the C flag will be clear and we don't have
                                                           ; enough space, so we jump to NW3+1, which returns
                                                           ; from the subroutine (with the C flag already cleared)

NW4:
       movb @INWK+33,ra                ; LDA INWK+33       ; If we get here then we do have enough space for our
       movb ra,@SLSP                   ; STA SLSP          ; new ship, so store the new bottom of the ship line
       movb @INWK+34,ra                ; LDA INWK+34       ; heap (i.e. INWK+33) in SLSP, doing both the high and
       movb ra,@SLSP+1                 ; STA SLSP+1        ; low bytes

NW6:
       li   ry,>0e*256                 ; LDY #14           ; Fetch ship blueprint byte #14, which contains the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; ship's energy, and store it in byte #35
       movb ra,@INWK+35                ; STA INWK+35       

       li   ry,>13*256                 ; LDY #19           ; Fetch ship blueprint byte #19, which contains the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of missiles and laser power, and AND with %111
       andi ra,>07*256                 ; AND #%00000111    ; to extract the number of missiles before storing in
       movb ra,@INWK+31                ; STA INWK+31       ; byte #31

       movb @T,ra                      ; LDA T             ; Restore the ship type we stored above

NW2:
       movb ra,@FRIN(rx)               ; STA FRIN,X        ; Store the ship type in the X-th byte of FRIN, so the
                                                           ; this slot is now shown as occupied in the index table

       movb ra,rx                      ; TAX               ; Copy the ship type into X

       jlt  B74                        ; BMI B74           ; If the ship type is negative (planet or sun), then
                                                           ; skip the following instruction

       ab   rone,ra                    ; INC MANY,X        ; Increment the total number of ships of type X

B74:
       li   ry,(NI.-1)*256             ; LDY #NI%-1        ; The final step is to copy the new ship's data block
                                                           ; from INWK to INF, so set up a counter for NI% bytes
                                                           ; in Y

NWL3:
       movb @INWK(ry),ra               ; LDA INWK,Y        ; Load the Y-th byte of INWK and store in the Y-th byte
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; of the workspace pointed to by INF

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jgt  NWL3                       ; BPL NWL3          ; Loop back for the next byte until we have copied them
                                                           ; all over

       .sec                            ; SEC               ; We have successfully created our new ship, so set the
                                                           ; C flag to indicate success

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: NwS1
* Type: Subroutine
* Category: Universe
* Summary: Flip the sign and double an INWK byte
* 
* ------------------------------------------------------------------------------
* 
* Flip the sign of the INWK byte at offset X, and increment X by 2. This is
* used by the space station creation routine at NWSPS.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The offset of the INWK byte to be flipped
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   X is incremented by 2
* 
* ******************************************************************************

NwS1:
       movb @INWK(rx),ra               ; LDA INWK,X        ; Load the X-th byte of INWK into A and flip bit 7,
       .eoi (>80*256)                  ; EOR #%10000000    ; storing the result back in the X-th byte of INWK
       movb ra,@INWK(rx)               ; STA INWK,X        

       ab   rone,rx                    ; INX               ; Add 2 to X
       ab   rone,rx                    ; INX               

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ABORT
* Type: Subroutine
* Category: Dashboard
* Summary: Disarm missiles and update the dashboard indicators
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The new status of the leftmost missile indicator
* 
* ******************************************************************************

ABORT:
       li   rx,>ff*256                 ; LDX #&FF          ; Set X to &FF, which is the value of MSTG when we have
                                                           ; no target lock for our missile

                                                           ; Fall through into ABORT2 to set the missile lock to
                                                           ; the value in X, which effectively disarms the missile

* ******************************************************************************
* 
* Name: ABORT2
* Type: Subroutine
* Category: Dashboard
* Summary: Set/unset the lock target for a missile and update the dashboard
* 
* ------------------------------------------------------------------------------
* 
* Set the lock target for the leftmost missile and update the dashboard.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The slot number of the ship to lock our missile onto, or
* &FF to remove missile lock
* 
* Y                   The new colour of the missile indicator:
* 
* * &00 = black (no missile)
* 
* * &0E = red (armed and locked)
* 
* * &E0 = yellow/white (armed)
* 
* * &EE = green/cyan (disarmed)
* 
* ******************************************************************************

ABORT2:
       movb rx,@MSTG                   ; STX MSTG          ; Store the target of our missile lock in MSTG

       movb @NOMSL,rx                  ; LDX NOMSL         ; Call MSBAR to update the leftmost indicator in the
       .jsr @MSBAR                     ; JSR MSBAR         ; dashboard's missile bar, which returns with Y = 0

       movb ry,@MSAR                   ; STY MSAR          ; Set MSAR = 0 to indicate that the leftmost missile
                                                           ; is no longer seeking a target lock

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ECBLB2
* Type: Subroutine
* Category: Dashboard
* Summary: Start up the E.C.M. (light up the indicator, start the countdown
* and make the E.C.M. sound)
* 
* ******************************************************************************

ECBLB2:
       li   ra,>20*256                 ; LDA #32           ; Set the E.C.M. countdown timer in ECMA to 32
       movb ra,@ECMA                   ; STA ECMA          

       .asla                           ; ASL A             ; Call the NOISE routine with A = 64 to make the sound
       .jsr @NOISE                     ; JSR NOISE         ; of the E.C.M. being switched on

                                                           ; Fall through into ECBLB to light up the E.C.M. bulb

* ******************************************************************************
* 
* Name: ECBLB
* Type: Subroutine
* Category: Dashboard
* Summary: Light up the E.C.M. indicator bulb ("E") on the dashboard
* 
* ******************************************************************************

ECBLB:
       li   ra,(7*8)*256               ; LDA #7*8          ; The E.C.M. bulb is in character block number 7
                                                           ; with each character taking 8 bytes, so this sets the
                                                           ; low byte of the screen address of the character block
                                                           ; we want to draw to

       li   rx,((ECBT)%256)*256        ; LDX #LO(ECBT)     ; Set (Y X) to point to the character definition in
       li   ry,((ECBT)/256)*256        ; LDY #HI(ECBT)     ; ECBT. The LDY has no effect, as we overwrite Y with
                                                           ; the jump to BULB-2, which writes the high byte of SPBT
                                                           ; into Y. This works as long as ECBT and SPBT are in
                                                           ; the same page of memory, so perhaps the BNE below got
                                                           ; changed from BULB to BULB-2 so they could remove the
                                                           ; LDY, but for some reason it didn't get culled? Who
                                                           ; knows...

       jne  BULB-2                     ; BNE BULB-2        ; Jump down to BULB-2 (this BNE is effectively a JMP as
                                                           ; A will never be zero)

* ******************************************************************************
* 
* Name: SPBLB
* Type: Subroutine
* Category: Dashboard
* Summary: Light up the space station indicator ("S") on the dashboard
* 
* ******************************************************************************

SPBLB:
       li   ra,(24*8)*256              ; LDA #24*8         ; The space station bulb is in character block number 24
                                                           ; with each character taking 8 bytes, so this sets the
                                                           ; low byte of the screen address of the character block
                                                           ; we want to draw to

       li   rx,((SPBT)%256)*256        ; LDX #LO(SPBT)     ; Set (Y X) to point to the character definition in SPBT
       li   ry,((SPBT)/256)*256        ; LDY #HI(SPBT)     

                                                           ; Fall through into BULB to draw the space station bulb

* ******************************************************************************
* 
* Name: BULB
* Type: Subroutine
* Category: Dashboard
* Summary: Draw an indicator bulb on the dashboard
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The y-coordinate of the bulb as a low-byte screen
* address offset within screen page &7D (as both bulbs
* are on this character row in the dashboard)
* 
* (Y X)               The address of the character definition of the bulb to
* be drawn (i.e. ECBT for the E.C.M. bulb, or SPBT for the
* space station bulb)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* BULB-2              Set the Y screen address
* 
* ******************************************************************************

BULB:
       movb ra,@SC                     ; STA SC            ; Store the low byte of the screen address in SC

       movb rx,@P+1                    ; STX P+1           ; Set P(2 1) = (Y X)
       movb ry,@P+2                    ; STY P+2           

       li   ra,>7d*256                 ; LDA #&7D          ; Set A to the high byte of the screen address, which is
                                                           ; &7D as the bulbs are both in the character row from
                                                           ; &7D00 to &7DFF

       b    @RREN                      ; JMP RREN          ; Call RREN to print the character definition pointed to
                                                           ; by P(2 1) at the screen address pointed to by (A SC),
                                                           ; returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: ECBT
* Type: Variable
* Category: Dashboard
* Summary: The character bitmap for the E.C.M. indicator bulb
* 
* ------------------------------------------------------------------------------
* 
* The character bitmap for the E.C.M. indicator's "E" bulb that gets displayed
* on the dashboard.
* 
* The E.C.M. indicator uses the first 5 rows of the space station's "S" bulb
* below, as the bottom 5 rows of the "E" match the top 5 rows of the "S".
* 
* Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
* 
* ******************************************************************************

ECBT:
       byte >e0                                                      ; x x x .
       byte >e0                                                      ; x x x .
       byte >80                                                      ; x . . .
                                                                     ; x x x .
                                                                     ; x x x .
                                                                     ; x . . .
                                                                     ; x x x .
                                                                     ; x x x .

* ******************************************************************************
* 
* Name: SPBT
* Type: Variable
* Category: Dashboard
* Summary: The bitmap definition for the space station indicator bulb
* 
* ------------------------------------------------------------------------------
* 
* The bitmap definition for the space station indicator's "S" bulb that gets
* displayed on the dashboard.
* 
* Each pixel is in mode 5 colour 2 (%10), which is yellow/white.
* 
* ******************************************************************************

SPBT:
       byte >e0                                                      ; x x x .
       byte >e0                                                      ; x x x .
       byte >80                                                      ; x . . .
       byte >e0                                                      ; x x x .
       byte >e0                                                      ; x x x .
       byte >20                                                      ; . . x .
       byte >e0                                                      ; x x x .
       byte >e0                                                      ; x x x .

* ******************************************************************************
* 
* Name: MSBAR
* Type: Subroutine
* Category: Dashboard
* Summary: Draw a specific indicator in the dashboard's missile bar
* 
* ------------------------------------------------------------------------------
* 
* Each indicator is a rectangle that's 3 pixels wide and 5 pixels high. If the
* indicator is set to black, this effectively removes a missile.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The number of the missile indicator to update (counting
* from right to left, so indicator NOMSL is the leftmost
* indicator)
* 
* Y                   The colour of the missile indicator:
* 
* * &00 = black (no missile)
* 
* * &0E = red (armed and locked)
* 
* * &E0 = yellow/white (armed)
* 
* * &EE = green/cyan (disarmed)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   X is preserved
* 
* Y                   Y is set to 0
* 
* ******************************************************************************

MSBAR:
       movb rx,ra                      ; TXA               ; Set T = X * 8
       .asla                           ; ASL A             
       .asla                           ; ASL A             
       .asla                           ; ASL A             
       movb ra,@T                      ; STA T             

       li   ra,>31*256                 ; LDA #49           ; Set SC = 49 - T
       .sbc @T,ra                      ; SBC T             ; = 48 + 1 - (X * 8)
       movb ra,@SC                     ; STA SC            

                                                           ; So the low byte of SC(1 0) contains the row address
                                                           ; for the rightmost missile indicator, made up as
                                                           ; follows:
                                                           ; 
                                                           ; * 48 (character block 7, as byte #7 * 8 = 48), the
                                                           ; character block of the rightmost missile
                                                           ; 
                                                           ; * 1 (so we start drawing on the second row of the
                                                           ; character block)
                                                           ; 
                                                           ; * Move left one character (8 bytes) for each count
                                                           ; of X, so when X = 0 we are drawing the rightmost
                                                           ; missile, for X = 1 we hop to the left by one
                                                           ; character, and so on

       li   ra,>7e*256                 ; LDA #&7E          ; Set the high byte of SC(1 0) to &7E, the character row
       movb ra,@SCH                    ; STA SCH           ; that contains the missile indicators (i.e. the bottom
                                                           ; row of the screen)

       movb ry,ra                      ; TYA               ; Set A to the correct colour, which is a 3-pixel wide
                                                           ; mode 5 character row in the correct colour (for
                                                           ; example, a green block has Y = &EE, or %11101110, so
                                                           ; the missile blocks are 3 pixels wide, with the
                                                           ; fourth pixel on the character row being empty)

       li   ry,>05*256                 ; LDY #5            ; We now want to draw this line five times, so set a
                                                           ; counter in Y

MBL1:
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Draw the 3-pixel row, and as we do not use EOR logic,
                                                           ; this will overwrite anything that is already there
                                                           ; (so drawing a black missile will delete what's there)

       sb   rone,ry                    ; DEY               ; Decrement the counter for the next row

       jne  MBL1                       ; BNE MBL1          ; Loop back to MBL1 if have more rows to draw

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PROJ
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Project the current ship or planet onto the screen
* Deep dive: Extended screen coordinates
* 
* ------------------------------------------------------------------------------
* 
* Project the current ship's location or the planet onto the screen, either
* returning the screen coordinates of the projection (if it's on-screen), or
* returning an error via the C flag.
* 
* In this context, "on-screen" means that the point is projected into the
* following range:
* 
* centre of screen - 1024 < x < centre of screen + 1024
* centre of screen - 1024 < y < centre of screen + 1024
* 
* This is to cater for ships (and, more likely, planets and suns) whose centres
* are off-screen but whose edges may still be visible.
* 
* The projection calculation is:
* 
* K3(1 0) = #X + x / z
* K4(1 0) = #Y + y / z
* 
* where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
* the screen.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* INWK                The ship data block for the ship to project on-screen
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* K3(1 0)             The x-coordinate of the ship's projection on-screen
* 
* K4(1 0)             The y-coordinate of the ship's projection on-screen
* 
* C flag              Set if the ship's projection doesn't fit on the screen,
* clear if it does project onto the screen
* 
* A                   Contains K4+1, the high byte of the y-coordinate
* 
* ******************************************************************************

PROJ:
       movb @INWK,ra                   ; LDA INWK          ; Set P(1 0) = (x_hi x_lo)
       movb ra,@P                      ; STA P             ; = x
       movb @INWK+1,ra                 ; LDA INWK+1        
       movb ra,@P+1                    ; STA P+1           

       movb @INWK+2,ra                 ; LDA INWK+2        ; Set A = x_sign

       .jsr @PLS6                      ; JSR PLS6          ; Call PLS6 to calculate:
                                                           ; 
                                                           ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
                                                           ; = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
                                                           ; = x / z

       joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
                                                           ; the coordinate doesn't fit on the screen, so return
                                                           ; from the subroutine with the C flag set (as PL2-1
                                                           ; contains an RTS)

       movb @K,ra                      ; LDA K             ; Set K3(1 0) = (X K) + #X
       .adi ((X)*256)                  ; ADC #X            ; = #X + x / z
       movb ra,@K3                     ; STA K3            ; 
                                                           ; first doing the low bytes

       movb rx,ra                      ; TXA               ; And then the high bytes. #X is the x-coordinate of
       .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
       movb ra,@K3+1                   ; STA K3+1          ; space x-coordinate into a screen x-coordinate

       movb @INWK+3,ra                 ; LDA INWK+3        ; Set P(1 0) = (y_hi y_lo)
       movb ra,@P                      ; STA P             
       movb @INWK+4,ra                 ; LDA INWK+4        
       movb ra,@P+1                    ; STA P+1           

       movb @INWK+5,ra                 ; LDA INWK+5        ; Set A = -y_sign
       .eoi (>80*256)                  ; EOR #%10000000    

       .jsr @PLS6                      ; JSR PLS6          ; Call PLS6 to calculate:
                                                           ; 
                                                           ; (X K) = (A P+1 P) / (z_sign z_hi z_lo)
                                                           ; = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
                                                           ; = -y / z

       joc  PL2-1                      ; BCS PL2-1         ; If the C flag is set then the result overflowed and
                                                           ; the coordinate doesn't fit on the screen, so return
                                                           ; from the subroutine with the C flag set (as PL2-1
                                                           ; contains an RTS)

       movb @K,ra                      ; LDA K             ; Set K4(1 0) = (X K) + #Y
       .adi ((Y)*256)                  ; ADC #Y            ; = #Y - y / z
       movb ra,@K4                     ; STA K4            ; 
                                                           ; first doing the low bytes

       movb rx,ra                      ; TXA               ; And then the high bytes. #Y is the y-coordinate of
       .adi (>00*256)                  ; ADC #0            ; the centre of the space view, so this converts the
       movb ra,@K4+1                   ; STA K4+1          ; space x-coordinate into a screen y-coordinate

       .clc                            ; CLC               ; Clear the C flag to indicate success

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PL2
* Type: Subroutine
* Category: Drawing planets
* Summary: Remove the planet or sun from the screen
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* PL2-1               Contains an RTS
* 
* ******************************************************************************

PL2:
       movb @TYPE,ra                   ; LDA TYPE          ; Shift bit 0 of the planet/sun's type into the C flag
       srl  ra,1                       ; LSR A             

       joc  B75                        ; BCS B75           ; If the planet/sun's type has bit 0 clear, then it's
                                                           ; either 128 or 130, which is a planet; meanwhile, the
                                                           ; sun has type 129, which has bit 0 set. So if this is
                                                           ; the sun, skip the following instruction

       b    @WPLS2                     ; JMP WPLS2         ; This is the planet, so jump to WPLS2 to remove it from
                                                           ; screen, returning from the subroutine using a tail
                                                           ; call

B75:
       b    @WPLS                      ; JMP WPLS          ; This is the sun, so jump to WPLS to remove it from
                                                           ; screen, returning from the subroutine using a tail
                                                           ; call

* ******************************************************************************
* 
* Name: PLANET
* Type: Subroutine
* Category: Drawing planets
* Summary: Draw the planet or sun
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* INWK                The planet or sun's ship data block
* 
* ******************************************************************************

PLANET:
       movb @INWK+8,ra                 ; LDA INWK+8        ; Set A = z_sign (the highest byte in the planet/sun's
                                                           ; coordinates)

       jlt  PL2                        ; BMI PL2           ; If A is negative then the planet/sun is behind us, so
                                                           ; jump to PL2 to remove it from the screen, returning
                                                           ; from the subroutine using a tail call

       ci   ra,>30*256                 ; CMP #48           ; If A >= 48 then the planet/sun is too far away to be
       joc  PL2                        ; BCS PL2           ; seen, so jump to PL2 to remove it from the screen,
                                                           ; returning from the subroutine using a tail call

       socb @INWK+7,ra                 ; ORA INWK+7        ; Set A to 0 if both z_sign and z_hi are 0

       jeq  PL2                        ; BEQ PL2           ; If both z_sign and z_hi are 0, then the planet/sun is
                                                           ; too close to be shown, so jump to PL2 to remove it
                                                           ; from the screen, returning from the subroutine using a
                                                           ; tail call

       .jsr @PROJ                      ; JSR PROJ          ; Project the planet/sun onto the screen, returning the
                                                           ; centre's coordinates in K3(1 0) and K4(1 0)

       joc  PL2                        ; BCS PL2           ; If the C flag is set by PROJ then the planet/sun is
                                                           ; not visible on-screen, so jump to PL2 to remove it
                                                           ; from the screen, returning from the subroutine using
                                                           ; a tail call

       li   ra,>60*256                 ; LDA #96           ; Set (A P+1 P) = (0 96 0) = 24576
       movb ra,@P+1                    ; STA P+1           ; 
       li   ra,>00*256                 ; LDA #0            ; This represents the planet/sun's radius at a distance
       movb ra,@P                      ; STA P             ; of z = 1

       .jsr @DVID3B2                   ; JSR DVID3B2       ; Call DVID3B2 to calculate:
                                                           ; 
                                                           ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
                                                           ; = (0 96 0) / z
                                                           ; = 24576 / z
                                                           ; 
                                                           ; so K now contains the planet/sun's radius, reduced by
                                                           ; the actual distance to the planet/sun. We know that
                                                           ; K+3 and K+2 will be 0, as the number we are dividing,
                                                           ; (0 96 0), fits into the two bottom bytes, so the
                                                           ; result is actually in K(1 0)

       movb @K+1,ra                    ; LDA K+1           ; If the high byte of the reduced radius is zero, jump
       jeq  PL82                       ; BEQ PL82          ; to PL82, as K contains the radius on its own

       li   ra,>f8*256                 ; LDA #248          ; Otherwise set K = 248, to round up the radius in
       movb ra,@K                      ; STA K             ; K(1 0) to the nearest integer (if we consider the low
                                                           ; byte to be the fractional part)

PL82:
       movb @TYPE,ra                   ; LDA TYPE          ; If the planet/sun's type has bit 0 clear, then it's
       srl  ra,1                       ; LSR A             ; either 128 or 130, which is a planet (the sun has type
       jnc  PL9                        ; BCC PL9           ; 129, which has bit 0 set). So jump to PL9 to draw the
                                                           ; planet with radius K, returning from the subroutine
                                                           ; using a tail call

       b    @SUN                       ; JMP SUN           ; Otherwise jump to SUN to draw the sun with radius K,
                                                           ; returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: PL9 (Part 1 of 3)
* Type: Subroutine
* Category: Drawing planets
* Summary: Draw the planet, with either an equator and meridian, or a crater
* 
* ------------------------------------------------------------------------------
* 
* Draw the planet with radius K at pixel coordinate (K3, K4), and with either an
* equator and meridian, or a crater.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K(1 0)              The planet's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the planet
* 
* K4(1 0)             Pixel y-coordinate of the centre of the planet
* 
* INWK                The planet's ship data block
* 
* ******************************************************************************

PL9:
       .jsr @WPLS2                     ; JSR WPLS2         ; Call WPLS2 to remove the planet from the screen

       .jsr @CIRCLE                    ; JSR CIRCLE        ; Call CIRCLE to draw the planet's new circle

       joc  PL20                       ; BCS PL20          ; If the call to CIRCLE returned with the C flag set,
                                                           ; then the circle does not fit on-screen, so jump to
                                                           ; PL20 to return from the subroutine

       movb @K+1,ra                    ; LDA K+1           ; If K+1 is zero, jump to PL25 as K(1 0) < 256, so the
       jeq  PL25                       ; BEQ PL25          ; planet fits on the screen and we can draw meridians or
                                                           ; craters

PL20:
       .rts                            ; RTS               ; The planet doesn't fit on-screen, so return from the
                                                           ; subroutine

PL25:
       movb @TYPE,ra                   ; LDA TYPE          ; If the planet type is 128 then it has an equator and
       ci   ra,>80*256                 ; CMP #128          ; a meridian, so this jumps to PL26 if this is not a
       jne  PL26                       ; BNE PL26          ; planet with an equator - in other words, if it is a
                                                           ; planet with a crater

                                                           ; Otherwise this is a planet with an equator and
                                                           ; meridian, so fall through into the following to draw
                                                           ; them

* ******************************************************************************
* 
* Name: PL9 (Part 2 of 3)
* Type: Subroutine
* Category: Drawing planets
* Summary: Draw the planet's equator and meridian
* Deep dive: Drawing meridians and equators
* 
* ------------------------------------------------------------------------------
* 
* Draw the planet's equator and meridian.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K(1 0)              The planet's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the planet
* 
* K4(1 0)             Pixel y-coordinate of the centre of the planet
* 
* INWK                The planet's ship data block
* 
* ******************************************************************************

       movb @K,ra                      ; LDA K             ; If the planet's radius is less than 6, the planet is
       ci   ra,>06*256                 ; CMP #6            ; too small to show a meridian, so jump to PL20 to
       jnc  PL20                       ; BCC PL20          ; return from the subroutine

       movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@P                      ; STA P             

       movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi

       .jsr @PLS4                      ; JSR PLS4          ; Call PLS4 to calculate the following:
                                                           ; 
                                                           ; CNT2 = arctan(P / A) / 4
                                                           ; = arctan(-nosev_z_hi / roofv_z_hi) / 4
                                                           ; 
                                                           ; and do the following if nosev_z_hi >= 0:
                                                           ; 
                                                           ; CNT2 = CNT2 + PI

       li   rx,>09*256                 ; LDX #9            ; Set X to 9 so the call to PLS1 divides nosev_x

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
       movb ra,@K2                     ; STA K2            ; 
       movb ry,@XX16                   ; STY XX16          ; (XX16 K2) = nosev_x / z
                                                           ; 
                                                           ; and increment X to point to nosev_y for the next call

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
       movb ra,@K2+1                   ; STA K2+1          ; 
       movb ry,@XX16+1                 ; STY XX16+1        ; (XX16+1 K2+1) = nosev_y / z

       li   rx,>0f*256                 ; LDX #15           ; Set X to 15 so the call to PLS5 divides roofv_x

       .jsr @PLS5                      ; JSR PLS5          ; Call PLS5 to calculate the following:
                                                           ; 
                                                           ; (XX16+2 K2+2) = roofv_x / z
                                                           ; 
                                                           ; (XX16+3 K2+3) = roofv_y / z

       .jsr @PLS2                      ; JSR PLS2          ; Call PLS2 to draw the first meridian

       movb @INWK+14,ra                ; LDA INWK+14       ; Set P = -nosev_z_hi
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@P                      ; STA P             

       movb @INWK+26,ra                ; LDA INWK+26       ; Set A = sidev_z_hi, so the second meridian will be at
                                                           ; 90 degrees to the first

       .jsr @PLS4                      ; JSR PLS4          ; Call PLS4 to calculate the following:
                                                           ; 
                                                           ; CNT2 = arctan(P / A) / 4
                                                           ; = arctan(-nosev_z_hi / sidev_z_hi) / 4
                                                           ; 
                                                           ; and do the following if nosev_z_hi >= 0:
                                                           ; 
                                                           ; CNT2 = CNT2 + PI

       li   rx,>15*256                 ; LDX #21           ; Set X to 21 so the call to PLS5 divides sidev_x

       .jsr @PLS5                      ; JSR PLS5          ; Call PLS5 to calculate the following:
                                                           ; 
                                                           ; (XX16+2 K2+2) = sidev_x / z
                                                           ; 
                                                           ; (XX16+3 K2+3) = sidev_y / z

       b    @PLS2                      ; JMP PLS2          ; Jump to PLS2 to draw the second meridian, returning
                                                           ; from the subroutine using a tail call

* ******************************************************************************
* 
* Name: PL9 (Part 3 of 3)
* Type: Subroutine
* Category: Drawing planets
* Summary: Draw the planet's crater
* Deep dive: Drawing craters
* 
* ------------------------------------------------------------------------------
* 
* Draw the planet's crater.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K(1 0)              The planet's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the planet
* 
* K4(1 0)             Pixel y-coordinate of the centre of the planet
* 
* INWK                The planet's ship data block
* 
* ******************************************************************************

PL26:
       movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z_hi

       jlt  PL20                       ; BMI PL20          ; If A is negative, the crater is on the far side of the
                                                           ; planet, so return from the subroutine (as PL2
                                                           ; contains an RTS)

       li   rx,>0f*256                 ; LDX #15           ; Set X = 15, so the following call to PLS3 operates on
                                                           ; roofv

       .jsr @PLS3                      ; JSR PLS3          ; Call PLS3 to calculate:
                                                           ; 
                                                           ; (Y A P) = 222 * roofv_x / z
                                                           ; 
                                                           ; to give the x-coordinate of the crater offset and
                                                           ; increment X to point to roofv_y for the next call

       .clc                            ; CLC               ; Calculate:
       .adc @K3,ra                     ; ADC K3            ; 
       movb ra,@K3                     ; STA K3            ; K3(1 0) = (Y A) + K3(1 0)
                                                           ; = 222 * roofv_x / z + x-coordinate of planet
                                                           ; centre
                                                           ; 
                                                           ; starting with the high bytes

       movb ry,ra                      ; TYA               ; And then doing the low bytes, so now K3(1 0) contains
       .adc @K3+1,ra                   ; ADC K3+1          ; the x-coordinate of the crater offset plus the planet
       movb ra,@K3+1                   ; STA K3+1          ; centre to give the x-coordinate of the crater's centre

       .jsr @PLS3                      ; JSR PLS3          ; Call PLS3 to calculate:
                                                           ; 
                                                           ; (Y A P) = 222 * roofv_y / z
                                                           ; 
                                                           ; to give the y-coordinate of the crater offset

       movb ra,@P                      ; STA P             ; Calculate:
       movb @K4,ra                     ; LDA K4            ; 
       .sec                            ; SEC               ; K4(1 0) = K4(1 0) - (Y A)
       .sbc @P,ra                      ; SBC P             ; = 222 * roofv_y / z - y-coordinate of planet
       movb ra,@K4                     ; STA K4            ; centre
                                                           ; 
                                                           ; starting with the low bytes

       movb ry,@P                      ; STY P             ; And then doing the low bytes, so now K4(1 0) contains
       movb @K4+1,ra                   ; LDA K4+1          ; the y-coordinate of the crater offset plus the planet
       .sbc @P,ra                      ; SBC P             ; centre to give the y-coordinate of the crater's centre
       movb ra,@K4+1                   ; STA K4+1          

       li   rx,>09*256                 ; LDX #9            ; Set X = 9, so the following call to PLS1 operates on
                                                           ; nosev

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
                                                           ; 
                                                           ; (Y A) = nosev_x / z
                                                           ; 
                                                           ; and increment X to point to nosev_y for the next call

       srl  ra,1                       ; LSR A             ; Set (XX16 K2) = (Y A) / 2
       movb ra,@K2                     ; STA K2            
       movb ry,@XX16                   ; STY XX16          

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
                                                           ; 
                                                           ; (Y A) = nosev_y / z
                                                           ; 
                                                           ; and increment X to point to nosev_z for the next call

       srl  ra,1                       ; LSR A             ; Set (XX16+1 K2+1) = (Y A) / 2
       movb ra,@K2+1                   ; STA K2+1          
       movb ry,@XX16+1                 ; STY XX16+1        

       li   rx,>15*256                 ; LDX #21           ; Set X = 21, so the following call to PLS1 operates on
                                                           ; sidev

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
                                                           ; 
                                                           ; (Y A) = sidev_x / z
                                                           ; 
                                                           ; and increment X to point to sidev_y for the next call

       srl  ra,1                       ; LSR A             ; Set (XX16+2 K2+2) = (Y A) / 2
       movb ra,@K2+2                   ; STA K2+2          
       movb ry,@XX16+2                 ; STY XX16+2        

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
                                                           ; 
                                                           ; (Y A) = sidev_y / z
                                                           ; 
                                                           ; and increment X to point to sidev_z for the next call

       srl  ra,1                       ; LSR A             ; Set (XX16+3 K2+3) = (Y A) / 2
       movb ra,@K2+3                   ; STA K2+3          
       movb ry,@XX16+3                 ; STY XX16+3        

       li   ra,>40*256                 ; LDA #64           ; Set TGT = 64, so we draw a full ellipse in the call to
       movb ra,@TGT                    ; STA TGT           ; PLS22 below

       li   ra,>00*256                 ; LDA #0            ; Set CNT2 = 0 as we are drawing a full ellipse, so we
       movb ra,@CNT2                   ; STA CNT2          ; don't need to apply an offset

       b    @PLS22                     ; JMP PLS22         ; Jump to PLS22 to draw the crater, returning from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: PLS1
* Type: Subroutine
* Category: Drawing planets
* Summary: Calculate (Y A) = nosev_x / z
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following division of a specified value from one of the
* orientation vectors (in this example, nosev_x):
* 
* (Y A) = nosev_x / z
* 
* where z is the z-coordinate of the planet from INWK. The result is an 8-bit
* magnitude in A, with maximum value 254, and just a sign bit (bit 7) in Y.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   Determines which of the INWK orientation vectors to
* divide:
* 
* * X = 9, 11, 13: divides nosev_x, nosev_y, nosev_z
* 
* * X = 15, 17, 19: divides roofv_x, roofv_y, roofv_z
* 
* * X = 21, 23, 25: divides sidev_x, sidev_y, sidev_z
* 
* INWK                The planet's ship data block
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The result as an 8-bit magnitude with maximum value 254
* 
* Y                   The sign of the result in bit 7
* 
* K+3                 Also the sign of the result in bit 7
* 
* X                   X gets incremented by 2 so it points to the next
* coordinate in this orientation vector (so consecutive
* calls to the routine will start with x, then move onto y
* and then z)
* 
* ******************************************************************************

PLS1:
       movb @INWK(rx),ra               ; LDA INWK,X        ; Set P = nosev_x_lo
       movb ra,@P                      ; STA P             

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set P+1 = |nosev_x_hi|
       andi ra,>7f*256                 ; AND #%01111111    
       movb ra,@P+1                    ; STA P+1           

       movb @INWK+1(rx),ra             ; LDA INWK+1,X      ; Set A = sign bit of nosev_x_lo
       andi ra,>80*256                 ; AND #%10000000    

       .jsr @DVID3B2                   ; JSR DVID3B2       ; Call DVID3B2 to calculate:
                                                           ; 
                                                           ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)

       movb @K,ra                      ; LDA K             ; Fetch the lowest byte of the result into A

       movb @K+1,ry                    ; LDY K+1           ; Fetch the second byte of the result into Y

       jeq  B76                        ; BEQ B76           ; If the second byte is 0, skip the next instruction

       li   ra,>fe*256                 ; LDA #254          ; The second byte is non-zero, so the result won't fit
                                                           ; into one byte, so set A = 254 as our maximum one-byte
                                                           ; value to return

B76:
       movb @K+3,ry                    ; LDY K+3           ; Fetch the sign of the result from K+3 into Y

       ab   rone,rx                    ; INX               ; Add 2 to X so the index points to the next coordinate
       ab   rone,rx                    ; INX               ; in this orientation vector (so consecutive calls to
                                                           ; the routine will start with x, then move onto y and z)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PLS2
* Type: Subroutine
* Category: Drawing planets
* Summary: Draw a half-ellipse
* Deep dive: Drawing ellipses
* Drawing meridians and equators
* 
* ------------------------------------------------------------------------------
* 
* Draw a half-ellipse, used for the planet's equator and meridian.
* 
* ******************************************************************************

PLS2:
       li   ra,>1f*256                 ; LDA #31           ; Set TGT = 31, so we only draw half an ellipse
       movb ra,@TGT                    ; STA TGT           

                                                           ; Fall through into PLS22 to draw the half-ellipse

* ******************************************************************************
* 
* Name: PLS22
* Type: Subroutine
* Category: Drawing planets
* Summary: Draw an ellipse or half-ellipse
* Deep dive: Drawing ellipses
* Drawing meridians and equators
* Drawing craters
* 
* ------------------------------------------------------------------------------
* 
* Draw an ellipse or half-ellipse, to be used for the planet's equator and
* meridian (in which case we draw half an ellipse), or crater (in which case we
* draw a full ellipse).
* 
* The ellipse is defined by a centre point, plus two conjugate radius vectors,
* u and v, where:
* 
* u = [ u_x ]       v = [ v_x ]
* [ u_y ]           [ v_y ]
* 
* The individual components of these 2D vectors (i.e. u_x, u_y etc.) are 16-bit
* sign-magnitude numbers, where the high bytes contain only the sign bit (in
* bit 7), with bits 0 to 6 being clear. This means that as we store u_x as
* (XX16 K2), for example, we know that |u_x| = K2.
* 
* This routine calls BLINE to draw each line segment in the ellipse, passing the
* coordinates as follows:
* 
* K6(1 0) = K3(1 0) + u_x * cos(CNT2) + v_x * sin(CNT2)
* 
* K6(3 2) = K4(1 0) - u_y * cos(CNT2) - v_y * sin(CNT2)
* 
* The y-coordinates are negated because BLINE expects pixel coordinates but the
* u and v vectors are extracted from the orientation vector. The y-axis runs
* in the opposite direction in 3D space to that on the screen, so we need to
* negate the 3D space coordinates before we can combine them with the ellipse's
* centre coordinates.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K(1 0)              The planet's radius
* 
* K3(1 0)             The pixel x-coordinate of the centre of the ellipse
* 
* K4(1 0)             The pixel y-coordinate of the centre of the ellipse
* 
* (XX16 K2)           The x-component of u (i.e. u_x), where XX16 contains
* just the sign of the sign-magnitude number
* 
* (XX16+1 K2+1)       The y-component of u (i.e. u_y), where XX16+1 contains
* just the sign of the sign-magnitude number
* 
* (XX16+2 K2+2)       The x-component of v (i.e. v_x), where XX16+2 contains
* just the sign of the sign-magnitude number
* 
* (XX16+3 K2+3)       The y-component of v (i.e. v_y), where XX16+3 contains
* just the sign of the sign-magnitude number
* 
* TGT                 The number of segments to draw:
* 
* * 32 for a half ellipse (a meridian)
* 
* * 64 for a full ellipse (a crater)
* 
* CNT2                The starting segment for drawing the half-ellipse
* 
* ******************************************************************************

PLS22:
       li   rx,>00*256                 ; LDX #0            ; Set CNT = 0
       movb rx,@CNT                    ; STX CNT           

       sb   rone,rx                    ; DEX               ; Set FLAG = &FF to start a new line in the ball line
       movb rx,@FLAG                   ; STX FLAG          ; heap when calling BLIN below, so the crater or
                                                           ; meridian is separate from any previous ellipses

PLL4:
       movb @CNT2,ra                   ; LDA CNT2          ; Set X = CNT2 mod 32
       andi ra,>1f*256                 ; AND #31           ; 
       movb ra,rx                      ; TAX               ; So X is the starting segment, reduced to the range 0
                                                           ; to 32, so as there are 64 segments in the circle, this
                                                           ; reduces the starting angle to 0 to 180 degrees, so we
                                                           ; can use X as an index into the sine table (which only
                                                           ; contains values for segments 0 to 31)
                                                           ; 
                                                           ; Also, because CNT2 mod 32 is in the range 0 to 180
                                                           ; degrees, we know that sin(CNT2 mod 32) is always
                                                           ; positive, or to put it another way:
                                                           ; 
                                                           ; sin(CNT2 mod 32) = |sin(CNT2)|

       movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
       movb ra,@Q                      ; STA Q             ; = sin(CNT2 mod 32)
                                                           ; = |sin(CNT2)|

       movb @K2+2,ra                   ; LDA K2+2          ; Set A = K2+2
                                                           ; = |v_x|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set R = A * Q / 256
       movb ra,@R                      ; STA R             ; = |v_x| * |sin(CNT2)|

       movb @K2+3,ra                   ; LDA K2+3          ; Set A = K2+3
                                                           ; = |v_y|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set K = A * Q / 256
       movb ra,@K                      ; STA K             ; = |v_y| * |sin(CNT2)|

       movb @CNT2,rx                   ; LDX CNT2          ; If CNT2 >= 33 then this sets the C flag, otherwise
       ci   rx,>21*256                 ; CPX #33           ; it's clear, so this means that:
                                                           ; 
                                                           ; * C is clear if the segment starts in the first half
                                                           ; of the circle, 0 to 180 degrees
                                                           ; 
                                                           ; * C is set if the segment starts in the second half
                                                           ; of the circle, 180 to 360 degrees
                                                           ; 
                                                           ; In other words, the C flag contains the sign bit for
                                                           ; sin(CNT2), which is positive for 0 to 180 degrees
                                                           ; and negative for 180 to 360 degrees

       li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+5, so
       .rora                           ; ROR A             ; XX16+5 has the correct sign for sin(CNT2)
       movb ra,@XX16+5                 ; STA XX16+5        ; 
                                                           ; Because we set the following above:
                                                           ; 
                                                           ; K = |v_y| * |sin(CNT2)|
                                                           ; R = |v_x| * |sin(CNT2)|
                                                           ; 
                                                           ; we can add XX16+5 as the high byte to give us the
                                                           ; following:
                                                           ; 
                                                           ; (XX16+5 K) = |v_y| * sin(CNT2)
                                                           ; (XX16+5 R) = |v_x| * sin(CNT2)

       movb @CNT2,ra                   ; LDA CNT2          ; Set X = (CNT2 + 16) mod 32
       .clc                            ; CLC               ; 
       .adi (>10*256)                  ; ADC #16           ; So we can use X as a lookup index into the SNE table
       andi ra,>1f*256                 ; AND #31           ; to get the cosine (as there are 16 segments in a
       movb ra,rx                      ; TAX               ; quarter-circle)
                                                           ; 
                                                           ; Also, because the sine table only contains positive
                                                           ; values, we know that sin((CNT2 + 16) mod 32) will
                                                           ; always be positive, or to put it another way:
                                                           ; 
                                                           ; sin((CNT2 + 16) mod 32) = |cos(CNT2)|

       movb @SNE(rx),ra                ; LDA SNE,X         ; Set Q = sin(X)
       movb ra,@Q                      ; STA Q             ; = sin((CNT2 + 16) mod 32)
                                                           ; = |cos(CNT2)|

       movb @K2+1,ra                   ; LDA K2+1          ; Set A = K2+1
                                                           ; = |u_y|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set K+2 = A * Q / 256
       movb ra,@K+2                    ; STA K+2           ; = |u_y| * |cos(CNT2)|

       movb @K2,ra                     ; LDA K2            ; Set A = K2
                                                           ; = |u_x|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set P = A * Q / 256
       movb ra,@P                      ; STA P             ; = |u_x| * |cos(CNT2)|
                                                           ; 
                                                           ; The call to FMLTU also sets the C flag, so in the
                                                           ; following, ADC #15 adds 16 rather than 15

       movb @CNT2,ra                   ; LDA CNT2          ; If (CNT2 + 16) mod 64 >= 33 then this sets the C flag,
       .adi (>0f*256)                  ; ADC #15           ; otherwise it's clear, so this means that:
       andi ra,>3f*256                 ; AND #63           ; 
       ci   ra,>21*256                 ; CMP #33           ; * C is clear if the segment starts in the first or
                                                           ; last quarter of the circle, 0 to 90 degrees or 270
                                                           ; to 360 degrees
                                                           ; 
                                                           ; * C is set if the segment starts in the second or
                                                           ; third quarter of the circle, 90 to 270 degrees
                                                           ; 
                                                           ; In other words, the C flag contains the sign bit for
                                                           ; cos(CNT2), which is positive for 0 to 90 degrees or
                                                           ; 270 to 360 degrees, and negative for 90 to 270 degrees

       li   ra,>00*256                 ; LDA #0            ; Shift the C flag into the sign bit of XX16+4, so:
       .rora                           ; ROR A             ; XX16+4 has the correct sign for cos(CNT2)
       movb ra,@XX16+4                 ; STA XX16+4        ; 
                                                           ; Because we set the following above:
                                                           ; 
                                                           ; K+2 = |u_y| * |cos(CNT2)|
                                                           ; P   = |u_x| * |cos(CNT2)|
                                                           ; 
                                                           ; we can add XX16+4 as the high byte to give us the
                                                           ; following:
                                                           ; 
                                                           ; (XX16+4 K+2) = |u_y| * cos(CNT2)
                                                           ; (XX16+4 P)   = |u_x| * cos(CNT2)

       movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+2 * XX16+5
       .eor @XX16+2                    ; EOR XX16+2        ; = the sign of v_x * XX16+5
       movb ra,@S                      ; STA S             ; 
                                                           ; So because we set this above:
                                                           ; 
                                                           ; (XX16+5 R) = |v_x| * sin(CNT2)
                                                           ; 
                                                           ; we now have this:
                                                           ; 
                                                           ; (S R) = v_x * sin(CNT2)

       movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16 * XX16+4
       .eor @XX16                      ; EOR XX16          ; = the sign of u_x * XX16+4
                                                           ; 
                                                           ; So because we set this above:
                                                           ; 
                                                           ; (XX16+4 P)   = |u_x| * cos(CNT2)
                                                           ; 
                                                           ; we now have this:
                                                           ; 
                                                           ; (A P) = u_x * cos(CNT2)

       .jsr @ADD                       ; JSR ADD           ; Set (A X) = (A P) + (S R)
                                                           ; = u_x * cos(CNT2) + v_x * sin(CNT2)

       movb ra,@T                      ; STA T             ; Store the high byte in T, so the result is now:
                                                           ; 
                                                           ; (T X) = u_x * cos(CNT2) + v_x * sin(CNT2)

       jgt  PL42                       ; BPL PL42          ; If the result is positive, jump down to PL42

       movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
       .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
       .clc                            ; CLC               ; byte in X
       .adi (>01*256)                  ; ADC #1            
       movb ra,rx                      ; TAX               

       movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
       .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
       .adi (>00*256)                  ; ADC #0            
       movb ra,@T                      ; STA T             

PL42:
       movb rx,ra                      ; TXA               ; Set K6(1 0) = K3(1 0) + (T X)
       .adc @K3,ra                     ; ADC K3            ; 
       movb ra,@K6                     ; STA K6            ; starting with the low bytes

       movb @T,ra                      ; LDA T             ; And then doing the high bytes, so we now get:
       .adc @K3+1,ra                   ; ADC K3+1          ; 
       movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K3(1 0) + (T X)
                                                           ; = K3(1 0) + u_x * cos(CNT2)
                                                           ; + v_x * sin(CNT2)
                                                           ; 
                                                           ; K3(1 0) is the x-coordinate of the centre of the
                                                           ; ellipse, so we now have the correct x-coordinate for
                                                           ; our ellipse segment that we can pass to BLINE below

       movb @K,ra                      ; LDA K             ; Set R = K = |v_y| * sin(CNT2)
       movb ra,@R                      ; STA R             

       movb @XX16+5,ra                 ; LDA XX16+5        ; Set S = the sign of XX16+3 * XX16+5
       .eor @XX16+3                    ; EOR XX16+3        ; = the sign of v_y * XX16+5
       movb ra,@S                      ; STA S             ; 
                                                           ; So because we set this above:
                                                           ; 
                                                           ; (XX16+5 K) = |v_y| * sin(CNT2)
                                                           ; 
                                                           ; and we just set R = K, we now have this:
                                                           ; 
                                                           ; (S R) = v_y * sin(CNT2)

       movb @K+2,ra                    ; LDA K+2           ; Set P = K+2 = |u_y| * cos(CNT2)
       movb ra,@P                      ; STA P             

       movb @XX16+4,ra                 ; LDA XX16+4        ; Set A = the sign of XX16+1 * XX16+4
       .eor @XX16+1                    ; EOR XX16+1        ; = the sign of u_y * XX16+4
                                                           ; 
                                                           ; So because we set this above:
                                                           ; 
                                                           ; (XX16+4 K+2) = |u_y| * cos(CNT2)
                                                           ; 
                                                           ; and we just set P = K+2, we now have this:
                                                           ; 
                                                           ; (A P) = u_y * cos(CNT2)

       .jsr @ADD                       ; JSR ADD           ; Set (A X) = (A P) + (S R)
                                                           ; =  u_y * cos(CNT2) + v_y * sin(CNT2)

       .eoi (>80*256)                  ; EOR #%10000000    ; Store the negated high byte in T, so the result is
       movb ra,@T                      ; STA T             ; now:
                                                           ; 
                                                           ; (T X) = - u_y * cos(CNT2) - v_y * sin(CNT2)
                                                           ; 
                                                           ; This negation is necessary because BLINE expects us
                                                           ; to pass pixel coordinates, where y-coordinates get
                                                           ; larger as we go down the screen; u_y and v_y, on the
                                                           ; other hand, are extracted from the orientation
                                                           ; vectors, where y-coordinates get larger as we go up
                                                           ; in space, so to rectify this we need to negate the
                                                           ; result in (T X) before we can add it to the
                                                           ; y-coordinate of the ellipse's centre in BLINE

       jgt  PL43                       ; BPL PL43          ; If the result is positive, jump down to PL43

       movb rx,ra                      ; TXA               ; The result is negative, so we need to negate the
       .eoi (>ff*256)                  ; EOR #%11111111    ; magnitude using two's complement, first doing the low
       .clc                            ; CLC               ; byte in X
       .adi (>01*256)                  ; ADC #1            
       movb ra,rx                      ; TAX               

       movb @T,ra                      ; LDA T             ; And then the high byte in T, making sure to leave the
       .eoi (>7f*256)                  ; EOR #%01111111    ; sign bit alone
       .adi (>00*256)                  ; ADC #0            
       movb ra,@T                      ; STA T             

PL43:
                                                           ; We now call BLINE to draw the ellipse line segment
                                                           ; 
                                                           ; The first few instructions of BLINE do the following:
                                                           ; 
                                                           ; K6(3 2) = K4(1 0) + (T X)
                                                           ; 
                                                           ; which gives:
                                                           ; 
                                                           ; K6(3 2) = K4(1 0) - u_y * cos(CNT2)
                                                           ; - v_y * sin(CNT2)
                                                           ; 
                                                           ; K4(1 0) is the pixel y-coordinate of the centre of the
                                                           ; ellipse, so this gives us the correct y-coordinate for
                                                           ; our ellipse segment (we already calculated the
                                                           ; x-coordinate in K3(1 0) above)
       .jsr @BLINE                     ; JSR BLINE         ; Call BLINE to draw this segment, which also returns
                                                           ; the updated value of CNT in A

       cb   @TGT,ra                    ; CMP TGT           ; If CNT > TGT then jump to PL40 to stop drawing the
       jeq  B77                        ; BEQ B77           ; ellipse (which is how we draw half-ellipses)
       joc  PL40                       ; BCS PL40          

B77:
       movb @CNT2,ra                   ; LDA CNT2          ; Set CNT2 = (CNT2 + STP) mod 64
       .clc                            ; CLC               
       .adc @STP,ra                    ; ADC STP           
       andi ra,>3f*256                 ; AND #63           
       movb ra,@CNT2                   ; STA CNT2          

       b    @PLL4                      ; JMP PLL4          ; Jump back to PLL4 to draw the next segment

PL40:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SUN (Part 1 of 4)
* Type: Subroutine
* Category: Drawing suns
* Summary: Draw the sun: Set up all the variables needed to draw the sun
* Deep dive: Drawing the sun
* 
* ------------------------------------------------------------------------------
* 
* Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
* sun if there is one. This routine is used to draw the sun, as well as the
* star systems on the Short-range Chart.
* 
* The first part sets up all the variables needed to draw the new sun.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K                   The new sun's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the new sun
* 
* K4(1 0)             Pixel y-coordinate of the centre of the new sun
* 
* SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
* sun (the one currently on-screen)
* 
* ******************************************************************************

       b    @WPLS                      ; JMP WPLS          ; Jump to WPLS to remove the old sun from the screen. We
                                                           ; only get here via the BCS just after the SUN entry
                                                           ; point below, when there is no new sun to draw

PLF3:
                                                           ; This is called from below to negate X and set A to
                                                           ; &FF, for when the new sun's centre is off the bottom
                                                           ; of the screen (so we don't need to draw its bottom
                                                           ; half)
                                                           ; 
                                                           ; This happens when the y-coordinate of the centre of
                                                           ; the sun is bigger than the y-coordinate of the bottom
                                                           ; of the space view
       movb rx,ra                      ; TXA               ; Negate X using two's complement, so X = ~X + 1
       .eoi (>ff*256)                  ; EOR #%11111111    
       .clc                            ; CLC               
       .adi (>01*256)                  ; ADC #1            
       movb ra,rx                      ; TAX               

PLF17:
                                                           ; This is called from below to set A to &FF, for when
                                                           ; the new sun's centre is right on the bottom of the
                                                           ; screen (so we don't need to draw its bottom half)
       li   ra,>ff*256                 ; LDA #&FF          ; Set A = &FF

       b    @PLF5                      ; JMP PLF5          ; Jump to PLF5

SUN:
       li   ra,>01*256                 ; LDA #1            ; Set LSX = 1 to indicate the sun line heap is about to
       movb ra,@LSX                    ; STA LSX           ; be filled up

       .jsr @CHKON                     ; JSR CHKON         ; Call CHKON to check whether any part of the new sun's
                                                           ; circle appears on-screen, and if it does, set P(2 1)
                                                           ; to the maximum y-coordinate of the new sun on-screen

       joc  PLF3-3                     ; BCS PLF3-3        ; If CHKON set the C flag then the new sun's circle does
                                                           ; not appear on-screen, so jump to WPLS (via the JMP at
                                                           ; the top of this routine) to remove the sun from the
                                                           ; screen, returning from the subroutine using a tail
                                                           ; call

       li   ra,>00*256                 ; LDA #0            ; Set A = 0

       movb @K,rx                      ; LDX K             ; Set X = K = radius of the new sun

       ci   rx,>60*256                 ; CPX #96           ; If X >= 96, set the C flag and rotate it into bit 0
       .rola                           ; ROL A             ; of A, otherwise rotate a 0 into bit 0

       ci   rx,>28*256                 ; CPX #40           ; If X >= 40, set the C flag and rotate it into bit 0
       .rola                           ; ROL A             ; of A, otherwise rotate a 0 into bit 0

       ci   rx,>10*256                 ; CPX #16           ; If X >= 16, set the C flag and rotate it into bit 0
       .rola                           ; ROL A             ; of A, otherwise rotate a 0 into bit 0

                                                           ; By now, A contains the following:
                                                           ; 
                                                           ; * If radius is 96-255 then A = %111 = 7
                                                           ; 
                                                           ; * If radius is 40-95  then A = %11  = 3
                                                           ; 
                                                           ; * If radius is 16-39  then A = %1   = 1
                                                           ; 
                                                           ; * If radius is 0-15   then A = %0   = 0
                                                           ; 
                                                           ; The value of A determines the size of the new sun's
                                                           ; ragged fringes - the bigger the sun, the bigger the
                                                           ; fringes

PLF18:
       movb ra,@CNT                    ; STA CNT           ; Store the fringe size in CNT

                                                           ; We now calculate the highest pixel y-coordinate of the
                                                           ; new sun, given that P(2 1) contains the 16-bit maximum
                                                           ; y-coordinate of the new sun on-screen

       li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; #Y is the y-coordinate of the centre of the space
                                                           ; view, so this sets Y to the y-coordinate of the bottom
                                                           ; of the space view

       movb @P+2,rx                    ; LDX P+2           ; If P+2 is non-zero, the maximum y-coordinate is off
       jne  PLF2                       ; BNE PLF2          ; the bottom of the screen, so skip to PLF2 with A set
                                                           ; to the y-coordinate of the bottom of the space view

       cb   @P+1,ra                    ; CMP P+1           ; If A < P+1, the maximum y-coordinate is underneath the
       jnc  PLF2                       ; BCC PLF2          ; dashboard, so skip to PLF2 with A set to the
                                                           ; y-coordinate of the bottom of the space view

       movb @P+1,ra                    ; LDA P+1           ; Set A = P+1, the low byte of the maximum y-coordinate
                                                           ; of the sun on-screen

       jne  PLF2                       ; BNE PLF2          ; If A is non-zero, skip to PLF2 as it contains the
                                                           ; value we are after

       li   ra,>01*256                 ; LDA #1            ; Otherwise set A = 1, the top line of the screen

PLF2:
       movb ra,@TGT                    ; STA TGT           ; Set TGT to A, the maximum y-coordinate of the sun on
                                                           ; screen

                                                           ; We now calculate the number of lines we need to draw
                                                           ; and the direction in which we need to draw them, both
                                                           ; from the centre of the new sun

       li   ra,(2*Y-1)*256             ; LDA #2*Y-1        ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
       .sec                            ; SEC               ; 
       .sbc @K4,ra                     ; SBC K4            ; Starting with the low bytes
       movb ra,rx                      ; TAX               

       li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so (A X) now contains
       .sbc @K4+1,ra                   ; SBC K4+1          ; the number of lines between the centre of the sun and
                                                           ; the bottom of the screen. If it is positive then the
                                                           ; centre of the sun is above the bottom of the screen,
                                                           ; if it is negative then the centre of the sun is below
                                                           ; the bottom of the screen

       jlt  PLF3                       ; BMI PLF3          ; If A < 0, then this means the new sun's centre is off
                                                           ; the bottom of the screen, so jump up to PLF3 to negate
                                                           ; the height in X (so it becomes positive), set A to &FF
                                                           ; and jump down to PLF5

       jne  PLF4                       ; BNE PLF4          ; If A > 0, then the new sun's centre is at least a full
                                                           ; screen above the bottom of the space view, so jump
                                                           ; down to PLF4 to set X = radius and A = 0

       ab   rone,rx                    ; INX               ; Set the flags depending on the value of X
       sb   rone,rx                    ; DEX               

       jeq  PLF17                      ; BEQ PLF17         ; If X = 0 (we already know A = 0 by this point) then
                                                           ; jump up to PLF17 to set A to &FF before jumping down
                                                           ; to PLF5

       cb   @K,rx                      ; CPX K             ; If X < the radius in K, jump down to PLF5, so if
       jnc  PLF5                       ; BCC PLF5          ; X >= the radius in K, we set X = radius and A = 0

PLF4:
       movb @K,rx                      ; LDX K             ; Set X to the radius

       li   ra,>00*256                 ; LDA #0            ; Set A = 0

PLF5:
       movb rx,@V                      ; STX V             ; Store the height in V

       movb ra,@V+1                    ; STA V+1           ; Store the direction in V+1

       movb @K,ra                      ; LDA K             ; Set (A P) = K * K
       .jsr @SQUA2                     ; JSR SQUA2         

       movb ra,@K2+1                   ; STA K2+1          ; Set K2(1 0) = (A P) = K * K
       movb @P,ra                      ; LDA P             
       movb ra,@K2                     ; STA K2            

                                                           ; By the time we get here, the variables should be set
                                                           ; up as shown in the header for part 3 below

* ******************************************************************************
* 
* Name: SUN (Part 2 of 4)
* Type: Subroutine
* Category: Drawing suns
* Summary: Draw the sun: Start from the bottom of the screen and erase the
* old sun line by line
* Deep dive: Drawing the sun
* 
* ------------------------------------------------------------------------------
* 
* This part erases the old sun, starting at the bottom of the screen and working
* upwards until we reach the bottom of the new sun.
* 
* ******************************************************************************

       li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; Set Y = y-coordinate of the bottom of the screen,
                                                           ; which we use as a counter in the following routine to
                                                           ; redraw the old sun

       movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
       movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
       movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
       movb ra,@YY+1                   ; STA YY+1          

PLFL2:
       cb   @TGT,ry                    ; CPY TGT           ; If Y = TGT, we have reached the line where we will
       jeq  PLFL                       ; BEQ PLFL          ; start drawing the new sun, so there is no need to
                                                           ; keep erasing the old one, so jump down to PLFL

       movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
                                                           ; gives us the half-width of the old sun's line on this
                                                           ; line of the screen

       jeq  PLF13                      ; BEQ PLF13         ; If A = 0, skip the following call to HLOIN2 as there
                                                           ; is no sun line on this line of the screen

       .jsr @HLOIN2                    ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
                                                           ; with centre point YY(1 0) and half-width A, and remove
                                                           ; the line from the sun line heap once done

PLF13:
       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jne  PLFL2                      ; BNE PLFL2         ; Loop back for the next line in the line heap until
                                                           ; we have either gone through the entire heap, or
                                                           ; reached the bottom row of the new sun

* ******************************************************************************
* 
* Name: SUN (Part 3 of 4)
* Type: Subroutine
* Category: Drawing suns
* Summary: Draw the sun: Continue to move up the screen, drawing the new sun
* line by line
* Deep dive: Drawing the sun
* 
* ------------------------------------------------------------------------------
* 
* This part draws the new sun. By the time we get to this point, the following
* variables should have been set up by parts 1 and 2:
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* V                   As we draw lines for the new sun, V contains the
* vertical distance between the line we're drawing and the
* centre of the new sun. As we draw lines and move up the
* screen, we either decrement (bottom half) or increment
* (top half) this value. See the deep dive on "Drawing the
* sun" to see a diagram that shows V in action
* 
* V+1                 This determines which half of the new sun we are drawing
* as we work our way up the screen, line by line:
* 
* * 0 means we are drawing the bottom half, so the lines
* get wider as we work our way up towards the centre,
* at which point we will move into the top half, and
* V+1 will switch to &FF
* 
* * &FF means we are drawing the top half, so the lines
* get smaller as we work our way up, away from the
* centre
* 
* TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
* the screen y-coordinate of the bottom row of the new
* sun)
* 
* CNT                 The fringe size of the new sun
* 
* K2(1 0)             The new sun's radius squared, i.e. K^2
* 
* Y                   The y-coordinate of the bottom row of the new sun
* 
* ******************************************************************************

PLFL:
       movb @V,ra                      ; LDA V             ; Set (T P) = V * V
       .jsr @SQUA2                     ; JSR SQUA2         ; = V^2
       movb ra,@T                      ; STA T             

       movb @K2,ra                     ; LDA K2            ; Set (R Q) = K^2 - V^2
       .sec                            ; SEC               ; 
       .sbc @P,ra                      ; SBC P             ; First calculating the low bytes
       movb ra,@Q                      ; STA Q             

       movb @K2+1,ra                   ; LDA K2+1          ; And then doing the high bytes
       .sbc @T,ra                      ; SBC T             
       movb ra,@R                      ; STA R             

       movb ry,@Y1                     ; STY Y1            ; Store Y in Y1, so we can restore it after the call to
                                                           ; LL5

       .jsr @LL5                       ; JSR LL5           ; Set Q = SQRT(R Q)
                                                           ; = SQRT(K^2 - V^2)
                                                           ; 
                                                           ; So Q contains the half-width of the new sun's line at
                                                           ; height V from the sun's centre - in other words, it
                                                           ; contains the half-width of the sun's line on the
                                                           ; current pixel row Y

       movb @Y1,ry                     ; LDY Y1            ; Restore Y from Y1

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       .and @CNT                       ; AND CNT           ; Reduce A to a random number in the range 0 to CNT,
                                                           ; where CNT is the fringe size of the new sun

       .clc                            ; CLC               ; Set A = A + Q
       .adc @Q,ra                      ; ADC Q             ; 
                                                           ; So A now contains the half-width of the sun on row
                                                           ; V, plus a random variation based on the fringe size

       jnc  PLF44                      ; BCC PLF44         ; If the above addition did not overflow, skip the
                                                           ; following instruction

       li   ra,>ff*256                 ; LDA #255          ; The above overflowed, so set the value of A to 255

                                                           ; So A contains the half-width of the new sun on pixel
                                                           ; line Y, changed by a random amount within the size of
                                                           ; the sun's fringe

PLF44:
       movb @LSO(ry),rx                ; LDX LSO,Y         ; Set X to the line heap value for the old sun's line
                                                           ; at row Y

       movb ra,@LSO(ry)                ; STA LSO,Y         ; Store the half-width of the new row Y line in the line
                                                           ; heap

       jeq  PLF11                      ; BEQ PLF11         ; If X = 0 then there was no sun line on pixel row Y, so
                                                           ; jump to PLF11

       movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
       movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
       movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
       movb ra,@YY+1                   ; STA YY+1          

       movb rx,ra                      ; TXA               ; Transfer the line heap value for the old sun's line
                                                           ; from X into A

       .jsr @EDGES                     ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
                                                           ; line centred on YY(1 0) and with half-width A, i.e.
                                                           ; the line for the old sun

       movb @X1,ra                     ; LDA X1            ; Store X1 and X2, the ends of the line for the old sun,
       movb ra,@XX                     ; STA XX            ; in XX and XX+1
       movb @X2,ra                     ; LDA X2            
       movb ra,@XX+1                   ; STA XX+1          

       movb @K3,ra                     ; LDA K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
       movb ra,@YY                     ; STA YY            ; of the new sun
       movb @K3+1,ra                   ; LDA K3+1          
       movb ra,@YY+1                   ; STA YY+1          

       movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the half-width of the new row Y line from the
                                                           ; line heap (which we stored above)

       .jsr @EDGES                     ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
                                                           ; line centred on YY(1 0) and with half-width A, i.e.
                                                           ; the line for the new sun

       joc  PLF23                      ; BCS PLF23         ; If the C flag is set, the new line doesn't fit on the
                                                           ; screen, so jump to PLF23 to just draw the old line
                                                           ; without drawing the new one

                                                           ; At this point the old line is from XX to XX+1 and the
                                                           ; new line is from X1 to X2, and both fit on-screen. We
                                                           ; now want to remove the old line and draw the new one.
                                                           ; We could do this by simply drawing the old one then
                                                           ; drawing the new one, but instead Elite does this by
                                                           ; drawing first from X1 to XX and then from X2 to XX+1,
                                                           ; which you can see in action by looking at all the
                                                           ; permutations below of the four points on the line and
                                                           ; imagining what happens if you draw from X1 to XX and
                                                           ; X2 to XX+1 using EOR logic. The six possible
                                                           ; permutations are as follows, along with the result of
                                                           ; drawing X1 to XX and then X2 to XX+1:
                                                           ; 
                                                           ; X1    X2    XX____XX+1      ->      +__+  +  +
                                                           ; 
                                                           ; X1    XX____X2____XX+1      ->      +__+__+  +
                                                           ; 
                                                           ; X1    XX____XX+1  X2        ->      +__+__+__+
                                                           ; 
                                                           ; XX____X1____XX+1  X2        ->      +  +__+__+
                                                           ; 
                                                           ; XX____XX+1  X1    X2        ->      +  +  +__+
                                                           ; 
                                                           ; XX____X1____X2____XX+1      ->      +  +__+  +
                                                           ; 
                                                           ; They all end up with a line between X1 and X2, which
                                                           ; is what we want. There's probably a mathematical proof
                                                           ; of why this works somewhere, but the above is probably
                                                           ; easier to follow.
                                                           ; 
                                                           ; We can draw from X1 to XX and X2 to XX+1 by swapping
                                                           ; XX and X2 and drawing from X1 to X2, and then drawing
                                                           ; from XX to XX+1, so let's do this now

       movb @X2,ra                     ; LDA X2            ; Swap XX and X2
       movb @XX,rx                     ; LDX XX            
       movb rx,@X2                     ; STX X2            
       movb ra,@XX                     ; STA XX            

       .jsr @HLOIN                     ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)

PLF23:
                                                           ; If we jump here from the BCS above when there is no
                                                           ; new line this will just draw the old line
       movb @XX,ra                     ; LDA XX            ; Set X1 = XX
       movb ra,@X1                     ; STA X1            

       movb @XX+1,ra                   ; LDA XX+1          ; Set X2 = XX+1
       movb ra,@X2                     ; STA X2            

PLF16:
       .jsr @HLOIN                     ; JSR HLOIN         ; Draw a horizontal line from (X1, Y1) to (X2, Y1)

PLF6:
       sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
                                                           ; above

       jeq  PLF8                       ; BEQ PLF8          ; If we have reached the top of the screen, jump to PLF8
                                                           ; as we are done drawing (the top line of the screen is
                                                           ; the border, so we don't draw there)

       movb @V+1,ra                    ; LDA V+1           ; If V+1 is non-zero then we are doing the top half of
       jne  PLF10                      ; BNE PLF10         ; the new sun, so jump down to PLF10 to increment V and
                                                           ; decrease the width of the line we draw

       sb   rone,ra                    ; DEC V             ; Decrement V, the height of the sun that we use to work
                                                           ; out the width, so this makes the line get wider, as we
                                                           ; move up towards the sun's centre

       jne  PLFL                       ; BNE PLFL          ; If V is non-zero, jump back up to PLFL to do the next
                                                           ; screen line up

       sb   rone,ra                    ; DEC V+1           ; Otherwise V is 0 and we have reached the centre of the
                                                           ; sun, so decrement V+1 to -1 so we start incrementing V
                                                           ; each time, thus doing the top half of the new sun

PLFLS:
       b    @PLFL                      ; JMP PLFL          ; Jump back up to PLFL to do the next screen line up

PLF11:
                                                           ; If we get here then there is no old sun line on this
                                                           ; line, so we can just draw the new sun's line
       movb @K3,rx                     ; LDX K3            ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
       movb rx,@YY                     ; STX YY            ; of the new sun's line
       movb @K3+1,rx                   ; LDX K3+1          
       movb rx,@YY+1                   ; STX YY+1          

       .jsr @EDGES                     ; JSR EDGES         ; Call EDGES to calculate X1 and X2 for the horizontal
                                                           ; line centred on YY(1 0) and with half-width A, i.e.
                                                           ; the line for the new sun

       jnc  PLF16                      ; BCC PLF16         ; If the line is on-screen, jump up to PLF16 to draw the
                                                           ; line and loop round for the next line up

       li   ra,>00*256                 ; LDA #0            ; The line is not on-screen, so set the line heap for
       movb ra,@LSO(ry)                ; STA LSO,Y         ; line Y to 0, which means there is no sun line here

       jeq  PLF6                       ; BEQ PLF6          ; Jump up to PLF6 to loop round for the next line up
                                                           ; (this BEQ is effectively a JMP as A is always zero)

PLF10:
       movb @V,rx                      ; LDX V             ; Increment V, the height of the sun that we use to work
       ab   rone,rx                    ; INX               ; out the width, so this makes the line get narrower, as
       movb rx,@V                      ; STX V             ; we move up and away from the sun's centre

       cb   @K,rx                      ; CPX K             ; If V <= the radius of the sun, we still have lines to
       jnc  PLFLS                      ; BCC PLFLS         ; draw, so jump up to PLFL (via PLFLS) to do the next
       jeq  PLFLS                      ; BEQ PLFLS         ; screen line up

* ******************************************************************************
* 
* Name: SUN (Part 4 of 4)
* Type: Subroutine
* Category: Drawing suns
* Summary: Draw the sun: Continue to the top of the screen, erasing the old
* sun line by line
* Deep dive: Drawing the sun
* 
* ------------------------------------------------------------------------------
* 
* This part erases any remaining traces of the old sun, now that we have drawn
* all the way to the top of the new sun.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* RTS2                Contains an RTS
* 
* ******************************************************************************

       movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
       movb ra,@YY                     ; STA YY            ; vertical centre axis of the old sun that's currently
       movb @SUNX+1,ra                 ; LDA SUNX+1        ; on-screen
       movb ra,@YY+1                   ; STA YY+1          

PLFL3:
       movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
                                                           ; gives us the half-width of the old sun's line on this
                                                           ; line of the screen

       jeq  PLF9                       ; BEQ PLF9          ; If A = 0, skip the following call to HLOIN2 as there
                                                           ; is no sun line on this line of the screen

       .jsr @HLOIN2                    ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
                                                           ; with centre point YY(1 0) and half-width A, and remove
                                                           ; the line from the sun line heap once done

PLF9:
       sb   rone,ry                    ; DEY               ; Decrement the line number in Y to move to the line
                                                           ; above

       jne  PLFL3                      ; BNE PLFL3         ; Jump up to PLFL3 to redraw the next line up, until we
                                                           ; have reached the top of the screen

PLF8:
                                                           ; If we get here, we have successfully made it from the
                                                           ; bottom line of the screen to the top, and the old sun
                                                           ; has been replaced by the new one
       .clc                            ; CLC               ; Clear the C flag to indicate success in drawing the
                                                           ; sun

       movb @K3,ra                     ; LDA K3            ; Set SUNX(1 0) = K3(1 0)
       movb ra,@SUNX                   ; STA SUNX          
       movb @K3+1,ra                   ; LDA K3+1          
       movb ra,@SUNX+1                 ; STA SUNX+1        

RTS2:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: CIRCLE
* Type: Subroutine
* Category: Drawing circles
* Summary: Draw a circle for the planet
* Deep dive: Drawing circles
* 
* ------------------------------------------------------------------------------
* 
* Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
* planet's main outline.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K                   The planet's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the planet
* 
* K4(1 0)             Pixel y-coordinate of the centre of the planet
* 
* ******************************************************************************

CIRCLE:
       .jsr @CHKON                     ; JSR CHKON         ; Call CHKON to check whether the circle fits on-screen

       joc  RTS2                       ; BCS RTS2          ; If CHKON set the C flag then the circle does not fit
                                                           ; on-screen, so return from the subroutine (as RTS2
                                                           ; contains an RTS)

       li   ra,>00*256                 ; LDA #0            ; Set LSX2 = 0 to indicate that the ball line heap is
       movb ra,@LSX2                   ; STA LSX2          ; not empty, as we are about to fill it

       movb @K,rx                      ; LDX K             ; Set X = K = radius

       li   ra,>08*256                 ; LDA #8            ; Set A = 8

       ci   rx,>08*256                 ; CPX #8            ; If the radius < 8, skip to PL89
       jnc  PL89                       ; BCC PL89          

       srl  ra,1                       ; LSR A             ; Halve A so A = 4

       ci   rx,>3c*256                 ; CPX #60           ; If the radius < 60, skip to PL89
       jnc  PL89                       ; BCC PL89          

       srl  ra,1                       ; LSR A             ; Halve A so A = 2

PL89:
       movb ra,@STP                    ; STA STP           ; Set STP = A. STP is the step size for the circle, so
                                                           ; the above sets a smaller step size for bigger circles

                                                           ; Fall through into CIRCLE2 to draw the circle with the
                                                           ; correct step size

* ******************************************************************************
* 
* Name: CIRCLE2
* Type: Subroutine
* Category: Drawing circles
* Summary: Draw a circle (for the planet or chart)
* Deep dive: Drawing circles
* 
* ------------------------------------------------------------------------------
* 
* Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
* planet and the chart circles.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* STP                 The step size for the circle
* 
* K                   The circle's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the circle
* 
* K4(1 0)             Pixel y-coordinate of the centre of the circle
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              The C flag is cleared
* 
* ******************************************************************************

CIRCLE2:
       li   rx,>ff*256                 ; LDX #&FF          ; Set FLAG = &FF to reset the ball line heap in the call
       movb rx,@FLAG                   ; STX FLAG          ; to the BLINE routine below

       ab   rone,rx                    ; INX               ; Set CNT = 0, our counter that goes up to 64, counting
       movb rx,@CNT                    ; STX CNT           ; segments in our circle

PLL3:
       movb @CNT,ra                    ; LDA CNT           ; Set A = CNT

       .jsr @FMLTU2                    ; JSR FMLTU2        ; Call FMLTU2 to calculate:
                                                           ; 
                                                           ; A = K * sin(A)
                                                           ; = K * sin(CNT)

       li   rx,>00*256                 ; LDX #0            ; Set T = 0, so we have the following:
       movb rx,@T                      ; STX T             ; 
                                                           ; (T A) = K * sin(CNT)
                                                           ; 
                                                           ; which is the x-coordinate of the circle for this count

       movb @CNT,rx                    ; LDX CNT           ; If CNT < 33 then jump to PL37, as this is the right
       ci   rx,>21*256                 ; CPX #33           ; half of the circle and the sign of the x-coordinate is
       jnc  PL37                       ; BCC PL37          ; correct

       .eoi (>ff*256)                  ; EOR #%11111111    ; This is the left half of the circle, so we want to
       .adi (>00*256)                  ; ADC #0            ; flip the sign of the x-coordinate in (T A) using two's
       movb ra,rx                      ; TAX               ; complement, so we start with the low byte and store it
                                                           ; in X (the ADC adds 1 as we know the C flag is set)

       li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T
       .adi (>00*256)                  ; ADC #0            
       movb ra,@T                      ; STA T             

       movb rx,ra                      ; TXA               ; Finally, we restore the low byte from X, so we have
                                                           ; now negated the x-coordinate in (T A)

       .clc                            ; CLC               ; Clear the C flag so we can do some more addition below

PL37:
       .adc @K3,ra                     ; ADC K3            ; We now calculate the following:
       movb ra,@K6                     ; STA K6            ; 
                                                           ; K6(1 0) = (T A) + K3(1 0)
                                                           ; 
                                                           ; to add the coordinates of the centre to our circle
                                                           ; point, starting with the low bytes

       movb @K3+1,ra                   ; LDA K3+1          ; And then doing the high bytes, so we now have:
       .adc @T,ra                      ; ADC T             ; 
       movb ra,@K6+1                   ; STA K6+1          ; K6(1 0) = K * sin(CNT) + K3(1 0)
                                                           ; 
                                                           ; which is the result we want for the x-coordinate

       movb @CNT,ra                    ; LDA CNT           ; Set A = CNT + 16
       .clc                            ; CLC               
       .adi (>10*256)                  ; ADC #16           

       .jsr @FMLTU2                    ; JSR FMLTU2        ; Call FMLTU2 to calculate:
                                                           ; 
                                                           ; A = K * sin(A)
                                                           ; = K * sin(CNT + 16)
                                                           ; = K * cos(CNT)

       movb ra,rx                      ; TAX               ; Set X = A
                                                           ; = K * cos(CNT)

       li   ra,>00*256                 ; LDA #0            ; Set T = 0, so we have the following:
       movb ra,@T                      ; STA T             ; 
                                                           ; (T X) = K * cos(CNT)
                                                           ; 
                                                           ; which is the y-coordinate of the circle for this count

       movb @CNT,ra                    ; LDA CNT           ; Set A = (CNT + 15) mod 64
       .adi (>0f*256)                  ; ADC #15           
       andi ra,>3f*256                 ; AND #63           

       ci   ra,>21*256                 ; CMP #33           ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
       jnc  PL38                       ; BCC PL38          ; PL38, as this is the bottom half of the circle and the
                                                           ; sign of the y-coordinate is correct

       movb rx,ra                      ; TXA               ; This is the top half of the circle, so we want to
       .eoi (>ff*256)                  ; EOR #%11111111    ; flip the sign of the y-coordinate in (T X) using two's
       .adi (>00*256)                  ; ADC #0            ; complement, so we start with the low byte in X (the
       movb ra,rx                      ; TAX               ; ADC adds 1 as we know the C flag is set)

       li   ra,>ff*256                 ; LDA #&FF          ; And then we flip the high byte in T, so we have
       .adi (>00*256)                  ; ADC #0            ; now negated the y-coordinate in (T X)
       movb ra,@T                      ; STA T             

       .clc                            ; CLC               ; Clear the C flag so the addition at the start of BLINE
                                                           ; will work

PL38:
       .jsr @BLINE                     ; JSR BLINE         ; Call BLINE to draw this segment, which also increases
                                                           ; CNT by STP, the step size

       ci   ra,>41*256                 ; CMP #65           ; If CNT >= 65 then skip the next instruction
       joc  B78                        ; BCS B78           

       b    @PLL3                      ; JMP PLL3          ; Jump back for the next segment

B78:
       .clc                            ; CLC               ; Clear the C flag to indicate success

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: WPLS2
* Type: Subroutine
* Category: Drawing planets
* Summary: Remove the planet from the screen
* Deep dive: The ball line heap
* 
* ------------------------------------------------------------------------------
* 
* We do this by redrawing it using the lines stored in the ball line heap when
* the planet was originally drawn by the BLINE routine.
* 
* ******************************************************************************

WPLS2:
       movb @LSX2,ry                   ; LDY LSX2          ; If LSX2 is non-zero (which indicates the ball line
       jne  WP1                        ; BNE WP1           ; heap is empty), jump to WP1 to reset the line heap
                                                           ; without redrawing the planet

                                                           ; Otherwise Y is now 0, so we can use it as a counter to
                                                           ; loop through the lines in the line heap, redrawing
                                                           ; each one to remove the planet from the screen, before
                                                           ; resetting the line heap once we are done

WPL1:
       cb   @LSP,ry                    ; CPY LSP           ; If Y >= LSP then we have reached the end of the line
       joc  WP1                        ; BCS WP1           ; heap and have finished redrawing the planet (as LSP
                                                           ; points to the end of the heap), so jump to WP1 to
                                                           ; reset the line heap, returning from the subroutine
                                                           ; using a tail call

       movb @LSY2(ry),ra               ; LDA LSY2,Y        ; Set A to the y-coordinate of the current heap entry

       ci   ra,>ff*256                 ; CMP #&FF          ; If the y-coordinate is &FF, this indicates that the
       jeq  WP2                        ; BEQ WP2           ; next point in the heap denotes the start of a line
                                                           ; segment, so jump to WP2 to put it into (X1, Y1)

       movb ra,@Y2                     ; STA Y2            ; Set (X2, Y2) to the x- and y-coordinates from the
       movb @LSX2(ry),ra               ; LDA LSX2,Y        ; heap
       movb ra,@X2                     ; STA X2            

       .jsr @LOIN                      ; JSR LOIN          ; Draw a line from (X1, Y1) to (X2, Y2)

       ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point

       movb @SWAP,ra                   ; LDA SWAP          ; If SWAP is non-zero then we swapped the coordinates
       jne  WPL1                       ; BNE WPL1          ; when filling the heap in BLINE, so loop back WPL1
                                                           ; for the next point in the heap

       movb @X2,ra                     ; LDA X2            ; Swap (X1, Y1) and (X2, Y2), so the next segment will
       movb ra,@X1                     ; STA X1            ; be drawn from the current (X2, Y2) to the next point
       movb @Y2,ra                     ; LDA Y2            ; in the heap
       movb ra,@Y1                     ; STA Y1            

       b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap

WP2:
       ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point

       movb @LSX2(ry),ra               ; LDA LSX2,Y        ; Set (X1, Y1) to the x- and y-coordinates from the
       movb ra,@X1                     ; STA X1            ; heap
       movb @LSY2(ry),ra               ; LDA LSY2,Y        
       movb ra,@Y1                     ; STA Y1            

       ab   rone,ry                    ; INY               ; Increment the loop counter to point to the next point

       b    @WPL1                      ; JMP WPL1          ; Loop back to WPL1 for the next point in the heap

* ******************************************************************************
* 
* Name: WP1
* Type: Subroutine
* Category: Drawing planets
* Summary: Reset the ball line heap
* 
* ******************************************************************************

WP1:
       li   ra,>01*256                 ; LDA #1            ; Set LSP = 1 to reset the ball line heap pointer
       movb ra,@LSP                    ; STA LSP           

       li   ra,>ff*256                 ; LDA #&FF          ; Set LSX2 = &FF to indicate the ball line heap is empty
       movb ra,@LSX2                   ; STA LSX2          

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: WPLS
* Type: Subroutine
* Category: Drawing suns
* Summary: Remove the sun from the screen
* Deep dive: Drawing the sun
* 
* ------------------------------------------------------------------------------
* 
* We do this by redrawing it using the lines stored in the sun line heap when
* the sun was originally drawn by the SUN routine.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* WPLS-1              Contains an RTS
* 
* ******************************************************************************

WPLS:
       movb @LSX,ra                    ; LDA LSX           ; If LSX < 0, the sun line heap is empty, so return from
       jlt  WPLS-1                     ; BMI WPLS-1        ; the subroutine (as WPLS-1 contains an RTS)

       movb @SUNX,ra                   ; LDA SUNX          ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
       movb ra,@YY                     ; STA YY            ; vertical centre axis of the sun that's currently on
       movb @SUNX+1,ra                 ; LDA SUNX+1        ; screen
       movb ra,@YY+1                   ; STA YY+1          

       li   ry,(2*Y-1)*256             ; LDY #2*Y-1        ; #Y is the y-coordinate of the centre of the space
                                                           ; view, so this sets Y as a counter for the number of
                                                           ; lines in the space view (i.e. 191), which is also the
                                                           ; number of lines in the LSO block

WPL2:
       movb @LSO(ry),ra                ; LDA LSO,Y         ; Fetch the Y-th point from the sun line heap, which
                                                           ; gives us the half-width of the sun's line on this line
                                                           ; of the screen

       jeq  B79                        ; BEQ B79           ; If A = 0, skip the following call to HLOIN2 as there
                                                           ; is no sun line on this line of the screen

       .jsr @HLOIN2                    ; JSR HLOIN2        ; Call HLOIN2 to draw a horizontal line on pixel line Y,
                                                           ; with centre point YY(1 0) and half-width A, and remove
                                                           ; the line from the sun line heap once done

B79:
       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jne  WPL2                       ; BNE WPL2          ; Loop back for the next line in the line heap until
                                                           ; we have gone through the entire heap

       sb   rone,ry                    ; DEY               ; This sets Y to &FF, as we end the loop with Y = 0

       movb ry,@LSX                    ; STY LSX           ; Set LSX to &FF to indicate the sun line heap is empty

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: EDGES
* Type: Subroutine
* Category: Drawing lines
* Summary: Draw a horizontal line given a centre and a half-width
* 
* ------------------------------------------------------------------------------
* 
* Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
* centre x-coordinate YY(1 0), and length A in either direction from the centre
* (so a total line length of 2 * A). In other words, this line:
* 
* X1             YY(1 0)             X2
* +-----------------+-----------------+
* <- A ->           <- A ->
* 
* The resulting line gets clipped to the edges of the screen, if needed. If the
* calculation doesn't overflow, we return with the C flag clear, otherwise the C
* flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The half-length of the line
* 
* YY(1 0)             The centre x-coordinate
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Clear if the line fits on-screen, set if it doesn't
* 
* X1, X2              The x-coordinates of the clipped line
* 
* LSO+Y               If the line doesn't fit, LSO+Y is set to 0
* 
* Y                   Y is preserved
* 
* ******************************************************************************

EDGES:
       movb ra,@T                      ; STA T             ; Set T to the line's half-length in argument A

       .clc                            ; CLC               ; We now calculate:
       .adc @YY,ra                     ; ADC YY            ; 
       movb ra,@X2                     ; STA X2            ; (A X2) = YY(1 0) + A
                                                           ; 
                                                           ; to set X2 to the x-coordinate of the right end of the
                                                           ; line, starting with the low bytes

       movb @YY+1,ra                   ; LDA YY+1          ; And then adding the high bytes
       .adi (>00*256)                  ; ADC #0            

       jlt  ED1                        ; BMI ED1           ; If the addition is negative then the calculation has
                                                           ; overflowed, so jump to ED1 to return a failure

       jeq  B80                        ; BEQ B80           ; If the high byte A from the result is 0, skip the
                                                           ; next two instructions, as the result already fits on
                                                           ; the screen

       li   ra,>fe*256                 ; LDA #254          ; The high byte is positive and non-zero, so we went
       movb ra,@X2                     ; STA X2            ; past the right edge of the screen, so clip X2 to the
                                                           ; x-coordinate of the right edge of the screen

B80:
       movb @YY,ra                     ; LDA YY            ; We now calculate:
       .sec                            ; SEC               ; 
       .sbc @T,ra                      ; SBC T             ; (A X1) = YY(1 0) - argument A
       movb ra,@X1                     ; STA X1            ; 
                                                           ; to set X1 to the x-coordinate of the left end of the
                                                           ; line, starting with the low bytes

       movb @YY+1,ra                   ; LDA YY+1          ; And then subtracting the high bytes
       .sbi (>00*256)                  ; SBC #0            

       jne  ED3                        ; BNE ED3           ; If the high byte subtraction is non-zero, then skip
                                                           ; to ED3

       .clc                            ; CLC               ; Otherwise the high byte of the subtraction was zero,
                                                           ; so the line fits on-screen and we clear the C flag to
                                                           ; indicate success

       .rts                            ; RTS               ; Return from the subroutine

ED3:
       jgt  ED1                        ; BPL ED1           ; If the addition is positive then the calculation has
                                                           ; underflowed, so jump to ED1 to return a failure

       li   ra,>02*256                 ; LDA #2            ; The high byte is negative and non-zero, so we went
       movb ra,@X1                     ; STA X1            ; past the left edge of the screen, so clip X1 to the
                                                           ; x-coordinate of the left edge of the screen

       .clc                            ; CLC               ; The line does fit on-screen, so clear the C flag to
                                                           ; indicate success

       .rts                            ; RTS               ; Return from the subroutine

ED1:
       li   ra,>00*256                 ; LDA #0            ; Set the Y-th byte of the LSO block to 0
       movb ra,@LSO(ry)                ; STA LSO,Y         

       .sec                            ; SEC               ; The line does not fit on the screen, so set the C flag
                                                           ; to indicate this result

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: CHKON
* Type: Subroutine
* Category: Drawing circles
* Summary: Check whether any part of a circle appears on the extended screen
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K                   The circle's radius
* 
* K3(1 0)             Pixel x-coordinate of the centre of the circle
* 
* K4(1 0)             Pixel y-coordinate of the centre of the circle
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Clear if any part of the circle appears on-screen, set
* if none of the circle appears on-screen
* 
* (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
* y-coordinate of the top edge of the circle)
* 
* P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
* y-coordinate of the bottom edge of the circle)
* 
* ******************************************************************************

CHKON:
       movb @K3,ra                     ; LDA K3            ; Set A = K3 + K
       .clc                            ; CLC               
       .adc @K,ra                      ; ADC K             

       movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 + 0 + any carry from above, so this
       .adi (>00*256)                  ; ADC #0            ; effectively sets A to the high byte of K3(1 0) + K:
                                                           ; 
                                                           ; (A ?) = K3(1 0) + K
                                                           ; 
                                                           ; so A is the high byte of the x-coordinate of the right
                                                           ; edge of the circle

       jlt  PL21                       ; BMI PL21          ; If A is negative then the right edge of the circle is
                                                           ; to the left of the screen, so jump to PL21 to set the
                                                           ; C flag and return from the subroutine, as the whole
                                                           ; circle is off-screen to the left

       movb @K3,ra                     ; LDA K3            ; Set A = K3 - K
       .sec                            ; SEC               
       .sbc @K,ra                      ; SBC K             

       movb @K3+1,ra                   ; LDA K3+1          ; Set A = K3+1 - 0 - any carry from above, so this
       .sbi (>00*256)                  ; SBC #0            ; effectively sets A to the high byte of K3(1 0) - K:
                                                           ; 
                                                           ; (A ?) = K3(1 0) - K
                                                           ; 
                                                           ; so A is the high byte of the x-coordinate of the left
                                                           ; edge of the circle

       jlt  PL31                       ; BMI PL31          ; If A is negative then the left edge of the circle is
                                                           ; to the left of the screen, and we already know the
                                                           ; right edge is either on-screen or off-screen to the
                                                           ; right, so skip to PL31 to move on to the y-coordinate
                                                           ; checks, as at least part of the circle is on-screen in
                                                           ; terms of the x-axis

       jne  PL21                       ; BNE PL21          ; If A is non-zero, then the left edge of the circle is
                                                           ; to the right of the screen, so jump to PL21 to set the
                                                           ; C flag and return from the subroutine, as the whole
                                                           ; circle is off-screen to the right

PL31:
       movb @K4,ra                     ; LDA K4            ; Set P+1 = K4 + K
       .clc                            ; CLC               
       .adc @K,ra                      ; ADC K             
       movb ra,@P+1                    ; STA P+1           

       movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 + 0 + any carry from above, so this
       .adi (>00*256)                  ; ADC #0            ; does the following:
                                                           ; 
                                                           ; (A P+1) = K4(1 0) + K
                                                           ; 
                                                           ; so A is the high byte of the y-coordinate of the
                                                           ; bottom edge of the circle

       jlt  PL21                       ; BMI PL21          ; If A is negative then the bottom edge of the circle is
                                                           ; above the top of the screen, so jump to PL21 to set
                                                           ; the C flag and return from the subroutine, as the
                                                           ; whole circle is off-screen to the top

       movb ra,@P+2                    ; STA P+2           ; Store the high byte in P+2, so now we have:
                                                           ; 
                                                           ; P(2 1) = K4(1 0) + K
                                                           ; 
                                                           ; i.e. the maximum y-coordinate of the circle on-screen
                                                           ; (which we return)

       movb @K4,ra                     ; LDA K4            ; Set X = K4 - K
       .sec                            ; SEC               
       .sbc @K,ra                      ; SBC K             
       movb ra,rx                      ; TAX               

       movb @K4+1,ra                   ; LDA K4+1          ; Set A = K4+1 - 0 - any carry from above, so this
       .sbi (>00*256)                  ; SBC #0            ; does the following:
                                                           ; 
                                                           ; (A X) = K4(1 0) - K
                                                           ; 
                                                           ; so A is the high byte of the y-coordinate of the top
                                                           ; edge of the circle

       jlt  PL44                       ; BMI PL44          ; If A is negative then the top edge of the circle is
                                                           ; above the top of the screen, and we already know the
                                                           ; bottom edge is either on-screen or below the bottom
                                                           ; of the screen, so skip to PL44 to clear the C flag and
                                                           ; return from the subroutine using a tail call, as part
                                                           ; of the circle definitely appears on-screen

       jne  PL21                       ; BNE PL21          ; If A is non-zero, then the top edge of the circle is
                                                           ; below the bottom of the screen, so jump to PL21 to set
                                                           ; the C flag and return from the subroutine, as the
                                                           ; whole circle is off-screen to the bottom

       ci   rx,(2*Y-1)*256             ; CPX #2*Y-1        ; If we get here then A is zero, which means the top
                                                           ; edge of the circle is within the screen boundary, so
                                                           ; now we need to check whether it is in the space view
                                                           ; (in which case it is on-screen) or the dashboard (in
                                                           ; which case the top of the circle is hidden by the
                                                           ; dashboard, so the circle isn't on-screen). We do this
                                                           ; by checking the low byte of the result in X against
                                                           ; 2 * #Y - 1, and returning the C flag from this
                                                           ; comparison. The constant #Y is the y-coordinate of the
                                                           ; mid-point of the space view, so 2 * #Y - 1, the
                                                           ; y-coordinate of the bottom pixel row of the space
                                                           ; view. So this does the following:
                                                           ; 
                                                           ; * The C flag is set if coordinate (A X) is below the
                                                           ; bottom row of the space view, i.e. the top edge of
                                                           ; the circle is hidden by the dashboard
                                                           ; 
                                                           ; * The C flag is clear if coordinate (A X) is above
                                                           ; the bottom row of the space view, i.e. the top
                                                           ; edge of the circle is on-screen

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PL21
* Type: Subroutine
* Category: Drawing planets
* Summary: Return from a planet/sun-drawing routine with a failure flag
* 
* ------------------------------------------------------------------------------
* 
* Set the C flag and return from the subroutine. This is used to return from a
* planet- or sun-drawing routine with the C flag indicating an overflow in the
* calculation.
* 
* ******************************************************************************

PL21:
       .sec                            ; SEC               ; Set the C flag to indicate an overflow

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PLS3
* Type: Subroutine
* Category: Drawing planets
* Summary: Calculate (Y A P) = 222 * roofv_x / z
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following, with X determining the vector to use:
* 
* (Y A P) = 222 * roofv_x / z
* 
* though in reality only (Y A) is used.
* 
* Although the code below supports a range of values of X, in practice the
* routine is only called with X = 15, and then again after X has been
* incremented to 17. So the values calculated by PLS1 use roofv_x first, then
* roofv_y. The comments below refer to roofv_x, for the first call.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   Determines which of the INWK orientation vectors to
* divide:
* 
* * X = 15: divides roofv_x
* 
* * X = 17: divides roofv_y
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   X gets incremented by 2 so it points to the next
* coordinate in this orientation vector (so consecutive
* calls to the routine will start with x, then move onto y
* and then z)
* 
* ******************************************************************************

PLS3:
       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
       movb ra,@P                      ; STA P             ; 
                                                           ; P = |roofv_x / z|
                                                           ; K+3 = sign of roofv_x / z
                                                           ; 
                                                           ; and increment X to point to roofv_y for the next call

       li   ra,>de*256                 ; LDA #222          ; Set Q = 222, the offset to the crater
       movb ra,@Q                      ; STA Q             

       movb rx,@U                      ; STX U             ; Store the vector index X in U for retrieval after the
                                                           ; call to MULTU

       .jsr @MULTU                     ; JSR MULTU         ; Call MULTU to calculate
                                                           ; 
                                                           ; (A P) = P * Q
                                                           ; = 222 * |roofv_x / z|

       movb @U,rx                      ; LDX U             ; Restore the vector index from U into X

       movb @K+3,ry                    ; LDY K+3           ; If the sign of the result in K+3 is positive, skip to
       jgt  PL12                       ; BPL PL12          ; PL12 to return with Y = 0

       .eoi (>ff*256)                  ; EOR #&FF          ; Otherwise the result should be negative, so negate the
       .clc                            ; CLC               ; high byte of the result using two's complement with
       .adi (>01*256)                  ; ADC #1            ; A = ~A + 1

       jeq  PL12                       ; BEQ PL12          ; If A = 0, jump to PL12 to return with (Y A) = 0

       li   ry,>ff*256                 ; LDY #&FF          ; Set Y = &FF to be a negative high byte

       .rts                            ; RTS               ; Return from the subroutine

PL12:
       li   ry,>00*256                 ; LDY #0            ; Set Y = 0 to be a positive high byte

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PLS4
* Type: Subroutine
* Category: Drawing planets
* Summary: Calculate CNT2 = arctan(P / A) / 4
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* CNT2 = arctan(P / A) / 4
* 
* and do the following if nosev_z_hi >= 0:
* 
* CNT2 = CNT2 + 32
* 
* which is the equivalent of adding 180 degrees to the result (or PI radians),
* as there are 64 segments in a full circle.
* 
* This routine is called with the following arguments when calculating the
* equator and meridian for planets:
* 
* * A = roofv_z_hi, P = -nosev_z_hi
* 
* * A = sidev_z_hi, P = -nosev_z_hi
* 
* So it calculates the angle between the planet's orientation vectors, in the
* z-axis.
* 
* ******************************************************************************

PLS4:
       movb ra,@Q                      ; STA Q             ; Set Q = A

       .jsr @ARCTAN                    ; JSR ARCTAN        ; Call ARCTAN to calculate:
                                                           ; 
                                                           ; A = arctan(P / Q)
                                                           ; arctan(P / A)
                                                           ; 
                                                           ; The result in A will be in the range 0 to 128, which
                                                           ; represents an angle of 0 to 180 degrees (or 0 to PI
                                                           ; radians)

       movb @INWK+14,rx                ; LDX INWK+14       ; If nosev_z_hi is negative, skip the following
       jlt  B81                        ; BMI B81           ; instruction to leave the angle in A as a positive
                                                           ; integer in the range 0 to 128 (so when we calculate
                                                           ; CNT2 below, it will be in the right half of the
                                                           ; anti-clockwise arc that we describe when drawing
                                                           ; circles, i.e. from 6 o'clock, through 3 o'clock and
                                                           ; on to 12 o'clock)

       .eoi (>80*256)                  ; EOR #%10000000    ; If we get here then nosev_z_hi is positive, so flip
                                                           ; bit 7 of the angle in A, which is the same as adding
                                                           ; 128 to give a result in the range 129 to 256 (i.e. 129
                                                           ; to 0), or 180 to 360 degrees (so when we calculate
                                                           ; CNT2 below, it will be in the left half of the
                                                           ; anti-clockwise arc that we describe when drawing
                                                           ; circles, i.e. from 12 o'clock, through 9 o'clock and
                                                           ; on to 6 o'clock)

B81:
       srl  ra,1                       ; LSR A             ; Set CNT2 = A / 4
       srl  ra,1                       ; LSR A             
       movb ra,@CNT2                   ; STA CNT2          

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PLS5
* Type: Subroutine
* Category: Drawing planets
* Summary: Calculate roofv_x / z and roofv_y / z
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following divisions of a specified value from one of the
* orientation vectors (in this example, roofv):
* 
* (XX16+2 K2+2) = roofv_x / z
* 
* (XX16+3 K2+3) = roofv_y / z
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   Determines which of the INWK orientation vectors to
* divide:
* 
* * X = 15: divides roofv_x and roofv_y
* 
* * X = 21: divides sidev_x and sidev_y
* 
* INWK                The planet's ship data block
* 
* ******************************************************************************

PLS5:
       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
       movb ra,@K2+2                   ; STA K2+2          ; 
       movb ry,@XX16+2                 ; STY XX16+2        ; K+2    = |roofv_x / z|
                                                           ; XX16+2 = sign of roofv_x / z
                                                           ; 
                                                           ; i.e. (XX16+2 K2+2) = roofv_x / z
                                                           ; 
                                                           ; and increment X to point to roofv_y for the next call

       .jsr @PLS1                      ; JSR PLS1          ; Call PLS1 to calculate the following:
       movb ra,@K2+3                   ; STA K2+3          ; 
       movb ry,@XX16+3                 ; STY XX16+3        ; K+3    = |roofv_y / z|
                                                           ; XX16+3 = sign of roofv_y / z
                                                           ; 
                                                           ; i.e. (XX16+3 K2+3) = roofv_y / z
                                                           ; 
                                                           ; and increment X to point to roofv_z for the next call

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: PLS6
* Type: Subroutine
* Category: Drawing planets
* Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* (X K) = (A P+1 P) / (z_sign z_hi z_lo)
* 
* returning an overflow in the C flag if the result is >= 1024.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* INWK                The planet or sun's ship data block
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the result >= 1024, clear otherwise
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* PL44                Clear the C flag and return from the subroutine
* 
* ******************************************************************************

PLS6:
       .jsr @DVID3B2                   ; JSR DVID3B2       ; Call DVID3B2 to calculate:
                                                           ; 
                                                           ; K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)

       movb @K+3,ra                    ; LDA K+3           ; Set A = |K+3| OR K+2
       andi ra,>7f*256                 ; AND #%01111111    
       socb @K+2,ra                    ; ORA K+2           

       jne  PL21                       ; BNE PL21          ; If A is non-zero then the two high bytes of K(3 2 1 0)
                                                           ; are non-zero, so jump to PL21 to set the C flag and
                                                           ; return from the subroutine

                                                           ; We can now just consider K(1 0), as we know the top
                                                           ; two bytes of K(3 2 1 0) are both 0

       movb @K+1,rx                    ; LDX K+1           ; Set X = K+1, so now (X K) contains the result in
                                                           ; K(1 0), which is the format we want to return the
                                                           ; result in

       ci   rx,>04*256                 ; CPX #4            ; If the high byte of K(1 0) >= 4 then the result is
       joc  PL6                        ; BCS PL6           ; >= 1024, so return from the subroutine with the C flag
                                                           ; set to indicate an overflow (as PL6 contains an RTS)

       movb @K+3,ra                    ; LDA K+3           ; Fetch the sign of the result from K+3 (which we know
                                                           ; has zeroes in bits 0-6, so this just fetches the sign)

* CLC                    \ This instruction is commented out in the original
                                                           ; source. It would have no effect as we know the C flag
                                                           ; is already clear, as we skipped past the BCS above

       jgt  PL6                        ; BPL PL6           ; If the sign bit is clear and the result is positive,
                                                           ; then the result is already correct, so return from
                                                           ; the subroutine with the C flag clear to indicate
                                                           ; success (as PL6 contains an RTS)

       movb @K,ra                      ; LDA K             ; Otherwise we need to negate the result, which we do
       .eoi (>ff*256)                  ; EOR #%11111111    ; using two's complement, starting with the low byte:
       .adi (>01*256)                  ; ADC #1            ; 
       movb ra,@K                      ; STA K             ; K = ~K + 1

       movb rx,ra                      ; TXA               ; And then the high byte:
       .eoi (>ff*256)                  ; EOR #%11111111    ; 
       .adi (>00*256)                  ; ADC #0            ; X = ~X
       movb ra,rx                      ; TAX               

PL44:
       .clc                            ; CLC               ; Clear the C flag to indicate success

PL6:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT17
* Type: Subroutine
* Category: Keyboard
* Summary: Scan the keyboard for cursor key or joystick movement
* 
* ------------------------------------------------------------------------------
* 
* Scan the keyboard and joystick for cursor key or stick movement, and return
* the result as deltas (changes) in x- and y-coordinates as follows:
* 
* * For joystick, X and Y are integers between -2 and +2 depending on how far
* the stick has moved
* 
* * For keyboard, X and Y are integers between -1 and +1 depending on which
* keys are pressed
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The key pressed, if the arrow keys were used
* 
* X                   Change in the x-coordinate according to the cursor keys
* being pressed or joystick movement, as an integer (see
* above)
* 
* Y                   Change in the y-coordinate according to the cursor keys
* being pressed or joystick movement, as an integer (see
* above)
* 
* ******************************************************************************

TT17:
       .jsr @DOKEY                     ; JSR DOKEY         ; Scan the keyboard for flight controls and pause keys,
                                                           ; (or the equivalent on joystick) and update the key
                                                           ; logger, setting KL to the key pressed

       movb @JSTK,ra                   ; LDA JSTK          ; If the joystick is not configured, jump down to TJ1,
       jeq  TJ1                        ; BEQ TJ1           ; otherwise we move the cursor with the joystick

       movb @JSTX,ra                   ; LDA JSTX          ; Fetch the joystick roll, ranging from 1 to 255 with
                                                           ; 128 as the centre point

       .eoi (>ff*256)                  ; EOR #&FF          ; Flip the sign so A = -JSTX, because the joystick roll
                                                           ; works in the opposite way to moving a cursor on-screen
                                                           ; in terms of left and right

       .jsr @TJS1                      ; JSR TJS1          ; Call TJS1 just below to set A to a value between -2
                                                           ; and +2 depending on the joystick roll value (moving
                                                           ; the stick sideways)

       movb ry,ra                      ; TYA               ; Copy Y to A

       movb ra,rx                      ; TAX               ; Copy A to X, so X contains the joystick roll value

       movb @JSTY,ra                   ; LDA JSTY          ; Fetch the joystick pitch, ranging from 1 to 255 with
                                                           ; 128 as the centre point, and fall through into TJS1 to
                                                           ; set Y to the joystick pitch value (moving the stick up
                                                           ; and down)

TJS1:
       movb ra,ry                      ; TAY               ; Store A in Y

       li   ra,>00*256                 ; LDA #0            ; Set the result, A = 0

       ci   ry,>10*256                 ; CPY #16           ; If Y >= 16 set the C flag, so A = A - 1
       .sbi (>00*256)                  ; SBC #0            

* CPY #&20               \ These instructions are commented out in the original
* SBC #0                 \ source, but they would make the joystick move the
                                                           ; cursor faster by increasing the range of Y by -1 to +1

       ci   ry,>40*256                 ; CPY #64           ; If Y >= 64 set the C flag, so A = A - 1
       .sbi (>00*256)                  ; SBC #0            

       ci   ry,>c0*256                 ; CPY #192          ; If Y >= 192 set the C flag, so A = A + 1
       .adi (>00*256)                  ; ADC #0            

       ci   ry,>e0*256                 ; CPY #224          ; If Y >= 224 set the C flag, so A = A + 1
       .adi (>00*256)                  ; ADC #0            

* CPY #&F0               \ These instructions are commented out in the original
* ADC #0                 \ source, but they would make the joystick move the
                                                           ; cursor faster by increasing the range of Y by -1 to +1

       movb ra,ry                      ; TAY               ; Copy the value of A into Y

       movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)

       .rts                            ; RTS               ; Return from the subroutine

TJ1:
       movb @KL,ra                     ; LDA KL            ; Set A to the value of KL (the key pressed)

       li   rx,>00*256                 ; LDX #0            ; Set the initial values for the results, X = Y = 0,
       li   ry,>00*256                 ; LDY #0            ; which we now increase or decrease appropriately

       ci   ra,>19*256                 ; CMP #&19          ; If left arrow was pressed, set X = X - 1
       jne  B82                        ; BNE B82           
       sb   rone,rx                    ; DEX               

B82:
       ci   ra,>79*256                 ; CMP #&79          ; If right arrow was pressed, set X = X + 1
       jne  B83                        ; BNE B83           
       ab   rone,rx                    ; INX               

B83:
       ci   ra,>39*256                 ; CMP #&39          ; If up arrow was pressed, set Y = Y + 1
       jne  B84                        ; BNE B84           
       ab   rone,ry                    ; INY               

B84:
       ci   ra,>29*256                 ; CMP #&29          ; If down arrow was pressed, set Y = Y - 1
       jne  B85                        ; BNE B85           
       sb   rone,ry                    ; DEY               

B85:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ping
* Type: Subroutine
* Category: Universe
* Summary: Set the selected system to the current system
* 
* ******************************************************************************

ping_:
       li   rx,>01*256                 ; LDX #1            ; We want to copy the X- and Y-coordinates of the
                                                           ; current system in (QQ0, QQ1) to the selected system's
                                                           ; coordinates in (QQ9, QQ10), so set up a counter to
                                                           ; copy two bytes

pl1_:
       movb @QQ0(rx),ra                ; LDA QQ0,X         ; Load byte X from the current system in QQ0/QQ1

       movb ra,@QQ9(rx)                ; STA QQ9,X         ; Store byte X in the selected system in QQ9/QQ10

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  pl1_                       ; BPL pl1           ; Loop back for the next byte to copy

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Save ELTE.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE F FILE
* 
* Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_F.:
       equ $

LOAD_F.:
       equ LOAD. + $ - CODE.

* ******************************************************************************
* 
* Name: KS3
* Type: Subroutine
* Category: Universe
* Summary: Set the SLSP ship line heap pointer after shuffling ship slots
* 
* ------------------------------------------------------------------------------
* 
* The final part of the KILLSHP routine, called after we have shuffled the ship
* slots and sorted out our missiles. This simply sets SLSP to the new bottom of
* the ship line heap.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* P(1 0)              Points to the ship line heap of the ship in the last
* occupied slot (i.e. it points to the bottom of the
* descending heap)
* 
* ******************************************************************************

KS3:
       movb @P,ra                      ; LDA P             ; After shuffling the ship slots, P(1 0) will point to
       movb ra,@SLSP                   ; STA SLSP          ; the new bottom of the ship line heap, so store this in
       movb @P+1,ra                    ; LDA P+1           ; SLSP(1 0), which stores the bottom of the heap
       movb ra,@SLSP+1                 ; STA SLSP+1        

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: KS1
* Type: Subroutine
* Category: Universe
* Summary: Remove the current ship from our local bubble of universe
* 
* ------------------------------------------------------------------------------
* 
* Part 12 of the main flight loop calls this routine to remove the ship that is
* currently being analysed by the flight loop. Once the ship is removed, it
* jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
* same slot that we just cleared (and which now contains the next ship in the
* local bubble of universe).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX0                 The address of the blueprint for this ship
* 
* INF                 The address of the data block for this ship
* 
* ******************************************************************************

KS1:
       movb @XSAV,rx                   ; LDX XSAV          ; Store the current ship's slot number in XSAV

       .jsr @KILLSHP                   ; JSR KILLSHP       ; Call KILLSHP to remove the ship in slot X from our
                                                           ; local bubble of universe

       movb @XSAV,rx                   ; LDX XSAV          ; Restore the current ship's slot number from XSAV,
                                                           ; which now points to the next ship in the bubble

       b    @MAL1                      ; JMP MAL1          ; Jump to MAL1 to rejoin the main flight loop at the
                                                           ; start of the ship analysis loop

* ******************************************************************************
* 
* Name: KS4
* Type: Subroutine
* Category: Universe
* Summary: Remove the space station and replace it with the sun
* 
* ******************************************************************************

KS4:
       .jsr @ZINF                      ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace

       .jsr @FLFLLS                    ; JSR FLFLLS        ; Reset the LSO block, returns with A = 0

       movb ra,@FRIN+1                 ; STA FRIN+1        ; Set the second slot in the FRIN table to 0, which
                                                           ; sets this slot to empty, so when we call NWSHP below
                                                           ; the new sun that gets created will go into FRIN+1

       movb ra,@SSPR                   ; STA SSPR          ; Set the "space station present" flag to 0, as we are
                                                           ; no longer in the space station's safe zone

       .jsr @SPBLB                     ; JSR SPBLB         ; Call SPBLB to redraw the space station bulb, which
                                                           ; will erase it from the dashboard

       li   ra,>06*256                 ; LDA #6            ; Set the sun's y_sign to 6
       movb ra,@INWK+5                 ; STA INWK+5        

       li   ra,>81*256                 ; LDA #129          ; Set A = 129, the ship type for the sun

       b    @NWSHP                     ; JMP NWSHP         ; Call NWSHP to set up the sun's data block and add it
                                                           ; to FRIN, where it will get put in the second slot as
                                                           ; we just cleared out the second slot, and the first
                                                           ; slot is already taken by the planet

* ******************************************************************************
* 
* Name: KS2
* Type: Subroutine
* Category: Universe
* Summary: Check the local bubble for missiles with target lock
* 
* ------------------------------------------------------------------------------
* 
* Check the local bubble of universe to see if there are any missiles with
* target lock in the vicinity. If there are, then check their targets; if we
* just removed their target in the KILLSHP routine, then switch off their AI so
* they just drift in space, otherwise update their targets to reflect the newly
* shuffled slot numbers.
* 
* This is called from KILLSHP once the slots have been shuffled down, following
* the removal of a ship.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX4                 The slot number of the ship we removed just before
* calling this routine
* 
* ******************************************************************************

KS2:
       li   rx,>ff*256                 ; LDX #&FF          ; We want to go through the ships in our local bubble
                                                           ; and pick out all the missiles, so set X to &FF to
                                                           ; use as a counter

KSL4:
       ab   rone,rx                    ; INX               ; Increment the counter (so it starts at 0 on the first
                                                           ; iteration)

       movb @FRIN(rx),ra               ; LDA FRIN,X        ; If slot X is empty then we have worked our way through
       jeq  KS3                        ; BEQ KS3           ; all the slots, so jump to KS3 to stop looking

       ci   ra,(MSL)*256               ; CMP #MSL          ; If the slot does not contain a missile, loop back to
       jne  KSL4                       ; BNE KSL4          ; KSL4 to check the next slot

                                                           ; We have found a slot containing a missile, so now we
                                                           ; want to check whether it has target lock

       movb rx,ra                      ; TXA               ; Set Y = X * 2 and fetch the Y-th address from UNIV
       .asla                           ; ASL A             ; and store it in SC and SC+1 - in other words, set
       movb ra,ry                      ; TAY               ; SC(1 0) to point to the missile's ship data block
       movb @UNIV(ry),ra               ; LDA UNIV,Y        
       movb ra,@SC                     ; STA SC            
       movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      
       movb ra,@SC+1                   ; STA SC+1          

       li   ry,>20*256                 ; LDY #32           ; Fetch byte #32 from the missile's ship data (AI)
       .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        

       jgt  KSL4                       ; BPL KSL4          ; If bit 7 of byte #32 is clear, then the missile is
                                                           ; dumb and has no AI, so loop back to KSL4 to move on
                                                           ; to the next slot

       andi ra,>7f*256                 ; AND #%01111111    ; Otherwise this missile has AI, so clear bit 7 and
       srl  ra,1                       ; LSR A             ; shift right to set the C flag to the missile's "is
                                                           ; locked" flag, and A to the target's slot number

       cb   @XX4,ra                    ; CMP XX4           ; If this missile's target is less than XX4, then the
       jnc  KSL4                       ; BCC KSL4          ; target's slot isn't being shuffled down, so jump to
                                                           ; KSL4 to move on to the next slot

       jeq  KS6                        ; BEQ KS6           ; If this missile was locked onto the ship that we just
                                                           ; removed in KILLSHP, jump to KS6 to stop the missile
                                                           ; from continuing to hunt it down

       .sbi (>01*256)                  ; SBC #1            ; Otherwise this missile is locked and has AI enabled,
                                                           ; and its target will have moved down a slot, so
                                                           ; subtract 1 from the target number (we know C is set
                                                           ; from the BCC above)

       .asla                           ; ASL A             ; Shift the target number left by 1, so it's in bits
                                                           ; 1-6 once again, and also set bit 0 to 1, as the C
                                                           ; flag is still set, so this makes sure the missile is
                                                           ; still set to being locked

       ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7, so the missile's AI is enabled

       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Update the missile's AI flag to the value in A

       jne  KSL4                       ; BNE KSL4          ; Loop back to KSL4 to move on to the next slot (this
                                                           ; BNE is effectively a JMP as A will never be zero)

KS6:
       li   ra,>00*256                 ; LDA #0            ; The missile's target lock just got removed, so set the
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; AI flag to 0 to make it dumb and not locked

       jeq  KSL4                       ; BEQ KSL4          ; Loop back to KSL4 to move on to the next slot (this
                                                           ; BEQ is effectively a JMP as A is always zero)

* ******************************************************************************
* 
* Name: KILLSHP
* Type: Subroutine
* Category: Universe
* Summary: Remove a ship from our local bubble of universe
* 
* ------------------------------------------------------------------------------
* 
* Remove the ship in slot X from our local bubble of universe. This happens
* when we kill a ship, collide with a ship and destroy it, or when a ship moves
* outside our local bubble.
* 
* We also use this routine when we move out of range of the space station, in
* which case we replace it with the sun.
* 
* When removing a ship, this creates a gap in the ship slots at FRIN, so we
* shuffle all the later slots down to close the gap. We also shuffle the ship
* data blocks at K% and ship line heap at WP, to reclaim all the memory that
* the removed ship used to occupy.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The slot number of the ship to remove
* 
* XX0                 The address of the blueprint for the ship to remove
* 
* INF                 The address of the data block for the ship to remove
* 
* ******************************************************************************

KILLSHP:
       movb rx,@XX4                    ; STX XX4           ; Store the slot number of the ship to remove in XX4


       movb @MSTG,ra                   ; LDA MSTG          ; Check whether this slot matches the slot number in
       cb   @XX4,ra                    ; CMP XX4           ; MSTG, which is the target of our missile lock


       cb   @MSTG,rx                   ; CPX MSTG          ; Check whether this slot matches the slot number in
                                                           ; MSTG, which is the target of our missile lock
                                                           ; 
                                                           ; This instructions saves two bytes of memory over the
                                                           ; LDA and CMP-based code in the source disc version, as
                                                           ; CPX MSTG is a two-byte opcode, while LDA MSTG and
                                                           ; CMP XX4 take up four bytes between them (the code does
                                                           ; the same thing)


       jne  KS5                        ; BNE KS5           ; If our missile is not locked on this ship, jump to KS5

       li   ry,>ee*256                 ; LDY #&EE          ; Otherwise we need to remove our missile lock, so call
       .jsr @ABORT                     ; JSR ABORT         ; ABORT to disarm the missile and update the missile
                                                           ; indicators on the dashboard to green/cyan (Y = &EE)

       li   ra,>c8*256                 ; LDA #200          ; Print recursive token 40 ("TARGET LOST") as an
       .jsr @MESS                      ; JSR MESS          ; in-flight message

KS5:
       movb @XX4,ry                    ; LDY XX4           ; Restore the slot number of the ship to remove into Y

       movb @FRIN(ry),rx               ; LDX FRIN,Y        ; Fetch the contents of the slot, which contains the
                                                           ; ship type

       ci   rx,(SST)*256               ; CPX #SST          ; If this is the space station, then jump to KS4 to
       jeq  KS4                        ; BEQ KS4           ; replace the space station with the sun

       sb   rone,ra                    ; DEC MANY,X        ; Decrease the number of this type of ship in our little
                                                           ; bubble, which is stored in MANY+X (where X is the ship
                                                           ; type)

       movb @XX4,rx                    ; LDX XX4           ; Restore the slot number of the ship to remove into X

                                                           ; We now want to remove this ship and reclaim all the
                                                           ; memory that it uses. Removing the ship will leave a
                                                           ; gap in three places, which we need to close up:
                                                           ; 
                                                           ; * The ship slots in FRIN
                                                           ; 
                                                           ; * The ship data blocks in K%
                                                           ; 
                                                           ; * The descending ship line heap at WP down
                                                           ; 
                                                           ; The rest of this routine closes up these gaps by
                                                           ; looping through all the occupied ship slots after the
                                                           ; slot we are removing, one by one, and shuffling each
                                                           ; ship's slot, data block and line heap down to close
                                                           ; up the gaps left by the removed ship. As part of this,
                                                           ; we have to make sure we update any address pointers
                                                           ; so they point to the newly shuffled data blocks and
                                                           ; line heaps
                                                           ; 
                                                           ; In the following, when shuffling a ship's data down
                                                           ; into the preceding empty slot, we call the ship that
                                                           ; we are shuffling down the "source", and we call the
                                                           ; empty slot we are shuffling it into the "destination"
                                                           ; 
                                                           ; Before we start looping through the ships we need to
                                                           ; shuffle down, we need to set up some variables to
                                                           ; point to the source and destination line heaps

       li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the removed ship's blueprint into A,
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; which gives the ship's maximum heap size for the ship
                                                           ; we are removing (i.e. the size of the gap in the heap
                                                           ; created by the ship removal)

                                                           ; INF currently contains the ship data for the ship we
                                                           ; are removing, and INF(34 33) contains the address of
                                                           ; the bottom of the ship's heap, so we can calculate
                                                           ; the address of the top of the heap by adding the heap
                                                           ; size to this address

       li   ry,>21*256                 ; LDY #33           ; First we add A and the address in INF+33, to get the
       .clc                            ; CLC               ; low byte of the top of the heap, which we store in P
       .adc_ind_y_idx @INF,ra          ; ADC (INF),Y       
       movb ra,@P                      ; STA P             

       ab   rone,ry                    ; INY               ; And next we add A and the address in INF+34, with any
       .ld_ind_y_idx @INF,ra           ; LDA (INF),Y       ; carry from the previous addition, to get the high byte
       .adi (>00*256)                  ; ADC #0            ; of the top of the heap, which we store in P+1, so
       movb ra,@P+1                    ; STA P+1           ; P(1 0) points to the top of this ship's heap

                                                           ; Now, we're ready to start looping through the ships
                                                           ; we want to move, moving the slots, data blocks and
                                                           ; line heap from the source to the destination. In the
                                                           ; following, we set up SC to point to the source data,
                                                           ; and INF (which currently points to the removed ship's
                                                           ; data that we can now overwrite) points to the
                                                           ; destination
                                                           ; 
                                                           ; So P(1 0) now points to the top of the line heap for
                                                           ; the destination

KSL1:
       ab   rone,rx                    ; INX               ; On entry, X points to the empty slot we want to
                                                           ; shuffle the next ship into (the destination), so
                                                           ; this increment points X to the next slot - i.e. the
                                                           ; source slot we want to shuffle down

       movb @FRIN(rx),ra               ; LDA FRIN,X        ; Copy the contents of the source slot into the
       movb ra,@FRIN-1(rx)             ; STA FRIN-1,X      ; destination slot

       jeq  KS2                        ; BEQ KS2           ; If the slot we just shuffled down contains 0, then
                                                           ; the source slot is empty and we are done shuffling,
                                                           ; so jump to KS2 to move on to processing missiles

       .asla                           ; ASL A             ; Otherwise we have a source ship to shuffle down into
       movb ra,ry                      ; TAY               ; the destination, so set Y = A * 2 so it can act as an
                                                           ; index into the two-byte ship blueprint lookup table
                                                           ; at XX21 for the source ship

       movb @XX21-2(ry),ra             ; LDA XX21-2,Y      ; Set SC(0 1) to point to the blueprint data for the
       movb ra,@SC                     ; STA SC            ; source ship
       movb @XX21-1(ry),ra             ; LDA XX21-1,Y      
       movb ra,@SC+1                   ; STA SC+1          

       li   ry,>05*256                 ; LDY #5            ; Fetch blueprint byte #5 for the source ship, which
       .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; gives us its maximum heap size, and store it in T
       movb ra,@T                      ; STA T             

                                                           ; We now subtract T from P(1 0), so P(1 0) will point to
                                                           ; the bottom of the line heap for the destination
                                                           ; (which we will use later when closing up the gap in
                                                           ; the heap space)

       movb @P,ra                      ; LDA P             ; First, we subtract the low bytes
       .sec                            ; SEC               
       .sbc @T,ra                      ; SBC T             
       movb ra,@P                      ; STA P             

       movb @P+1,ra                    ; LDA P+1           ; And then we do the high bytes, for which we subtract
       .sbi (>00*256)                  ; SBC #0            ; 0 to include any carry, so this is effectively doing
       movb ra,@P+1                    ; STA P+1           ; P(1 0) = P(1 0) - (0 T)

                                                           ; Next, we want to set SC(1 0) to point to the source
                                                           ; ship's data block

       movb rx,ra                      ; TXA               ; Set Y = X * 2 so it can act as an index into the
       .asla                           ; ASL A             ; two-byte lookup table at UNIV, which contains the
       movb ra,ry                      ; TAY               ; addresses of the ship data blocks. In this case we are
                                                           ; multiplying X by 2, and X contains the source ship's
                                                           ; slot number so Y is now an index for the source ship's
                                                           ; entry in UNIV

       movb @UNIV(ry),ra               ; LDA UNIV,Y        ; Set SC(1 0) to the address of the data block for the
       movb ra,@SC                     ; STA SC            ; source ship
       movb @UNIV+1(ry),ra             ; LDA UNIV+1,Y      
       movb ra,@SC+1                   ; STA SC+1          

                                                           ; We have now set up our variables as follows:
                                                           ; 
                                                           ; SC(1 0) points to the source's ship data block
                                                           ; 
                                                           ; INF(1 0) points to the destination's ship data block
                                                           ; 
                                                           ; P(1 0) points to the destination's line heap
                                                           ; 
                                                           ; so let's start copying data from the source to the
                                                           ; destination

       li   ry,>23*256                 ; LDY #35           ; We are going to be using Y as a counter for the 36
                                                           ; bytes of ship data we want to copy from the source
                                                           ; to the destination, so we set it to 35 to start things
                                                           ; off, and will decrement Y for each byte we copy

       .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Fetch byte #35 of the source's ship data block at SC,
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; and store it in byte #35 of the destination's block
                                                           ; at INF, so that's the ship's energy copied from the
                                                           ; source to the destination. One down, quite a few to
                                                           ; go...

       sb   rone,ry                    ; DEY               ; Fetch byte #34 of the source ship, which is the
       .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; high byte of the source ship's line heap, and store
       movb ra,@K+1                    ; STA K+1           ; in K+1

       movb @P+1,ra                    ; LDA P+1           ; Set the low byte of the destination's heap pointer
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P+1

       sb   rone,ry                    ; DEY               ; Fetch byte #33 of the source ship, which is the
       .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; low byte of the source ship's heap, and store in K
       movb ra,@K                      ; STA K             ; so now we have the following:
                                                           ; 
                                                           ; K(1 0) points to the source's line heap

       movb @P,ra                      ; LDA P             ; Set the low byte of the destination's heap pointer
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; to P, so now the destination's heap pointer is to
                                                           ; P(1 0), so that's the heap pointer in bytes #33 and
                                                           ; #34 done

       sb   rone,ry                    ; DEY               ; Luckily, we can just copy the rest of the source's
                                                           ; ship data block into the destination, as there are no
                                                           ; more address pointers, so first we decrement our
                                                           ; counter in Y to point to the next byte (the AI flag)
                                                           ; in byte #32) and then start looping

KSL2:
       .ld_ind_y_idx @SC,ra            ; LDA (SC),Y        ; Copy the Y-th byte of the source to the Y-th byte of
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the destination

       sb   rone,ry                    ; DEY               ; Decrement the counter

       jgt  KSL2                       ; BPL KSL2          ; Loop back to KSL2 to copy the next byte until we have
                                                           ; copied the whole block

                                                           ; We have now shuffled the ship's slot and the ship's
                                                           ; data block, so we only have the heap data itself to do

       movb @SC,ra                     ; LDA SC            ; First, we copy SC into INF, so when we loop round
       movb ra,@INF                    ; STA INF           ; again, INF will correctly point to the destination for
       movb @SC+1,ra                   ; LDA SC+1          ; the next iteration
       movb ra,@INF+1                  ; STA INF+1         

       movb @T,ry                      ; LDY T             ; Now we want to move the contents of the heap, as all
                                                           ; we did above was to update the pointers, so first
                                                           ; we set a counter in Y that is initially set to T
                                                           ; (which we set above to the maximum heap size for the
                                                           ; source ship)
                                                           ; 
                                                           ; As a reminder, we have already set the following:
                                                           ; 
                                                           ; K(1 0) points to the source's line heap
                                                           ; 
                                                           ; P(1 0) points to the destination's line heap
                                                           ; 
                                                           ; so we can move the heap data by simply copying the
                                                           ; correct number of bytes from K(1 0) to P(1 0)
KSL3:
       sb   rone,ry                    ; DEY               ; Decrement the counter

       .ld_ind_y_idx @K,ra             ; LDA (K),Y         ; Copy the Y-th byte of the source heap at K(1 0) to
       .st_ind_y_idx @P,ra             ; STA (P),Y         ; the destination heap at P(1 0)

       movb ry,ra                      ; TYA               ; Loop back to KSL3 to copy the next byte, until we
       jne  KSL3                       ; BNE KSL3          ; have done them all

       jeq  KSL1                       ; BEQ KSL1          ; We have now shuffled everything down one slot, so
                                                           ; jump back up to KSL1 to see if there is another slot
                                                           ; that needs shuffling down (this BEQ is effectively a
                                                           ; JMP as A will always be zero)

* ******************************************************************************
* 
* Name: SFX
* Type: Variable
* Category: Sound
* Summary: Sound data
* 
* ------------------------------------------------------------------------------
* 
* Sound data. To make a sound, the NOS1 routine copies the four relevant sound
* bytes to XX16, and NO3 then makes the sound. The sound numbers are shown in
* the table, and are always multiples of 8. Generally, sounds are made by
* calling the NOISE routine with the sound number in A.
* 
* These bytes are passed to OSWORD 7, and are the equivalents to the parameters
* passed to the SOUND keyword in BASIC. The parameters therefore have these
* meanings:
* 
* channel/flush, amplitude (or envelope number if 1-4), pitch, duration
* 
* For the channel/flush parameter, the high nibble of the low byte is the flush
* control (where a flush control of 0 queues the sound, and a flush control of
* 1 makes the sound instantly), while the low nibble of the low byte is the
* channel number. When written in hexadecimal, the first figure gives the flush
* control, while the second is the channel (so &13 indicates flush control = 1
* and channel = 3).
* 
* So when we call NOISE with A = 40 to make a long, low beep, then this is
* effectively what the NOISE routine does:
* 
* SOUND &13, &F4, &0C, &08
* 
* which makes a sound with flush control 1 on channel 3, and with amplitude &F4
* (-12), pitch &0C (2) and duration &08 (8). Meanwhile, to make the hyperspace
* sound, the NOISE routine does this:
* 
* SOUND &10, &02, &60, &10
* 
* which makes a sound with flush control 1 on channel 0, using envelope 2,
* and with pitch &60 (96) and duration &10 (16). The four sound envelopes (1-4)
* are set up by the loading process.
* 
* ******************************************************************************

SFX:
       byte >12                                                      ; 0  - Lasers fired by us
       byte >12                                                      ; 8  - We're being hit by lasers
       byte >11                                                      ; 16 - We died 1 / We made a hit or kill 2
       byte >10                                                      ; 24 - We died 2 / We made a hit or kill 1
       byte >03                                                      ; 32 - Short, high beep
       byte >13                                                      ; 40 - Long, low beep
       byte >10                                                      ; 48 - Missile launched / Ship launched from station
       byte >10                                                      ; 56 - Hyperspace drive engaged
       byte >13                                                      ; 64 - E.C.M. on
       byte >13                                                      ; 72 - E.C.M. off

* ******************************************************************************
* 
* Name: RESET
* Type: Subroutine
* Category: Start and end
* Summary: Reset most variables
* 
* ------------------------------------------------------------------------------
* 
* Reset our ship and various controls, recharge shields and energy, and then
* fall through into RES2 to reset the stardust and the ship workspace at INWK.
* 
* In this subroutine, this means zero-filling the following locations:
* 
* * Pages &9, &A, &B, &C and &D
* 
* * BETA to BETA+6, which covers the following:
* 
* * BETA, BET1 - Set pitch to 0
* 
* * XC, YC - Set text cursor to (0, 0)
* 
* * QQ22 - Set hyperspace counters to 0
* 
* * ECMA - Turn E.C.M. off
* 
* It also sets QQ12 to &FF, to indicate we are docked, recharges the shields and
* energy banks, and then falls through into RES2.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* RES4                Reset the shields and energy banks, then fall through
* into RES2 to reset the stardust and the ship workspace
* at INWK
* 
* ******************************************************************************

RESET:
       .jsr @ZERO                      ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
                                                           ; the ship data blocks, the ship line heap, the ship
                                                           ; slots for the local bubble of universe, and various
                                                           ; flight and ship status variables

       li   rx,>06*256                 ; LDX #6            ; Set up a counter for zeroing BETA through BETA+6

SAL3:
       movb ra,@BETA(rx)               ; STA BETA,X        ; Zero the X-th byte after BETA

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  SAL3                       ; BPL SAL3          ; Loop back for the next byte to zero

       movb rx,@QQ12                   ; STX QQ12          ; X is now negative - i.e. &FF - so this sets QQ12 to
                                                           ; &FF to indicate we are docked

                                                           ; We now fall through into RES4 to restore shields and
                                                           ; energy, and reset the stardust and ship workspace at
                                                           ; INWK

RES4:
       li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can fill up the shields and energy
                                                           ; bars with a full charge

       li   rx,>02*256                 ; LDX #2            ; We're now going to recharge both shields and the
                                                           ; energy bank, which live in the three bytes at FSH,
                                                           ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
                                                           ; in X for 3 bytes

REL5:
       movb ra,@FSH(rx)                ; STA FSH,X         ; Set the X-th byte of FSH to &FF to charge up that
                                                           ; shield/bank

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  REL5                       ; BPL REL5          ; Loop back to REL5 until we have recharged both shields
                                                           ; and the energy bank

                                                           ; Fall through into RES2 to reset the stardust and ship
                                                           ; workspace at INWK

* ******************************************************************************
* 
* Name: RES2
* Type: Subroutine
* Category: Start and end
* Summary: Reset a number of flight variables and workspaces
* 
* ------------------------------------------------------------------------------
* 
* This is called after we launch from a space station, arrive in a new system
* after hyperspace, launch an escape pod, or die a cold, lonely death in the
* depths of space.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is set to &FF
* 
* ******************************************************************************

RES2:
       li   ra,(NOST)*256              ; LDA #NOST         ; Reset NOSTM, the number of stardust particles, to the
       movb ra,@NOSTM                  ; STA NOSTM         ; maximum allowed (18)

       li   rx,>ff*256                 ; LDX #&FF          ; Reset LSX2 and LSY2, the ball line heaps used by the
       movb rx,@LSX2                   ; STX LSX2          ; BLINE routine for drawing circles, to &FF, to set the
       movb rx,@LSY2                   ; STX LSY2          ; heap to empty

       movb rx,@MSTG                   ; STX MSTG          ; Reset MSTG, the missile target, to &FF (no target)

       li   ra,>80*256                 ; LDA #128          ; Set the current pitch rate to the mid-point, 128
       movb ra,@JSTY                   ; STA JSTY          

       movb ra,@ALP2                   ; STA ALP2          ; Reset ALP2 (roll sign) and BET2 (pitch sign)
       movb ra,@BET2                   ; STA BET2          ; to negative, i.e. pitch and roll negative

       .asla                           ; ASL A             ; This sets A to 0

       movb ra,@ALP2+1                 ; STA ALP2+1        ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
       movb ra,@BET2+1                 ; STA BET2+1        ; pitch sign) to positive, i.e. pitch and roll negative

       movb ra,@MCNT                   ; STA MCNT          ; Reset MCNT (the main loop counter) to 0

       li   ra,>03*256                 ; LDA #3            ; Reset DELTA (speed) to 3
       movb ra,@DELTA                  ; STA DELTA         

       movb ra,@ALPHA                  ; STA ALPHA         ; Reset ALPHA (roll angle alpha) to 3

       movb ra,@ALP1                   ; STA ALP1          ; Reset ALP1 (magnitude of roll angle alpha) to 3

       movb @SSPR,ra                   ; LDA SSPR          ; Fetch the "space station present" flag, and if we are
       jeq  B86                        ; BEQ B86           ; not inside the safe zone, skip the next instruction

       .jsr @SPBLB                     ; JSR SPBLB         ; Light up the space station bulb on the dashboard

B86:
       movb @ECMA,ra                   ; LDA ECMA          ; Fetch the E.C.M. status flag, and if E.C.M. is off,
       jeq  yu_                        ; BEQ yu            ; skip the next instruction

       .jsr @ECMOF                     ; JSR ECMOF         ; Turn off the E.C.M. sound

yu_:
       .jsr @WPSHPS                    ; JSR WPSHPS        ; Wipe all ships from the scanner

       .jsr @ZERO                      ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
                                                           ; the ship data blocks, the ship line heap, the ship
                                                           ; slots for the local bubble of universe, and various
                                                           ; flight and ship status variables

       li   ra,((WP-1)%256)*256        ; LDA #LO(WP-1)     ; We have reset the ship line heap, so we now point
       movb ra,@SLSP                   ; STA SLSP          ; SLSP to the byte before the WP workspace to indicate
       li   ra,((WP-1)/256)*256        ; LDA #HI(WP-1)     ; that the heap is empty
       movb ra,@SLSP+1                 ; STA SLSP+1        

       .jsr @DIALS                     ; JSR DIALS         ; Update the dashboard

                                                           ; Finally, fall through into ZINF to reset the INWK
                                                           ; ship workspace

* ******************************************************************************
* 
* Name: ZINF
* Type: Subroutine
* Category: Universe
* Summary: Reset the INWK workspace and orientation vectors
* Deep dive: Orientation vectors
* 
* ------------------------------------------------------------------------------
* 
* Zero-fill the INWK ship workspace and reset the orientation vectors, with
* nosev pointing out of the screen, towards us.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Y                   Y is set to &FF
* 
* ******************************************************************************

ZINF:
       li   ry,(NI.-1)*256             ; LDY #NI%-1        ; There are NI% bytes in the INWK workspace, so set a
                                                           ; counter in Y so we can loop through them

       li   ra,>00*256                 ; LDA #0            ; Set A to 0 so we can zero-fill the workspace

ZI1:
       movb ra,@INWK(ry)               ; STA INWK,Y        ; Zero the Y-th byte of the INWK workspace

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jgt  ZI1                        ; BPL ZI1           ; Loop back for the next byte, ending when we have
                                                           ; zero-filled the last byte at INWK, which leaves Y
                                                           ; with a value of &FF

                                                           ; Finally, we reset the orientation vectors as follows:
                                                           ; 
                                                           ; sidev = (1,  0,  0)
                                                           ; roofv = (0,  1,  0)
                                                           ; nosev = (0,  0, -1)
                                                           ; 
                                                           ; 96 * 256 (&6000) represents 1 in the orientation
                                                           ; vectors, while -96 * 256 (&E000) represents -1. We
                                                           ; already set the vectors to zero above, so we just
                                                           ; need to set up the high bytes of the diagonal values
                                                           ; and we're done. The negative nosev makes the ship
                                                           ; point towards us, as the z-axis points into the screen

       li   ra,>60*256                 ; LDA #96           ; Set A to represent a 1 (in vector terms)

       movb ra,@INWK+18                ; STA INWK+18       ; Set byte #18 = roofv_y_hi = 96 = 1

       movb ra,@INWK+22                ; STA INWK+22       ; Set byte #22 = sidev_x_hi = 96 = 1

       ori  ra,>80*256                 ; ORA #%10000000    ; Flip the sign of A to represent a -1

       movb ra,@INWK+14                ; STA INWK+14       ; Set byte #14 = nosev_z_hi = -96 = -1

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: msblob
* Type: Subroutine
* Category: Dashboard
* Summary: Display the dashboard's missile indicators in green
* 
* ------------------------------------------------------------------------------
* 
* Display the dashboard's missile indicators, with all the missiles reset to
* green/cyan (i.e. not armed or locked).
* 
* ******************************************************************************

msblob_:
       li   rx,>04*256                 ; LDX #4            ; Set up a loop counter in X to count through all four
                                                           ; missile indicators

ss_:
       cb   @NOMSL,rx                  ; CPX NOMSL         ; If the counter is equal to the number of missiles,
       jeq  SAL8                       ; BEQ SAL8          ; jump down to SAL8 to draw the remaining missiles, as
                                                           ; the rest of them are present and should be drawn in
                                                           ; green/cyan

       li   ry,>00*256                 ; LDY #0            ; Draw the missile indicator at position X in black
       .jsr @MSBAR                     ; JSR MSBAR         

       sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile

       jne  ss_                        ; BNE ss            ; Loop back to ss if we still have missiles to draw

       .rts                            ; RTS               ; Return from the subroutine

SAL8:
       li   ry,>ee*256                 ; LDY #&EE          ; Draw the missile indicator at position X in green/cyan
       .jsr @MSBAR                     ; JSR MSBAR         

       sb   rone,rx                    ; DEX               ; Decrement the counter to point to the next missile

       jne  SAL8                       ; BNE SAL8          ; Loop back to SAL8 if we still have missiles to draw

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: me2
* Type: Subroutine
* Category: Flight
* Summary: Remove an in-flight message from the space view
* 
* ******************************************************************************

me2_:
       movb @MCH,ra                    ; LDA MCH           ; Fetch the token number of the current message into A

       .jsr @MESS                      ; JSR MESS          ; Call MESS to print the token, which will remove it
                                                           ; from the screen as printing uses EOR logic

       li   ra,>00*256                 ; LDA #0            ; Set the delay in DLY to 0, so any new in-flight
       movb ra,@DLY                    ; STA DLY           ; messages will be shown instantly

       b    @me3_                      ; JMP me3           ; Jump back into the main spawning loop at me3

* ******************************************************************************
* 
* Name: Ze
* Type: Subroutine
* Category: Universe
* Summary: Initialise the INWK workspace to a hostile ship
* Deep dive: Fixing ship positions
* 
* ------------------------------------------------------------------------------
* 
* Specifically, this routine does the following:
* 
* * Reset the INWK ship workspace
* 
* * Set the ship to a fair distance away in all axes, in front of us but
* randomly up or down, left or right
* 
* * Give the ship a 4% chance of having E.C.M.
* 
* * Set the ship to hostile, with AI enabled
* 
* This routine also sets A, X, T1 and the C flag to random values.
* 
* Note that because this routine uses the value of X returned by DORND, and X
* contains the value of A returned by the previous call to DORND, this routine
* does not necessarily set the new ship to a totally random location. See the
* deep dive on "Fixing ship positions" for details.
* 
* ******************************************************************************

Ze:
       .jsr @ZINF                      ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb ra,@T1                     ; STA T1            ; Store A in T1

       andi ra,>80*256                 ; AND #%10000000    ; Extract the sign of A and store in x_sign
       movb ra,@INWK+2                 ; STA INWK+2        

       movb rx,ra                      ; TXA               ; Extract the sign of X and store in y_sign
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@INWK+5                 ; STA INWK+5        

       li   ra,>20*256                 ; LDA #32           ; Set x_hi = y_hi = z_hi = 32, a fair distance away
       movb ra,@INWK+1                 ; STA INWK+1        
       movb ra,@INWK+4                 ; STA INWK+4        
       movb ra,@INWK+7                 ; STA INWK+7        

       movb rx,ra                      ; TXA               ; Set the C flag if X >= 245 (4% chance)
       ci   ra,>f5*256                 ; CMP #245          

       .rola                           ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 4%
                                                           ; chance of this ship having E.C.M.)

       ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
                                                           ; and has AI (bit 7)

       movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship

                                                           ; Fall through into DORND2 to set A, X and the C flag
                                                           ; randomly

* ******************************************************************************
* 
* Name: DORND
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Generate random numbers
* Deep dive: Generating random numbers
* Fixing ship positions
* 
* ------------------------------------------------------------------------------
* 
* Set A and X to random numbers (though note that X is set to the random number
* that was returned in A the last time DORND was called).
* 
* The C and V flags are also set randomly.
* 
* If we want to generate a repeatable sequence of random numbers, when
* generating explosion clouds, for example, then we call DORND2 to ensure that
* the value of the C flag on entry doesn't affect the outcome, as otherwise we
* might not get the same sequence of numbers if the C flag changes.
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* DORND2              Make sure the C flag doesn't affect the outcome
* 
* ******************************************************************************

DORND2:
       .clc                            ; CLC               ; Clear the C flag so the value of the C flag on entry
                                                           ; doesn't affect the outcome

DORND:
       movb @RAND,ra                   ; LDA RAND          ; Calculate the next two values f2 and f3 in the feeder
       .rola                           ; ROL A             ; sequence:
       movb ra,rx                      ; TAX               ; 
       .adc @RAND+2,ra                 ; ADC RAND+2        ; * f2 = (f1 << 1) mod 256 + C flag on entry
       movb ra,@RAND                   ; STA RAND          ; * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
       movb rx,@RAND+2                 ; STX RAND+2        ; * C flag is set according to the f3 calculation

       movb @RAND+1,ra                 ; LDA RAND+1        ; Calculate the next value m2 in the main sequence:
       movb ra,rx                      ; TAX               ; 
       .adc @RAND+3,ra                 ; ADC RAND+3        ; * A = m2 = m0 + m1 + C flag from feeder calculation
       movb ra,@RAND+1                 ; STA RAND+1        ; * X = m1
       movb rx,@RAND+3                 ; STX RAND+3        ; * C and V flags set according to the m2 calculation

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: Main game loop (Part 1 of 6)
* Type: Subroutine
* Category: Main loop
* Summary: Spawn a trader (a peaceful Cobra Mk III)
* Deep dive: Program flow of the main game loop
* Ship data blocks
* 
* ------------------------------------------------------------------------------
* 
* This is part of the main game loop. This is where the core loop of the game
* lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
* iterated when we are docked, while the entire loop from part 1 to 6 iterates
* if we are in space.
* 
* This section covers the following:
* 
* * Spawn a trader, i.e. a Cobra Mk III that isn't hostile, with a 50% chance
* of it having a missile, a 50% chance of it having an E.C.M., a speed
* between 16 and 31, and a gentle clockwise roll
* 
* We call this from within the main loop, with A set to a random number.
* 
* ******************************************************************************

MTT4:
       srl  ra,1                       ; LSR A             ; Clear bit 7 of our random number in A and set the C
                                                           ; flag to bit 0 of A, which is random

       movb ra,@INWK+32                ; STA INWK+32       ; Store this in the ship's AI flag, so this ship does
                                                           ; not have AI

       movb ra,@INWK+29                ; STA INWK+29       ; Store A in the ship's roll counter, giving it a
                                                           ; clockwise roll (as bit 7 is clear), and a 1 in 127
                                                           ; chance of it having no damping

       .rol @INWK+31                   ; ROL INWK+31       ; Set bit 0 of the ship's missile count randomly (as the
                                                           ; C flag was set), giving the ship either no missiles or
                                                           ; one missile

       andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
       ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
       movb ra,@INWK+27                ; STA INWK+27       

       li   ra,(CYL)*256               ; LDA #CYL          ; Add a new Cobra Mk III to the local bubble and fall
       .jsr @NWSHP                     ; JSR NWSHP         ; through into the main game loop again

* ******************************************************************************
* 
* Name: Main game loop (Part 2 of 6)
* Type: Subroutine
* Category: Main loop
* Summary: Call the main flight loop, and potentially spawn a trader, an
* asteroid, or a cargo canister
* Deep dive: Program flow of the main game loop
* Ship data blocks
* Fixing ship positions
* 
* ------------------------------------------------------------------------------
* 
* This section covers the following:
* 
* * Call M% to do the main flight loop
* 
* * Potentially spawn a trader, asteroid or cargo canister
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TT100               The entry point for the start of the main game loop,
* which calls the main flight loop and the moves into the
* spawning routine
* 
* me3                 Used by me2 to jump back into the main game loop after
* printing an in-flight message
* 
* ******************************************************************************

TT100:
       .jsr @M.                        ; JSR M%            ; Call M% to iterate through the main flight loop

       sb   rone,ra                    ; DEC DLY           ; Decrement the delay counter in DLY, so any in-flight
                                                           ; messages get removed once the counter reaches zero

       jeq  me2_                       ; BEQ me2           ; If DLY is now 0, jump to me2 to remove any in-flight
                                                           ; message from the space view, and once done, return to
                                                           ; me3 below, skipping the following two instructions

       jgt  me3_                       ; BPL me3           ; If DLY is positive, jump to me3 to skip the next
                                                           ; instruction

       ab   rone,ra                    ; INC DLY           ; If we get here, DLY is negative, so we have gone too
                                                           ; and need to increment DLY back to 0

me3_:
       sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter in MCNT

       jeq  B87                        ; BEQ B87           ; If the counter has reached zero, which it will do
                                                           ; every 256 main loops, skip the next JMP instruction
                                                           ; (or to put it another way, if the counter hasn't
                                                           ; reached zero, jump down to MLOOP, skipping all the
                                                           ; following checks)

ytq_:
       b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP to do some end-of-loop tidying and
                                                           ; restart the main loop

                                                           ; We only get here once every 256 iterations of the
                                                           ; main loop. If we aren't in witchspace and don't
                                                           ; already have 3 or more asteroids in our local bubble,
                                                           ; then this section has a 13% chance of spawning
                                                           ; something benign (the other 87% of the time we jump
                                                           ; down to consider spawning cops, pirates and bounty
                                                           ; hunters)
                                                           ; 
                                                           ; If we are in that 13%, then 50% of the time this will
                                                           ; be a Cobra Mk III trader, and the other 50% of the
                                                           ; time it will either be an asteroid (98.5% chance) or,
                                                           ; very rarely, a cargo canister (1.5% chance)

B87:
       movb @MJ,ra                     ; LDA MJ            ; If we are in witchspace following a mis-jump, skip the
       jne  ytq_                       ; BNE ytq           ; following by jumping down to MLOOP (via ytq above)

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>23*256                 ; CMP #35           ; If A >= 35 (87% chance), jump down to MTT1 to skip
       joc  MTT1                       ; BCS MTT1          ; the spawning of an asteroid or cargo canister and
                                                           ; potentially spawn something else

       movb @MANY+AST,ra               ; LDA MANY+AST      ; If we already have 3 or more asteroids in the local
       ci   ra,>03*256                 ; CMP #3            ; bubble, jump down to MTT1 to skip the following and
       joc  MTT1                       ; BCS MTT1          ; potentially spawn something else

       .jsr @ZINF                      ; JSR ZINF          ; Call ZINF to reset the INWK ship workspace

       li   ra,>26*256                 ; LDA #38           ; Set z_hi = 38 (far away)
       movb ra,@INWK+7                 ; STA INWK+7        

       .jsr @DORND                     ; JSR DORND         ; Set A, X and C flag to random numbers

       movb ra,@INWK                   ; STA INWK          ; Set x_lo = random

       movb rx,@INWK+3                 ; STX INWK+3        ; Set y_lo = random
                                                           ; 
                                                           ; Note that because we use the value of X returned by
                                                           ; DORND, and X contains the value of A returned by the
                                                           ; previous call to DORND, this does not set the new ship
                                                           ; to a totally random location. See the deep dive on
                                                           ; "Fixing ship positions" for details

       andi ra,>80*256                 ; AND #%10000000    ; Set x_sign = bit 7 of x_lo
       movb ra,@INWK+2                 ; STA INWK+2        

       movb rx,ra                      ; TXA               ; Set y_sign = bit 7 of y_lo
       andi ra,>80*256                 ; AND #%10000000    
       movb ra,@INWK+5                 ; STA INWK+5        

       .rol @INWK+1                    ; ROL INWK+1        ; Set bit 1 of x_hi to the C flag, which is random, so
       .rol @INWK+1                    ; ROL INWK+1        ; this randomly moves us off-centre by 512 (as if x_hi
                                                           ; is %00000010, then (x_hi x_lo) is 512 + x_lo)

       .jsr @DORND                     ; JSR DORND         ; Set A, X and V flag to random numbers

       .bvs MTT4                       ; BVS MTT4          ; If V flag is set (50% chance), jump up to MTT4 to
                                                           ; spawn a trader

       ori  ra,>6f*256                 ; ORA #%01101111    ; Take the random number in A and set bits 0-3 and 5-6,
       movb ra,@INWK+29                ; STA INWK+29       ; so the result has a 50% chance of being positive or
                                                           ; negative, and a 50% chance of bits 0-6 being 127.
                                                           ; Storing this number in the roll counter therefore
                                                           ; gives our new ship a fast roll speed with a 50%
                                                           ; chance of having no damping, plus a 50% chance of
                                                           ; rolling clockwise or anti-clockwise

       movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station safe zone, jump
       jne  MTT1                       ; BNE MTT1          ; down to MTT1 to skip the following and potentially
                                                           ; spawn something else

       movb rx,ra                      ; TXA               ; Set A to the random X we set above, which we haven't
       joc  MTT2                       ; BCS MTT2          ; used yet, and if the C flag is set (50% chance) jump
                                                           ; down to MTT2 to skip the following

       andi ra,>1f*256                 ; AND #31           ; Set the ship speed to our random number, set to a
       ori  ra,>10*256                 ; ORA #16           ; minimum of 16 and a maximum of 31
       movb ra,@INWK+27                ; STA INWK+27       

       jnc  MTT3                       ; BCC MTT3          ; Jump down to MTT3, skipping the following (this BCC
                                                           ; is effectively a JMP as we know the C flag is clear,
                                                           ; having passed through the BCS above)

MTT2:
       ori  ra,>7f*256                 ; ORA #%01111111    ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
       movb ra,@INWK+30                ; STA INWK+30       ; storing this number in the pitch counter means we have
                                                           ; full pitch with no damping, with a 50% chance of
                                                           ; pitching up or down

MTT3:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>05*256                 ; CMP #5            ; Set A to the ship number of an asteroid, and keep
       li   ra,(AST)*256               ; LDA #AST          ; this value for 98.5% of the time (i.e. if random
       joc  B88                        ; BCS B88           ; A >= 5 then skip the following instruction)

       li   ra,(OIL)*256               ; LDA #OIL          ; Set A to the ship number of a cargo canister

B88:
       .jsr @NWSHP                     ; JSR NWSHP         ; Add our new asteroid or canister to the universe

* ******************************************************************************
* 
* Name: Main game loop (Part 3 of 6)
* Type: Subroutine
* Category: Main loop
* Summary: Potentially spawn a cop, particularly if we've been bad
* Deep dive: Program flow of the main game loop
* Ship data blocks
* Fixing ship positions
* 
* ------------------------------------------------------------------------------
* 
* This section covers the following:
* 
* * Potentially spawn a cop (in a Viper), very rarely if we have been good,
* more often if have been naughty, and very often if we have been properly
* bad
* 
* ******************************************************************************

MTT1:
       movb @SSPR,ra                   ; LDA SSPR          ; If we are inside the space station's safe zone, jump
       jne  MLOOP                      ; BNE MLOOP         ; to MLOOP to skip the following

       .jsr @BAD                       ; JSR BAD           ; Call BAD to work out how much illegal contraband we
                                                           ; are carrying in our hold (A is up to 40 for a
                                                           ; standard hold crammed with contraband, up to 70 for
                                                           ; an extended cargo hold full of narcotics and slaves)

       .asla                           ; ASL A             ; Double A to a maximum of 80 or 140

       movb @MANY+COPS,rx              ; LDX MANY+COPS     ; If there are no cops in the local bubble, skip the
       jeq  B89                        ; BEQ B89           ; next instruction

       socb @FIST,ra                   ; ORA FIST          ; There are cops in the vicinity and we've got a hold
                                                           ; full of jail time, so OR the value in A with FIST to
                                                           ; get a new value that is at least as high as both
                                                           ; values, to reflect the fact that they have almost
                                                           ; certainly scanned our ship

B89:
       movb ra,@T                      ; STA T             ; Store our badness level in T

       .jsr @Ze                        ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
                                                           ; ship, and set A and X to random values
                                                           ; 
                                                           ; Note that because Ze uses the value of X returned by
                                                           ; DORND, and X contains the value of A returned by the
                                                           ; previous call to DORND, this does not set the new ship
                                                           ; to a totally random location. See the deep dive on
                                                           ; "Fixing ship positions" for details

       cb   @T,ra                      ; CMP T             ; If the random value in A >= our badness level, which
       joc  B90                        ; BCS B90           ; will be the case unless we have been really, really
                                                           ; bad, then skip the following two instructions (so
                                                           ; if we are really bad, there's a higher chance of
                                                           ; spawning a cop, otherwise we got away with it, for
                                                           ; now)

       li   ra,(COPS)*256              ; LDA #COPS         ; Add a new police ship to the local bubble
       .jsr @NWSHP                     ; JSR NWSHP         

B90:
       movb @MANY+COPS,ra              ; LDA MANY+COPS     ; If we now have at least one cop in the local bubble,
       jne  MLOOP                      ; BNE MLOOP         ; jump down to MLOOP, otherwise fall through into the
                                                           ; next part to look at spawning something else

* ******************************************************************************
* 
* Name: Main game loop (Part 4 of 6)
* Type: Subroutine
* Category: Main loop
* Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
* pirates
* Deep dive: Program flow of the main game loop
* Ship data blocks
* Fixing ship positions
* 
* ------------------------------------------------------------------------------
* 
* This section covers the following:
* 
* * Potentially spawn (35% chance) either a lone bounty hunter (a Mamba,
* Python or Cobra Mk III), a Thargoid, or a group of up to 4 pirates
* (Sidewinders and/or Mambas)
* 
* ******************************************************************************

       sb   rone,ra                    ; DEC EV            ; Decrement EV, the extra vessels spawning delay, and
       jgt  MLOOP                      ; BPL MLOOP         ; jump to MLOOP if it is still positive, so we only
                                                           ; do the following when the EV counter runs down

       ab   rone,ra                    ; INC EV            ; EV is negative, so bump it up again, setting it back
                                                           ; to 0

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       movb @gov_,ry                   ; LDY gov           ; If the government of this system is 0 (anarchy), jump
       jeq  LABEL_2                    ; BEQ LABEL_2       ; straight to LABEL_2 to start spawning pirates or a
                                                           ; lone bounty hunter

       ci   ra,>5a*256                 ; CMP #90           ; If the random number in A >= 90 (65% chance), jump to
       joc  MLOOP                      ; BCS MLOOP         ; MLOOP to stop spawning (so there's a 35% chance of
                                                           ; spawning pirates or a lone bounty hunter)

       andi ra,>07*256                 ; AND #7            ; Reduce the random number in A to the range 0-7, and
       cb   @gov_,ra                   ; CMP gov           ; if A is less than government of this system, jump
       jnc  MLOOP                      ; BCC MLOOP         ; to MLOOP to stop spawning (so safer governments with
                                                           ; larger gov numbers have a greater chance of jumping
                                                           ; out, which is another way of saying that more
                                                           ; dangerous systems spawn pirates and bounty hunters
                                                           ; more often)

LABEL_2:
                                                           ; Now to spawn a lone bounty hunter, a Thargoid or a
                                                           ; group of pirates
       .jsr @Ze                        ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
                                                           ; ship, and set A and X to random values
                                                           ; 
                                                           ; Note that because Ze uses the value of X returned by
                                                           ; DORND, and X contains the value of A returned by the
                                                           ; previous call to DORND, this does not set the new ship
                                                           ; to a totally random location. See the deep dive on
                                                           ; "Fixing ship positions" for details

       ci   ra,>c8*256                 ; CMP #200          ; If the random number in A >= 200 (13% chance), jump
       joc  mt1_                       ; BCS mt1           ; to mt1 to spawn pirates, otherwise keep going to
                                                           ; spawn a lone bounty hunter or a Thargoid

       ab   rone,ra                    ; INC EV            ; Increase the extra vessels spawning counter, to
                                                           ; prevent the next attempt to spawn extra vessels

       andi ra,>03*256                 ; AND #3            ; Set A = Y = random number in the range 3-6, which
       .adi (>03*256)                  ; ADC #3            ; we will use to determine the type of ship
       movb ra,ry                      ; TAY               

                                                           ; We now build the AI flag for this ship in A

       movb rx,ra                      ; TXA               ; First, copy the random number in X to A

       ci   ra,>c8*256                 ; CMP #200          ; First, set the C flag if X >= 200 (22% chance)

       .rola                           ; ROL A             ; Set bit 0 of A to the C flag (i.e. there's a 22%
                                                           ; chance of this ship having E.C.M.)

       ori  ra,>c0*256                 ; ORA #%11000000    ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
                                                           ; and has AI (bit 7)

       ci   ry,>06*256                 ; CPY #6            ; If Y = 6 (i.e. a Thargoid), jump down to the tha
       jeq  tha_                       ; BEQ tha           ; routine in part 6 to decide whether or not to spawn it
                                                           ; (where there's a 22% chance of this happening)

       movb ra,@INWK+32                ; STA INWK+32       ; Store A in the AI flag of this ship

       movb ry,ra                      ; TYA               ; Add a new ship of type Y to the local bubble, so
       .jsr @NWSHP                     ; JSR NWSHP         ; that's a Mamba, Cobra Mk III or Python

mj1_:
       b    @MLOOP                     ; JMP MLOOP         ; Jump down to MLOOP, as we are done spawning ships

mt1_:
       andi ra,>03*256                 ; AND #3            ; It's time to spawn a group of pirates, so set A to a
                                                           ; random number in the range 0-3, which will be the
                                                           ; loop counter for spawning pirates below (so we will
                                                           ; spawn 1-4 pirates)

       movb ra,@EV                     ; STA EV            ; Delay further spawnings by this number

       movb ra,@XX13                   ; STA XX13          ; Store the number in XX13, the pirate counter

mt3_:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       andi ra,>03*256                 ; AND #3            ; Set A to a random number in the range 0-3

       ori  ra,>01*256                 ; ORA #1            ; Set A to %01 or %11 (Sidewinder or Mamba)

       .jsr @NWSHP                     ; JSR NWSHP         ; Try adding a new ship of type A to the local bubble

       sb   rone,ra                    ; DEC XX13          ; Decrement the pirate counter

       jgt  mt3_                       ; BPL mt3           ; If we need more pirates, loop back up to mt3,
                                                           ; otherwise we are done spawning, so fall through into
                                                           ; the end of the main loop at MLOOP

* ******************************************************************************
* 
* Name: Main game loop (Part 5 of 6)
* Type: Subroutine
* Category: Main loop
* Summary: Cool down lasers, make calls to update the dashboard
* Deep dive: Program flow of the main game loop
* The dashboard indicators
* 
* ------------------------------------------------------------------------------
* 
* This is the first half of the minimal game loop, which we iterate when we are
* docked. This section covers the following:
* 
* * Cool down lasers
* 
* * Make calls to update the dashboard
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* MLOOP               The entry point for the main game loop. This entry point
* comes after the call to the main flight loop and
* spawning routines, so it marks the start of the main
* game loop for when we are docked (as we don't need to
* call the main flight loop or spawning routines if we
* aren't in space)
* 
* ******************************************************************************

MLOOP:
       li   ra,>01*256                 ; LDA #%00000001    ; Set 6522 System VIA interrupt enable register IER
       movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. disable the CA2 interrupt,
                                                           ; which comes from the keyboard)

       li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
       movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
                                                           ; effectively resets the stack

       movb @GNTMP,rx                  ; LDX GNTMP         ; If the laser temperature in GNTMP is non-zero,
       jeq  EE20                       ; BEQ EE20          ; decrement it (i.e. cool it down a bit)
       sb   rone,ra                    ; DEC GNTMP         

EE20:
       .jsr @DIALS                     ; JSR DIALS         ; Call DIALS to update the dashboard

       movb @QQ11,ra                   ; LDA QQ11          ; If this is a space view, skip the following four
       jeq  B91                        ; BEQ B91           ; instructions (i.e. jump to JSR TT17 below)

       .and @PATG                      ; AND PATG          ; If PATG = &FF (author names are shown on start-up)
       srl  ra,1                       ; LSR A             ; and bit 0 of QQ11 is 1 (the current view is type 1),
       joc  B91                        ; BCS B91           ; then skip the following instruction

       .jsr @DELAY-5                   ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds), to
                                                           ; slow the main loop down a bit

B91:
       .jsr @TT17                      ; JSR TT17          ; Scan the keyboard for the cursor keys or joystick,
                                                           ; returning the cursor's delta values in X and Y and
                                                           ; the key pressed in A

* ******************************************************************************
* 
* Name: Main game loop (Part 6 of 6)
* Type: Subroutine
* Category: Main loop
* Summary: Process non-flight key presses (red function keys, docked keys)
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* This is the second half of the minimal game loop, which we iterate when we are
* docked. This section covers the following:
* 
* * Process more key presses (red function keys, docked keys etc.)
* 
* It also supports joining the main loop with a key already "pressed", so we can
* jump into the main game loop to perform a specific action. In practice, this
* is used when we enter the docking bay in BAY to display Status Mode (red key
* f8), and when we finish buying or selling cargo in BAY2 to jump to the
* Inventory (red key f9).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* FRCE                The entry point for the main game loop if we want to
* jump straight to a specific screen, by pretending to
* "press" a key, in which case A contains the internal key
* number of the key we want to "press"
* 
* tha                 Consider spawning a Thargoid (22% chance)
* 
* ******************************************************************************

FRCE:
       .jsr @TT102                     ; JSR TT102         ; Call TT102 to process the key pressed in A

       movb @QQ12,ra                   ; LDA QQ12          ; Fetch the docked flag from QQ12 into A

       jne  MLOOP                      ; BNE MLOOP         ; If we are docked, loop back up to MLOOP just above
                                                           ; to restart the main loop, but skipping all the flight
                                                           ; and spawning code in the top part of the main loop

       b    @TT100                     ; JMP TT100         ; Otherwise jump to TT100 to restart the main loop from
                                                           ; the start

tha_:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       ci   ra,>c8*256                 ; CMP #200          ; If A < 200 (78% chance), skip the next instruction
       jnc  B92                        ; BCC B92           

       .jsr @GTHG                      ; JSR GTHG          ; Call GTHG to spawn a Thargoid ship and a Thargon
                                                           ; companion

B92:
       b    @MLOOP                     ; JMP MLOOP         ; Jump back into the main loop at MLOOP, which is just
                                                           ; after the ship-spawning section

* ******************************************************************************
* 
* Name: TT102
* Type: Subroutine
* Category: Keyboard
* Summary: Process function key, save key, hyperspace and chart key presses
* and update the hyperspace counter
* 
* ------------------------------------------------------------------------------
* 
* Process function key presses, plus "@" (save commander), "H" (hyperspace),
* "D" (show distance to system) and "O" (move chart cursor back to current
* system). We can also pass cursor position deltas in X and Y to indicate that
* the cursor keys or joystick have been used (i.e. the values that are returned
* by routine TT17).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The internal key number of the key pressed (see p.142 of
* the Advanced User Guide for a list of internal key
* numbers)
* 
* X                   The amount to move the crosshairs in the x-axis
* 
* Y                   The amount to move the crosshairs in the y-axis
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* T95                 Print the distance to the selected system
* 
* ******************************************************************************

TT102:
       ci   ra,(f8_)*256               ; CMP #f8           ; If red key f8 was pressed, jump to STATUS to show the
       jne  B93                        ; BNE B93           ; Status Mode screen, returning from the subroutine
       b    @STATUS                    ; JMP STATUS        ; using a tail call

B93:
       ci   ra,(f4_)*256               ; CMP #f4           ; If red key f4 was pressed, jump to TT22 to show the
       jne  B94                        ; BNE B94           ; Long-range Chart, returning from the subroutine using
       b    @TT22                      ; JMP TT22          ; a tail call

B94:
       ci   ra,(f5_)*256               ; CMP #f5           ; If red key f5 was pressed, jump to TT23 to show the
       jne  B95                        ; BNE B95           ; Short-range Chart, returning from the subroutine using
       b    @TT23                      ; JMP TT23          ; a tail call

B95:
       ci   ra,(f6_)*256               ; CMP #f6           ; If red key f6 was pressed, call TT111 to select the
       jne  TT92                       ; BNE TT92          ; system nearest to galactic coordinates (QQ9, QQ10)
       .jsr @TT111                     ; JSR TT111         ; (the location of the chart crosshairs) and jump to
       b    @TT25                      ; JMP TT25          ; TT25 to show the Data on System screen, returning
                                                           ; from the subroutine using a tail call

TT92:
       ci   ra,(f9_)*256               ; CMP #f9           ; If red key f9 was pressed, jump to TT213 to show the
       jne  B96                        ; BNE B96           ; Inventory screen, returning from the subroutine
       b    @TT213                     ; JMP TT213         ; using a tail call

B96:
       ci   ra,(f7_)*256               ; CMP #f7           ; If red key f7 was pressed, jump to TT167 to show the
       jne  B97                        ; BNE B97           ; Market Price screen, returning from the subroutine
       b    @TT167                     ; JMP TT167         ; using a tail call

B97:
       ci   ra,(f0_)*256               ; CMP #f0           ; If red key f0 was pressed, jump to TT110 to launch our
       jne  fvw_                       ; BNE fvw           ; ship (if docked), returning from the subroutine using
       b    @TT110                     ; JMP TT110         ; a tail call

fvw_:
       .bit @QQ12                      ; BIT QQ12          ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
       jgt  INSP                       ; BPL INSP          ; in space), jump to INSP to skip the following checks
                                                           ; for f1-f3 and "@" (save commander file) key presses

       ci   ra,(f3_)*256               ; CMP #f3           ; If red key f3 was pressed, jump to EQSHP to show the
       jne  B98                        ; BNE B98           ; Equip Ship screen, returning from the subroutine using
       b    @EQSHP                     ; JMP EQSHP         ; a tail call

B98:
       ci   ra,(f1_)*256               ; CMP #f1           ; If red key f1 was pressed, jump to TT219 to show the
       jne  B99                        ; BNE B99           ; Buy Cargo screen, returning from the subroutine using
       b    @TT219                     ; JMP TT219         ; a tail call

B99:
       ci   ra,>47*256                 ; CMP #&47          ; If "@" was pressed, jump to SVE to save the commander
       jne  B100                       ; BNE B100          ; file, returning from the subroutine using a tail call
       b    @SVE                       ; JMP SVE           

B100:
       ci   ra,(f2_)*256               ; CMP #f2           ; If red key f2 was pressed, jump to TT208 to show the
       jne  LABEL_3                    ; BNE LABEL_3       ; Sell Cargo screen, returning from the subroutine using
       b    @TT208                     ; JMP TT208         ; a tail call

INSP:
       ci   ra,(f1_)*256               ; CMP #f1           ; If the key pressed is < red key f1 or > red key f3,
       jnc  LABEL_3                    ; BCC LABEL_3       ; jump to LABEL_3 (so only do the following if the key
       ci   ra,(f3_+1)*256             ; CMP #f3+1         ; pressed is f1, f2 or f3)
       joc  LABEL_3                    ; BCS LABEL_3       

       andi ra,>03*256                 ; AND #3            ; If we get here then we are either in space, or we are
       movb ra,rx                      ; TAX               ; docked and none of f1-f3 were pressed, so we can now
       b    @LOOK1                     ; JMP LOOK1         ; process f1-f3 with their in-flight functions, i.e.
                                                           ; switching space views
                                                           ; 
                                                           ; A will contain &71, &72 or &73 (for f1, f2 or f3), so
                                                           ; set X to the last digit (1, 2 or 3) and jump to LOOK1
                                                           ; to switch to view X (rear, left or right), returning
                                                           ; from the subroutine using a tail call

LABEL_3:
       ci   ra,>54*256                 ; CMP #&54          ; If "H" was pressed, jump to hyp to do a hyperspace
       jne  B101                       ; BNE B101          ; jump (if we are in space), returning from the
       b    @hyp_                      ; JMP hyp           ; subroutine using a tail call

B101:
       ci   ra,>32*256                 ; CMP #&32          ; If "D" was pressed, jump to T95 to print the distance
       jeq  T95                        ; BEQ T95           ; to a system (if we are in one of the chart screens)

       movb ra,@T1                     ; STA T1            ; Store A (the key that's been pressed) in T1

       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
       andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise jump down to TT107 to skip the
       jeq  TT107                      ; BEQ TT107         ; following

       movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is non-zero,
       jne  TT107                      ; BNE TT107         ; then we are already counting down, so jump to TT107
                                                           ; to skip the following

       movb @T1,ra                     ; LDA T1            ; Restore the original value of A (the key that's been
                                                           ; pressed) from T1

       ci   ra,>36*256                 ; CMP #&36          ; If "O" was pressed, do the following three jumps,
       jne  ee2_                       ; BNE ee2           ; otherwise skip to ee2 to continue

       .jsr @TT103                     ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
                                                           ; which will erase the crosshairs currently there

       .jsr @ping_                     ; JSR ping          ; Set the target system to the current system (which
                                                           ; will move the location in (QQ9, QQ10) to the current
                                                           ; home system

       .jsr @TT103                     ; JSR TT103         ; Draw small crosshairs at coordinates (QQ9, QQ10),
                                                           ; which will draw the crosshairs at our current home
                                                           ; system

ee2_:
       .jsr @TT16                      ; JSR TT16          ; Call TT16 to move the crosshairs by the amount in X
                                                           ; and Y, which were passed to this subroutine as
                                                           ; arguments

TT107:
       movb @QQ22+1,ra                 ; LDA QQ22+1        ; If the on-screen hyperspace counter is zero, return
       jeq  t95_                       ; BEQ t95           ; from the subroutine (as t95 contains an RTS), as we
                                                           ; are not currently counting down to a hyperspace jump

       sb   rone,ra                    ; DEC QQ22          ; Decrement the internal hyperspace counter

       jne  t95_                       ; BNE t95           ; If the internal hyperspace counter is still non-zero,
                                                           ; then we are still counting down, so return from the
                                                           ; subroutine (as t95 contains an RTS)

                                                           ; If we get here then the internal hyperspace counter
                                                           ; has just reached zero and it wasn't zero before, so
                                                           ; we need to reduce the on-screen counter and update
                                                           ; the screen. We do this by first printing the next
                                                           ; number in the countdown sequence, and then printing
                                                           ; the old number, which will erase the old number
                                                           ; and display the new one because printing uses EOR
                                                           ; logic

       movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter - 1
       sb   rone,rx                    ; DEX               ; (i.e. the next number in the sequence)

       .jsr @ee3_                      ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1)

       li   ra,>05*256                 ; LDA #5            ; Reset the internal hyperspace counter to 5
       movb ra,@QQ22                   ; STA QQ22          

       movb @QQ22+1,rx                 ; LDX QQ22+1        ; Set X = the on-screen hyperspace counter (i.e. the
                                                           ; current number in the sequence, which is already
                                                           ; shown on-screen)

       .jsr @ee3_                      ; JSR ee3           ; Print the 8-bit number in X at text location (0, 1),
                                                           ; i.e. print the hyperspace countdown in the top-left
                                                           ; corner

       sb   rone,ra                    ; DEC QQ22+1        ; Decrement the on-screen hyperspace countdown

       jne  t95_                       ; BNE t95           ; If the countdown is not yet at zero, return from the
                                                           ; subroutine (as t95 contains an RTS)

       b    @TT18                      ; JMP TT18          ; Otherwise the countdown has finished, so jump to TT18
                                                           ; to do a hyperspace jump, returning from the subroutine
                                                           ; using a tail call

t95_:
       .rts                            ; RTS               ; Return from the subroutine

T95:
                                                           ; If we get here, "D" was pressed, so we need to show
                                                           ; the distance to the selected system (if we are in a
                                                           ; chart view)
       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is a chart (QQ11 = 64 or 128),
       andi ra,>c0*256                 ; AND #%11000000    ; keep going, otherwise return from the subroutine (as
       jeq  t95_                       ; BEQ t95           ; t95 contains an RTS)

       .jsr @hm_                       ; JSR hm            ; Call hm to move the crosshairs to the target system
                                                           ; in (QQ9, QQ10), returning with A = 0

       movb ra,@QQ17                   ; STA QQ17          ; Set QQ17 = 0 to switch to ALL CAPS

       .jsr @cpl_                      ; JSR cpl           ; Print control code 3 (the selected system name)

       li   ra,>80*256                 ; LDA #%10000000    ; Set bit 7 of QQ17 to switch to Sentence Case, with the
       movb ra,@QQ17                   ; STA QQ17          ; next letter in capitals

       li   ra,>01*256                 ; LDA #1            ; Move the text cursor to column 1 and down one line
       movb ra,@XC                     ; STA XC            ; (in other words, to the start of the next line)
       ab   rone,ra                    ; INC YC            

       b    @TT146                     ; JMP TT146         ; Print the distance to the selected system and return
                                                           ; from the subroutine using a tail call

* ******************************************************************************
* 
* Name: BAD
* Type: Subroutine
* Category: Status
* Summary: Calculate how bad we have been
* 
* ------------------------------------------------------------------------------
* 
* Work out how bad we are from the amount of contraband in our hold. The
* formula is:
* 
* (slaves + narcotics) * 2 + firearms
* 
* so slaves and narcotics are twice as illegal as firearms. The value in FIST
* (our legal status) is set to at least this value whenever we launch from a
* space station, and a FIST of 50 or more gives us fugitive status, so leaving a
* station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
* across multiple trips, is enough to make us a fugitive.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A value that determines how bad we are from the amount
* of contraband in our hold
* 
* ******************************************************************************

BAD:
       movb @QQ20+3,ra                 ; LDA QQ20+3        ; Set A to the number of tonnes of slaves in the hold

       .clc                            ; CLC               ; Clear the C flag so we can do addition without the
                                                           ; C flag affecting the result

       .adc @QQ20+6,ra                 ; ADC QQ20+6        ; Add the number of tonnes of narcotics in the hold

       .asla                           ; ASL A             ; Double the result and add the number of tonnes of
       .adc @QQ20+10,ra                ; ADC QQ20+10       ; firearms in the hold

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: FAROF
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Compare x_hi, y_hi and z_hi with 224
* 
* ------------------------------------------------------------------------------
* 
* Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
* otherwise clear the C flag.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
* 
* Clear otherwise (i.e. if any one of them are bigger than
* 224)
* 
* ******************************************************************************

FAROF:
       li   ra,>e0*256                 ; LDA #224          ; Set A = 224 and fall through into FAROF2 to do the
                                                           ; comparison

* ******************************************************************************
* 
* Name: FAROF2
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Compare x_hi, y_hi and z_hi with A
* 
* ------------------------------------------------------------------------------
* 
* Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
* otherwise clear the C flag.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
* 
* Clear otherwise (i.e. if any one of them are bigger than
* A)
* 
* ******************************************************************************

FAROF2:
       cb   @INWK+1,ra                 ; CMP INWK+1        ; If A < x_hi, C will be clear so jump to MA34 to
       jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
                                                           ; C will be set so move on to the next one

       cb   @INWK+4,ra                 ; CMP INWK+4        ; If A < y_hi, C will be clear so jump to MA34 to
       jnc  MA34                       ; BCC MA34          ; return from the subroutine with C clear, otherwise
                                                           ; C will be set so move on to the next one

       cb   @INWK+7,ra                 ; CMP INWK+7        ; If A < z_hi, C will be clear, otherwise C will be set

MA34:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: MAS4
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate a cap on the maximum distance to a ship
* 
* ------------------------------------------------------------------------------
* 
* Logical OR the value in A with the high bytes of the ship's position (x_hi,
* y_hi and z_hi).
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A OR x_hi OR y_hi OR z_hi
* 
* ******************************************************************************

MAS4:
       socb @INWK+1,ra                 ; ORA INWK+1        ; OR A with x_hi, y_hi and z_hi
       socb @INWK+4,ra                 ; ORA INWK+4        
       socb @INWK+7,ra                 ; ORA INWK+7        

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DEATH
* Type: Subroutine
* Category: Start and end
* Summary: Display the death screen
* 
* ------------------------------------------------------------------------------
* 
* We have been killed, so display the chaos of our destruction above a "GAME
* OVER" sign, and clean up the mess ready for the next attempt.
* 
* ******************************************************************************

DEATH:
       .jsr @EXNO3                     ; JSR EXNO3         ; Make the sound of us dying

       .jsr @RES2                      ; JSR RES2          ; Reset a number of flight variables and workspaces

       .asl @DELTA                     ; ASL DELTA         ; Divide our speed in DELTA by 4
       .asl @DELTA                     ; ASL DELTA         

       li   rx,>18*256                 ; LDX #24           ; Set the screen to only show 24 text rows, which hides
       .jsr @DET1                      ; JSR DET1          ; the dashboard, setting A to 6 in the process

       .jsr @TT66                      ; JSR TT66          ; Clear the top part of the screen, draw a white border,
                                                           ; and set the current view type in QQ11 to 6 (death
                                                           ; screen)

       .jsr @BOX                       ; JSR BOX           ; Call BOX to redraw the same white border (BOX is part
                                                           ; of TT66), which removes the border as it is drawn
                                                           ; using EOR logic

       .jsr @nWq                       ; JSR nWq           ; Create a cloud of stardust containing the correct
                                                           ; number of dust particles (i.e. NOSTM of them)

       li   ra,>0c*256                 ; LDA #12           ; Move the text cursor to column 12 on row 12
       movb ra,@YC                     ; STA YC            
       movb ra,@XC                     ; STA XC            

       li   ra,>92*256                 ; LDA #146          ; Print recursive token 146 ("{all caps}GAME OVER")
       .jsr @ex_                       ; JSR ex            

D1:
       .jsr @Ze                        ; JSR Ze            ; Call Ze to initialise INWK to a potentially hostile
                                                           ; ship, and set A and X to random values

       srl  ra,1                       ; LSR A             ; Set A = A / 4, so A is now between 0 and 63, and
       srl  ra,1                       ; LSR A             ; store in byte #0 (x_lo)
       movb ra,@INWK                   ; STA INWK          

       li   ry,>00*256                 ; LDY #0            ; Set the following to 0: the current view in QQ11
       movb ry,@QQ11                   ; STY QQ11          ; (space view), x_hi, y_hi, z_hi and the AI flag (no AI
       movb ry,@INWK+1                 ; STY INWK+1        ; or E.C.M. and not hostile)
       movb ry,@INWK+4                 ; STY INWK+4        
       movb ry,@INWK+7                 ; STY INWK+7        
       movb ry,@INWK+32                ; STY INWK+32       

       sb   rone,ry                    ; DEY               ; Set Y = 255

       movb ry,@MCNT                   ; STY MCNT          ; Reset the main loop counter to 255, so all timer-based
                                                           ; calls will be stopped

       movb ry,@LASCT                  ; STY LASCT         ; Set the laser count to 255 to act as a counter in the
                                                           ; D2 loop below, so this setting determines how long the
                                                           ; death animation lasts (it's 5.1 seconds, as LASCT is
                                                           ; decremented every vertical sync, or 50 times a second,
                                                           ; and 255 / 50 = 5.1)

       .eoi (>2a*256)                  ; EOR #%00101010    ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
       movb ra,@INWK+3                 ; STA INWK+3        ; between 48 and 63, and store in byte #3 (y_lo)

       ori  ra,>50*256                 ; ORA #%01010000    ; Set bits 4 and 6 of A to bump it up to between 112 and
       movb ra,@INWK+6                 ; STA INWK+6        ; 127, and store in byte #6 (z_lo)

       movb rx,ra                      ; TXA               ; Set A to the random number in X and keep bits 0-3 and
       andi ra,>8f*256                 ; AND #%10001111    ; the sign in bit 7 to get a number between -15 and +15,
       movb ra,@INWK+29                ; STA INWK+29       ; and store in byte #29 (roll counter) to give our ship
                                                           ; a gentle roll with damping

       .rora                           ; ROR A             ; The C flag is randomly set from the above call to Ze,
       andi ra,>87*256                 ; AND #%10000111    ; so this sets A to a number between -7 and +7, which
       movb ra,@INWK+30                ; STA INWK+30       ; we store in byte #30 (the pitch counter) to give our
                                                           ; ship a very gentle pitch with damping

       .php                            ; PHP               ; Store the processor flags

       li   rx,(OIL)*256               ; LDX #OIL          ; Call fq1 with X set to #OIL, which adds a new cargo
       .jsr @fq1_                      ; JSR fq1           ; canister to our local bubble of universe and points it
                                                           ; away from us with double DELTA speed (i.e. 6, as DELTA
                                                           ; was set to 3 by the call to RES2 above). INF is set to
                                                           ; point to the canister's ship data block in K%

       .plp                            ; PLP               ; Restore the processor flags, including our random C
                                                           ; flag from before

       li   ra,>00*256                 ; LDA #0            ; Set bit 7 of A to our random C flag and store in byte
       .rora                           ; ROR A             ; #31 of the ship's data block, so this has a 50% chance
       li   ry,>1f*256                 ; LDY #31           ; of marking our new canister as being killed (so it
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; will explode)

       movb @FRIN+3,ra                 ; LDA FRIN+3        ; The call we made to RES2 before we entered the loop at
       jeq  D1                         ; BEQ D1            ; D1 will have reset all the ship slots at FRIN, so this
                                                           ; checks to see if the fourth slot is empty, and if it
                                                           ; is we loop back to D1 to add another canister, until
                                                           ; we have added four of them

       .jsr @U.                        ; JSR U%            ; Clear the key logger, which also sets A = 0

       movb ra,@DELTA                  ; STA DELTA         ; Set our speed in DELTA to 0, as we aren't going
                                                           ; anywhere any more

D2:
       .jsr @M.                        ; JSR M%            ; Call the M% routine to do the main flight loop once,
                                                           ; which will display our exploding canister scene and
                                                           ; move everything about

       movb @LASCT,ra                  ; LDA LASCT         ; Loop back to D2 to run the main flight loop until
       jne  D2                         ; BNE D2            ; LASCT reaches zero (which will take 5.1 seconds, as
                                                           ; explained above)

       li   rx,>1f*256                 ; LDX #31           ; Set the screen to show all 31 text rows, which shows
       .jsr @DET1                      ; JSR DET1          ; the dashboard

                                                           ; Fall through into DEATH2 to reset and restart the game

* ******************************************************************************
* 
* Name: DEATH2
* Type: Subroutine
* Category: Start and end
* Summary: Reset most of the game and restart from the title screen
* 
* ------------------------------------------------------------------------------
* 
* This routine is called following death, and when the game is quit by pressing
* ESCAPE when paused.
* 
* ******************************************************************************

DEATH2:
       .jsr @RES2                      ; JSR RES2          ; Reset a number of flight variables and workspaces
                                                           ; and fall through into the entry code for the game
                                                           ; to restart from the title screen

* ******************************************************************************
* 
* Name: TT170
* Type: Subroutine
* Category: Start and end
* Summary: Main entry point for the Elite game code
* Deep dive: Program flow of the main game loop
* 
* ------------------------------------------------------------------------------
* 
* This is the main entry point for the main game code.
* 
* ******************************************************************************

TT170:
       li   rx,>ff*256                 ; LDX #&FF          ; Set the stack pointer to &01FF, which is the standard
       movb rx,@rsplb                  ; TXS               ; location for the 6502 stack, so this instruction
                                                           ; effectively resets the stack. We need to do this
                                                           ; because the loader code in elite-loader.asm pushes
                                                           ; code onto the stack, and this effectively removes that
                                                           ; code so we start afresh

                                                           ; Fall through into BR1 to start the game

* ******************************************************************************
* 
* Name: BR1 (Part 1 of 2)
* Type: Subroutine
* Category: Start and end
* Summary: Show the "Load New Commander (Y/N)?" screen and start the game
* 
* ------------------------------------------------------------------------------
* 
* BRKV is set to point to BR1 by the loading process.
* 
* ******************************************************************************

BR1:
       li   rx,>03*256                 ; LDX #3            ; Set XC = 3 (set text cursor to column 3)
       movb rx,@XC                     ; STX XC            

       .jsr @FX200                     ; JSR FX200         ; Disable the ESCAPE key and clear memory if the BREAK
                                                           ; key is pressed (*FX 200,3)

       li   rx,(CYL)*256               ; LDX #CYL          ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
       li   ra,>80*256                 ; LDA #128          ; token 128 ("  LOAD NEW COMMANDER (Y/N)?{crlf}{crlf}"),
       .jsr @TITLE                     ; JSR TITLE         ; returning with the internal number of the key pressed
                                                           ; in A

       ci   ra,>44*256                 ; CMP #&44          ; Did we press "Y"? If not, jump to QU5, otherwise
       jne  QU5                        ; BNE QU5           ; continue on to load a new commander

* BR1                    \ These instructions are commented out in the original
* LDX #3                 \ source. This block starts with the same *FX call as
* STX XC                 \ above, then clears the screen, calls a routine to
* JSR FX200              \ flush the keyboard buffer (FLKB) that isn't present
* LDA #1                 \ in the cassette version but is in other versions,
* JSR TT66               \ and then it displays "LOAD NEW COMMANDER (Y/N)?" and
* JSR FLKB               \ lists the current cargo, before falling straight into
* LDA #14                \ the load routine below, whether or not we have
* JSR TT214              \ pressed "Y". This may be a bit of testing code, as the
* BCC QU5                \ first line is a commented label, BR1, which is where
                                                           ; BRKV points, so when this is uncommented, pressing
                                                           ; the BREAK key should jump straight to the load screen

       .jsr @GTNME                     ; JSR GTNME         ; We want to load a new commander, so we need to get
                                                           ; the commander name to load

       .jsr @LOD                       ; JSR LOD           ; We then call the LOD subroutine to load the commander
                                                           ; file to address NA%+8, which is where we store the
                                                           ; commander save file

       .jsr @TRNME                     ; JSR TRNME         ; Once loaded, we copy the commander name to NA%

       .jsr @TTX66                     ; JSR TTX66         ; And we clear the top part of the screen and draw a
                                                           ; white border

* ******************************************************************************
* 
* Name: QU5
* Type: Subroutine
* Category: Start and end
* Summary: Reset the current commander data block to the last saved commander
* 
* ******************************************************************************

QU5:
                                                           ; By the time we get here, the correct commander name
                                                           ; is at NA% and the correct commander data is at NA%+8.
                                                           ; Specifically:
                                                           ; 
                                                           ; * If we loaded a commander file, then the name and
                                                           ; data from that file will be at NA% and NA%+8
                                                           ; 
                                                           ; * If this is a brand new game, then NA% will contain
                                                           ; the default starting commander name ("JAMESON")
                                                           ; and NA%+8 will contain the default commander data
                                                           ; 
                                                           ; * If this is not a new game (because they died or
                                                           ; quit) and we didn't want to load a commander file,
                                                           ; then NA% will contain the last saved commander
                                                           ; name, and NA%+8 the last saved commander data. If
                                                           ; the game has never been saved, this will still be
                                                           ; the default commander
* JSR TTX66              \ This instruction is commented out in the original
                                                           ; source; it clears the screen and draws a border
       li   rx,(NT.)*256               ; LDX #NT%          ; The size of the commander data block is NT% bytes,
                                                           ; and it starts at NA%+8, so we need to copy the data
                                                           ; from the "last saved" buffer at NA%+8 to the current
                                                           ; commander workspace at TP. So we set up a counter in X
                                                           ; for the NT% bytes that we want to copy

QUL1:
       movb @NA.+7(rx),ra              ; LDA NA%+7,X       ; Copy the X-th byte of NA%+7 to the X-th byte of TP-1,
       movb ra,@TP-1(rx)               ; STA TP-1,X        ; (the -1 is because X is counting down from NT% to 1)

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  QUL1                       ; BNE QUL1          ; Loop back for the next byte of the commander data
                                                           ; block

       movb rx,@QQ11                   ; STX QQ11          ; X is 0 by the end of the above loop, so this sets QQ11
                                                           ; to 0, which means we will be showing a view without a
                                                           ; boxed title at the top (i.e. we're going to use the
                                                           ; screen layout of a space view in the following)

                                                           ; If the commander check below fails, we keep jumping
                                                           ; back to here to crash the game with an infinite loop

B102:
       .jsr @CHECK                     ; JSR CHECK         ; Call the CHECK subroutine to calculate the checksum
                                                           ; for the current commander block at NA%+8 and put it
                                                           ; in A

       cb   @CHK,ra                    ; CMP CHK           ; Test the calculated checksum against CHK


       nop                             ; NOP               ; If we have disabled checksums, then ignore the result
       nop                             ; NOP               ; of the comparison and fall through into the next part


       jne  B102                       ; BNE B102          ; If the calculated checksum does not match CHK, then
                                                           ; loop back to repeat the check - in other words, we
                                                           ; enter an infinite loop here, as the checksum routine
                                                           ; will keep returning the same incorrect value


                                                           ; The checksum CHK is correct, so now we check whether
                                                           ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
                                                           ; the competition flags at COK gets set, to indicate
                                                           ; to Acornsoft via the competition code that there has
                                                           ; been some hacking going on with this competition entry

       .eoi (>a9*256)                  ; EOR #&A9          ; X = checksum EOR &A9
       movb ra,rx                      ; TAX               

       movb @COK,ra                    ; LDA COK           ; Set A to the competition flags in COK

       cb   @CHK2,rx                   ; CPX CHK2          ; If X = CHK2, then skip the next instruction
       jeq  tZ                         ; BEQ tZ            

       ori  ra,>80*256                 ; ORA #%10000000    ; Set bit 7 of A to indicate this commander file has
                                                           ; been tampered with

tZ:
       ori  ra,>02*256                 ; ORA #%00000010    ; Set bit 1 of A to denote that this is the cassette
                                                           ; version

       movb ra,@COK                    ; STA COK           ; Store the updated competition flags in COK

* ******************************************************************************
* 
* Name: BR1 (Part 2 of 2)
* Type: Subroutine
* Category: Start and end
* Summary: Show the "Press Fire or Space, Commander" screen and start the
* game
* 
* ------------------------------------------------------------------------------
* 
* BRKV is set to point to BR1 by the loading process.
* 
* ******************************************************************************

       .jsr @msblob_                   ; JSR msblob        ; Reset the dashboard's missile indicators so none of
                                                           ; them are targeted

       li   ra,>93*256                 ; LDA #147          ; Call TITLE to show a rotating Mamba (#3) and token
       li   rx,>03*256                 ; LDX #3            ; 147 ("PRESS FIRE OR SPACE,COMMANDER.{crlf}{crlf}"),
       .jsr @TITLE                     ; JSR TITLE         ; returning with the internal number of the key pressed
                                                           ; in A

       .jsr @ping_                     ; JSR ping          ; Set the target system coordinates (QQ9, QQ10) to the
                                                           ; current system coordinates (QQ0, QQ1) we just loaded

       .jsr @hyp1_                     ; JSR hyp1          ; Arrive in the system closest to (QQ9, QQ10)

                                                           ; Fall through into the docking bay routine below

* ******************************************************************************
* 
* Name: BAY
* Type: Subroutine
* Category: Status
* Summary: Go to the docking bay (i.e. show the Status Mode screen)
* 
* ------------------------------------------------------------------------------
* 
* We end up here after the start-up process (load commander etc.), as well as
* after a successful save, an escape pod launch, a successful docking, the end
* of a cargo sell, and various errors (such as not having enough cash, entering
* too many items when buying, trying to fit an item to your ship when you
* already have it, running out of cargo space, and so on).
* 
* ******************************************************************************

BAY:
       li   ra,>ff*256                 ; LDA #&FF          ; Set QQ12 = &FF (the docked flag) to indicate that we
       movb ra,@QQ12                   ; STA QQ12          ; are docked

       li   ra,(f8_)*256               ; LDA #f8           ; Jump into the main loop at FRCE, setting the key
       b    @FRCE                      ; JMP FRCE          ; that's "pressed" to red key f8 (so we show the Status
                                                           ; Mode screen)

* ******************************************************************************
* 
* Name: TITLE
* Type: Subroutine
* Category: Start and end
* Summary: Display a title screen with a rotating ship and prompt
* 
* ------------------------------------------------------------------------------
* 
* Display the title screen, with a rotating ship and a text token at the bottom
* of the screen.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The number of the recursive token to show below the
* rotating ship (see variable QQ18 for details of
* recursive tokens)
* 
* X                   The type of the ship to show (see variable XX21 for a
* list of ship types)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   If a key is being pressed, X contains the internal key
* number, otherwise it contains 0
* 
* ******************************************************************************

TITLE:
       .pha                            ; PHA               ; Store the token number on the stack for later

       movb rx,@TYPE                   ; STX TYPE          ; Store the ship type in location TYPE

       .jsr @RESET                     ; JSR RESET         ; Reset our ship so we can use it for the rotating
                                                           ; title ship

       li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 1

       sb   rone,ra                    ; DEC QQ11          ; Decrement QQ11 to 0, so from here on we are using a
                                                           ; space view

       li   ra,>60*256                 ; LDA #96           ; Set nosev_z hi = 96 (96 is the value of unity in the
       movb ra,@INWK+14                ; STA INWK+14       ; rotation vector)

* LSR A                  \ This instruction is commented out in the original
                                                           ; source. It would halve the value of z_hi to 48, so the
                                                           ; ship would start off closer to the viewer

       movb ra,@INWK+7                 ; STA INWK+7        ; Set z_hi, the high byte of the ship's z-coordinate,
                                                           ; to 96, which is the distance at which the rotating
                                                           ; ship starts out before coming towards us

       li   rx,>7f*256                 ; LDX #127          ; Set roll counter = 127, so don't dampen the roll and
       movb rx,@INWK+29                ; STX INWK+29       ; make the roll direction clockwise

       movb rx,@INWK+30                ; STX INWK+30       ; Set pitch counter = 127, so don't dampen the pitch and
                                                           ; set the pitch direction to dive

       ab   rone,rx                    ; INX               ; Set QQ17 to 128 (so bit 7 is set) to switch to
       movb rx,@QQ17                   ; STX QQ17          ; Sentence Case, with the next letter printing in upper
                                                           ; case

       movb @TYPE,ra                   ; LDA TYPE          ; Set up a new ship, using the ship type in TYPE
       .jsr @NWSHP                     ; JSR NWSHP         

       li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6
       movb ry,@XC                     ; STY XC            

       .jsr @DELAY                     ; JSR DELAY         ; Delay for 6 vertical syncs (6/50 = 0.12 seconds)

       li   ra,>1e*256                 ; LDA #30           ; Print recursive token 144 ("---- E L I T E ----")
       .jsr @plf_                      ; JSR plf           ; followed by a newline

       li   ry,>06*256                 ; LDY #6            ; Move the text cursor to column 6 again
       movb ry,@XC                     ; STY XC            

       ab   rone,ra                    ; INC YC            ; Move the text cursor down a row

       movb @PATG,ra                   ; LDA PATG          ; If PATG = 0, skip the following two lines, which
       jeq  awe_                       ; BEQ awe           ; print the author credits (PATG can be toggled by
                                                           ; pausing the game and pressing "X")

       li   ra,>fe*256                 ; LDA #254          ; Print recursive token 94 ("BY D.BRABEN & I.BELL")
       .jsr @TT27                      ; JSR TT27          

awe_:
       .jsr @CLYNS                     ; JSR CLYNS         ; Clear the bottom three text rows of the upper screen,
                                                           ; and move the text cursor to column 1 on row 21, i.e.
                                                           ; the start of the top row of the three bottom rows.
                                                           ; It also returns with Y = 0

       movb ry,@DELTA                  ; STY DELTA         ; Set DELTA = 0 (i.e. ship speed = 0)

       movb ry,@JSTK                   ; STY JSTK          ; Set JSTK = 0 (i.e. keyboard, not joystick)

       .pla                            ; PLA               ; Restore the recursive token number we stored on the
       .jsr @ex_                       ; JSR ex            ; stack at the start of this subroutine, and print that
                                                           ; token

       li   ra,>94*256                 ; LDA #148          ; Set A to recursive token 148

       li   rx,>07*256                 ; LDX #7            ; Move the text cursor to column 7
       movb rx,@XC                     ; STX XC            

       .jsr @ex_                       ; JSR ex            ; Print recursive token 148 ("(C) ACORNSOFT 1984")

TLL2:
       movb @INWK+7,ra                 ; LDA INWK+7        ; If z_hi (the ship's distance) is 1, jump to TL1 to
       ci   ra,>01*256                 ; CMP #1            ; skip the following decrement
       jeq  TL1                        ; BEQ TL1           

       sb   rone,ra                    ; DEC INWK+7        ; Decrement the ship's distance, to bring the ship
                                                           ; a bit closer to us

TL1:
       .jsr @MVEIT                     ; JSR MVEIT         ; Move the ship in space according to the orientation
                                                           ; vectors and the new value in z_hi

       li   ra,>80*256                 ; LDA #128          ; Set z_lo = 128, so the closest the ship gets to us is
       movb ra,@INWK+6                 ; STA INWK+6        ; z_hi = 1, z_lo = 128, or 256 + 128 = 384

       .asla                           ; ASL A             ; Set A = 0

       movb ra,@INWK                   ; STA INWK          ; Set x_lo = 0, so the ship remains in the screen centre

       movb ra,@INWK+3                 ; STA INWK+3        ; Set y_lo = 0, so the ship remains in the screen centre

       .jsr @LL9                       ; JSR LL9           ; Call LL9 to display the ship

       sb   rone,ra                    ; DEC MCNT          ; Decrement the main loop counter

       movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)

       andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
                                                           ; button is pressed, otherwise it is set, so AND'ing
                                                           ; the value of IRB with %10000 extracts this bit

* TAX                    \ This instruction is commented out in the original
                                                           ; source; it would have no effect, as the comparison
                                                           ; flags are already set by the AND, and the value of X
                                                           ; is not used anywhere

       jeq  TL2                        ; BEQ TL2           ; If the joystick fire button is pressed, jump to TL2

       .jsr @RDKEY                     ; JSR RDKEY         ; Scan the keyboard for a key press

       jeq  TLL2                       ; BEQ TLL2          ; If no key was pressed, loop back up to move/rotate
                                                           ; the ship and check again for a key press

       .rts                            ; RTS               ; Return from the subroutine

TL2:
       sb   rone,ra                    ; DEC JSTK          ; Joystick fire button was pressed, so set JSTK to &FF
                                                           ; (it was set to 0 above), to disable keyboard and
                                                           ; enable joysticks

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: CHECK
* Type: Subroutine
* Category: Save and load
* Summary: Calculate the checksum for the last saved commander data block
* Deep dive: Commander save files
* 
* ------------------------------------------------------------------------------
* 
* The checksum for the last saved commander data block is saved as part of the
* commander file, in two places (CHK AND CHK2), to protect against file
* tampering. This routine calculates the checksum and returns it in A.
* 
* This algorithm is also implemented in elite-checksum.py.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   The checksum for the last saved commander data block
* 
* ******************************************************************************

CHECK:
       li   rx,(NT.-2)*256             ; LDX #NT%-2        ; Set X to the size of the commander data block, less
                                                           ; 2 (to omit the checksum bytes and the save count)

       .clc                            ; CLC               ; Clear the C flag so we can do addition without the
                                                           ; C flag affecting the result

       movb rx,ra                      ; TXA               ; Seed the checksum calculation by setting A to the
                                                           ; size of the commander data block, less 2

                                                           ; We now loop through the commander data block,
                                                           ; starting at the end and looping down to the start
                                                           ; (so at the start of this loop, the X-th byte is the
                                                           ; last byte of the commander data block, i.e. the save
                                                           ; count)

QUL2:
       .adc @NA.+7(rx),ra              ; ADC NA%+7,X       ; Add the X-1-th byte of the data block to A, plus the
                                                           ; C flag

       .eor @NA.+8(rx)                 ; EOR NA%+8,X       ; EOR A with the X-th byte of the data block

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  QUL2                       ; BNE QUL2          ; Loop back for the next byte in the calculation, until
                                                           ; we have added byte #0 and EOR'd with byte #1 of the
                                                           ; data block

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TRNME
* Type: Subroutine
* Category: Save and load
* Summary: Copy the last saved commander's name from INWK to NA%
* 
* ******************************************************************************

TRNME:
       li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
                                                           ; characters, and is terminated by a carriage return,
                                                           ; so set up a counter in X to copy 8 characters

GTL1:
       movb @INWK(rx),ra               ; LDA INWK,X        ; Copy the X-th byte of INWK to the X-th byte of NA%
       movb ra,@NA.(rx)                ; STA NA%,X         

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  GTL1                       ; BPL GTL1          ; Loop back until we have copied all 8 bytes

                                                           ; Fall through into TR1 to copy the name back from NA%
                                                           ; to INWK. This isn't necessary as the name is already
                                                           ; there, but it does save one byte, as we don't need an
                                                           ; RTS here

* ******************************************************************************
* 
* Name: TR1
* Type: Subroutine
* Category: Save and load
* Summary: Copy the last saved commander's name from NA% to INWK
* 
* ******************************************************************************

TR1:
       li   rx,>07*256                 ; LDX #7            ; The commander's name can contain a maximum of 7
                                                           ; characters, and is terminated by a carriage return,
                                                           ; so set up a counter in X to copy 8 characters

GTL2:
       movb @NA.(rx),ra                ; LDA NA%,X         ; Copy the X-th byte of NA% to the X-th byte of INWK
       movb ra,@INWK(rx)               ; STA INWK,X        

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  GTL2                       ; BPL GTL2          ; Loop back until we have copied all 8 bytes

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: GTNME
* Type: Subroutine
* Category: Save and load
* Summary: Fetch the name of a commander file to save or load
* 
* ------------------------------------------------------------------------------
* 
* Get the commander's name for loading or saving a commander file. The name is
* stored in the INWK workspace and is terminated by a return character (13).
* 
* If ESCAPE is pressed or a blank name is entered, then the name stored is set
* to the name from the last saved commander block.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* INWK                The commander name entered, terminated by a return
* character (13)
* 
* ******************************************************************************

GTNME:
       li   ra,>01*256                 ; LDA #1            ; Clear the top part of the screen, draw a white border,
       .jsr @TT66                      ; JSR TT66          ; and set the current view type in QQ11 to 1

       li   ra,>7b*256                 ; LDA #123          ; Print recursive token 123 ("{crlf}COMMANDER'S NAME? ")
       .jsr @TT27                      ; JSR TT27          

       .jsr @DEL8                      ; JSR DEL8          ; Wait for 8/50 of a second (0.16 seconds)

       li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
       movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
                                                           ; which comes from the keyboard)

       li   ra,>0f*256                 ; LDA #15           ; Call OSBYTE with A = 15 (flush all buffers)
       movb ra,rx                      ; TAX               
       .jsr @OSBYTE                    ; JSR OSBYTE        

       li   rx,((RLINE)%256)*256       ; LDX #LO(RLINE)    ; Set (Y X) to point to the RLINE parameter block
       li   ry,((RLINE)/256)*256       ; LDY #HI(RLINE)    ; configuration block below

       li   ra,>00*256                 ; LDA #0            ; Call OSWORD with A = 0 to read a line from the current
       .jsr @OSWORD                    ; JSR OSWORD        ; input stream (i.e. the keyboard)

* LDA #%00000001         \ These instructions are commented out in the original
* STA VIA+&4E            \ source, but they would set 6522 System VIA interrupt
                                                           ; enable register IER (SHEILA &4E) bit 1 (i.e. disable
                                                           ; the CA2 interrupt, which comes from the keyboard)

       joc  TR1                        ; BCS TR1           ; The C flag will be set if we pressed ESCAPE when
                                                           ; entering the name, in which case jump to TR1 to copy
                                                           ; the last saved commander's name from NA% to INWK
                                                           ; and return from the subroutine there

       movb ry,ra                      ; TYA               ; The OSWORD call returns the length of the commander's
                                                           ; name in Y, so transfer this to A

       jeq  TR1                        ; BEQ TR1           ; If A = 0, no name was entered, so jump to TR1 to copy
                                                           ; the last saved commander's name from NA% to INWK
                                                           ; and return from the subroutine there

       b    @TT67                      ; JMP TT67          ; We have a name, so jump to TT67 to print a newline
                                                           ; and return from the subroutine using a tail call

* ******************************************************************************
* 
* Name: RLINE
* Type: Variable
* Category: Text
* Summary: The OSWORD configuration block used to fetch a line of text from
* the keyboard
* 
* ******************************************************************************

RLINE:
       data >0000                                                    ; The address to store the input, so the commander's
                                                                     ; name will be stored in INWK as it is typed

       byte >07                                                      ; Maximum line length = 7, as that's the maximum size
                                                                     ; for a commander's name

       byte >00                                                      ; Allow ASCII characters from "!" through to "z" in
       byte >00                                                      ; the name

* ******************************************************************************
* 
* Name: ZERO
* Type: Subroutine
* Category: Utility routines
* Summary: Zero-fill pages &9, &A, &B, &C and &D
* 
* ------------------------------------------------------------------------------
* 
* This resets the following workspaces to zero:
* 
* * The ship data blocks ascending from K% at &0900
* 
* * The ship line heap descending from WP at &0D40
* 
* * WP workspace variables from FRIN to de, which include the ship slots for
* the local bubble of universe, and various flight and ship status variables
* (only a portion of the LSX/LSO sun line heap is cleared)
* 
* ******************************************************************************

ZERO:
       li   rx,>0d*256                 ; LDX #&D           ; Point X to page &D

ZEL:
       .jsr @ZES1                      ; JSR ZES1          ; Call ZES1 to zero-fill the page in X

       sb   rone,rx                    ; DEX               ; Decrement X to point to the next page

       ci   rx,>09*256                 ; CPX #9            ; If X is > 9 (i.e. is &A, &B or &C), then loop back
       jne  ZEL                        ; BNE ZEL           ; up to clear the next page

                                                           ; Then fall through into ZES1 with X set to 9, so we
                                                           ; clear page &9 too

* ******************************************************************************
* 
* Name: ZES1
* Type: Subroutine
* Category: Utility routines
* Summary: Zero-fill the page whose number is in X
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The page we want to zero-fill
* 
* ******************************************************************************

ZES1:
       li   ry,>00*256                 ; LDY #0            ; If we set Y = SC = 0 and fall through into ZES2
       movb ry,@SC                     ; STY SC            ; below, then we will zero-fill 255 bytes starting from
                                                           ; SC - in other words, we will zero-fill the whole of
                                                           ; page X

* ******************************************************************************
* 
* Name: ZES2
* Type: Subroutine
* Category: Utility routines
* Summary: Zero-fill a specific page
* 
* ------------------------------------------------------------------------------
* 
* Zero-fill from address (X SC) + Y to (X SC) + &FF.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The high byte (i.e. the page) of the starting point of
* the zero-fill
* 
* Y                   The offset from (X SC) where we start zeroing, counting
* up to &FF
* 
* SC                  The low byte (i.e. the offset into the page) of the
* starting point of the zero-fill
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* Z flag              Z flag is set
* 
* ******************************************************************************

ZES2:
       li   ra,>00*256                 ; LDA #0            ; Load A with the byte we want to fill the memory block
                                                           ; with - i.e. zero

       movb rx,@SC+1                   ; STX SC+1          ; We want to zero-fill page X, so store this in the
                                                           ; high byte of SC, so the 16-bit address in SC and
                                                           ; SC+1 is now pointing to the SC-th byte of page X

ZEL1:
       .st_ind_y_idx @SC,ra            ; STA (SC),Y        ; Zero the Y-th byte of the block pointed to by SC,
                                                           ; so that's effectively the Y-th byte before SC

       ab   rone,ry                    ; INY               ; Increment the loop counter

       jne  ZEL1                       ; BNE ZEL1          ; Loop back to zero the next byte

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: SVE
* Type: Subroutine
* Category: Save and load
* Summary: Save the commander file
* Deep dive: Commander save files
* The competition code
* 
* ******************************************************************************

SVE:
       .jsr @GTNME                     ; JSR GTNME         ; Clear the screen and ask for the commander filename
                                                           ; to save, storing the name at INWK

       .jsr @TRNME                     ; JSR TRNME         ; Transfer the commander filename from INWK to NA%

       .jsr @ZERO                      ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
                                                           ; the ship data blocks, the ship line heap, the ship
                                                           ; slots for the local bubble of universe, and various
                                                           ; flight and ship status variables

       .lsr @SVC                       ; LSR SVC           ; Halve the save count value in SVC

       li   rx,(NT.)*256               ; LDX #NT%          ; We now want to copy the current commander data block
                                                           ; from location TP to the last saved commander block at
                                                           ; NA%+8, so set a counter in X to copy the NT% bytes in
                                                           ; the commander data block
                                                           ; 
                                                           ; We also want to copy the data block to another
                                                           ; location &0B00, which is normally used for the ship
                                                           ; lines heap

SVL1:
       movb @TP(rx),ra                 ; LDA TP,X          ; Copy the X-th byte of TP to the X-th byte of &0B00
       movb ra,@>0B00(rx)              ; STA &0B00,X       ; and NA%+8
       movb ra,@NA.+8(rx)              ; STA NA%+8,X       

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  SVL1                       ; BPL SVL1          ; Loop back until we have copied all the bytes in the
                                                           ; commander data block

       .jsr @CHECK                     ; JSR CHECK         ; Call CHECK to calculate the checksum for the last
                                                           ; saved commander and return it in A

       movb ra,@CHK                    ; STA CHK           ; Store the checksum in CHK, which is at the end of the
                                                           ; last saved commander block

       .pha                            ; PHA               ; Store the checksum on the stack

       ori  ra,>80*256                 ; ORA #%10000000    ; Set K = checksum with bit 7 set
       movb ra,@K                      ; STA K             

       .eor @COK                       ; EOR COK           ; Set K+2 = K EOR COK (the competition flags)
       movb ra,@K+2                    ; STA K+2           

       .eor @CASH+2                    ; EOR CASH+2        ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
       movb ra,@K+1                    ; STA K+1           

       .eoi (>5a*256)                  ; EOR #&5A          ; Set K+3 = K+1 EOR &5A EOR TALLY+1 (the high byte of
       .eor @TALLY+1                   ; EOR TALLY+1       ; the kill tally)
       movb ra,@K+3                    ; STA K+3           

       .jsr @BPRNT                     ; JSR BPRNT         ; Print the competition number stored in K to K+3. The
                                                           ; value of U might affect how this is printed, and as
                                                           ; it's a temporary variable in zero page that isn't
                                                           ; reset by ZERO, it might have any value, but as the
                                                           ; competition code is a 10-digit number, this just means
                                                           ; it may or may not have an extra space of padding

       .jsr @TT67                      ; JSR TT67          ; Call TT67 twice to print two newlines
       .jsr @TT67                      ; JSR TT67          

       .pla                            ; PLA               ; Restore the checksum from the stack

       movb ra,@>0B00+NT.              ; STA &0B00+NT%     ; Store the checksum in the last byte of the save file
                                                           ; at &0B00 (the equivalent of CHK in the last saved
                                                           ; block)

       .eoi (>a9*256)                  ; EOR #&A9          ; Store the checksum EOR &A9 in CHK2, the penultimate
       movb ra,@CHK2                   ; STA CHK2          ; byte of the last saved commander block

       movb ra,@>0AFF+NT.              ; STA &0AFF+NT%     ; Store the checksum EOR &A9 in the penultimate byte of
                                                           ; the save file at &0B00 (the equivalent of CHK2 in the
                                                           ; last saved block)

       li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
       movb ry,@>0C0B                  ; STY &0C0B         ; 
       ab   rone,ry                    ; INY               ; Start address for save = &00000B00 in &0C0A to &0C0D
       movb ry,@>0C0F                  ; STY &0C0F         ; 
                                                           ; End address for save = &00000C00 in &0C0E to &0C11
                                                           ; 
                                                           ; Y is left containing &C which we use below

       li   ra,>81*256                 ; LDA #%10000001    ; Clear 6522 System VIA interrupt enable register IER
       movb ra,@VIA+>4E                ; STA VIA+&4E       ; (SHEILA &4E) bit 1 (i.e. enable the CA2 interrupt,
                                                           ; which comes from the keyboard)

       ab   rone,ra                    ; INC SVN           ; Increment SVN to indicate we are about to start saving

       li   ra,>00*256                 ; LDA #0            ; Call QUS1 with A = 0, Y = &C to save the commander
       .jsr @QUS1                      ; JSR QUS1          ; file with the filename we copied to INWK at the start
                                                           ; of this routine

       li   rx,>00*256                 ; LDX #0            ; Set X = 0 for storing in SVN below

* STX VIA+&4E            \ This instruction is commented out in the original
                                                           ; source. It would affect the 6522 System VIA interrupt
                                                           ; enable register IER (SHEILA &4E) if any of bits 0-6
                                                           ; of X were set, but they aren't, so this instruction
                                                           ; would have no effect anyway

* DEX                    \ This instruction is commented out in the original
                                                           ; source. It would end up setting SVN to &FF, which
                                                           ; affects the logic in the IRQ1 handler

       movb rx,@SVN                    ; STX SVN           ; Set SVN to 0 to indicate we are done saving

       b    @BAY                       ; JMP BAY           ; Go to the docking bay (i.e. show Status Mode)

* ******************************************************************************
* 
* Name: QUS1
* Type: Subroutine
* Category: Save and load
* Summary: Save or load the commander file
* Deep dive: Commander save files
* 
* ------------------------------------------------------------------------------
* 
* The filename should be stored at INWK, terminated with a carriage return (13).
* The routine should be called with Y set to &C.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   File operation to be performed. Can be one of the
* following:
* 
* * 0 (save file)
* 
* * &FF (load file)
* 
* Y                   Points to the page number containing the OSFILE block,
* which must be &C because that's where the pointer to the
* filename in INWK is stored below (by the STX &0C00
* instruction)
* 
* ******************************************************************************

QUS1:
       li   rx,(INWK)*256              ; LDX #INWK         ; Store a pointer to INWK at the start of the block at
       movb rx,@>0C00                  ; STX &0C00         ; &0C00, storing #INWK in the low byte because INWK is
                                                           ; in zero page

       li   rx,>00*256                 ; LDX #0            ; Set X to 0 so (Y X) = &0C00

       b    @OSFILE                    ; JMP OSFILE        ; Jump to OSFILE to do the file operation specified in
                                                           ; &0C00 (i.e. save or load a file depending on the value
                                                           ; of A), returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: LOD
* Type: Subroutine
* Category: Save and load
* Summary: Load a commander file
* 
* ------------------------------------------------------------------------------
* 
* The filename should be stored at INWK, terminated with a carriage return (13).
* 
* ******************************************************************************

LOD:
       li   rx,>02*256                 ; LDX #2            ; Enable the ESCAPE key and clear memory if the BREAK
       .jsr @FX200                     ; JSR FX200         ; key is pressed (*FX 200,2)

       .jsr @ZERO                      ; JSR ZERO          ; Zero-fill pages &9, &A, &B, &C and &D, which clears
                                                           ; the ship data blocks, the ship line heap, the ship
                                                           ; slots for the local bubble of universe, and various
                                                           ; flight and ship status variables

       li   ry,>0b*256                 ; LDY #&B           ; Set up an OSFILE block at &0C00, containing:
       movb ry,@>0C03                  ; STY &0C03         ; 
       ab   rone,ra                    ; INC &0C0B         ; Load address = &00000B00 in &0C02 to &0C05
                                                           ; 
                                                           ; Length of file = &00000100 in &0C0A to &0C0D

       ab   rone,ry                    ; INY               ; Increment Y to &C, which we use next

       li   ra,>ff*256                 ; LDA #&FF          ; Call QUS1 with A = &FF, Y = &C to load the commander
       .jsr @QUS1                      ; JSR QUS1          ; file to address &0B00

       movb @>0B00,ra                  ; LDA &0B00         ; If the first byte of the loaded file has bit 7 set,
       jlt  SPS1+1                     ; BMI SPS1+1        ; jump to SPS+1, which is the second byte of an LDA #0
                                                           ; instruction, i.e. a BRK instruction, which will force
                                                           ; an interrupt to call the address in BRKV, which is set
                                                           ; to BR1... so this instruction restarts the game from
                                                           ; the title screen. Valid commander files for the
                                                           ; cassette version of Elite only have 0 for the first
                                                           ; byte, as there are no missions in this version, so
                                                           ; having bit 7 set is invalid anyway

       li   rx,(NT.)*256               ; LDX #NT%          ; We have successfully loaded the commander file at
                                                           ; &0B00, so now we want to copy it to the last saved
                                                           ; commander data block at NA%+8, so we set up a counter
                                                           ; in X to copy NT% bytes

LOL1:
       movb @>0B00(rx),ra              ; LDA &0B00,X       ; Copy the X-th byte of &0B00 to the X-th byte of NA%+8
       movb ra,@NA.+8(rx)              ; STA NA%+8,X       

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  LOL1                       ; BPL LOL1          ; Loop back until we have copied all NT% bytes

       li   rx,>03*256                 ; LDX #3            ; Fall through into FX200 to disable the ESCAPE key and
                                                           ; clear memory if the BREAK key is pressed (*FX 200,3)
                                                           ; and return from the subroutine there

* ******************************************************************************
* 
* Name: FX200
* Type: Subroutine
* Category: Utility routines
* Summary: Set the behaviour of the ESCAPE and BREAK keys
* 
* ------------------------------------------------------------------------------
* 
* This is the equivalent of a *FX 200 command, which controls the behaviour of
* the ESCAPE and BREAK keys.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   Controls the behaviour as follows:
* 
* * 0 = Enable ESCAPE key
* Normal BREAK key action
* 
* * 1 = Disable ESCAPE key
* Normal BREAK key action
* 
* * 2 = Enable ESCAPE key
* Clear memory if the BREAK key is pressed
* 
* * 3 = Disable ESCAPE key
* Clear memory if the BREAK key is pressed
* 
* ******************************************************************************

FX200:
       li   ry,>00*256                 ; LDY #0            ; Call OSBYTE 200 with Y = 0, so the new value is set to
       li   ra,>c8*256                 ; LDA #200          ; X, and return from the subroutine using a tail call
       b    @OSBYTE                    ; JMP OSBYTE        

       .rts                            ; RTS               ; This instruction has no effect, as we already returned
                                                           ; from the subroutine

* ******************************************************************************
* 
* Name: SPS1
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate the vector to the planet and store it in XX15
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* SPS1+1              A BRK instruction
* 
* ******************************************************************************

SPS1:
       li   rx,>00*256                 ; LDX #0            ; Copy the two high bytes of the planet's x-coordinate
       .jsr @SPS3                      ; JSR SPS3          ; into K3(2 1 0), separating out the sign bit into K3+2

       li   rx,>03*256                 ; LDX #3            ; Copy the two high bytes of the planet's y-coordinate
       .jsr @SPS3                      ; JSR SPS3          ; into K3(5 4 3), separating out the sign bit into K3+5

       li   rx,>06*256                 ; LDX #6            ; Copy the two high bytes of the planet's z-coordinate
       .jsr @SPS3                      ; JSR SPS3          ; into K3(8 7 6), separating out the sign bit into K3+8

                                                           ; Fall through into TAS2 to build XX15 from K3

* ******************************************************************************
* 
* Name: TAS2
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Normalise the three-coordinate vector in K3
* 
* ------------------------------------------------------------------------------
* 
* Normalise the vector in K3, which has 16-bit values and separate sign bits,
* and store the normalised version in XX15 as a signed 8-bit vector.
* 
* A normalised vector (also known as a unit vector) has length 1, so this
* routine takes an existing vector in K3 and scales it so the length of the
* new vector is 1. This is used in two places: when drawing the compass, and
* when applying AI tactics to ships.
* 
* We do this in two stages. This stage shifts the 16-bit vector coordinates in
* K3 to the left as far as they will go without losing any bits off the end, so
* we can then take the high bytes and use them as the most accurate 8-bit vector
* to normalise. Then the next stage (in routine NORM) does the normalisation.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
* x_sign is just bit 7
* 
* K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
* y_sign is just bit 7
* 
* K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
* z_sign is just bit 7
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* XX15                The normalised vector, with:
* 
* * The x-coordinate in XX15
* 
* * The y-coordinate in XX15+1
* 
* * The z-coordinate in XX15+2
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* TA2                 Calculate the length of the vector in XX15 (ignoring the
* low coordinates), returning it in Q
* 
* ******************************************************************************

TAS2:
       movb @K3,ra                     ; LDA K3            ; OR the three low bytes and 1 to get a byte that has
       socb @K3+3,ra                   ; ORA K3+3          ; a 1 wherever any of the three low bytes has a 1
       socb @K3+6,ra                   ; ORA K3+6          ; (as well as always having bit 0 set), and store in
       ori  ra,>01*256                 ; ORA #1            ; K3+9
       movb ra,@K3+9                   ; STA K3+9          

       movb @K3+1,ra                   ; LDA K3+1          ; OR the three high bytes to get a byte in A that has a
       socb @K3+4,ra                   ; ORA K3+4          ; 1 wherever any of the three high bytes has a 1
       socb @K3+7,ra                   ; ORA K3+7          

                                                           ; (A K3+9) now has a 1 wherever any of the 16-bit
                                                           ; values in K3 has a 1
TAL2:
       .asl @K3+9                      ; ASL K3+9          ; Shift (A K3+9) to the left, so bit 7 of the high byte
       .rola                           ; ROL A             ; goes into the C flag

       joc  TA2                        ; BCS TA2           ; If the left shift pushed a 1 out of the end, then we
                                                           ; know that at least one of the coordinates has a 1 in
                                                           ; this position, so jump to TA2 as we can't shift the
                                                           ; values in K3 any further to the left

       .asl @K3                        ; ASL K3            ; Shift K3(1 0), the x-coordinate, to the left
       .rol @K3+1                      ; ROL K3+1          

       .asl @K3+3                      ; ASL K3+3          ; Shift K3(4 3), the y-coordinate, to the left
       .rol @K3+4                      ; ROL K3+4          

       .asl @K3+6                      ; ASL K3+6          ; Shift K3(6 7), the z-coordinate, to the left
       .rol @K3+7                      ; ROL K3+7          

       jnc  TAL2                       ; BCC TAL2          ; Jump back to TAL2 to do another shift left (this BCC
                                                           ; is effectively a JMP as we know bit 7 of K3+7 is not a
                                                           ; 1, as otherwise bit 7 of A would have been a 1 and we
                                                           ; would have taken the BCS above)

TA2:
       movb @K3+1,ra                   ; LDA K3+1          ; Fetch the high byte of the x-coordinate from our left-
       srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
       socb @K3+2,ra                   ; ORA K3+2          ; sign bit in there from the x_sign part of K3, and
       movb ra,@XX15                   ; STA XX15          ; store the resulting signed 8-bit x-coordinate in XX15

       movb @K3+4,ra                   ; LDA K3+4          ; Fetch the high byte of the y-coordinate from our left-
       srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
       socb @K3+5,ra                   ; ORA K3+5          ; sign bit in there from the y_sign part of K3, and
       movb ra,@XX15+1                 ; STA XX15+1        ; store the resulting signed 8-bit y-coordinate in
                                                           ; XX15+1

       movb @K3+7,ra                   ; LDA K3+7          ; Fetch the high byte of the z-coordinate from our left-
       srl  ra,1                       ; LSR A             ; shifted K3, shift it right to clear bit 7, stick the
       socb @K3+8,ra                   ; ORA K3+8          ; sign bit in there from the z_sign part of K3, and
       movb ra,@XX15+2                 ; STA XX15+2        ; store the resulting signed 8-bit  z-coordinate in
                                                           ; XX15+2

                                                           ; Now we have a signed 8-bit version of the vector K3 in
                                                           ; XX15, so fall through into NORM to normalise it

* ******************************************************************************
* 
* Name: NORM
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Normalise the three-coordinate vector in XX15
* Deep dive: Tidying orthonormal vectors
* Orientation vectors
* 
* ------------------------------------------------------------------------------
* 
* We do this by dividing each of the three coordinates by the length of the
* vector, which we can calculate using Pythagoras. Once normalised, 96 (&60) is
* used to represent a value of 1, and 96 with bit 7 set (&E0) is used to
* represent -1. This enables us to represent fractional values of less than 1
* using integers.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX15                The vector to normalise, with:
* 
* * The x-coordinate in XX15
* 
* * The y-coordinate in XX15+1
* 
* * The z-coordinate in XX15+2
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* XX15                The normalised vector
* 
* Q                   The length of the original XX15 vector
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* NO1                 Contains an RTS
* 
* ******************************************************************************

NORM:
       movb @XX15,ra                   ; LDA XX15          ; Fetch the x-coordinate into A

       .jsr @SQUA                      ; JSR SQUA          ; Set (A P) = A * A = x^2

       movb ra,@R                      ; STA R             ; Set (R Q) = (A P) = x^2
       movb @P,ra                      ; LDA P             
       movb ra,@Q                      ; STA Q             

       movb @XX15+1,ra                 ; LDA XX15+1        ; Fetch the y-coordinate into A

       .jsr @SQUA                      ; JSR SQUA          ; Set (A P) = A * A = y^2

       movb ra,@T                      ; STA T             ; Set (T P) = (A P) = y^2

       movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
       .adc @Q,ra                      ; ADC Q             ; 
       movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P

       movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
       .adc @R,ra                      ; ADC R             
       movb ra,@R                      ; STA R             

       movb @XX15+2,ra                 ; LDA XX15+2        ; Fetch the z-coordinate into A

       .jsr @SQUA                      ; JSR SQUA          ; Set (A P) = A * A = z^2

       movb ra,@T                      ; STA T             ; Set (T P) = (A P) = z^2

       movb @P,ra                      ; LDA P             ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
       .adc @Q,ra                      ; ADC Q             ; 
       movb ra,@Q                      ; STA Q             ; First, doing the low bytes, Q = Q + P

       movb @T,ra                      ; LDA T             ; And then the high bytes, R = R + T
       .adc @R,ra                      ; ADC R             
       movb ra,@R                      ; STA R             

       .jsr @LL5                       ; JSR LL5           ; We now have the following:
                                                           ; 
                                                           ; (R Q) = x^2 + y^2 + z^2
                                                           ; 
                                                           ; so we can call LL5 to use Pythagoras to get:
                                                           ; 
                                                           ; Q = SQRT(R Q)
                                                           ; = SQRT(x^2 + y^2 + z^2)
                                                           ; 
                                                           ; So Q now contains the length of the vector (x, y, z),
                                                           ; and we can normalise the vector by dividing each of
                                                           ; the coordinates by this value, which we do by calling
                                                           ; routine TIS2. TIS2 returns the divided figure, using
                                                           ; 96 to represent 1 and 96 with bit 7 set for -1

       movb @XX15,ra                   ; LDA XX15          ; Call TIS2 to divide the x-coordinate in XX15 by Q,
       .jsr @TIS2                      ; JSR TIS2          ; with 1 being represented by 96
       movb ra,@XX15                   ; STA XX15          

       movb @XX15+1,ra                 ; LDA XX15+1        ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
       .jsr @TIS2                      ; JSR TIS2          ; with 1 being represented by 96
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX15+2,ra                 ; LDA XX15+2        ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
       .jsr @TIS2                      ; JSR TIS2          ; with 1 being represented by 96
       movb ra,@XX15+2                 ; STA XX15+2        

NO1:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: RDKEY
* Type: Subroutine
* Category: Keyboard
* Summary: Scan the keyboard for key presses
* 
* ------------------------------------------------------------------------------
* 
* Scan the keyboard, starting with internal key number 16 ("Q") and working
* through the set of internal key numbers (see p.142 of the Advanced User Guide
* for a list of internal key numbers).
* 
* This routine is effectively the same as OSBYTE 122, though the OSBYTE call
* preserves A, unlike this routine.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   If a key is being pressed, X contains the internal key
* number, otherwise it contains 0
* 
* A                   Contains the same as X
* 
* ******************************************************************************

RDKEY:
       li   rx,>10*256                 ; LDX #16           ; Start the scan with internal key number 16 ("Q")

Rd1:
       .jsr @DKS4                      ; JSR DKS4          ; Scan the keyboard to see if the key in X is currently
                                                           ; being pressed, returning the result in A and X

       jlt  Rd2                        ; BMI Rd2           ; Jump to Rd2 if this key is being pressed (in which
                                                           ; case DKS4 will have returned the key number with bit
                                                           ; 7 set, which is negative)

       ab   rone,rx                    ; INX               ; Increment the key number, which was unchanged by the
                                                           ; above call to DKS4

       jgt  Rd1                        ; BPL Rd1           ; Loop back to test the next key, ending the loop when
                                                           ; X is negative (i.e. 128)

       movb rx,ra                      ; TXA               ; If we get here, nothing is being pressed, so copy X
                                                           ; into A so that X = A = 128 = %10000000

Rd2:
       .eoi (>80*256)                  ; EOR #%10000000    ; EOR A with #%10000000 to flip bit 7, so A now contains
                                                           ; 0 if no key has been pressed, or the internal key
                                                           ; number if a key has been pressed

       movb ra,rx                      ; TAX               ; Copy A into X

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: ECMOF
* Type: Subroutine
* Category: Sound
* Summary: Switch off the E.C.M.
* 
* ------------------------------------------------------------------------------
* 
* Switch the E.C.M. off, turn off the dashboard bulb and make the sound of the
* E.C.M. switching off).
* 
* ******************************************************************************

ECMOF:
       li   ra,>00*256                 ; LDA #0            ; Set ECMA and ECMP to 0 to indicate that no E.C.M. is
       movb ra,@ECMA                   ; STA ECMA          ; currently running
       movb ra,@ECMP                   ; STA ECMP          

       .jsr @ECBLB                     ; JSR ECBLB         ; Update the E.C.M. indicator bulb on the dashboard

       li   ra,>48*256                 ; LDA #72           ; Call the NOISE routine with A = 72 to make the sound
       jne  NOISE                      ; BNE NOISE         ; of the E.C.M. being turned off and return from the
                                                           ; subroutine using a tail call (this BNE is effectively
                                                           ; a JMP as A will never be zero)

* ******************************************************************************
* 
* Name: EXNO3
* Type: Subroutine
* Category: Sound
* Summary: Make an explosion sound
* 
* ------------------------------------------------------------------------------
* 
* Make the sound of death in the cold, hard vacuum of space. Apparently, in
* Elite space, everyone can hear you scream.
* 
* This routine also makes the sound of a destroyed cargo canister if we don't
* get scooping right, the sound of us colliding with another ship, and the sound
* of us being hit with depleted shields. It is not a good sound to hear.
* 
* ******************************************************************************

EXNO3:
       li   ra,>10*256                 ; LDA #16           ; Call the NOISE routine with A = 16 to make the first
       .jsr @NOISE                     ; JSR NOISE         ; death sound

       li   ra,>18*256                 ; LDA #24           ; Call the NOISE routine with A = 24 to make the second
       jne  NOISE                      ; BNE NOISE         ; death sound and return from the subroutine using a
                                                           ; tail call (this BNE is effectively a JMP as A will
                                                           ; never be zero)

* ******************************************************************************
* 
* Name: SFRMIS
* Type: Subroutine
* Category: Tactics
* Summary: Add an enemy missile to our local bubble of universe
* 
* ------------------------------------------------------------------------------
* 
* An enemy has fired a missile, so add the missile to our universe if there is
* room, and if there is, make the appropriate warnings and noises.
* 
* ******************************************************************************

SFRMIS:
       li   rx,(MSL)*256               ; LDX #MSL          ; Set X to the ship type of a missile, and call SFS1-2
       .jsr @SFS1-2                    ; JSR SFS1-2        ; to add the missile to our universe with an AI flag
                                                           ; of %11111110 (AI enabled, hostile, no E.C.M.)

       jnc  NO1                        ; BCC NO1           ; The C flag will be set if the call to SFS1-2 was a
                                                           ; success, so if it's clear, jump to NO1 to return from
                                                           ; the subroutine (as NO1 contains an RTS)

       li   ra,>78*256                 ; LDA #120          ; Print recursive token 120 ("INCOMING MISSILE") as an
       .jsr @MESS                      ; JSR MESS          ; in-flight message

       li   ra,>30*256                 ; LDA #48           ; Call the NOISE routine with A = 48 to make the sound
       jne  NOISE                      ; BNE NOISE         ; of the missile being launched and return from the
                                                           ; subroutine using a tail call (this BNE is effectively
                                                           ; a JMP as A will never be zero)

* ******************************************************************************
* 
* Name: EXNO2
* Type: Subroutine
* Category: Status
* Summary: Process us making a kill
* Deep dive: Combat rank
* 
* ------------------------------------------------------------------------------
* 
* We have killed a ship, so increase the kill tally, displaying an iconic
* message of encouragement if the kill total is a multiple of 256, and then
* make a nearby explosion sound.
* 
* ******************************************************************************

EXNO2:
       ab   rone,ra                    ; INC TALLY         ; Increment the low byte of the kill count in TALLY

       jne  EXNO-2                     ; BNE EXNO-2        ; If there is no carry, jump to the LDX #7 below (at
                                                           ; EXNO-2)

       ab   rone,ra                    ; INC TALLY+1       ; Increment the high byte of the kill count in TALLY

       li   ra,>65*256                 ; LDA #101          ; The kill total is a multiple of 256, so it's time
       .jsr @MESS                      ; JSR MESS          ; for a pat on the back, so print recursive token 101
                                                           ; ("RIGHT ON COMMANDER!") as an in-flight message

       li   rx,>07*256                 ; LDX #7            ; Set X = 7 and fall through into EXNO to make the
                                                           ; sound of a ship exploding

* ******************************************************************************
* 
* Name: EXNO
* Type: Subroutine
* Category: Sound
* Summary: Make the sound of a laser strike or ship explosion
* 
* ------------------------------------------------------------------------------
* 
* Make the two-part explosion sound of us making a laser strike, or of another
* ship exploding.
* 
* The volume of the first explosion is affected by the distance of the ship
* being hit, with more distant ships being quieter. The value in X also affects
* the volume of the first explosion, with a higher X giving a quieter sound
* (so X can be used to differentiate a laser strike from an explosion).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The larger the value of X, the fainter the explosion.
* Allowed values are:
* 
* * 7  = explosion is louder (i.e. the ship has just
* exploded)
* 
* * 15 = explosion is quieter (i.e. this is just a laser
* strike)
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* EXNO-2              Set X = 7 and fall through into EXNO to make the sound
* of a ship exploding
* 
* ******************************************************************************

EXNO:
       movb rx,@T                      ; STX T             ; Store the distance in T

       li   ra,>18*256                 ; LDA #24           ; Set A = 24 to denote the sound of us making a hit or
       .jsr @NOS1                      ; JSR NOS1          ; kill (part 1 of the explosion), and call NOS1 to set
                                                           ; up the sound block in XX16

       movb @INWK+7,ra                 ; LDA INWK+7        ; Fetch z_hi, the distance of the ship being hit in
       srl  ra,1                       ; LSR A             ; terms of the z-axis (in and out of the screen), and
       srl  ra,1                       ; LSR A             ; divide by 4. If z_hi has either bit 6 or 7 set then
                                                           ; that ship is too far away to be shown on the scanner
                                                           ; (as per the SCAN routine), so we know the maximum
                                                           ; z_hi at this point is %00111111, and shifting z_hi
                                                           ; to the right twice gives us a maximum value of
                                                           ; %00001111

       .and @T                         ; AND T             ; This reduces A to a maximum of X; X can be either
                                                           ; 7 = %0111 or 15 = %1111, so AND'ing with 15 will
                                                           ; not affect A, while AND'ing with 7 will clear bit
                                                           ; 3, reducing the maximum value in A to 7

       ori  ra,>f1*256                 ; ORA #%11110001    ; The SOUND statement's amplitude ranges from 0 (for no
                                                           ; sound) to -15 (full volume), so we can set bits 0 and
                                                           ; 4-7 in A, and keep bits 1-3 from the above to get
                                                           ; a value between -15 (%11110001) and -1 (%11111111),
                                                           ; with lower values of z_hi and argument X leading
                                                           ; to a more negative, or quieter number (so the closer
                                                           ; the ship, i.e. the smaller the value of X, the louder
                                                           ; the sound)

       movb ra,@XX16+2                 ; STA XX16+2        ; The amplitude byte of the sound block in XX16 is in
                                                           ; byte #3 (where it's the low byte of the amplitude), so
                                                           ; this sets the amplitude to the value in A

       .jsr @NO3                       ; JSR NO3           ; Make the sound from our updated sound block in XX16

       li   ra,>10*256                 ; LDA #16           ; Set A = 16 to denote we have made a hit or kill
                                                           ; (part 2 of the explosion), and fall through into NOISE
                                                           ; to make the sound

       byte >2c                                                      ; Skip the next instruction by turning it into
                                                                     ; &2C &A9 &20, or BIT &20A9, which does nothing apart
                                                                     ; from affect the flags

* ******************************************************************************
* 
* Name: BEEP
* Type: Subroutine
* Category: Sound
* Summary: Make a short, high beep
* 
* ******************************************************************************

BEEP:
       li   ra,>20*256                 ; LDA #32           ; Set A = 32 to denote a short, high beep, and fall
                                                           ; through into the NOISE routine to make the sound

* ******************************************************************************
* 
* Name: NOISE
* Type: Subroutine
* Category: Sound
* Summary: Make the sound whose number is in A
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The number of the sound to be made. See the
* documentation for variable SFX for a list of sound
* numbers
* 
* ******************************************************************************

NOISE:
       .jsr @NOS1                      ; JSR NOS1          ; Set up the sound block in XX16 for the sound in A and
                                                           ; fall through into NO3 to make the sound

* ******************************************************************************
* 
* Name: NO3
* Type: Subroutine
* Category: Sound
* Summary: Make a sound from a prepared sound block
* 
* ------------------------------------------------------------------------------
* 
* Make a sound from a prepared sound block in XX16 (if sound is enabled). See
* routine NOS1 for details of preparing the XX16 sound block.
* 
* ******************************************************************************

NO3:
       movb @DNOIZ,rx                  ; LDX DNOIZ         ; Set X to the DNOIZ configuration setting

       jne  NO1                        ; BNE NO1           ; If DNOIZ is non-zero, then sound is disabled, so
                                                           ; return from the subroutine (as NO1 contains an RTS)

       li   rx,((XX16)%256)*256        ; LDX #LO(XX16)     ; Otherwise set (Y X) to point to the sound block in
       li   ry,((XX16)/256)*256        ; LDY #HI(XX16)     ; XX16

       li   ra,>07*256                 ; LDA #7            ; Call OSWORD 7 to makes the sound, as described in the
       b    @OSWORD                    ; JMP OSWORD        ; documentation for variable SFX, and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: NOS1
* Type: Subroutine
* Category: Sound
* Summary: Prepare a sound block
* 
* ------------------------------------------------------------------------------
* 
* Copy four sound bytes from SFX into XX16, interspersing them with null bytes,
* with Y indicating the sound number to copy (from the values in the sound
* table at SFX). So, for example, if we call this routine with A = 40 (long,
* low beep), the following bytes will be set in XX16 to XX16+7:
* 
* &13 &00 &F4 &00 &0C &00 &08 &00
* 
* This block will be passed to OSWORD 7 to make the sound, which expects the
* four sound attributes as 16-bit big-endian values - in other words, with the
* low byte first. So the above block would pass the values &0013, &00F4, &000C
* and &0008 to the SOUND statement when used with OSWORD 7, or:
* 
* SOUND &13, &F4, &0C, &08
* 
* as the high bytes are always zero.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The sound number to copy from SFX to XX16, which is
* always a multiple of 8
* 
* ******************************************************************************

NOS1:
       srl  ra,1                       ; LSR A             ; Divide A by 2, and also clear the C flag, as bit 0 of
                                                           ; A is always zero (as A is a multiple of 8)

       .adi (>03*256)                  ; ADC #3            ; Set Y = A + 3, so Y now points to the last byte of
       movb ra,ry                      ; TAY               ; four within the block of four-byte values

       li   rx,>07*256                 ; LDX #7            ; We want to copy four bytes, spread out into an 8-byte
                                                           ; block, so set a counter in Y to cover 8 bytes

NOL1:
       li   ra,>00*256                 ; LDA #0            ; Set the X-th byte of XX16 to 0
       movb ra,@XX16(rx)               ; STA XX16,X        

       sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer

       movb @SFX(ry),ra                ; LDA SFX,Y         ; Set the X-th byte of XX16 to the value from SFX+Y
       movb ra,@XX16(rx)               ; STA XX16,X        

       sb   rone,ry                    ; DEY               ; Decrement the source byte pointer again

       sb   rone,rx                    ; DEX               ; Decrement the destination byte pointer again

       jgt  NOL1                       ; BPL NOL1          ; Loop back for the next source byte

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: KYTB
* Type: Variable
* Category: Keyboard
* Summary: Lookup table for in-flight keyboard controls
* Deep dive: The key logger
* 
* ------------------------------------------------------------------------------
* 
* Keyboard table for in-flight controls. This table contains the internal key
* codes for the flight keys (see p.142 of the Advanced User Guide for a list of
* internal key numbers).
* 
* The pitch, roll, speed and laser keys (i.e. the seven primary flight
* control keys) have bit 7 set, so they have 128 added to their internal
* values. This doesn't appear to be used anywhere.
* 
* ******************************************************************************

KYTB:                                                      ; Point KYTB to the byte before the start of the table
       equ $ - 1

                                                           ; These are the primary flight controls (pitch, roll,
                                                           ; speed and lasers):

       byte >68                                                      ; ?         KYTB+1      Slow down
       byte >62                                                      ; Space     KYTB+2      Speed up
       byte >66                                                      ; <         KYTB+3      Roll left
       byte >67                                                      ; >         KYTB+4      Roll right
       byte >42                                                      ; X         KYTB+5      Pitch up
       byte >51                                                      ; S         KYTB+6      Pitch down
       byte >41                                                      ; A         KYTB+7      Fire lasers

                                                           ; These are the secondary flight controls:

       byte >60                                                      ; TAB       KYTB+8      Energy bomb
       byte >70                                                      ; ESCAPE    KYTB+9      Launch escape pod
       byte >23                                                      ; T         KYTB+10     Arm missile
       byte >35                                                      ; U         KYTB+11     Unarm missile
       byte >65                                                      ; M         KYTB+12     Fire missile
       byte >22                                                      ; E         KYTB+13     E.C.M.
       byte >45                                                      ; J         KYTB+14     In-system jump
       byte >52                                                      ; C         KYTB+15     Docking computer

* ******************************************************************************
* 
* Name: DKS1
* Type: Subroutine
* Category: Keyboard
* Summary: Scan the keyboard for a flight key
* Deep dive: The key logger
* 
* ------------------------------------------------------------------------------
* 
* Scan the keyboard for the flight key given in register Y, where Y is the
* offset into the KYTB table above (so we can scan for Space by setting Y to
* 2, for example). If the key is pressed, set the corresponding byte in the
* key logger at KL to &FF.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* Y                   The offset into the KYTB table above of the key that we
* want to scan on the keyboard
* 
* ******************************************************************************

DKS1:
       movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number from the Y-th byte of the
                                                           ; KYTB table above

       .jsr @DKS4                      ; JSR DKS4          ; Call DKS4, which will set A and X to a negative value
                                                           ; if the key is being pressed

       jgt  DKS2-1                     ; BPL DKS2-1        ; The key is not being pressed, so return from the
                                                           ; subroutine (as DKS2-1 contains an RTS)

       li   rx,>ff*256                 ; LDX #&FF          ; Store &FF in the Y-th byte of the key logger at KL
       movb rx,@KL(ry)                 ; STX KL,Y          

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: CTRL
* Type: Subroutine
* Category: Keyboard
* Summary: Scan the keyboard to see if CTRL is currently pressed
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   X = %10000001 (i.e. 129 or -127) if CTRL is being
* pressed
* 
* X = 1 if CTRL is not being pressed
* 
* A                   Contains the same as X
* 
* ******************************************************************************

CTRL:
       li   rx,>01*256                 ; LDX #1            ; Set X to the internal key number for CTRL and fall
                                                           ; through to DKS4 to scan the keyboard

* ******************************************************************************
* 
* Name: DKS4
* Type: Subroutine
* Category: Keyboard
* Summary: Scan the keyboard to see if a specific key is being pressed
* Deep dive: The key logger
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The internal number of the key to check (see p.142 of
* the Advanced User Guide for a list of internal key
* numbers)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   If the key in A is being pressed, A contains the
* original argument A, but with bit 7 set (i.e. A + 128).
* If the key in A is not being pressed, the value in A is
* unchanged
* 
* X                   Contains the same as A
* 
* ******************************************************************************

DKS4:
       li   ra,>03*256                 ; LDA #%00000011    ; Set A to %00000011, so it's ready to send to SHEILA
                                                           ; once interrupts have been disabled

       limi 0                          ; SEI               ; Disable interrupts so we can scan the keyboard
                                                           ; without being hijacked

       movb ra,@VIA+>40                ; STA VIA+&40       ; Set 6522 System VIA output register ORB (SHEILA &40)
                                                           ; to %00000011 to stop auto scan of keyboard

       li   ra,>7f*256                 ; LDA #%01111111    ; Set 6522 System VIA data direction register DDRA
       movb ra,@VIA+>43                ; STA VIA+&43       ; (SHEILA &43) to %01111111. This sets the A registers
                                                           ; (IRA and ORA) so that:
                                                           ; 
                                                           ; * Bits 0-6 of ORA will be sent to the keyboard
                                                           ; 
                                                           ; * Bit 7 of IRA will be read from the keyboard

       movb rx,@VIA+>4F                ; STX VIA+&4F       ; Set 6522 System VIA output register ORA (SHEILA &4F)
                                                           ; to X, the key we want to scan for; bits 0-6 will be
                                                           ; sent to the keyboard, of which bits 0-3 determine the
                                                           ; keyboard column, and bits 4-6 the keyboard row

       movb @VIA+>4F,rx                ; LDX VIA+&4F       ; Read 6522 System VIA output register IRA (SHEILA &4F)
                                                           ; into X; bit 7 is the only bit that will have changed.
                                                           ; If the key is pressed, then bit 7 will be set,
                                                           ; otherwise it will be clear

       li   ra,>0b*256                 ; LDA #%00001011    ; Set 6522 System VIA output register ORB (SHEILA &40)
       movb ra,@VIA+>40                ; STA VIA+&40       ; to %00001011 to restart auto scan of keyboard

       limi 2                          ; CLI               ; Allow interrupts again

       movb rx,ra                      ; TXA               ; Transfer X into A

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DKS2
* Type: Subroutine
* Category: Keyboard
* Summary: Read the joystick position
* 
* ------------------------------------------------------------------------------
* 
* Return the value of ADC channel in X (used to read the joystick). The value
* will be inverted if the game has been configured to reverse both joystick
* channels (which can be done by pausing the game and pressing J).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The ADC channel to read:
* 
* * 1 = joystick X
* 
* * 2 = joystick Y
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* (A X)               The 16-bit value read from channel X, with the value
* inverted if the game has been configured to reverse the
* joystick
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* DKS2-1              Contains an RTS
* 
* ******************************************************************************

DKS2:
       li   ra,>80*256                 ; LDA #128          ; Call OSBYTE with A = 128 to fetch the 16-bit value
       .jsr @OSBYTE                    ; JSR OSBYTE        ; from ADC channel X, returning (Y X), i.e. the high
                                                           ; byte in Y and the low byte in X
                                                           ; 
                                                           ; * Channel 1 is the x-axis: 0 = right, 65520 = left
                                                           ; 
                                                           ; * Channel 2 is the y-axis: 0 = down,  65520 = up

       movb ry,ra                      ; TYA               ; Copy Y to A, so the result is now in (A X)

       .eor @JSTE                      ; EOR JSTE          ; The high byte A is now EOR'd with the value in
                                                           ; location JSTE, which contains &FF if both joystick
                                                           ; channels are reversed and 0 otherwise (so A now
                                                           ; contains the high byte but inverted, if that's what
                                                           ; the current settings say)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DKS3
* Type: Subroutine
* Category: Keyboard
* Summary: Toggle a configuration setting and emit a beep
* 
* ------------------------------------------------------------------------------
* 
* This is called when the game is paused and a key is pressed that changes the
* game's configuration.
* 
* Specifically, this routine toggles the configuration settings for the
* following keys:
* 
* * CAPS LOCK toggles keyboard flight damping (&40)
* * A toggles keyboard auto-recentre (&41)
* * X toggles author names on start-up screen (&42)
* * F toggles flashing console bars (&43)
* * Y toggles reverse joystick Y channel (&44)
* * J toggles reverse both joystick channels (&45)
* * K toggles keyboard and joystick (&46)
* 
* The numbers in brackets are the internal key numbers (see p.142 of the
* Advanced User Guide for a list of internal key numbers). We pass the key that
* has been pressed in X, and the configuration option to check it against in Y,
* so this routine is typically called in a loop that loops through the various
* configuration options.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   The internal number of the key that's been pressed
* 
* Y                   The internal number of the configuration key to check
* against, from the list above (i.e. Y must be from &40 to
* &46)
* 
* ******************************************************************************

DKS3:
       movb ry,@T                      ; STY T             ; Store the configuration key argument in T

       cb   @T,rx                      ; CPX T             ; If X <> Y, jump to Dk3 to return from the subroutine
       jne  Dk3                        ; BNE Dk3           

                                                           ; We have a match between X and Y, so now to toggle
                                                           ; the relevant configuration byte. CAPS LOCK has a key
                                                           ; value of &40 and has its configuration byte at
                                                           ; location DAMP, A has a value of &41 and has its byte
                                                           ; at location DJD, which is DAMP+1, and so on. So we
                                                           ; can toggle the configuration byte by changing the
                                                           ; byte at DAMP + (X - &40), or to put it in indexing
                                                           ; terms, DAMP-&40,X. It's no coincidence that the
                                                           ; game's configuration bytes are set up in this order
                                                           ; and with these keys (and this is also why the sound
                                                           ; on/off keys are dealt with elsewhere, as the internal
                                                           ; key for S and Q are &51 and &10, which don't fit
                                                           ; nicely into this approach)

       movb @DAMP->40(rx),ra           ; LDA DAMP-&40,X    ; Fetch the byte from DAMP + (X - &40), invert it and
       .eoi (>ff*256)                  ; EOR #&FF          ; put it back (0 means no and &FF means yes in the
       movb ra,@DAMP->40(rx)           ; STA DAMP-&40,X    ; configuration bytes, so this toggles the setting)

       .jsr @BELL                      ; JSR BELL          ; Make a beep sound so we know something has happened

       .jsr @DELAY                     ; JSR DELAY         ; Wait for Y vertical syncs (Y is between 64 and 70, so
                                                           ; this is always a bit longer than a second)

       movb @T,ry                      ; LDY T             ; Restore the configuration key argument into Y

Dk3:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DKJ1
* Type: Subroutine
* Category: Keyboard
* Summary: Read joystick and flight controls
* 
* ------------------------------------------------------------------------------
* 
* Specifically, scan the keyboard for the speed up and slow down keys, and read
* the joystick's fire button and X and Y axes, storing the results in the key
* logger and the joystick position variables.
* 
* This routine is only called if joysticks are enabled (JSTK = non-zero).
* 
* ******************************************************************************

DKJ1:
       li   ry,>01*256                 ; LDY #1            ; Update the key logger for key 1 in the KYTB table, so
       .jsr @DKS1                      ; JSR DKS1          ; KY1 will be &FF if "?" (slow down) is being pressed

       ab   rone,ry                    ; INY               ; Update the key logger for key 2 in the KYTB table, so
       .jsr @DKS1                      ; JSR DKS1          ; KY2 will be &FF if Space (speed up) is being pressed

       movb @VIA+>40,ra                ; LDA VIA+&40       ; Read 6522 System VIA input register IRB (SHEILA &40)

       movb ra,rx                      ; TAX               ; This instruction doesn't seem to have any effect, as
                                                           ; X is overwritten in a few instructions. When the
                                                           ; joystick is checked in a similar way in the TITLE
                                                           ; subroutine for the "Press Fire Or Space,Commander."
                                                           ; stage of the start-up screen, there's another
                                                           ; unnecessary TAX instruction present, but there it's
                                                           ; commented out

       andi ra,>10*256                 ; AND #%00010000    ; Bit 4 of IRB (PB4) is clear if joystick 1's fire
                                                           ; button is pressed, otherwise it is set, so AND'ing
                                                           ; the value of IRB with %10000 extracts this bit

       .eoi (>10*256)                  ; EOR #%00010000    ; Flip bit 4 so that it's set if the fire button has
       movb ra,@KY7                    ; STA KY7           ; been pressed, and store the result in the keyboard
                                                           ; logger at location KY7, which is also where the A key
                                                           ; (fire lasers) key is logged

       li   rx,>01*256                 ; LDX #1            ; Call DKS2 to fetch the value of ADC channel 1 (the
       .jsr @DKS2                      ; JSR DKS2          ; joystick X value) into (A X), and OR A with 1. This
       ori  ra,>01*256                 ; ORA #1            ; ensures that the high byte is at least 1, and then we
       movb ra,@JSTX                   ; STA JSTX          ; store the result in JSTX

       li   rx,>02*256                 ; LDX #2            ; Call DKS2 to fetch the value of ADC channel 2 (the
       .jsr @DKS2                      ; JSR DKS2          ; joystick Y value) into (A X), and EOR A with JSTGY.
       .eor @JSTGY                     ; EOR JSTGY         ; JSTGY will be &FF if the game is configured to
       movb ra,@JSTY                   ; STA JSTY          ; reverse the joystick Y channel, so this EOR does
                                                           ; exactly that, and then we store the result in JSTY

       b    @DK4                       ; JMP DK4           ; We are done scanning the joystick flight controls,
                                                           ; so jump to DK4 to scan for other keys, using a tail
                                                           ; call so we can return from the subroutine there

* ******************************************************************************
* 
* Name: U%
* Type: Subroutine
* Category: Keyboard
* Summary: Clear the key logger
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* A                   A is set to 0
* 
* Y                   Y is set to 0
* 
* ******************************************************************************

U.:
       li   ra,>00*256                 ; LDA #0            ; Set A to 0, as this means "key not pressed" in the
                                                           ; key logger at KL

       li   ry,>0f*256                 ; LDY #15           ; We want to clear the 15 key logger locations from
                                                           ; KY1 to KY19, so set a counter in Y

DKL3:
       movb ra,@KL(ry)                 ; STA KL,Y          ; Store 0 in the Y-th byte of the key logger

       sb   rone,ry                    ; DEY               ; Decrement the counter

       jne  DKL3                       ; BNE DKL3          ; And loop back for the next key, until we have just
                                                           ; KL+1. We don't want to clear the first key logger
                                                           ; location at KL, as the keyboard table at KYTB starts
                                                           ; with offset 1, not 0, so KL is not technically part of
                                                           ; the key logger (it's actually used for logging keys
                                                           ; that don't appear in the keyboard table, and which
                                                           ; therefore don't use the key logger)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: DOKEY
* Type: Subroutine
* Category: Keyboard
* Summary: Scan for the seven primary flight controls
* Deep dive: The key logger
* The docking computer
* 
* ------------------------------------------------------------------------------
* 
* Scan for the seven primary flight controls (or the equivalent on joystick),
* pause and configuration keys, and secondary flight controls, and update the
* key logger accordingly. Specifically:
* 
* * If we are on keyboard configuration, clear the key logger and update it
* for the seven primary flight controls, and update the pitch and roll
* rates accordingly.
* 
* * If we are on joystick configuration, clear the key logger and jump to
* DKJ1, which reads the joystick equivalents of the primary flight
* controls.
* 
* Both options end up at DK4 to scan for other keys, beyond the seven primary
* flight controls.
* 
* ******************************************************************************

DOKEY:
       .jsr @U.                        ; JSR U%            ; Call U% to clear the key logger

       movb @JSTK,ra                   ; LDA JSTK          ; If JSTK is non-zero, then we are configured to use
       jne  DKJ1                       ; BNE DKJ1          ; the joystick rather than keyboard, so jump to DKJ1
                                                           ; to read the joystick flight controls, before jumping
                                                           ; to DK4 to scan for pause, configuration and secondary
                                                           ; flight keys

       li   ry,>07*256                 ; LDY #7            ; We're going to work our way through the primary flight
                                                           ; control keys (pitch, roll, speed and laser), so set a
                                                           ; counter in Y so we can loop through all 7

DKL2:
       .jsr @DKS1                      ; JSR DKS1          ; Call DKS1 to see if the KYTB key at offset Y is being
                                                           ; pressed, and set the key logger accordingly

       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       jne  DKL2                       ; BNE DKL2          ; Loop back for the next key, working our way from A at
                                                           ; KYTB+7 down to ? at KYTB+1

       movb @JSTX,rx                   ; LDX JSTX          ; Set X = JSTX, the current roll rate (as shown in the
                                                           ; RL indicator on the dashboard)

       li   ra,>07*256                 ; LDA #7            ; Set A to 7, which is the amount we want to alter the
                                                           ; roll rate by if the roll keys are being pressed

       movb @KL+3,ry                   ; LDY KL+3          ; If the "<" key is being pressed, then call the BUMP2
       jeq  B103                       ; BEQ B103          ; routine to increase the roll rate in X by A
       .jsr @BUMP2                     ; JSR BUMP2         

B103:
       movb @KL+4,ry                   ; LDY KL+4          ; If the ">" key is being pressed, then call the REDU2
       jeq  B104                       ; BEQ B104          ; routine to decrease the roll rate in X by A, taking
       .jsr @REDU2                     ; JSR REDU2         ; the keyboard auto re-centre setting into account

B104:
       movb rx,@JSTX                   ; STX JSTX          ; Store the updated roll rate in JSTX

       .asla                           ; ASL A             ; Double the value of A, to 14

       movb @JSTY,rx                   ; LDX JSTY          ; Set X = JSTY, the current pitch rate (as shown in the
                                                           ; DC indicator on the dashboard)

       movb @KL+5,ry                   ; LDY KL+5          ; If the "X" key is being pressed, then call the REDU2
       jeq  B105                       ; BEQ B105          ; routine to decrease the pitch rate in X by A, taking
       .jsr @REDU2                     ; JSR REDU2         ; the keyboard auto re-centre setting into account

B105:
       movb @KL+6,ry                   ; LDY KL+6          ; If the "S" key is being pressed, then call the BUMP2
       jeq  B106                       ; BEQ B106          ; routine to increase the pitch rate in X by A
       .jsr @BUMP2                     ; JSR BUMP2         

B106:
       movb rx,@JSTY                   ; STX JSTY          ; Store the updated roll rate in JSTY

                                                           ; Fall through into DK4 to scan for other keys

* ******************************************************************************
* 
* Name: DK4
* Type: Subroutine
* Category: Keyboard
* Summary: Scan for pause, configuration and secondary flight keys
* Deep dive: The key logger
* 
* ------------------------------------------------------------------------------
* 
* Scan for pause and configuration keys, and if this is a space view, also scan
* for secondary flight controls.
* 
* Specifically:
* 
* * Scan for the pause button (COPY) and if it's pressed, pause the game and
* process any configuration key presses until the game is unpaused (DELETE)
* 
* * If this is a space view, scan for secondary flight keys and update the
* relevant bytes in the key logger
* 
* ******************************************************************************

DK4:
       .jsr @RDKEY                     ; JSR RDKEY         ; Scan the keyboard for a key press and return the
                                                           ; internal key number in X (or 0 for no key press)

       movb rx,@KL                     ; STX KL            ; Store X in KL, byte #0 of the key logger

       ci   rx,>69*256                 ; CPX #&69          ; If COPY is not being pressed, jump to DK2 below,
       jne  DK2                        ; BNE DK2           ; otherwise let's process the configuration keys

FREEZE:
                                                           ; COPY is being pressed, so we enter a loop that
                                                           ; listens for configuration keys, and we keep looping
                                                           ; until we detect a DELETE key press. This effectively
                                                           ; pauses the game when COPY is pressed, and unpauses
                                                           ; it when DELETE is pressed
       .jsr @WSCAN                     ; JSR WSCAN         ; Call WSCAN to wait for the vertical sync, so the whole
                                                           ; screen gets drawn

       .jsr @RDKEY                     ; JSR RDKEY         ; Scan the keyboard for a key press and return the
                                                           ; internal key number in X (or 0 for no key press)

       ci   rx,>51*256                 ; CPX #&51          ; If "S" is not being pressed, skip to DK6
       jne  DK6                        ; BNE DK6           

       li   ra,>00*256                 ; LDA #0            ; "S" is being pressed, so set DNOIZ to 0 to turn the
       movb ra,@DNOIZ                  ; STA DNOIZ         ; sound on

DK6:
       li   ry,>40*256                 ; LDY #&40          ; We now want to loop through the keys that toggle
                                                           ; various settings. These have internal key numbers
                                                           ; between &40 (CAPS LOCK) and &46 ("K"), so we set up
                                                           ; the first key number in Y to act as a loop counter.
                                                           ; See subroutine DKS3 for more details on this

DKL4:
       .jsr @DKS3                      ; JSR DKS3          ; Call DKS3 to scan for the key given in Y, and toggle
                                                           ; the relevant setting if it is pressed

       ab   rone,ry                    ; INY               ; Increment Y to point to the next toggle key

       ci   ry,>47*256                 ; CPY #&47          ; The last toggle key is &46 (K), so check whether we
                                                           ; have just done that one

       jne  DKL4                       ; BNE DKL4          ; If not, loop back to check for the next toggle key

DK55:
       ci   rx,>10*256                 ; CPX #&10          ; If "Q" is not being pressed, skip to DK7
       jne  DK7                        ; BNE DK7           

       movb rx,@DNOIZ                  ; STX DNOIZ         ; "Q" is being pressed, so set DNOIZ to X, which is
                                                           ; non-zero (&10), so this will turn the sound off

DK7:
       ci   rx,>70*256                 ; CPX #&70          ; If ESCAPE is not being pressed, skip over the next
       jne  B107                       ; BNE B107          ; instruction

       b    @DEATH2                    ; JMP DEATH2        ; ESCAPE is being pressed, so jump to DEATH2 to end
                                                           ; the game

B107:
       ci   rx,>59*256                 ; CPX #&59          ; If DELETE is not being pressed, we are still paused,
       jne  FREEZE                     ; BNE FREEZE        ; so loop back up to keep listening for configuration
                                                           ; keys, otherwise fall through into the rest of the
                                                           ; key detection code, which unpauses the game

DK2:
       movb @QQ11,ra                   ; LDA QQ11          ; If the current view is non-zero (i.e. not a space
       jne  DK5                        ; BNE DK5           ; view), return from the subroutine (as DK5 contains
                                                           ; an RTS)

       li   ry,>0f*256                 ; LDY #15           ; This is a space view, so now we want to check for all
                                                           ; the secondary flight keys. The internal key numbers
                                                           ; are in the keyboard table KYTB from KYTB+8 to
                                                           ; KYTB+15, and their key logger locations are from KL+8
                                                           ; to KL+15. So set a decreasing counter in Y for the
                                                           ; index, starting at 15, so we can loop through them

       li   ra,>ff*256                 ; LDA #&FF          ; Set A to &FF so we can store this in the keyboard
                                                           ; logger for keys that are being pressed

DKL1:
       movb @KYTB(ry),rx               ; LDX KYTB,Y        ; Get the internal key number of the Y-th flight key
                                                           ; the KYTB keyboard table

       cb   @KL,rx                     ; CPX KL            ; We stored the key that's being pressed in KL above,
                                                           ; so check to see if the Y-th flight key is being
                                                           ; pressed

       jne  DK1                        ; BNE DK1           ; If it is not being pressed, skip to DK1 below

       movb ra,@KL(ry)                 ; STA KL,Y          ; The Y-th flight key is being pressed, so set that
                                                           ; key's location in the key logger to &FF

DK1:
       sb   rone,ry                    ; DEY               ; Decrement the loop counter

       ci   ry,>07*256                 ; CPY #7            ; Have we just done the last key?

       jne  DKL1                       ; BNE DKL1          ; If not, loop back to process the next key

DK5:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TT217
* Type: Subroutine
* Category: Keyboard
* Summary: Scan the keyboard until a key is pressed
* 
* ------------------------------------------------------------------------------
* 
* Scan the keyboard until a key is pressed, and return the key's ASCII code.
* If, on entry, a key is already being held down, then wait until that key is
* released first (so this routine detects the first key down event following
* the subroutine call).
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   The ASCII code of the key that was pressed
* 
* A                   Contains the same as X
* 
* Y                   Y is preserved
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* out                 Contains an RTS
* 
* ******************************************************************************

TT217:
       movb ry,@YSAV                   ; STY YSAV          ; Store Y in temporary storage, so we can restore it
                                                           ; later

t_:
       .jsr @DELAY-5                   ; JSR DELAY-5       ; Delay for 8 vertical syncs (8/50 = 0.16 seconds) so we
                                                           ; don't take up too much CPU time while looping round

       .jsr @RDKEY                     ; JSR RDKEY         ; Scan the keyboard for a key press and return the
                                                           ; internal key number in X (or 0 for no key press)

       jne  t_                         ; BNE t             ; If a key was already being held down when we entered
                                                           ; this routine, keep looping back up to t, until the
                                                           ; key is released

t2_:
       .jsr @RDKEY                     ; JSR RDKEY         ; Any pre-existing key press is now gone, so we can
                                                           ; start scanning the keyboard again, returning the
                                                           ; internal key number in X (or 0 for no key press)

       jeq  t2_                        ; BEQ t2            ; Keep looping up to t2 until a key is pressed

       movb ra,ry                      ; TAY               ; Copy A to Y, so Y contains the internal key number
                                                           ; of the key pressed

       .ld_ind_y_idx @TRTB.,ra         ; LDA (TRTB%),Y     ; The address in TRTB% points to the MOS key
                                                           ; translation table, which is used to translate
                                                           ; internal key numbers to ASCII, so this fetches the
                                                           ; key's ASCII code into A

       movb @YSAV,ry                   ; LDY YSAV          ; Restore the original value of Y we stored above

       movb ra,rx                      ; TAX               ; Copy A into X

out_:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: me1
* Type: Subroutine
* Category: Flight
* Summary: Erase an old in-flight message and display a new one
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* X                   Must be set to 0
* 
* ******************************************************************************

me1_:
       movb rx,@DLY                    ; STX DLY           ; Set the message delay in DLY to 0, so any new
                                                           ; in-flight messages will be shown instantly

       .pha                            ; PHA               ; Store the new message token we want to print

       movb @MCH,ra                    ; LDA MCH           ; Set A to the token number of the message that is
       .jsr @mes9_                     ; JSR mes9          ; currently on-screen, and call mes9 to print it (which
                                                           ; will remove it from the screen, as printing is done
                                                           ; using EOR logic)

       .pla                            ; PLA               ; Restore the new message token

       byte >2c                                                      ; Fall through into ou2 to print the new message, but
                                                                     ; skip the first instruction by turning it into
                                                                     ; &2C &A9 &6C, or BIT &6CA9, which does nothing apart
                                                                     ; from affect the flags

* ******************************************************************************
* 
* Name: ou2
* Type: Subroutine
* Category: Flight
* Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
* 
* ******************************************************************************

ou2_:
       li   ra,>6c*256                 ; LDA #108          ; Set A to recursive token 108 ("E.C.M.SYSTEM")

       byte >2c                                                      ; Fall through into ou3 to print the new message, but
                                                                     ; skip the first instruction by turning it into
                                                                     ; &2C &A9 &6F, or BIT &6FA9, which does nothing apart
                                                                     ; from affect the flags

* ******************************************************************************
* 
* Name: ou3
* Type: Subroutine
* Category: Flight
* Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
* 
* ******************************************************************************

ou3_:
       li   ra,>6f*256                 ; LDA #111          ; Set A to recursive token 111 ("FUEL SCOOPS")

* ******************************************************************************
* 
* Name: MESS
* Type: Subroutine
* Category: Flight
* Summary: Display an in-flight message
* 
* ------------------------------------------------------------------------------
* 
* Display an in-flight message in capitals at the bottom of the space view,
* erasing any existing in-flight message first.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* A                   The text token to be printed
* 
* ******************************************************************************

MESS:
       li   rx,>00*256                 ; LDX #0            ; Set QQ17 = 0 to switch to ALL CAPS
       movb rx,@QQ17                   ; STX QQ17          

       li   ry,>09*256                 ; LDY #9            ; Move the text cursor to column 9, row 22, at the
       movb ry,@XC                     ; STY XC            ; bottom middle of the screen, and set Y = 22
       li   ry,>16*256                 ; LDY #22           
       movb ry,@YC                     ; STY YC            

       cb   @DLY,rx                    ; CPX DLY           ; If the message delay in DLY is not zero, jump up to
       jne  me1_                       ; BNE me1           ; me1 to erase the current message first (whose token
                                                           ; number will be in MCH)

       movb ry,@DLY                    ; STY DLY           ; Set the message delay in DLY to 22

       movb ra,@MCH                    ; STA MCH           ; Set MCH to the token we are about to display

                                                           ; Fall through into mes9 to print the token in A

* ******************************************************************************
* 
* Name: mes9
* Type: Subroutine
* Category: Flight
* Summary: Print a text token, possibly followed by " DESTROYED"
* 
* ------------------------------------------------------------------------------
* 
* Print a text token, followed by " DESTROYED" if the destruction flag is set
* (for when a piece of equipment is destroyed).
* 
* ******************************************************************************

mes9_:
       .jsr @TT27                      ; JSR TT27          ; Call TT27 to print the text token in A

       .lsr @de_                       ; LSR de            ; If bit 0 of variable de is clear, return from the
       jnc  out_                       ; BCC out           ; subroutine (as out contains an RTS)

       li   ra,>fd*256                 ; LDA #253          ; Print recursive token 93 (" DESTROYED") and return
       b    @TT27                      ; JMP TT27          ; from the subroutine using a tail call

* ******************************************************************************
* 
* Name: OUCH
* Type: Subroutine
* Category: Flight
* Summary: Potentially lose cargo or equipment following damage
* 
* ------------------------------------------------------------------------------
* 
* Our shields are dead and we are taking damage, so there is a small chance of
* losing cargo or equipment.
* 
* ******************************************************************************

OUCH:
       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       jlt  out_                       ; BMI out           ; If A < 0 (50% chance), return from the subroutine
                                                           ; (as out contains an RTS)

       ci   rx,>16*256                 ; CPX #22           ; If X >= 22 (91% chance), return from the subroutine
       joc  out_                       ; BCS out           ; (as out contains an RTS)

       movb @QQ20(rx),ra               ; LDA QQ20,X        ; If we do not have any of item QQ20+X, return from the
       jeq  out_                       ; BEQ out           ; subroutine (as out contains an RTS). X is in the range
                                                           ; 0-21, so this not only checks for cargo, but also for
                                                           ; E.C.M., fuel scoops, energy bomb, energy unit and
                                                           ; docking computer, all of which can be destroyed

       movb @DLY,ra                    ; LDA DLY           ; If there is already an in-flight message on-screen,
       jne  out_                       ; BNE out           ; return from the subroutine (as out contains an RTS)

       li   ry,>03*256                 ; LDY #3            ; Set bit 1 of de, the equipment destruction flag, so
       movb ry,@de_                    ; STY de            ; that when we call MESS below, " DESTROYED" is appended
                                                           ; to the in-flight message

       movb ra,@QQ20(rx)               ; STA QQ20,X        ; A is 0 (as we didn't branch with the BNE above), so
                                                           ; this sets QQ20+X to 0, which destroys any cargo or
                                                           ; equipment we have of that type

       ci   rx,>11*256                 ; CPX #17           ; If X >= 17 then we just lost a piece of equipment, so
       joc  ou1_                       ; BCS ou1           ; jump to ou1 to print the relevant message

       movb rx,ra                      ; TXA               ; Print recursive token 48 + A as an in-flight token,
       .adi (>d0*256)                  ; ADC #208          ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
       jne  MESS                       ; BNE MESS          ; ITEMS") as the C flag is clear, so this prints the
                                                           ; destroyed item's name, followed by " DESTROYED" (as we
                                                           ; set bit 1 of the de flag above), and returns from the
                                                           ; subroutine using a tail call

ou1_:
       jeq  ou2_                       ; BEQ ou2           ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
                                                           ; DESTROYED" and return from the subroutine using a tail
                                                           ; call

       ci   rx,>12*256                 ; CPX #18           ; If X = 18, jump to ou3 to print "FUEL SCOOPS
       jeq  ou3_                       ; BEQ ou3           ; DESTROYED" and return from the subroutine using a tail
                                                           ; call

       movb rx,ra                      ; TXA               ; Otherwise X is in the range 19 to 21 and the C flag is
       .adi ((113-20)*256)             ; ADC #113-20       ; set (as we got here via a BCS to ou1), so we set A as
                                                           ; follows:
                                                           ; 
                                                           ; A = 113 - 20 + X + C
                                                           ; = 113 - 19 + X
                                                           ; = 113 to 115

       jne  MESS                       ; BNE MESS          ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
                                                           ; or "DOCKING COMPUTERS") as an in-flight message,
                                                           ; followed by " DESTROYED", and return from the
                                                           ; subroutine using a tail call

* ******************************************************************************
* 
* Name: QQ16
* Type: Variable
* Category: Text
* Summary: The two-letter token lookup table
* Deep dive: Printing text tokens
* 
* ------------------------------------------------------------------------------
* 
* Two-letter token lookup table for tokens 128-159. See the deep dive on
* "Printing text tokens" for details of how the two-letter token system works.
* 
* ******************************************************************************

QQ16:
       text 'AL'                                                     ; Token 128
       text 'LE'                                                     ; Token 129
       text 'XE'                                                     ; Token 130
       text 'GE'                                                     ; Token 131
       text 'ZA'                                                     ; Token 132
       text 'CE'                                                     ; Token 133
       text 'BI'                                                     ; Token 134
       text 'SO'                                                     ; Token 135
       text 'US'                                                     ; Token 136
       text 'ES'                                                     ; Token 137
       text 'AR'                                                     ; Token 138
       text 'MA'                                                     ; Token 139
       text 'IN'                                                     ; Token 140
       text 'DI'                                                     ; Token 141
       text 'RE'                                                     ; Token 142
       text 'A?'                                                     ; Token 143
       text 'ER'                                                     ; Token 144
       text 'AT'                                                     ; Token 145
       text 'EN'                                                     ; Token 146
       text 'BE'                                                     ; Token 147
       text 'RA'                                                     ; Token 148
       text 'LA'                                                     ; Token 149
       text 'VE'                                                     ; Token 150
       text 'TI'                                                     ; Token 151
       text 'ED'                                                     ; Token 152
       text 'OR'                                                     ; Token 153
       text 'QU'                                                     ; Token 154
       text 'AN'                                                     ; Token 155
       text 'TE'                                                     ; Token 156
       text 'IS'                                                     ; Token 157
       text 'RI'                                                     ; Token 158
       text 'ON'                                                     ; Token 159

* ******************************************************************************
* 
* Name: ITEM
* Type: Macro
* Category: Market
* Summary: Macro definition for the market prices table
* Deep dive: Market item prices and availability
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used to build the market prices table:
* 
* ITEM price, factor, units, quantity, mask
* 
* It inserts an item into the market prices table at QQ23. See the deep dive on
* "Market item prices and availability" for more information on how the market
* system works.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* price               Base price
* 
* factor              Economic factor
* 
* units               Units: "t", "g" or "k"
* 
* quantity            Base quantity
* 
* mask                Fluctuations mask
* 
* ******************************************************************************

       ; ITEM price, factor, units, quantity, mask

       ; IF factor < 0                 ;                   
       ; s = 1 << 7                    ;                   
       ; ELSE                          ;                   
       ; s = 0                         ;                   
       ; ENDIF                         ;                   

       ; IF units = 't'                ;                   
       ; u = 0                         ;                   
       ; ELIF units = 'k'              ;                   
       ; u = 1 << 5                    ;                   
       ; ELSE                          ;                   
       ; u = 1 << 6                    ;                   
       ; ENDIF                         ;                   

       ; e = ABS(factor)               ;                   

       ; EQUB price                    ;                   
       ; EQUB s + u + e                ;                   
       ; EQUB quantity                 ;                   
       ; EQUB mask                     ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: QQ23
* Type: Variable
* Category: Market
* Summary: Market prices table
* 
* ------------------------------------------------------------------------------
* 
* Each item has four bytes of data, like this:
* 
* Byte #0 = Base price
* Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
* Unit in bits 5-6
* Byte #2 = Base quantity
* Byte #3 = Mask to control price fluctuations
* 
* To make it easier for humans to follow, we've defined a macro called ITEM
* that takes the following arguments and builds the four bytes for us:
* 
* ITEM base price, economic factor, units, base quantity, mask
* 
* So for food, we have the following:
* 
* * Base price = 19
* * Economic factor = -2
* * Unit = tonnes
* * Base quantity = 6
* * Mask = %00000001
* 
* ******************************************************************************

QQ23:
       ; ITEM 19,  -2, 't',   6, %00000001 ; ITEM 19,  -2, 't' ; 0 = Food
       ; ITEM 20,  -1, 't',  10, %00000011 ; ITEM 20,  -1, 't' ; 1 = Textiles
       ; ITEM 65,  -3, 't',   2, %00000111 ; ITEM 65,  -3, 't' ; 2 = Radioactives
       ; ITEM 40,  -5, 't', 226, %00011111 ; ITEM 40,  -5, 't' ; 3 = Slaves
       ; ITEM 83,  -5, 't', 251, %00001111 ; ITEM 83,  -5, 't' ; 4 = Liquor/Wines
       ; ITEM 196,  8, 't',  54, %00000011 ; ITEM 196,  8, 't' ; 5 = Luxuries
       ; ITEM 235, 29, 't',   8, %01111000 ; ITEM 235, 29, 't' ; 6 = Narcotics
       ; ITEM 154, 14, 't',  56, %00000011 ; ITEM 154, 14, 't' ; 7 = Computers
       ; ITEM 117,  6, 't',  40, %00000111 ; ITEM 117,  6, 't' ; 8 = Machinery
       ; ITEM 78,   1, 't',  17, %00011111 ; ITEM 78,   1, 't' ; 9 = Alloys
       ; ITEM 124, 13, 't',  29, %00000111 ; ITEM 124, 13, 't' ; 10 = Firearms
       ; ITEM 176, -9, 't', 220, %00111111 ; ITEM 176, -9, 't' ; 11 = Furs
       ; ITEM 32,  -1, 't',  53, %00000011 ; ITEM 32,  -1, 't' ; 12 = Minerals
       ; ITEM 97,  -1, 'k',  66, %00000111 ; ITEM 97,  -1, 'k' ; 13 = Gold
       ; ITEM 171, -2, 'k',  55, %00011111 ; ITEM 171, -2, 'k' ; 14 = Platinum
       ; ITEM 45,  -1, 'g', 250, %00001111 ; ITEM 45,  -1, 'g' ; 15 = Gem-Stones
       ; ITEM 53,  15, 't', 192, %00000111 ; ITEM 53,  15, 't' ; 16 = Alien items

* ******************************************************************************
* 
* Name: TIDY
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Orthonormalise the orientation vectors for a ship
* Deep dive: Tidying orthonormal vectors
* Orientation vectors
* 
* ------------------------------------------------------------------------------
* 
* This routine orthonormalises the orientation vectors for a ship. This means
* making the three orientation vectors orthogonal (perpendicular to each other),
* and normal (so each of the vectors has length 1).
* 
* We do this because we use the small angle approximation to rotate these
* vectors in space. It is not completely accurate, so the three vectors tend
* to get stretched over time, so periodically we tidy the vectors with this
* routine to ensure they remain as orthonormal as possible.
* 
* ******************************************************************************

TI2:
                                                           ; Called from below with A = 0, X = 0, Y = 4 when
                                                           ; nosev_x and nosev_y are small, so we assume that
                                                           ; nosev_z is big
       movb ry,ra                      ; TYA               ; A = Y = 4
       li   ry,>02*256                 ; LDY #2            
       .jsr @TIS3                      ; JSR TIS3          ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
       movb ra,@INWK+20                ; STA INWK+20       ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z

       b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying

TI1:
                                                           ; Called from below with A = 0, Y = 4 when nosev_x is
                                                           ; small
       movb ra,rx                      ; TAX               ; Set X = A = 0

       movb @XX15+1,ra                 ; LDA XX15+1        ; Set A = nosev_y, and if the top two magnitude bits
       andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
       jeq  TI2                        ; BEQ TI2           

       li   ra,>02*256                 ; LDA #2            ; Otherwise nosev_y is big, so set up the index values
                                                           ; to pass to TIS3

       .jsr @TIS3                      ; JSR TIS3          ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
       movb ra,@INWK+18                ; STA INWK+18       ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y

       b    @TI3                       ; JMP TI3           ; Jump to TI3 to keep tidying

TIDY:
       movb @INWK+10,ra                ; LDA INWK+10       ; Set (XX15, XX15+1, XX15+2) = nosev
       movb ra,@XX15                   ; STA XX15          
       movb @INWK+12,ra                ; LDA INWK+12       
       movb ra,@XX15+1                 ; STA XX15+1        
       movb @INWK+14,ra                ; LDA INWK+14       
       movb ra,@XX15+2                 ; STA XX15+2        

       .jsr @NORM                      ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. nosev

       movb @XX15,ra                   ; LDA XX15          ; Set nosev = (XX15, XX15+1, XX15+2)
       movb ra,@INWK+10                ; STA INWK+10       
       movb @XX15+1,ra                 ; LDA XX15+1        
       movb ra,@INWK+12                ; STA INWK+12       
       movb @XX15+2,ra                 ; LDA XX15+2        
       movb ra,@INWK+14                ; STA INWK+14       

       li   ry,>04*256                 ; LDY #4            ; Set Y = 4

       movb @XX15,ra                   ; LDA XX15          ; Set A = nosev_x, and if the top two magnitude bits
       andi ra,>60*256                 ; AND #%01100000    ; are both clear, jump to TI1 with A = 0, Y = 4
       jeq  TI1                        ; BEQ TI1           

       li   rx,>02*256                 ; LDX #2            ; Otherwise nosev_x is big, so set up the index values
       li   ra,>00*256                 ; LDA #0            ; to pass to TIS3

       .jsr @TIS3                      ; JSR TIS3          ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
       movb ra,@INWK+16                ; STA INWK+16       ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x

TI3:
       movb @INWK+16,ra                ; LDA INWK+16       ; Set (XX15, XX15+1, XX15+2) = roofv
       movb ra,@XX15                   ; STA XX15          
       movb @INWK+18,ra                ; LDA INWK+18       
       movb ra,@XX15+1                 ; STA XX15+1        
       movb @INWK+20,ra                ; LDA INWK+20       
       movb ra,@XX15+2                 ; STA XX15+2        

       .jsr @NORM                      ; JSR NORM          ; Call NORM to normalise the vector in XX15, i.e. roofv

       movb @XX15,ra                   ; LDA XX15          ; Set roofv = (XX15, XX15+1, XX15+2)
       movb ra,@INWK+16                ; STA INWK+16       
       movb @XX15+1,ra                 ; LDA XX15+1        
       movb ra,@INWK+18                ; STA INWK+18       
       movb @XX15+2,ra                 ; LDA XX15+2        
       movb ra,@INWK+20                ; STA INWK+20       

       movb @INWK+12,ra                ; LDA INWK+12       ; Set Q = nosev_y
       movb ra,@Q                      ; STA Q             

       movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z

       .jsr @MULT12                    ; JSR MULT12        ; Set (S R) = Q * A = nosev_y * roofv_z

       movb @INWK+14,rx                ; LDX INWK+14       ; Set X = nosev_z

       movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y

       .jsr @TIS1                      ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
                                                           ; = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
                                                           ; 
                                                           ; This also sets Q = nosev_z

       .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_x = -A
       movb ra,@INWK+22                ; STA INWK+22       ; = (nosev_z * roofv_y - nosev_y * roofv_z) / 96

       movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x

       .jsr @MULT12                    ; JSR MULT12        ; Set (S R) = Q * A = nosev_z * roofv_x

       movb @INWK+10,rx                ; LDX INWK+10       ; Set X = nosev_x

       movb @INWK+20,ra                ; LDA INWK+20       ; Set A = roofv_z

       .jsr @TIS1                      ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
                                                           ; = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
                                                           ; 
                                                           ; This also sets Q = nosev_x

       .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_y = -A
       movb ra,@INWK+24                ; STA INWK+24       ; = (nosev_x * roofv_z - nosev_z * roofv_x) / 96

       movb @INWK+18,ra                ; LDA INWK+18       ; Set A = roofv_y

       .jsr @MULT12                    ; JSR MULT12        ; Set (S R) = Q * A = nosev_x * roofv_y

       movb @INWK+12,rx                ; LDX INWK+12       ; Set X = nosev_y

       movb @INWK+16,ra                ; LDA INWK+16       ; Set A = roofv_x

       .jsr @TIS1                      ; JSR TIS1          ; Set (A ?) = (-X * A + (S R)) / 96
                                                           ; = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96

       .eoi (>80*256)                  ; EOR #%10000000    ; Set sidev_z = -A
       movb ra,@INWK+26                ; STA INWK+26       ; = (nosev_y * roofv_x - nosev_x * roofv_y) / 96

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 so we can clear the low bytes of the
                                                           ; orientation vectors

       li   rx,>0e*256                 ; LDX #14           ; We want to clear the low bytes, so start from sidev_y
                                                           ; at byte #9+14 (we clear all except sidev_z_lo, though
                                                           ; I suspect this is in error and that X should be 16)

TIL1:
       movb ra,@INWK+9(rx)             ; STA INWK+9,X      ; Set the low byte in byte #9+X to zero

       sb   rone,rx                    ; DEX               ; Set X = X - 2 to jump down to the next low byte
       sb   rone,rx                    ; DEX               

       jgt  TIL1                       ; BPL TIL1          ; Loop back until we have zeroed all the low bytes

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TIS2
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate A = A / Q
* Deep dive: Shift-and-subtract division
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following division, where A is a sign-magnitude number and Q is
* a positive integer:
* 
* A = A / Q
* 
* The value of A is returned as a sign-magnitude number with 96 representing 1,
* and the maximum value returned is 1 (i.e. 96). This routine is used when
* normalising vectors, where we represent fractions using integers, so this
* gives us an approximation to two decimal places.
* 
* ******************************************************************************

TIS2:
       movb ra,ry                      ; TAY               ; Store the argument A in Y

       andi ra,>7f*256                 ; AND #%01111111    ; Strip the sign bit from the argument, so A = |A|

       cb   @Q,ra                      ; CMP Q             ; If A >= Q then jump to TI4 to return a 1 with the
       joc  TI4                        ; BCS TI4           ; correct sign

       li   rx,>fe*256                 ; LDX #%11111110    ; Set T to have bits 1-7 set, so we can rotate through 7
       movb rx,@T                      ; STX T             ; loop iterations, getting a 1 each time, and then
                                                           ; getting a 0 on the 8th iteration... and we can also
                                                           ; use T to catch our result bits into bit 0 each time

TIL2:
       .asla                           ; ASL A             ; Shift A to the left

       cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
       jnc  B108                       ; BCC B108          

       .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q
                                                           ; 
                                                           ; Going into this subtraction we know the C flag is
                                                           ; set as we passed through the BCC above, and we also
                                                           ; know that A >= Q, so the C flag will still be set once
                                                           ; we are done

B108:
       .rol @T                         ; ROL T             ; Rotate the counter in T to the left, and catch the
                                                           ; result bit into bit 0 (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       joc  TIL2                       ; BCS TIL2          ; If we still have set bits in T, loop back to TIL2 to
                                                           ; do the next iteration of 7

                                                           ; We've done the division and now have a result in the
                                                           ; range 0-255 here, which we need to reduce to the range
                                                           ; 0-96. We can do that by multiplying the result by 3/8,
                                                           ; as 256 * 3/8 = 96

       movb @T,ra                      ; LDA T             ; Set T = T / 4
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       movb ra,@T                      ; STA T             

       srl  ra,1                       ; LSR A             ; Set T = T / 8 + T / 4
       .adc @T,ra                      ; ADC T             ; = 3T / 8
       movb ra,@T                      ; STA T             

       movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
       andi ra,>80*256                 ; AND #%10000000    

       socb @T,ra                      ; ORA T             ; Apply the sign bit to T

       .rts                            ; RTS               ; Return from the subroutine

TI4:
       movb ry,ra                      ; TYA               ; Fetch the sign bit of the original argument A
       andi ra,>80*256                 ; AND #%10000000    

       ori  ra,>60*256                 ; ORA #96           ; Apply the sign bit to 96 (which represents 1)

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: TIS3
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following expression:
* 
* A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
* 
* where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
* routine is called with the following values:
* 
* X = 0, Y = 2, A = 4 ->
* A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
* 
* X = 0, Y = 4, A = 2 ->
* A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
* 
* X = 2, Y = 4, A = 0 ->
* A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* X                   Index 1 (0 = x, 2 = y, 4 = z)
* 
* Y                   Index 2 (0 = x, 2 = y, 4 = z)
* 
* A                   Index 3 (0 = x, 2 = y, 4 = z)
* 
* ******************************************************************************

TIS3:
       movb ra,@P+2                    ; STA P+2           ; Store P+2 in A for later

       movb @INWK+10(rx),ra            ; LDA INWK+10,X     ; Set Q = nosev_x_hi (plus X)
       movb ra,@Q                      ; STA Q             

       movb @INWK+16(rx),ra            ; LDA INWK+16,X     ; Set A = roofv_x_hi (plus X)

       .jsr @MULT12                    ; JSR MULT12        ; Set (S R) = Q * A
                                                           ; = nosev_x_hi * roofv_x_hi

       movb @INWK+10(ry),rx            ; LDX INWK+10,Y     ; Set Q = nosev_x_hi (plus Y)
       movb rx,@Q                      ; STX Q             

       movb @INWK+16(ry),ra            ; LDA INWK+16,Y     ; Set A = roofv_x_hi (plus Y)

       .jsr @MAD                       ; JSR MAD           ; Set (A X) = Q * A + (S R)
                                                           ; = (nosev_x,X * roofv_x,X) +
                                                           ; (nosev_x,Y * roofv_x,Y)

       movb rx,@P                      ; STX P             ; Store low byte of result in P, so result is now in
                                                           ; (A P)

       movb @P+2,ry                    ; LDY P+2           ; Set Q = roofv_x_hi (plus argument A)
       movb @INWK+10(ry),rx            ; LDX INWK+10,Y     
       movb rx,@Q                      ; STX Q             

       .eoi (>80*256)                  ; EOR #%10000000    ; Flip the sign of A

                                                           ; Fall through into DIVDT to do:
                                                           ; 
                                                           ; (P+1 A) = (A P) / Q
                                                           ; 
                                                           ; = -((nosev_x,X * roofv_x,X) +
                                                           ; (nosev_x,Y * roofv_x,Y))
                                                           ; / nosev_x,A

* ******************************************************************************
* 
* Name: DVIDT
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (P+1 A) = (A P) / Q
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following integer division between sign-magnitude numbers:
* 
* (P+1 A) = (A P) / Q
* 
* This uses the same shift-and-subtract algorithm as TIS2.
* 
* ******************************************************************************

DVIDT:
       movb ra,@P+1                    ; STA P+1           ; Set P+1 = A, so P(1 0) = (A P)

       .eor @Q                         ; EOR Q             ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
       andi ra,>80*256                 ; AND #%10000000    ; have different signs, i.e. it's the sign of the result
       movb ra,@T                      ; STA T             ; of A / Q

       li   ra,>00*256                 ; LDA #0            ; Set A = 0 for us to build a result

       li   rx,>10*256                 ; LDX #16           ; Set a counter in X to count the 16 bits in P(1 0)

       .asl @P                         ; ASL P             ; Shift P(1 0) left
       .rol @P+1                       ; ROL P+1           

       .asl @Q                         ; ASL Q             ; Clear the sign bit of Q the C flag at the same time
       .lsr @Q                         ; LSR Q             

DVL2:
       .rola                           ; ROL A             ; Shift A to the left

       cb   @Q,ra                      ; CMP Q             ; If A < Q skip the following subtraction
       jnc  B109                       ; BCC B109          

       .sbc @Q,ra                      ; SBC Q             ; Set A = A - Q
                                                           ; 
                                                           ; Going into this subtraction we know the C flag is
                                                           ; set as we passed through the BCC above, and we also
                                                           ; know that A >= Q, so the C flag will still be set once
                                                           ; we are done

B109:
       .rol @P                         ; ROL P             ; Rotate P(1 0) to the left, and catch the result bit
       .rol @P+1                       ; ROL P+1           ; into the C flag (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jne  DVL2                       ; BNE DVL2          ; Loop back for the next bit until we have done all 16
                                                           ; bits of P(1 0)

       movb @P,ra                      ; LDA P             ; Set A = P so the low byte is in the result in A

       socb @T,ra                      ; ORA T             ; Set A to the correct sign bit that we set in T above

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Save ELTF.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE G FILE
* 
* Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_G.:
       equ $

LOAD_G.:
       equ LOAD. + $ - CODE.

* ******************************************************************************
* 
* Name: SHPPT
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw a distant ship as a point rather than a full wireframe
* 
* ******************************************************************************

SHPPT:
       .jsr @EE51                      ; JSR EE51          ; Call EE51 to remove the ship's wireframe from the
                                                           ; screen, if there is one

       .jsr @PROJ                      ; JSR PROJ          ; Project the ship onto the screen, returning:
                                                           ; 
                                                           ; * K3(1 0) = the screen x-coordinate
                                                           ; * K4(1 0) = the screen y-coordinate
                                                           ; * A = K4+1

       socb @K3+1,ra                   ; ORA K3+1          ; If either of the high bytes of the screen coordinates
       jne  nono_                      ; BNE nono          ; are non-zero, jump to nono as the ship is off-screen

       movb @K4,ra                     ; LDA K4            ; Set A = the y-coordinate of the dot

       ci   ra,(Y*2-2)*256             ; CMP #Y*2-2        ; If the y-coordinate is bigger than the y-coordinate of
       joc  nono_                      ; BCS nono          ; the bottom of the screen, jump to nono as the ship's
                                                           ; dot is off the bottom of the space view

       li   ry,>02*256                 ; LDY #2            ; Call Shpt with Y = 2 to set up bytes 1-4 in the ship
       .jsr @Shpt                      ; JSR Shpt          ; lines space, aborting the call to LL9 if the dot is
                                                           ; off the side of the screen. This call sets up the
                                                           ; first row of the dot (i.e. a four-pixel dash)

       li   ry,>06*256                 ; LDY #6            ; Set Y to 6 for the next call to Shpt

       movb @K4,ra                     ; LDA K4            ; Set A = y-coordinate of dot + 1 (so this is the second
       .adi (>01*256)                  ; ADC #1            ; row of the two-pixel-high dot)
                                                           ; 
                                                           ; The addition works as the Shpt routine clears the C
                                                           ; flag

       .jsr @Shpt                      ; JSR Shpt          ; Call Shpt with Y = 6 to set up bytes 5-8 in the ship
                                                           ; lines space, aborting the call to LL9 if the dot is
                                                           ; off the side of the screen. This call sets up the
                                                           ; second row of the dot (i.e. another four-pixel dash,
                                                           ; on the row below the first one)

       li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of the ship's byte #31 to record that we
       socb @XX1+31,ra                 ; ORA XX1+31        ; have now drawn something on-screen for this ship
       movb ra,@XX1+31                 ; STA XX1+31        

       li   ra,>08*256                 ; LDA #8            ; Set A = 8 so when we call LL18+2 next, byte #0 of the
                                                           ; heap gets set to 8, for the 8 bytes we just stuck on
                                                           ; the heap

       b    @LL81+2                    ; JMP LL81+2        ; Call LL81+2 to draw the ship's dot, returning from the
                                                           ; subroutine using a tail call

       .pla                            ; PLA               ; Pull the return address from the stack, so the RTS
       .pla                            ; PLA               ; below actually returns from the subroutine that called
                                                           ; LL9 (as we called SHPPT from LL9 with a JMP)

nono_:
       li   ra,>f7*256                 ; LDA #%11110111    ; Clear bit 3 of the ship's byte #31 to record that
       .and @XX1+31                    ; AND XX1+31        ; nothing is being drawn on-screen for this ship
       movb ra,@XX1+31                 ; STA XX1+31        

       .rts                            ; RTS               ; Return from the subroutine

Shpt:
                                                           ; This routine sets up four bytes in the ship line heap,
                                                           ; from byte Y-1 to byte Y+2. If the ship's screen point
                                                           ; turns out to be off-screen, then this routine aborts
                                                           ; the entire call to LL9, exiting via nono. The four
                                                           ; bytes define a horizontal 4-pixel dash, for either the
                                                           ; top or the bottom of the ship's dot
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in byte Y of the ship line heap (i.e. Y1)

       ab   rone,ry                    ; INY               ; Store A in byte Y+2 of the ship line heap (i.e. Y2)
       ab   rone,ry                    ; INY               
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       movb @K3,ra                     ; LDA K3            ; Set A = screen x-coordinate of the ship dot

       sb   rone,ry                    ; DEY               ; Store A in byte Y+1 of the ship line heap (i.e. X2)
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       .adi (>03*256)                  ; ADC #3            ; Set A = screen x-coordinate of the ship dot + 3

       joc  nono_-2                    ; BCS nono-2        ; If the addition pushed the dot off the right side of
                                                           ; the screen, jump to nono-2 to return from the parent
                                                           ; subroutine early (i.e. LL9). This works because we
                                                           ; called Shpt from above with a JSR, so nono-2 removes
                                                           ; that return address from the stack, leaving the next
                                                           ; return address exposed. LL9 called SHPPT with a JMP,
                                                           ; so the next return address is the one that was put on
                                                           ; the stack by the original call to LL9. So the RTS in
                                                           ; nono will actually return us from the original call
                                                           ; to LL9, thus aborting the entire drawing process

       sb   rone,ry                    ; DEY               ; Store A in byte Y-1 of the ship line heap (i.e. X1)
       sb   rone,ry                    ; DEY               
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL5
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate Q = SQRT(R Q)
* Deep dive: Calculating square roots
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following square root:
* 
* Q = SQRT(R Q)
* 
* ******************************************************************************

LL5:
       movb @R,ry                      ; LDY R             ; Set (Y S) = (R Q)
       movb @Q,ra                      ; LDA Q             
       movb ra,@S                      ; STA S             

                                                           ; So now to calculate Q = SQRT(Y S)

       li   rx,>00*256                 ; LDX #0            ; Set X = 0, to hold the remainder

       movb rx,@Q                      ; STX Q             ; Set Q = 0, to hold the result

       li   ra,>08*256                 ; LDA #8            ; Set T = 8, to use as a loop counter
       movb ra,@T                      ; STA T             

LL6:
       cb   @Q,rx                      ; CPX Q             ; If X < Q, jump to LL7
       jnc  LL7                        ; BCC LL7           

       jne  LL8                        ; BNE LL8           ; If X > Q, jump to LL8

       ci   ry,>40*256                 ; CPY #64           ; If Y < 64, jump to LL7 with the C flag clear,
       jnc  LL7                        ; BCC LL7           ; otherwise fall through into LL8 with the C flag set

LL8:
       movb ry,ra                      ; TYA               ; Set Y = Y - 64
       .sbi (>40*256)                  ; SBC #64           ; 
       movb ra,ry                      ; TAY               ; This subtraction will work as we know C is set from
                                                           ; the BCC above, and the result will not underflow as we
                                                           ; already checked that Y >= 64, so the C flag is also
                                                           ; set for the next subtraction

       movb rx,ra                      ; TXA               ; Set X = X - Q
       .sbc @Q,ra                      ; SBC Q             
       movb ra,rx                      ; TAX               

LL7:
       .rol @Q                         ; ROL Q             ; Shift the result in Q to the left, shifting the C flag
                                                           ; into bit 0 and bit 7 into the C flag

       .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left, inserting
       movb ry,ra                      ; TYA               ; bit 7 from above into bit 0
       .rola                           ; ROL A             
       movb ra,ry                      ; TAY               

       movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
       .rola                           ; ROL A             
       movb ra,rx                      ; TAX               

       .asl @S                         ; ASL S             ; Shift the dividend in (Y S) to the left
       movb ry,ra                      ; TYA               
       .rola                           ; ROL A             
       movb ra,ry                      ; TAY               

       movb rx,ra                      ; TXA               ; Shift the remainder in X to the left
       .rola                           ; ROL A             
       movb ra,rx                      ; TAX               

       sb   rone,ra                    ; DEC T             ; Decrement the loop counter

       jne  LL6                        ; BNE LL6           ; Loop back to LL6 until we have done 8 loops

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL28
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate R = 256 * A / Q
* Deep dive: Shift-and-subtract division
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following, where A < Q:
* 
* R = 256 * A / Q
* 
* This is a sister routine to LL61, which does the division when A >= Q.
* 
* If A >= Q then 255 is returned and the C flag is set to indicate an overflow
* (the C flag is clear if the division was a success).
* 
* The result is returned in one byte as the result of the division multiplied
* by 256, so we can return fractional results using integers.
* 
* This routine uses the same shift-and-subtract algorithm that's documented in
* TIS2, but it leaves the fractional result in the integer range 0-255.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the answer is too big for one byte, clear if the
* division was a success
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL28+4              Skips the A >= Q check and always returns with C flag
* cleared, so this can be called if we know the division
* will work
* 
* LL31                Skips the A >= Q check and does not set the R counter,
* so this can be used for jumping straight into the
* division loop if R is already set to 254 and we know the
* division will work
* 
* ******************************************************************************

LL28:
       cb   @Q,ra                      ; CMP Q             ; If A >= Q, then the answer will not fit in one byte,
       joc  LL2                        ; BCS LL2           ; so jump to LL2 to return 255

       li   rx,>fe*256                 ; LDX #%11111110    ; Set R to have bits 1-7 set, so we can rotate through 7
       movb rx,@R                      ; STX R             ; loop iterations, getting a 1 each time, and then
                                                           ; getting a 0 on the 8th iteration... and we can also
                                                           ; use R to catch our result bits into bit 0 each time

LL31:
       .asla                           ; ASL A             ; Shift A to the left

       joc  LL29                       ; BCS LL29          ; If bit 7 of A was set, then jump straight to the
                                                           ; subtraction

       cb   @Q,ra                      ; CMP Q             ; If A < Q, skip the following subtraction
       jnc  B110                       ; BCC B110          

       .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q

B110:
       .rol @R                         ; ROL R             ; Rotate the counter in R to the left, and catch the
                                                           ; result bit into bit 0 (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
                                                           ; do the next iteration of 7

       .rts                            ; RTS               ; R left with remainder of division

LL29:
       .sbc @Q,ra                      ; SBC Q             ; A >= Q, so set A = A - Q

       .sec                            ; SEC               ; Set the C flag to rotate into the result in R

       .rol @R                         ; ROL R             ; Rotate the counter in R to the left, and catch the
                                                           ; result bit into bit 0 (which will be a 0 if we didn't
                                                           ; do the subtraction, or 1 if we did)

       joc  LL31                       ; BCS LL31          ; If we still have set bits in R, loop back to LL31 to
                                                           ; do the next iteration of 7

       .rts                            ; RTS               ; Return from the subroutine with R containing the
                                                           ; remainder of the division

LL2:
       li   ra,>ff*256                 ; LDA #255          ; The division is very close to 1, so return the closest
       movb ra,@R                      ; STA R             ; possible answer to 256, i.e. R = 255

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL38
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (S A) = (S R) + (A Q)
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following between sign-magnitude numbers:
* 
* (S A) = (S R) + (A Q)
* 
* where the sign bytes only contain the sign bits, not magnitudes.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* C flag              Set if the addition overflowed, clear otherwise
* 
* ******************************************************************************

LL38:
       .eor @S                         ; EOR S             ; If the sign of A * S is negative, skip to LL35, as
       jlt  LL39                       ; BMI LL39          ; A and S have different signs so we need to subtract

       movb @Q,ra                      ; LDA Q             ; Otherwise set A = R + Q, which is the result we need,
       .clc                            ; CLC               ; as S already contains the correct sign
       .adc @R,ra                      ; ADC R             

       .rts                            ; RTS               ; Return from the subroutine

LL39:
       movb @R,ra                      ; LDA R             ; Set A = R - Q
       .sec                            ; SEC               
       .sbc @Q,ra                      ; SBC Q             

       jnc  B111                       ; BCC B111          ; If the subtraction underflowed, skip the next two
                                                           ; instructions so we can negate the result

       .clc                            ; CLC               ; Otherwise the result is correct, and S contains the
                                                           ; correct sign of the result as R is the dominant side
                                                           ; of the subtraction, so clear the C flag

B111:
       .rts                            ; RTS               ; And return from the subroutine

                                                           ; If we get here we need to negate both the result and
                                                           ; the sign in S, as both are the wrong sign

       .pha                            ; PHA               ; Store the result of the subtraction on the stack

       movb @S,ra                      ; LDA S             ; Flip the sign of S
       .eoi (>80*256)                  ; EOR #%10000000    
       movb ra,@S                      ; STA S             

       .pla                            ; PLA               ; Restore the subtraction result into A

       .eoi (>ff*256)                  ; EOR #%11111111    ; Negate the result in A using two's complement, i.e.
       .adi (>01*256)                  ; ADC #1            ; set A = ~A + 1

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL51
* Type: Subroutine
* Category: Maths (Geometry)
* Summary: Calculate the dot product of XX15 and XX16
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following dot products:
* 
* XX12(1 0) = XX15(5 0) . XX16(5 0)
* XX12(3 2) = XX15(5 0) . XX16(11 6)
* XX12(5 4) = XX15(5 0) . XX16(12 17)
* 
* storing the results as sign-magnitude numbers in XX12 through XX12+5.
* 
* When called from part 5 of LL9, XX12 contains the vector [x y z] to the ship
* we're drawing, and XX16 contains the orientation vectors, so it returns:
* 
* [ x ]   [ sidev_x ]         [ x ]   [ roofv_x ]         [ x ]   [ nosev_x ]
* [ y ] . [ sidev_y ]         [ y ] . [ roofv_y ]         [ y ] . [ nosev_y ]
* [ z ]   [ sidev_z ]         [ z ]   [ roofv_z ]         [ z ]   [ nosev_z ]
* 
* When called from part 6 of LL9, XX12 contains the vector [x y z] of the vertex
* we're analysing, and XX16 contains the transposed orientation vectors with
* each of them containing the x, y and z elements of the original vectors, so it
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* [ x ]   [ sidev_x ]         [ x ]   [ sidev_y ]         [ x ]   [ sidev_z ]
* [ y ] . [ roofv_x ]         [ y ] . [ roofv_y ]         [ y ] . [ roofv_z ]
* [ z ]   [ nosev_x ]         [ z ]   [ nosev_y ]         [ z ]   [ nosev_z ]
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX15(1 0)           The ship (or vertex)'s x-coordinate as (x_sign x_lo)
* 
* XX15(3 2)           The ship (or vertex)'s y-coordinate as (y_sign y_lo)
* 
* XX15(5 4)           The ship (or vertex)'s z-coordinate as (z_sign z_lo)
* 
* XX16 to XX16+5      The scaled sidev (or _x) vector, with:
* 
* * x, y, z magnitudes in XX16, XX16+2, XX16+4
* 
* * x, y, z signs in XX16+1, XX16+3, XX16+5
* 
* XX16+6 to XX16+11   The scaled roofv (or _y) vector, with:
* 
* * x, y, z magnitudes in XX16+6, XX16+8, XX16+10
* 
* * x, y, z signs in XX16+7, XX16+9, XX16+11
* 
* XX16+12 to XX16+17  The scaled nosev (or _z) vector, with:
* 
* * x, y, z magnitudes in XX16+12, XX16+14, XX16+16
* 
* * x, y, z signs in XX16+13, XX16+15, XX16+17
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* XX12(1 0)           The dot product of [x y z] vector with the sidev (or _x)
* vector, with the sign in XX12+1 and magnitude in XX12
* 
* XX12(3 2)           The dot product of [x y z] vector with the roofv (or _y)
* vector, with the sign in XX12+3 and magnitude in XX12+2
* 
* XX12(5 4)           The dot product of [x y z] vector with the nosev (or _z)
* vector, with the sign in XX12+5 and magnitude in XX12+4
* 
* ******************************************************************************

LL51:
       li   rx,>00*256                 ; LDX #0            ; Set X = 0, which will contain the offset of the vector
                                                           ; to use in the calculation, increasing by 6 for each
                                                           ; new vector

       li   ry,>00*256                 ; LDY #0            ; Set Y = 0, which will contain the offset of the
                                                           ; result bytes in XX12, increasing by 2 for each new
                                                           ; result

ll51_:
       movb @XX15,ra                   ; LDA XX15          ; Set Q = x_lo
       movb ra,@Q                      ; STA Q             

       movb @XX16(rx),ra               ; LDA XX16,X        ; Set A = |sidev_x|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set T = A * Q / 256
       movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo / 256

       movb @XX15+1,ra                 ; LDA XX15+1        ; Set S to the sign of x_sign * sidev_x
       .eor @XX16+1(rx)                ; EOR XX16+1,X      
       movb ra,@S                      ; STA S             

       movb @XX15+2,ra                 ; LDA XX15+2        ; Set Q = y_lo
       movb ra,@Q                      ; STA Q             

       movb @XX16+2(rx),ra             ; LDA XX16+2,X      ; Set A = |sidev_y|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set Q = A * Q / 256
       movb ra,@Q                      ; STA Q             ; = |sidev_y| * y_lo / 256

       movb @T,ra                      ; LDA T             ; Set R = T
       movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo / 256

       movb @XX15+3,ra                 ; LDA XX15+3        ; Set A to the sign of y_sign * sidev_y
       .eor @XX16+3(rx)                ; EOR XX16+3,X      

       .jsr @LL38                      ; JSR LL38          ; Set (S T) = (S R) + (A Q)
       movb ra,@T                      ; STA T             ; = |sidev_x| * x_lo + |sidev_y| * y_lo

       movb @XX15+4,ra                 ; LDA XX15+4        ; Set Q = z_lo
       movb ra,@Q                      ; STA Q             

       movb @XX16+4(rx),ra             ; LDA XX16+4,X      ; Set A = |sidev_z|

       .jsr @FMLTU                     ; JSR FMLTU         ; Set Q = A * Q / 256
       movb ra,@Q                      ; STA Q             ; = |sidev_z| * z_lo / 256

       movb @T,ra                      ; LDA T             ; Set R = T
       movb ra,@R                      ; STA R             ; = |sidev_x| * x_lo + |sidev_y| * y_lo

       movb @XX15+5,ra                 ; LDA XX15+5        ; Set A to the sign of z_sign * sidev_z
       .eor @XX16+5(rx)                ; EOR XX16+5,X      

       .jsr @LL38                      ; JSR LL38          ; Set (S A) = (S R) + (A Q)
                                                           ; = |sidev_x| * x_lo + |sidev_y| * y_lo
                                                           ; + |sidev_z| * z_lo

       movb ra,@XX12(ry)               ; STA XX12,Y        ; Store the result in XX12+Y(1 0)
       movb @S,ra                      ; LDA S             
       movb ra,@XX12+1(ry)             ; STA XX12+1,Y      

       ab   rone,ry                    ; INY               ; Set Y = Y + 2
       ab   rone,ry                    ; INY               

       movb rx,ra                      ; TXA               ; Set X = X + 6
       .clc                            ; CLC               
       .adi (>06*256)                  ; ADC #6            
       movb ra,rx                      ; TAX               

       ci   ra,>11*256                 ; CMP #17           ; If X < 17, loop back to ll51 for the next vector
       jnc  ll51_                      ; BCC ll51          

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL9 (Part 1 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Check if ship is exploding, check if ship is in front
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This routine draws the current ship on the screen. This part checks to see if
* the ship is exploding, or if it should start exploding, and if it does it sets
* things up accordingly.
* 
* It also does some basic checks to see if we can see the ship, and if not it
* removes it from the screen.
* 
* In this code, XX1 is used to point to the current ship's data block at INWK
* (the two labels are interchangeable).
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX1                 XX1 shares its location with INWK, which contains the
* zero-page copy of the data block for this ship from the
* K% workspace
* 
* INF                 The address of the data block for this ship in workspace
* K%
* 
* XX19(1 0)           XX19(1 0) shares its location with INWK(34 33), which
* contains the ship line heap address pointer
* 
* XX0                 The address of the blueprint for this ship
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* EE51                Remove the current ship from the screen, called from
* SHPPT before drawing the ship as a point
* 
* ******************************************************************************

LL25:
       b    @PLANET                    ; JMP PLANET        ; Jump to the PLANET routine, returning from the
                                                           ; subroutine using a tail call

LL9:
       movb @TYPE,ra                   ; LDA TYPE          ; If the ship type is negative then this indicates a
       jlt  LL25                       ; BMI LL25          ; planet or sun, so jump to PLANET via LL25 above

       li   ra,>1f*256                 ; LDA #31           ; Set XX4 = 31 to store the ship's distance for later
       movb ra,@XX4                    ; STA XX4           ; comparison with the visibility distance. We will
                                                           ; update this value below with the actual ship's
                                                           ; distance if it turns out to be visible on-screen

       li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the ship
       .bit @XX1+31                    ; BIT XX1+31        ; is currently exploding, so jump down to EE28
       jne  EE28                       ; BNE EE28          

       jgt  EE28                       ; BPL EE28          ; If bit 7 of the ship's byte #31 is clear then the ship
                                                           ; has not just been killed, so jump down to EE28

                                                           ; Otherwise bit 5 is clear and bit 7 is set, so the ship
                                                           ; is not yet exploding but it has been killed, so we
                                                           ; need to start an explosion

       socb @XX1+31,ra                 ; ORA XX1+31        ; Clear bits 6 and 7 of the ship's byte #31, to stop the
       andi ra,>3f*256                 ; AND #%00111111    ; ship from firing its laser and to mark it as no longer
       movb ra,@XX1+31                 ; STA XX1+31        ; having just been killed

       li   ra,>00*256                 ; LDA #0            ; Set the ship's acceleration in byte #31 to 0, updating
       li   ry,>1c*256                 ; LDY #28           ; the byte in the workspace K% data block so we don't
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; have to copy it back from INWK later

       li   ry,>1e*256                 ; LDY #30           ; Set the ship's pitch counter in byte #30 to 0, to stop
       .st_ind_y_idx @INF,ra           ; STA (INF),Y       ; the ship from pitching

       .jsr @EE51                      ; JSR EE51          ; Call EE51 to remove the ship from the screen

                                                           ; We now need to set up a new explosion cloud. We
                                                           ; initialise it with a size of 18 (which gets increased
                                                           ; by 4 every time the cloud gets redrawn), and the
                                                           ; explosion count (i.e. the number of particles in the
                                                           ; explosion), which go into bytes 1 and 2 of the ship
                                                           ; line heap. See DOEXP for more details of explosion
                                                           ; clouds

       li   ry,>01*256                 ; LDY #1            ; Set byte #1 of the ship line heap to 18, the initial
       li   ra,>12*256                 ; LDA #18           ; size of the explosion cloud
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       li   ry,>07*256                 ; LDY #7            ; Fetch byte #7 from the ship's blueprint, which
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; determines the explosion count (i.e. the number of
       li   ry,>02*256                 ; LDY #2            ; vertices used as origins for explosion clouds), and
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; store it in byte #2 of the ship line heap

* LDA XX1+32             \ These instructions are commented out in the original
* AND #&7F               \ source

                                                           ; The following loop sets bytes 3-6 of the of the ship
                                                           ; line heap to random numbers

EE55:
       ab   rone,ry                    ; INY               ; Increment Y (so the loop starts at 3)

       .jsr @DORND                     ; JSR DORND         ; Set A and X to random numbers

       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; Store A in the Y-th byte of the ship line heap

       ci   ry,>06*256                 ; CPY #6            ; Loop back until we have randomised the 6th byte
       jne  EE55                       ; BNE EE55          

EE28:
       movb @XX1+8,ra                  ; LDA XX1+8         ; Set A = z_sign

EE49:
       jgt  LL10                       ; BPL LL10          ; If A is positive, i.e. the ship is in front of us,
                                                           ; jump down to LL10

LL14:
                                                           ; The following removes the ship from the screen by
                                                           ; redrawing it (or, if it is exploding, by redrawing the
                                                           ; explosion cloud). We call it when the ship is no
                                                           ; longer on-screen, is too far away to be fully drawn,
                                                           ; and so on
       movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
       andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE51
       jeq  EE51                       ; BEQ EE51          ; to redraw its wireframe

       movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so clear bit 3 of the ship's
       andi ra,>f7*256                 ; AND #%11110111    ; byte #31 to denote that the ship is no longer being
       movb ra,@XX1+31                 ; STA XX1+31        ; drawn on-screen

       b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud, which
                                                           ; will remove it from the screen, returning from the
                                                           ; subroutine using a tail call

EE51:
       li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
       .bit @XX1+31                    ; BIT XX1+31        ; is already nothing being shown for this ship, so
       jeq  LL10-1                     ; BEQ LL10-1        ; return from the subroutine (as LL10-1 contains an RTS)

       .eor @XX1+31                    ; EOR XX1+31        ; Otherwise flip bit 3 of byte #31 and store it (which
       movb ra,@XX1+31                 ; STA XX1+31        ; clears bit 3 as we know it was set before the EOR), so
                                                           ; this sets this ship as no longer being drawn on-screen

       b    @LL155                     ; JMP LL155         ; Jump to LL155 to draw the ship, which removes it from
                                                           ; the screen, returning from the subroutine using a
                                                           ; tail call

* .LL24                  \ This label is commented out in the original source,
                                                           ; and was presumably used to label the RTS which is
                                                           ; actually called by LL10-1 above, not LL24

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL9 (Part 2 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Check if ship is in field of view, close enough to draw
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part checks whether the ship is in our field of view, and whether it is
* close enough to be fully drawn (if not, we jump to SHPPT to draw it as a dot).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL10-1              Contains an RTS
* 
* ******************************************************************************

LL10:
       movb @XX1+7,ra                  ; LDA XX1+7         ; Set A = z_hi

       ci   ra,>c0*256                 ; CMP #192          ; If A >= 192 then the ship is a long way away, so jump
       joc  LL14                       ; BCS LL14          ; to LL14 to remove the ship from the screen

       movb @XX1,ra                    ; LDA XX1           ; If x_lo >= z_lo, set the C flag, otherwise clear it
       cb   @XX1+6,ra                  ; CMP XX1+6         

       movb @XX1+1,ra                  ; LDA XX1+1         ; Set A = x_hi - z_hi using the carry from the low
       .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
                                                           ; two-byte subtraction (x_hi x_lo) - (z_hi z_lo)

       joc  LL14                       ; BCS LL14          ; If the C flag is set then x >= z, so the ship is
                                                           ; further to the side than it is in front of us, so it's
                                                           ; outside our viewing angle of 45 degrees, and we jump
                                                           ; to LL14 to remove it from the screen

       movb @XX1+3,ra                  ; LDA XX1+3         ; If y_lo >= z_lo, set the C flag, otherwise clear it
       cb   @XX1+6,ra                  ; CMP XX1+6         

       movb @XX1+4,ra                  ; LDA XX1+4         ; Set A = y_hi - z_hi using the carry from the low
       .sbc @XX1+7,ra                  ; SBC XX1+7         ; bytes, which sets the C flag as if we had done a full
                                                           ; two-byte subtraction (y_hi y_lo) - (z_hi z_lo)

       joc  LL14                       ; BCS LL14          ; If the C flag is set then y >= z, so the ship is
                                                           ; further above us than it is in front of us, so it's
                                                           ; outside our viewing angle of 45 degrees, and we jump
                                                           ; to LL14 to remove it from the screen

       li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 from the ship's blueprint into X, which
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; is the number * 4 of the vertex used for the ship's
       movb ra,rx                      ; TAX               ; laser

       li   ra,>ff*256                 ; LDA #255          ; Set bytes X and X+1 of the XX3 heap to 255. We're
       movb ra,@XX3(rx)                ; STA XX3,X         ; going to use XX3 to store the screen coordinates of
       movb ra,@XX3+1(rx)              ; STA XX3+1,X       ; all the visible vertices of this ship, so setting the
                                                           ; laser vertex to 255 means that if we don't update this
                                                           ; vertex with its screen coordinates in parts 6 and 7,
                                                           ; this vertex's entry in the XX3 heap will still be 255,
                                                           ; which we can check in part 9 to see if the laser
                                                           ; vertex is visible (and therefore whether we should
                                                           ; draw laser lines if the ship is firing on us)

       movb @XX1+6,ra                  ; LDA XX1+6         ; Set (A T) = (z_hi z_lo)
       movb ra,@T                      ; STA T             
       movb @XX1+7,ra                  ; LDA XX1+7         

       srl  ra,1                       ; LSR A             ; Set (A T) = (A T) / 8
       .ror @T                         ; ROR T             
       srl  ra,1                       ; LSR A             
       .ror @T                         ; ROR T             
       srl  ra,1                       ; LSR A             
       .ror @T                         ; ROR T             

       srl  ra,1                       ; LSR A             ; If A >> 4 is non-zero, i.e. z_hi >= 16, jump to LL13
       jne  LL13                       ; BNE LL13          ; as the ship is possibly far away enough to be shown as
                                                           ; a dot

       movb @T,ra                      ; LDA T             ; Otherwise the C flag contains the previous bit 0 of A,
       .rora                           ; ROR A             ; which could have been set, so rotate A right four
       srl  ra,1                       ; LSR A             ; times so it's in the form %000xxxxx, i.e. z_hi reduced
       srl  ra,1                       ; LSR A             ; to a maximum value of 31
       srl  ra,1                       ; LSR A             

       movb ra,@XX4                    ; STA XX4           ; Store A in XX4, which is now the distance of the ship
                                                           ; we can use for visibility testing

       jgt  LL17                       ; BPL LL17          ; Jump down to LL17 (this BPL is effectively a JMP as we
                                                           ; know bit 7 of A is definitely clear)

LL13:
                                                           ; If we get here then the ship is possibly far enough
                                                           ; away to be shown as a dot
       li   ry,>0d*256                 ; LDY #13           ; Fetch byte #13 from the ship's blueprint, which gives
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the ship's visibility distance, beyond which we show
                                                           ; the ship as a dot

       cb   @XX1+7,ra                  ; CMP XX1+7         ; If z_hi <= the visibility distance, skip to LL17 to
       joc  LL17                       ; BCS LL17          ; draw the ship fully, rather than as a dot, as it is
                                                           ; closer than the visibility distance

       li   ra,>20*256                 ; LDA #%00100000    ; If bit 5 of the ship's byte #31 is set, then the
       .and @XX1+31                    ; AND XX1+31        ; ship is currently exploding, so skip to LL17 to draw
       jne  LL17                       ; BNE LL17          ; the ship's explosion cloud

       b    @SHPPT                     ; JMP SHPPT         ; Otherwise jump to SHPPT to draw the ship as a dot,
                                                           ; returning from the subroutine using a tail call

* ******************************************************************************
* 
* Name: LL9 (Part 3 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Set up orientation vector, ship coordinate variables
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part sets up the following variable blocks:
* 
* * XX16 contains the orientation vectors, divided to normalise them
* 
* * XX18 contains the ship's x, y and z coordinates in space
* 
* ******************************************************************************

LL17:
       li   rx,>05*256                 ; LDX #5            ; First we copy the three orientation vectors into XX16,
                                                           ; so set up a counter in X for the 6 bytes in each
                                                           ; vector

LL15:
       movb @XX1+21(rx),ra             ; LDA XX1+21,X      ; Copy the X-th byte of sidev to the X-th byte of XX16
       movb ra,@XX16(rx)               ; STA XX16,X        

       movb @XX1+15(rx),ra             ; LDA XX1+15,X      ; Copy the X-th byte of roofv to XX16+6 to the X-th byte
       movb ra,@XX16+6(rx)             ; STA XX16+6,X      ; of XX16+6

       movb @XX1+9(rx),ra              ; LDA XX1+9,X       ; Copy the X-th byte of nosev to XX16+12 to the X-th
       movb ra,@XX16+12(rx)            ; STA XX16+12,X     ; byte of XX16+12

       sb   rone,rx                    ; DEX               ; Decrement the counter

       jgt  LL15                       ; BPL LL15          ; Loop back to copy the next byte of each vector, until
                                                           ; we have the following:
                                                           ; 
                                                           ; * XX16(1 0) = sidev_x
                                                           ; * XX16(3 2) = sidev_y
                                                           ; * XX16(5 4) = sidev_z
                                                           ; 
                                                           ; * XX16(7 6) = roofv_x
                                                           ; * XX16(9 8) = roofv_y
                                                           ; * XX16(11 10) = roofv_z
                                                           ; 
                                                           ; * XX16(13 12) = nosev_x
                                                           ; * XX16(15 14) = nosev_y
                                                           ; * XX16(17 16) = nosev_z

       li   ra,>c5*256                 ; LDA #197          ; Set Q = 197
       movb ra,@Q                      ; STA Q             

       li   ry,>10*256                 ; LDY #16           ; Set Y to be a counter that counts down by 2 each time,
                                                           ; starting with 16, then 14, 12 and so on. We use this
                                                           ; to work through each of the coordinates in each of the
                                                           ; orientation vectors

LL21:
       movb @XX16(ry),ra               ; LDA XX16,Y        ; Set A = the low byte of the vector coordinate, e.g.
                                                           ; nosev_z_lo when Y = 16

       .asla                           ; ASL A             ; Shift bit 7 into the C flag

       movb @XX16+1(ry),ra             ; LDA XX16+1,Y      ; Set A = the high byte of the vector coordinate, e.g.
                                                           ; nosev_z_hi when Y = 16

       .rola                           ; ROL A             ; Rotate A left, incorporating the C flag, so A now
                                                           ; contains the original high byte, doubled, and without
                                                           ; a sign bit, e.g. A = |nosev_z_hi| * 2

       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; 
                                                           ; so, for nosev, this would be:
                                                           ; 
                                                           ; R = 256 * |nosev_z_hi| * 2 / 197
                                                           ; = 2.6 * |nosev_z_hi|

       movb @R,rx                      ; LDX R             ; Store R in the low byte's location, so we can keep the
       movb rx,@XX16(ry)               ; STX XX16,Y        ; old, unscaled high byte intact for the sign

       sb   rone,ry                    ; DEY               ; Decrement the loop counter twice
       sb   rone,ry                    ; DEY               

       jgt  LL21                       ; BPL LL21          ; Loop back for the next vector coordinate until we have
                                                           ; divided them all

                                                           ; By this point, the vectors have been turned into
                                                           ; scaled magnitudes, so we have the following:
                                                           ; 
                                                           ; * XX16   = scaled |sidev_x|
                                                           ; * XX16+2 = scaled |sidev_y|
                                                           ; * XX16+4 = scaled |sidev_z|
                                                           ; 
                                                           ; * XX16+6  = scaled |roofv_x|
                                                           ; * XX16+8  = scaled |roofv_y|
                                                           ; * XX16+10 = scaled |roofv_z|
                                                           ; 
                                                           ; * XX16+12 = scaled |nosev_x|
                                                           ; * XX16+14 = scaled |nosev_y|
                                                           ; * XX16+16 = scaled |nosev_z|

       li   rx,>08*256                 ; LDX #8            ; Next we copy the ship's coordinates into XX18, so set
                                                           ; up a counter in X for 9 bytes

ll91_:
       movb @XX1(rx),ra                ; LDA XX1,X         ; Copy the X-th byte from XX1 to XX18
       movb ra,@XX18(rx)               ; STA XX18,X        

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  ll91_                      ; BPL ll91          ; Loop back for the next byte until we have copied all
                                                           ; three coordinates

                                                           ; So we now have the following:
                                                           ; 
                                                           ; * XX18(2 1 0) = (x_sign x_hi x_lo)
                                                           ; 
                                                           ; * XX18(5 4 3) = (y_sign y_hi y_lo)
                                                           ; 
                                                           ; * XX18(8 7 6) = (z_sign z_hi z_lo)

       li   ra,>ff*256                 ; LDA #255          ; Set the 15th byte of XX2 to 255, so that face 15 is
       movb ra,@XX2+15                 ; STA XX2+15        ; always visible. No ship definitions actually have this
                                                           ; number of faces, but this allows us to force a vertex
                                                           ; to always be visible by associating it with face 15
                                                           ; (see the ship blueprints for the Cobra Mk III at
                                                           ; SHIP_COBRA_MK_3 and the asteroid at SHIP_ASTEROID for
                                                           ; examples of vertices that are associated with face 15)

       li   ry,>0c*256                 ; LDY #12           ; Set Y = 12 to point to the ship blueprint byte #12,

       movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
       andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE29
       jeq  EE29                       ; BEQ EE29          ; to skip the following

                                                           ; Otherwise we fall through to set up the visibility
                                                           ; block for an exploding ship

* ******************************************************************************
* 
* Name: LL9 (Part 4 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Set visibility for exploding ship (all faces visible)
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part sets up the visibility block in XX2 for a ship that is exploding.
* 
* The XX2 block consists of one byte for each face in the ship's blueprint,
* which holds the visibility of that face. Because the ship is exploding, we
* want to set all the faces to be visible. A value of 255 in the visibility
* table means the face is visible, so the following code sets each face to 255
* and then skips over the face visibility calculations that we would apply to a
* non-exploding ship.
* 
* ******************************************************************************

       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; Fetch byte #12 of the ship's blueprint, which contains
                                                           ; the number of faces * 4

       srl  ra,1                       ; LSR A             ; Set X = A / 4
       srl  ra,1                       ; LSR A             ; = the number of faces
       movb ra,rx                      ; TAX               

       li   ra,>ff*256                 ; LDA #255          ; Set A = 255

EE30:
       movb ra,@XX2(rx)                ; STA XX2,X         ; Set the X-th byte of XX2 to 255

       sb   rone,rx                    ; DEX               ; Decrement the loop counter

       jgt  EE30                       ; BPL EE30          ; Loop back for the next byte until there is one byte
                                                           ; set to 255 for each face

       ab   rone,rx                    ; INX               ; Set XX4 = 0 for the distance value we use to test
       movb rx,@XX4                    ; STX XX4           ; for visibility, so we always shows everything

LL41:
       b    @LL42                      ; JMP LL42          ; Jump to LL42 to skip the face visibility calculations
                                                           ; as we don't need to do them now we've set up the XX2
                                                           ; block for the explosion

* ******************************************************************************
* 
* Name: LL9 (Part 5 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Calculate the visibility of each of the ship's faces
* Deep dive: Drawing ships
* Back-face culling
* 
* ******************************************************************************

EE29:
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; We set Y to 12 above before jumping down to EE29, so
                                                           ; this fetches byte #12 of the ship's blueprint, which
                                                           ; contains the number of faces * 4

       jeq  LL41                       ; BEQ LL41          ; If there are no faces in this ship, jump to LL42 (via
                                                           ; LL41) to skip the face visibility calculations

       movb ra,@XX20                   ; STA XX20          ; Set A = the number of faces * 4

       li   ry,>12*256                 ; LDY #18           ; Fetch byte #18 of the ship's blueprint, which contains
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the factor by which we scale the face normals, into X
       movb ra,rx                      ; TAX               

       movb @XX18+7,ra                 ; LDA XX18+7        ; Set A = z_hi

LL90:
       movb ra,ry                      ; TAY               ; Set Y = z_hi

       jeq  LL91                       ; BEQ LL91          ; If z_hi = 0 then jump to LL91

                                                           ; The following is a loop that jumps back to LL90+3,
                                                           ; i.e. here. LL90 is only used for this loop, so it's a
                                                           ; bit of a strange use of the label here

       ab   rone,rx                    ; INX               ; Increment the scale factor in X

       .lsr @XX18+4                    ; LSR XX18+4        ; Divide (y_hi y_lo) by 2
       .ror @XX18+3                    ; ROR XX18+3        

       .lsr @XX18+1                    ; LSR XX18+1        ; Divide (x_hi x_lo) by 2
       .ror @XX18                      ; ROR XX18          

       srl  ra,1                       ; LSR A             ; Divide (z_hi z_lo) by 2 (as A contains z_hi)
       .ror @XX18+6                    ; ROR XX18+6        

       movb ra,ry                      ; TAY               ; Set Y = z_hi

       jne  LL90+3                     ; BNE LL90+3        ; If Y is non-zero, loop back to LL90+3 to divide the
                                                           ; three coordinates until z_hi is 0

LL91:
                                                           ; By this point z_hi is 0 and X contains the number of
                                                           ; right shifts we had to do, plus the scale factor from
                                                           ; the blueprint
       movb rx,@XX17                   ; STX XX17          ; Store the updated scale factor in XX17

       movb @XX18+8,ra                 ; LDA XX18+8        ; Set XX15+5 = z_sign
       movb ra,@XX15+5                 ; STA XX15+5        

       movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = (x_sign x_lo)
       movb ra,@XX15                   ; STA XX15          
       movb @XX18+2,ra                 ; LDA XX18+2        
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = (y_sign y_lo)
       movb ra,@XX15+2                 ; STA XX15+2        
       movb @XX18+5,ra                 ; LDA XX18+5        
       movb ra,@XX15+3                 ; STA XX15+3        

       movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15+4 = z_lo, so now XX15(5 4) = (z_sign z_lo)
       movb ra,@XX15+4                 ; STA XX15+4        

       .jsr @LL51                      ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
                                                           ; XX16, which we'll call dot_sidev, dot_roofv and
                                                           ; dot_nosev:
                                                           ; 
                                                           ; XX12(1 0) = [x y z] . sidev
                                                           ; = (dot_sidev_sign dot_sidev_lo)
                                                           ; = dot_sidev
                                                           ; 
                                                           ; XX12(3 2) = [x y z] . roofv
                                                           ; = (dot_roofv_sign dot_roofv_lo)
                                                           ; = dot_roofv
                                                           ; 
                                                           ; XX12(5 4) = [x y z] . nosev
                                                           ; = (dot_nosev_sign dot_nosev_lo)
                                                           ; = dot_nosev

       movb @XX12,ra                   ; LDA XX12          ; Set XX18(2 0) = dot_sidev
       movb ra,@XX18                   ; STA XX18          
       movb @XX12+1,ra                 ; LDA XX12+1        
       movb ra,@XX18+2                 ; STA XX18+2        

       movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX18(5 3) = dot_roofv
       movb ra,@XX18+3                 ; STA XX18+3        
       movb @XX12+3,ra                 ; LDA XX12+3        
       movb ra,@XX18+5                 ; STA XX18+5        

       movb @XX12+4,ra                 ; LDA XX12+4        ; Set XX18(8 6) = dot_nosev
       movb ra,@XX18+6                 ; STA XX18+6        
       movb @XX12+5,ra                 ; LDA XX12+5        
       movb ra,@XX18+8                 ; STA XX18+8        

       li   ry,>04*256                 ; LDY #4            ; Fetch byte #4 of the ship's blueprint, which contains
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the low byte of the offset to the faces data

       .clc                            ; CLC               ; Set V = low byte faces offset + XX0
       .adc @XX0,ra                    ; ADC XX0           
       movb ra,@V                      ; STA V             

       li   ry,>11*256                 ; LDY #17           ; Fetch byte #17 of the ship's blueprint, which contains
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the faces data

       .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte faces offset + XX0+1
       movb ra,@V+1                    ; STA V+1           ; 
                                                           ; So V(1 0) now points to the start of the faces data
                                                           ; for this ship

       li   ry,>00*256                 ; LDY #0            ; We're now going to loop through all the faces for this
                                                           ; ship, so set a counter in Y, starting from 0, which we
                                                           ; will increment by 4 each loop to step through the
                                                           ; four bytes of data for each face

LL86:
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this face into A, so:
                                                           ; 
                                                           ; A = %xyz vvvvv, where:
                                                           ; 
                                                           ; * Bits 0-4 = visibility distance, beyond which the
                                                           ; face is always shown
                                                           ; 
                                                           ; * Bits 7-5 = the sign bits of normal_x, normal_y
                                                           ; and normal_z

       movb ra,@XX12+1                 ; STA XX12+1        ; Store byte #0 in XX12+1, so XX12+1 now has the sign of
                                                           ; normal_x

       andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to give the visibility distance

       cb   @XX4,ra                    ; CMP XX4           ; If XX4 <= the visibility distance, where XX4 contains
       joc  LL87                       ; BCS LL87          ; the ship's z-distance reduced to 0-31 (which we set in
                                                           ; part 2), skip to LL87 as this face is close enough
                                                           ; that we have to test its visibility using the face
                                                           ; normals

                                                           ; Otherwise this face is within range and is therefore
                                                           ; always shown

       movb ry,ra                      ; TYA               ; Set X = Y / 4
       srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
       srl  ra,1                       ; LSR A             ; = the number of this face
       movb ra,rx                      ; TAX               

       li   ra,>ff*256                 ; LDA #255          ; Set the X-th byte of XX2 to 255 to denote that this
       movb ra,@XX2(rx)                ; STA XX2,X         ; face is visible

       movb ry,ra                      ; TYA               ; Set Y = Y + 4 to point to the next face
       .adi (>04*256)                  ; ADC #4            
       movb ra,ry                      ; TAY               

       b    @LL88                      ; JMP LL88          ; Jump down to LL88 to skip the following, as we don't
                                                           ; need to test the face normals

LL87:
       movb @XX12+1,ra                 ; LDA XX12+1        ; Fetch byte #0 for this face into A

       .asla                           ; ASL A             ; Shift A left and store it, so XX12+3 now has the sign
       movb ra,@XX12+3                 ; STA XX12+3        ; of normal_y

       .asla                           ; ASL A             ; Shift A left and store it, so XX12+5 now has the sign
       movb ra,@XX12+5                 ; STA XX12+5        ; of normal_z

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #1

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this face and store in XX12, so
       movb ra,@XX12                   ; STA XX12          ; XX12 = normal_x

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #2

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this face and store in XX12+2, so
       movb ra,@XX12+2                 ; STA XX12+2        ; XX12+2 = normal_y

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #3

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this face and store in XX12+4, so
       movb ra,@XX12+4                 ; STA XX12+4        ; XX12+4 = normal_z

                                                           ; So we now have:
                                                           ; 
                                                           ; XX12(1 0) = (normal_x_sign normal_x)
                                                           ; 
                                                           ; XX12(3 2) = (normal_y_sign normal_y)
                                                           ; 
                                                           ; XX12(5 4) = (normal_z_sign normal_z)

       movb @XX17,rx                   ; LDX XX17          ; If XX17 < 4 then jump to LL92, otherwise we stored a
       ci   rx,>04*256                 ; CPX #4            ; larger scale factor above
       jnc  LL92                       ; BCC LL92          

LL143:
       movb @XX18,ra                   ; LDA XX18          ; Set XX15(1 0) = XX18(2 0)
       movb ra,@XX15                   ; STA XX15          ; = dot_sidev
       movb @XX18+2,ra                 ; LDA XX18+2        
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX18+3,ra                 ; LDA XX18+3        ; Set XX15(3 2) = XX18(5 3)
       movb ra,@XX15+2                 ; STA XX15+2        ; = dot_roofv
       movb @XX18+5,ra                 ; LDA XX18+5        
       movb ra,@XX15+3                 ; STA XX15+3        

       movb @XX18+6,ra                 ; LDA XX18+6        ; Set XX15(5 4) = XX18(8 6)
       movb ra,@XX15+4                 ; STA XX15+4        ; = dot_nosev
       movb @XX18+8,ra                 ; LDA XX18+8        
       movb ra,@XX15+5                 ; STA XX15+5        

       b    @LL89                      ; JMP LL89          ; Jump down to LL89

ovflw_:
                                                           ; If we get here then the addition below overflowed, so
                                                           ; we halve the dot products and normal vector
       .lsr @XX18                      ; LSR XX18          ; Divide dot_sidev_lo by 2, so dot_sidev = dot_sidev / 2

       .lsr @XX18+6                    ; LSR XX18+6        ; Divide dot_nosev_lo by 2, so dot_nosev = dot_nosev / 2

       .lsr @XX18+3                    ; LSR XX18+3        ; Divide dot_roofv_lo by 2, so dot_roofv = dot_roofv / 2

       li   rx,>01*256                 ; LDX #1            ; Set X = 1 so when we fall through into LL92, we divide
                                                           ; the normal vector by 2 as well

LL92:
                                                           ; We jump here from above with the scale factor in X,
                                                           ; and now we apply it by scaling the normal vector down
                                                           ; by a factor of 2^X (i.e. divide by 2^X)
       movb @XX12,ra                   ; LDA XX12          ; Set XX15 = normal_x
       movb ra,@XX15                   ; STA XX15          

       movb @XX12+2,ra                 ; LDA XX12+2        ; Set XX15+2 = normal_y
       movb ra,@XX15+2                 ; STA XX15+2        

       movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = normal_z

LL93:
       sb   rone,rx                    ; DEX               ; Decrement the scale factor in X

       jlt  LL94                       ; BMI LL94          ; If X was 0 before the decrement, there is no scaling
                                                           ; to do, so jump to LL94 to exit the loop

       .lsr @XX15                      ; LSR XX15          ; Set XX15 = XX15 / 2
                                                           ; = normal_x / 2

       .lsr @XX15+2                    ; LSR XX15+2        ; Set XX15+2 = XX15+2 / 2
                                                           ; = normal_y / 2

       srl  ra,1                       ; LSR A             ; Set A = A / 2
                                                           ; = normal_z / 2

       sb   rone,rx                    ; DEX               ; Decrement the scale factor in X

       jgt  LL93+3                     ; BPL LL93+3        ; If we have more scaling to do, loop back up to the
                                                           ; first LSR above until the normal vector is scaled down

LL94:
       movb ra,@R                      ; STA R             ; Set R = normal_z

       movb @XX12+5,ra                 ; LDA XX12+5        ; Set S = normal_z_sign
       movb ra,@S                      ; STA S             

       movb @XX18+6,ra                 ; LDA XX18+6        ; Set Q = dot_nosev_lo
       movb ra,@Q                      ; STA Q             

       movb @XX18+8,ra                 ; LDA XX18+8        ; Set A = dot_nosev_sign

       .jsr @LL38                      ; JSR LL38          ; Set (S A) = (S R) + (A Q)
                                                           ; = normal_z + dot_nosev
                                                           ; 
                                                           ; setting the sign of the result in S

       joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
                                                           ; both the normal vector and dot products by 2 and try
                                                           ; again

       movb ra,@XX15+4                 ; STA XX15+4        ; Set XX15(5 4) = (S A)
       movb @S,ra                      ; LDA S             ; = normal_z + dot_nosev
       movb ra,@XX15+5                 ; STA XX15+5        

       movb @XX15,ra                   ; LDA XX15          ; Set R = normal_x
       movb ra,@R                      ; STA R             

       movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = normal_x_sign
       movb ra,@S                      ; STA S             

       movb @XX18,ra                   ; LDA XX18          ; Set Q = dot_sidev_lo
       movb ra,@Q                      ; STA Q             

       movb @XX18+2,ra                 ; LDA XX18+2        ; Set A = dot_sidev_sign

       .jsr @LL38                      ; JSR LL38          ; Set (S A) = (S R) + (A Q)
                                                           ; = normal_x + dot_sidev
                                                           ; 
                                                           ; setting the sign of the result in S

       joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
                                                           ; both the normal vector and dot products by 2 and try
                                                           ; again

       movb ra,@XX15                   ; STA XX15          ; Set XX15(1 0) = (S A)
       movb @S,ra                      ; LDA S             ; = normal_x + dot_sidev
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = normal_y
       movb ra,@R                      ; STA R             

       movb @XX12+3,ra                 ; LDA XX12+3        ; Set S = normal_y_sign
       movb ra,@S                      ; STA S             

       movb @XX18+3,ra                 ; LDA XX18+3        ; Set Q = dot_roofv_lo
       movb ra,@Q                      ; STA Q             

       movb @XX18+5,ra                 ; LDA XX18+5        ; Set A = dot_roofv_sign

       .jsr @LL38                      ; JSR LL38          ; Set (S A) = (S R) + (A Q)
                                                           ; = normal_y + dot_roofv

       joc  ovflw_                     ; BCS ovflw         ; If the addition overflowed, jump up to ovflw to divide
                                                           ; both the normal vector and dot products by 2 and try
                                                           ; again

       movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15(3 2) = (S A)
       movb @S,ra                      ; LDA S             ; = normal_y + dot_roofv
       movb ra,@XX15+3                 ; STA XX15+3        

LL89:
                                                           ; When we get here, we have set up the following:
                                                           ; 
                                                           ; XX15(1 0) = normal_x + dot_sidev
                                                           ; = normal_x + [x y z] . sidev
                                                           ; 
                                                           ; XX15(3 2) = normal_y + dot_roofv
                                                           ; = normal_y + [x y z] . roofv
                                                           ; 
                                                           ; XX15(5 4) = normal_z + dot_nosev
                                                           ; = normal_z + [x y z] . nosev
                                                           ; 
                                                           ; and:
                                                           ; 
                                                           ; XX12(1 0) = (normal_x_sign normal_x)
                                                           ; 
                                                           ; XX12(3 2) = (normal_y_sign normal_y)
                                                           ; 
                                                           ; XX12(5 4) = (normal_z_sign normal_z)
                                                           ; 
                                                           ; We now calculate the dot product XX12 . XX15 to tell
                                                           ; us whether or not this face is visible
       movb @XX12,ra                   ; LDA XX12          ; Set Q = XX12
       movb ra,@Q                      ; STA Q             

       movb @XX15,ra                   ; LDA XX15          ; Set A = XX15

       .jsr @FMLTU                     ; JSR FMLTU         ; Set T = A * Q / 256
       movb ra,@T                      ; STA T             ; = XX15 * XX12 / 256

       movb @XX12+1,ra                 ; LDA XX12+1        ; Set S = sign of XX15(1 0) * XX12(1 0), so:
       .eor @XX15+1                    ; EOR XX15+1        ; 
       movb ra,@S                      ; STA S             ; (S T) = XX15(1 0) * XX12(1 0) / 256

       movb @XX12+2,ra                 ; LDA XX12+2        ; Set Q = XX12+2
       movb ra,@Q                      ; STA Q             

       movb @XX15+2,ra                 ; LDA XX15+2        ; Set A = XX15+2

       .jsr @FMLTU                     ; JSR FMLTU         ; Set Q = A * Q
       movb ra,@Q                      ; STA Q             ; = XX15+2 * XX12+2 / 256

       movb @T,ra                      ; LDA T             ; Set T = R, so now:
       movb ra,@R                      ; STA R             ; 
                                                           ; (S R) = XX15(1 0) * XX12(1 0) / 256

       movb @XX12+3,ra                 ; LDA XX12+3        ; Set A = sign of XX15+3 * XX12+3, so:
       .eor @XX15+3                    ; EOR XX15+3        ; 
                                                           ; (A Q) = XX15(3 2) * XX12(3 2) / 256

       .jsr @LL38                      ; JSR LL38          ; Set (S T) = (S R) + (A Q)
       movb ra,@T                      ; STA T             ; =   XX15(1 0) * XX12(1 0) / 256
                                                           ; + XX15(3 2) * XX12(3 2) / 256

       movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = XX12+4
       movb ra,@Q                      ; STA Q             

       movb @XX15+4,ra                 ; LDA XX15+4        ; Set A = XX15+4

       .jsr @FMLTU                     ; JSR FMLTU         ; Set Q = A * Q
       movb ra,@Q                      ; STA Q             ; = XX15+4 * XX12+4 / 256

       movb @T,ra                      ; LDA T             ; Set T = R, so now:
       movb ra,@R                      ; STA R             ; 
                                                           ; (S R) =   XX15(1 0) * XX12(1 0) / 256
                                                           ; + XX15(3 2) * XX12(3 2) / 256

       movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = sign of XX15+5 * XX12+5, so:
       .eor @XX12+5                    ; EOR XX12+5        ; 
                                                           ; (A Q) = XX15(5 4) * XX12(5 4) / 256

       .jsr @LL38                      ; JSR LL38          ; Set (S A) = (S R) + (A Q)
                                                           ; =   XX15(1 0) * XX12(1 0) / 256
                                                           ; + XX15(3 2) * XX12(3 2) / 256
                                                           ; + XX15(5 4) * XX12(5 4) / 256

       .pha                            ; PHA               ; Push the result A onto the stack, so the stack now
                                                           ; contains the dot product XX12 . XX15

       movb ry,ra                      ; TYA               ; Set X = Y / 4
       srl  ra,1                       ; LSR A             ; = the number of this face * 4 /4
       srl  ra,1                       ; LSR A             ; = the number of this face
       movb ra,rx                      ; TAX               

       .pla                            ; PLA               ; Pull the dot product off the stack into A

       .bit @S                         ; BIT S             ; If bit 7 of S is set, i.e. the dot product is
       jlt  B112                       ; BMI B112          ; negative, then this face is visible as its normal is
                                                           ; pointing towards us, so skip the following instruction

       li   ra,>00*256                 ; LDA #0            ; Otherwise the face is not visible, so set A = 0 so we
                                                           ; can store this to mean "not visible"

B112:
       movb ra,@XX2(rx)                ; STA XX2,X         ; Store the face's visibility in the X-th byte of XX2

       ab   rone,ry                    ; INY               ; Above we incremented Y to point to byte #3, so this
                                                           ; increments Y to point to byte #4, i.e. byte #0 of the
                                                           ; next face

LL88:
       cb   @XX20,ry                   ; CPY XX20          ; If Y >= XX20, the number of faces * 4, jump down to
       joc  LL42                       ; BCS LL42          ; LL42 to move on to the

       b    @LL86                      ; JMP LL86          ; Otherwise loop back to LL86 to work out the visibility
                                                           ; of the next face

* ******************************************************************************
* 
* Name: LL9 (Part 6 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Calculate the visibility of each of the ship's vertices
* Deep dive: Drawing ships
* Calculating vertex coordinates
* 
* ------------------------------------------------------------------------------
* 
* This section calculates the visibility of each of the ship's vertices, and for
* those that are visible, it starts the process of calculating the screen
* coordinates of each vertex
* 
* ******************************************************************************

LL42:
                                                           ; The first task is to set up the inverse matrix, ready
                                                           ; for us to send to the dot product routine at LL51.
                                                           ; Back up in part 3, we set up the following variables:
                                                           ; 
                                                           ; * XX16(1 0) = sidev_x
                                                           ; * XX16(3 2) = sidev_y
                                                           ; * XX16(5 4) = sidev_z
                                                           ; 
                                                           ; * XX16(7 6) = roofv_x
                                                           ; * XX16(9 8) = roofv_y
                                                           ; * XX16(11 10) = roofv_z
                                                           ; 
                                                           ; * XX16(13 12) = nosev_x
                                                           ; * XX16(15 14) = nosev_y
                                                           ; * XX16(17 16) = nosev_z
                                                           ; 
                                                           ; and we then scaled the vectors to give the following:
                                                           ; 
                                                           ; * XX16   = scaled |sidev_x|
                                                           ; * XX16+2 = scaled |sidev_y|
                                                           ; * XX16+4 = scaled |sidev_z|
                                                           ; 
                                                           ; * XX16+6  = scaled |roofv_x|
                                                           ; * XX16+8  = scaled |roofv_y|
                                                           ; * XX16+10 = scaled |roofv_z|
                                                           ; 
                                                           ; * XX16+12 = scaled |nosev_x|
                                                           ; * XX16+14 = scaled |nosev_y|
                                                           ; * XX16+16 = scaled |nosev_z|
                                                           ; 
                                                           ; We now need to rearrange these locations so they
                                                           ; effectively transpose the matrix into its inverse
       movb @XX16+2,ry                 ; LDY XX16+2        ; Set XX16+2 = XX16+6 = scaled |roofv_x|
       movb @XX16+3,rx                 ; LDX XX16+3        ; Set XX16+3 = XX16+7 = roofv_x_hi
       movb @XX16+6,ra                 ; LDA XX16+6        ; Set XX16+6 = XX16+2 = scaled |sidev_y|
       movb ra,@XX16+2                 ; STA XX16+2        ; Set XX16+7 = XX16+3 = sidev_y_hi
       movb @XX16+7,ra                 ; LDA XX16+7        
       movb ra,@XX16+3                 ; STA XX16+3        
       movb ry,@XX16+6                 ; STY XX16+6        
       movb rx,@XX16+7                 ; STX XX16+7        

       movb @XX16+4,ry                 ; LDY XX16+4        ; Set XX16+4 = XX16+12 = scaled |nosev_x|
       movb @XX16+5,rx                 ; LDX XX16+5        ; Set XX16+5 = XX16+13 = nosev_x_hi
       movb @XX16+12,ra                ; LDA XX16+12       ; Set XX16+12 = XX16+4 = scaled |sidev_z|
       movb ra,@XX16+4                 ; STA XX16+4        ; Set XX16+13 = XX16+5 = sidev_z_hi
       movb @XX16+13,ra                ; LDA XX16+13       
       movb ra,@XX16+5                 ; STA XX16+5        
       movb ry,@XX16+12                ; STY XX16+12       
       movb rx,@XX16+13                ; STX XX16+13       

       movb @XX16+10,ry                ; LDY XX16+10       ; Set XX16+10 = XX16+14 = scaled |nosev_y|
       movb @XX16+11,rx                ; LDX XX16+11       ; Set XX16+11 = XX16+15 = nosev_y_hi
       movb @XX16+14,ra                ; LDA XX16+14       ; Set XX16+14 = XX16+10 = scaled |roofv_z|
       movb ra,@XX16+10                ; STA XX16+10       ; Set XX16+15 = XX16+11 = roofv_z
       movb @XX16+15,ra                ; LDA XX16+15       
       movb ra,@XX16+11                ; STA XX16+11       
       movb ry,@XX16+14                ; STY XX16+14       
       movb rx,@XX16+15                ; STX XX16+15       

                                                           ; So now we have the following sign-magnitude variables
                                                           ; containing parts of the scaled orientation vectors:
                                                           ; 
                                                           ; XX16(1 0)   = scaled sidev_x
                                                           ; XX16(3 2)   = scaled roofv_x
                                                           ; XX16(5 4)   = scaled nosev_x
                                                           ; 
                                                           ; XX16(7 6)   = scaled sidev_y
                                                           ; XX16(9 8)   = scaled roofv_y
                                                           ; XX16(11 10) = scaled nosev_y
                                                           ; 
                                                           ; XX16(13 12) = scaled sidev_z
                                                           ; XX16(15 14) = scaled roofv_z
                                                           ; XX16(17 16) = scaled nosev_z
                                                           ; 
                                                           ; which is what we want, as the various vectors are now
                                                           ; arranged so we can use LL51 to multiply by the
                                                           ; transpose (i.e. the inverse of the matrix)

       li   ry,>08*256                 ; LDY #8            ; Fetch byte #8 of the ship's blueprint, which is the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of vertices * 8, and store it in XX20
       movb ra,@XX20                   ; STA XX20          

                                                           ; We now set V(1 0) = XX0(1 0) + 20, so V(1 0) points
                                                           ; to byte #20 of the ship's blueprint, which is always
                                                           ; where the vertex data starts (i.e. just after the 20
                                                           ; byte block that define the ship's characteristics)

       movb @XX0,ra                    ; LDA XX0           ; We start with the low bytes
       .clc                            ; CLC               
       .adi (>14*256)                  ; ADC #20           
       movb ra,@V                      ; STA V             

       movb @XX0+1,ra                  ; LDA XX0+1         ; And then do the high bytes
       .adi (>00*256)                  ; ADC #0            
       movb ra,@V+1                    ; STA V+1           

       li   ry,>00*256                 ; LDY #0            ; We are about to step through all the vertices, using
                                                           ; Y as a counter. There are six data bytes for each
                                                           ; vertex, so we will increment Y by 6 for each iteration
                                                           ; so it can act as an offset from V(1 0) to the current
                                                           ; vertex's data

       movb ry,@CNT                    ; STY CNT           ; Set CNT = 0, which we will use as a pointer to the
                                                           ; heap at XX3, starting it at zero so the heap starts
                                                           ; out empty

LL48:
       movb ry,@XX17                   ; STY XX17          ; Set XX17 = Y, so XX17 now contains the offset of the
                                                           ; current vertex's data

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this vertex into XX15, so:
       movb ra,@XX15                   ; STA XX15          ; 
                                                           ; XX15 = magnitude of the vertex's x-coordinate

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #1

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this vertex into XX15+2, so:
       movb ra,@XX15+2                 ; STA XX15+2        ; 
                                                           ; XX15+2 = magnitude of the vertex's y-coordinate

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #2

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this vertex into XX15+4, so:
       movb ra,@XX15+4                 ; STA XX15+4        ; 
                                                           ; XX15+4 = magnitude of the vertex's z-coordinate

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #3

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this vertex into T, so:
       movb ra,@T                      ; STA T             ; 
                                                           ; T = %xyz vvvvv, where:
                                                           ; 
                                                           ; * Bits 0-4 = visibility distance, beyond which the
                                                           ; vertex is not shown
                                                           ; 
                                                           ; * Bits 7-5 = the sign bits of x, y and z

       andi ra,>1f*256                 ; AND #%00011111    ; Extract bits 0-4 to get the visibility distance

       cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
       jnc  LL49-3                     ; BCC LL49-3        ; the ship's z-distance reduced to 0-31 (which we set in
                                                           ; part 2), then this vertex is too far away to be
                                                           ; visible, so jump down to LL50 (via the JMP instruction
                                                           ; in LL49-3) to move on to the next vertex

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #4

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #4 for this vertex into P, so:
       movb ra,@P                      ; STA P             ; 
                                                           ; P = %ffff ffff, where:
                                                           ; 
                                                           ; * Bits 0-3 = the number of face 1
                                                           ; 
                                                           ; * Bits 4-7 = the number of face 2

       andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
       movb ra,rx                      ; TAX               

       movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
       jne  LL49                       ; BNE LL49          ; face 1 is visible, so jump to LL49

       movb @P,ra                      ; LDA P             ; Fetch byte #4 for this vertex into A

       srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
       srl  ra,1                       ; LSR A             ; from bits 4-7 into X
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       movb ra,rx                      ; TAX               

       movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
       jne  LL49                       ; BNE LL49          ; face 2 is visible, so jump to LL49

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #5

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #5 for this vertex into P, so:
       movb ra,@P                      ; STA P             ; 
                                                           ; P = %ffff ffff, where:
                                                           ; 
                                                           ; * Bits 0-3 = the number of face 3
                                                           ; 
                                                           ; * Bits 4-7 = the number of face 4

       andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
       movb ra,rx                      ; TAX               

       movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
       jne  LL49                       ; BNE LL49          ; face 3 is visible, so jump to LL49

       movb @P,ra                      ; LDA P             ; Fetch byte #5 for this vertex into A

       srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 4
       srl  ra,1                       ; LSR A             ; from bits 4-7 into X
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       movb ra,rx                      ; TAX               

       movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
       jne  LL49                       ; BNE LL49          ; face 4 is visible, so jump to LL49

       b    @LL50                      ; JMP LL50          ; If we get here then none of the four faces associated
                                                           ; with this vertex are visible, so this vertex is also
                                                           ; not visible, so jump to LL50 to move on to the next
                                                           ; vertex

LL49:
       movb @T,ra                      ; LDA T             ; Fetch byte #5 for this vertex into A and store it, so
       movb ra,@XX15+1                 ; STA XX15+1        ; XX15+1 now has the sign of the vertex's x-coordinate

       .asla                           ; ASL A             ; Shift A left and store it, so XX15+3 now has the sign
       movb ra,@XX15+3                 ; STA XX15+3        ; of the vertex's y-coordinate

       .asla                           ; ASL A             ; Shift A left and store it, so XX15+5 now has the sign
       movb ra,@XX15+5                 ; STA XX15+5        ; of the vertex's z-coordinate

                                                           ; By this point we have the following:
                                                           ; 
                                                           ; XX15(1 0) = vertex x-coordinate
                                                           ; XX15(3 2) = vertex y-coordinate
                                                           ; XX15(5 4) = vertex z-coordinate
                                                           ; 
                                                           ; XX16(1 0)   = scaled sidev_x
                                                           ; XX16(3 2)   = scaled roofv_x
                                                           ; XX16(5 4)   = scaled nosev_x
                                                           ; 
                                                           ; XX16(7 6)   = scaled sidev_y
                                                           ; XX16(9 8)   = scaled roofv_y
                                                           ; XX16(11 10) = scaled nosev_y
                                                           ; 
                                                           ; XX16(13 12) = scaled sidev_z
                                                           ; XX16(15 14) = scaled roofv_z
                                                           ; XX16(17 16) = scaled nosev_z

       .jsr @LL51                      ; JSR LL51          ; Call LL51 to set XX12 to the dot products of XX15 and
                                                           ; XX16, as follows:
                                                           ; 
                                                           ; XX12(1 0) = [ x y z ] . [ sidev_x roofv_x nosev_x ]
                                                           ; 
                                                           ; XX12(3 2) = [ x y z ] . [ sidev_y roofv_y nosev_y ]
                                                           ; 
                                                           ; XX12(5 4) = [ x y z ] . [ sidev_z roofv_z nosev_z ]
                                                           ; 
                                                           ; XX12 contains the vector from the ship's centre to
                                                           ; the vertex, transformed from the orientation vector
                                                           ; space to the universe orientated around our ship. So
                                                           ; we can refer to this vector below, let's call it
                                                           ; vertv, so:
                                                           ; 
                                                           ; vertv_x = [ x y z ] . [ sidev_x roofv_x nosev_x ]
                                                           ; 
                                                           ; vertv_y = [ x y z ] . [ sidev_y roofv_y nosev_y ]
                                                           ; 
                                                           ; vertv_z = [ x y z ] . [ sidev_z roofv_z nosev_z ]
                                                           ; 
                                                           ; To finish the calculation, we now want to calculate:
                                                           ; 
                                                           ; vertv + [ x y z ]
                                                           ; 
                                                           ; So let's start with the vertv_x + x

       movb @XX1+2,ra                  ; LDA XX1+2         ; Set A = x_sign of the ship's location

       movb ra,@XX15+2                 ; STA XX15+2        ; Set XX15+2 = x_sign

       .eor @XX12+1                    ; EOR XX12+1        ; If the sign of x_sign * the sign of vertv_x is
       jlt  LL52                       ; BMI LL52          ; negative (i.e. they have different signs), skip to
                                                           ; LL52

       .clc                            ; CLC               ; Set XX15(2 1 0) = XX1(2 1 0) + XX12(1 0)
       movb @XX12,ra                   ; LDA XX12          ; = (x_sign x_hi x_lo) + vertv_x
       .adc @XX1,ra                    ; ADC XX1           ; 
       movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes

       movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can add 0 here as
       .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_x is 0)
       movb ra,@XX15+1                 ; STA XX15+1        

       b    @LL53                      ; JMP LL53          ; We've added the x-coordinates, so jump to LL53 to do
                                                           ; the y-coordinates

LL52:
                                                           ; If we get here then x_sign and vertv_x have different
                                                           ; signs, so we need to subtract them to get the result
       movb @XX1,ra                    ; LDA XX1           ; Set XX15(2 1 0) = XX1(2 1 0) - XX12(1 0)
       .sec                            ; SEC               ; = (x_sign x_hi x_lo) - vertv_x
       .sbc @XX12,ra                   ; SBC XX12          ; 
       movb ra,@XX15                   ; STA XX15          ; Starting with the low bytes

       movb @XX1+1,ra                  ; LDA XX1+1         ; And then doing the high bytes (we can subtract 0 here
       .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_x is 0)
       movb ra,@XX15+1                 ; STA XX15+1        

       joc  LL53                       ; BCS LL53          ; If the subtraction didn't underflow, then the sign of
                                                           ; the result is the same sign as x_sign, and that's what
                                                           ; we want, so we can jump down to LL53 to do the
                                                           ; y-coordinates

       .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
       movb ra,@XX15+1                 ; STA XX15+1        ; complement, so first we flip the bits of the high byte

       li   ra,>01*256                 ; LDA #1            ; And then subtract the low byte from 1
       .sbc @XX15,ra                   ; SBC XX15          
       movb ra,@XX15                   ; STA XX15          

       jnc  B113                       ; BCC B113          ; If the above subtraction underflowed then we need to
       ab   rone,ra                    ; INC XX15+1        ; bump the high byte of the result up by 1

B113:
       movb @XX15+2,ra                 ; LDA XX15+2        ; And now we flip the sign of the result to get the
       .eoi (>80*256)                  ; EOR #%10000000    ; correct result
       movb ra,@XX15+2                 ; STA XX15+2        

LL53:
                                                           ; Now for the y-coordinates, vertv_y + y
       movb @XX1+5,ra                  ; LDA XX1+5         ; Set A = y_sign of the ship's location

       movb ra,@XX15+5                 ; STA XX15+5        ; Set XX15+5 = y_sign

       .eor @XX12+3                    ; EOR XX12+3        ; If the sign of y_sign * the sign of vertv_y is
       jlt  LL54                       ; BMI LL54          ; negative (i.e. they have different signs), skip to
                                                           ; LL54

       .clc                            ; CLC               ; Set XX15(5 4 3) = XX1(5 4 3) + XX12(3 2)
       movb @XX12+2,ra                 ; LDA XX12+2        ; = (y_sign y_hi y_lo) + vertv_y
       .adc @XX1+3,ra                  ; ADC XX1+3         ; 
       movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes

       movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can add 0 here as
       .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
       movb ra,@XX15+4                 ; STA XX15+4        

       b    @LL55                      ; JMP LL55          ; We've added the y-coordinates, so jump to LL55 to do
                                                           ; the z-coordinates

LL54:
                                                           ; If we get here then y_sign and vertv_y have different
                                                           ; signs, so we need to subtract them to get the result
       movb @XX1+3,ra                  ; LDA XX1+3         ; Set XX15(5 4 3) = XX1(5 4 3) - XX12(3 2)
       .sec                            ; SEC               ; = (y_sign y_hi y_lo) - vertv_y
       .sbc @XX12+2,ra                 ; SBC XX12+2        ; 
       movb ra,@XX15+3                 ; STA XX15+3        ; Starting with the low bytes

       movb @XX1+4,ra                  ; LDA XX1+4         ; And then doing the high bytes (we can subtract 0 here
       .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
       movb ra,@XX15+4                 ; STA XX15+4        

       joc  LL55                       ; BCS LL55          ; If the subtraction didn't underflow, then the sign of
                                                           ; the result is the same sign as y_sign, and that's what
                                                           ; we want, so we can jump down to LL55 to do the
                                                           ; z-coordinates

       .eoi (>ff*256)                  ; EOR #%11111111    ; Otherwise we need to negate the result using two's
       movb ra,@XX15+4                 ; STA XX15+4        ; complement, so first we flip the bits of the high byte

       movb @XX15+3,ra                 ; LDA XX15+3        ; And then flip the bits of the low byte and add 1
       .eoi (>ff*256)                  ; EOR #%11111111    
       .adi (>01*256)                  ; ADC #1            
       movb ra,@XX15+3                 ; STA XX15+3        

       movb @XX15+5,ra                 ; LDA XX15+5        ; And now we flip the sign of the result to get the
       .eoi (>80*256)                  ; EOR #%10000000    ; correct result
       movb ra,@XX15+5                 ; STA XX15+5        

       jnc  LL55                       ; BCC LL55          ; If the above subtraction underflowed then we need to
       ab   rone,ra                    ; INC XX15+4        ; bump the high byte of the result up by 1

LL55:
                                                           ; Now for the z-coordinates, vertv_z + z
       movb @XX12+5,ra                 ; LDA XX12+5        ; If vertv_z_hi is negative, jump down to LL56
       jlt  LL56                       ; BMI LL56          

       movb @XX12+4,ra                 ; LDA XX12+4        ; Set (U T) = XX1(7 6) + XX12(5 4)
       .clc                            ; CLC               ; = (z_hi z_lo) + vertv_z
       .adc @XX1+6,ra                  ; ADC XX1+6         ; 
       movb ra,@T                      ; STA T             ; Starting with the low bytes

       movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can add 0 here as
       .adi (>00*256)                  ; ADC #0            ; we know the sign byte of vertv_y is 0)
       movb ra,@U                      ; STA U             

       b    @LL57                      ; JMP LL57          ; We've added the z-coordinates, so jump to LL57

                                                           ; The adding process is continued in part 7, after a
                                                           ; couple of subroutines that we don't need quite yet

* ******************************************************************************
* 
* Name: LL61
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (U R) = 256 * A / Q
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following, where A >= Q:
* 
* (U R) = 256 * A / Q
* 
* This is a sister routine to LL28, which does the division when A < Q.
* 
* ******************************************************************************

LL61:
       movb @Q,rx                      ; LDX Q             ; If Q = 0, jump down to LL84 to return a division
       jeq  LL84                       ; BEQ LL84          ; error

                                                           ; The LL28 routine returns A / Q, but only if A < Q. In
                                                           ; our case A >= Q, but we still want to use the LL28
                                                           ; routine, so we halve A until it's less than Q, call
                                                           ; the division routine, and then double A by the same
                                                           ; number of times

       li   rx,>00*256                 ; LDX #0            ; Set X = 0 to count the number of times we halve A

LL63:
       srl  ra,1                       ; LSR A             ; Halve A by shifting right

       ab   rone,rx                    ; INX               ; Increment X

       cb   @Q,ra                      ; CMP Q             ; If A >= Q, loop back to LL63 to halve it again
       joc  LL63                       ; BCS LL63          

       movb rx,@S                      ; STX S             ; Otherwise store the number of times we halved A in S

       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; 
                                                           ; which we can do now as A < Q

       movb @S,rx                      ; LDX S             ; Otherwise restore the number of times we halved A
                                                           ; above into X

       movb @R,ra                      ; LDA R             ; Set A = our division result

LL64:
       .asla                           ; ASL A             ; Double (U A) by shifting left
       .rol @U                         ; ROL U             

       jlt  LL84                       ; BMI LL84          ; If bit 7 of U is set, the doubling has overflowed, so
                                                           ; jump to LL84 to return a division error

       sb   rone,rx                    ; DEX               ; Decrement X

       jne  LL64                       ; BNE LL64          ; If X is not yet zero then we haven't done as many
                                                           ; doublings as we did halvings earlier, so loop back for
                                                           ; another doubling

       movb ra,@R                      ; STA R             ; Store the low byte of the division result in R

       .rts                            ; RTS               ; Return from the subroutine

LL84:
       li   ra,>32*256                 ; LDA #50           ; If we get here then either we tried to divide by 0, or
       movb ra,@R                      ; STA R             ; the result overflowed, so we set U and R to 50
       movb ra,@U                      ; STA U             

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL62
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate 128 - (U R)
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following for a positive sign-magnitude number (U R):
* 
* 128 - (U R)
* 
* and then store the result, low byte then high byte, on the end of the heap at
* XX3, where X points to the first free byte on the heap. Return by jumping down
* to LL66.
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* X                   X is incremented by 1
* 
* ******************************************************************************

LL62:
       li   ra,>80*256                 ; LDA #128          ; Calculate 128 - (U R), starting with the low bytes
       .sec                            ; SEC               
       .sbc @R,ra                      ; SBC R             

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
                                                           ; the heap at XX3

       ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
                                                           ; byte

       li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
       .sbc @U,ra                      ; SBC U             

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
                                                           ; the heap at XX3

       b    @LL66                      ; JMP LL66          ; Jump down to LL66

* ******************************************************************************
* 
* Name: LL9 (Part 7 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Calculate the visibility of each of the ship's vertices
* Deep dive: Drawing ships
* Calculating vertex coordinates
* 
* ------------------------------------------------------------------------------
* 
* This section continues the coordinate adding from part 6 by finishing off the
* calculation that we started above:
* 
* [ sidev_x roofv_x nosev_x ]   [ x ]   [ x ]
* vector to vertex = [ sidev_y roofv_y nosev_y ] . [ y ] + [ y ]
* [ sidev_z roofv_z nosev_z ]   [ z ]   [ z ]
* 
* The gets stored as follows, in sign-magnitude values with the magnitudes
* fitting into the low bytes:
* 
* XX15(2 0)           [ x y z ] . [ sidev_x roofv_x nosev_x ] + [ x y z ]
* 
* XX15(5 3)           [ x y z ] . [ sidev_y roofv_y nosev_y ] + [ x y z ]
* 
* (U T)               [ x y z ] . [ sidev_z roofv_z nosev_z ] + [ x y z ]
* 
* Finally, because this vector is from our ship to the vertex, and we are at the
* origin, this vector is the same as the coordinates of the vertex. In other
* words, we have just worked out:
* 
* XX15(2 0)           x-coordinate of the current vertex
* 
* XX15(5 3)           y-coordinate of the current vertex
* 
* (U T)               z-coordinate of the current vertex
* 
* ******************************************************************************

LL56:
       movb @XX1+6,ra                  ; LDA XX1+6         ; Set (U T) = XX1(7 6) - XX12(5 4)
       .sec                            ; SEC               ; = (z_hi z_lo) - vertv_z
       .sbc @XX12+4,ra                 ; SBC XX12+4        ; 
       movb ra,@T                      ; STA T             ; Starting with the low bytes

       movb @XX1+7,ra                  ; LDA XX1+7         ; And then doing the high bytes (we can subtract 0 here
       .sbi (>00*256)                  ; SBC #0            ; as we know the sign byte of vertv_z is 0)
       movb ra,@U                      ; STA U             

       jnc  LL140                      ; BCC LL140         ; If the subtraction just underflowed, skip to LL140 to
                                                           ; set (U T) to the minimum value of 4

       jne  LL57                       ; BNE LL57          ; If U is non-zero, jump down to LL57

       movb @T,ra                      ; LDA T             ; If T >= 4, jump down to LL57
       ci   ra,>04*256                 ; CMP #4            
       joc  LL57                       ; BCS LL57          

LL140:
       li   ra,>00*256                 ; LDA #0            ; If we get here then either (U T) < 4 or the
       movb ra,@U                      ; STA U             ; subtraction underflowed, so set (U T) = 4
       li   ra,>04*256                 ; LDA #4            
       movb ra,@T                      ; STA T             

LL57:
                                                           ; By this point we have our results, so now to scale
                                                           ; the 16-bit results down into 8-bit values
       movb @U,ra                      ; LDA U             ; If the high bytes of the result are all zero, we are
       socb @XX15+1,ra                 ; ORA XX15+1        ; done, so jump down to LL60 for the next stage
       socb @XX15+4,ra                 ; ORA XX15+4        
       jeq  LL60                       ; BEQ LL60          

       .lsr @XX15+1                    ; LSR XX15+1        ; Shift XX15(1 0) to the right
       .ror @XX15                      ; ROR XX15          

       .lsr @XX15+4                    ; LSR XX15+4        ; Shift XX15(4 3) to the right
       .ror @XX15+3                    ; ROR XX15+3        

       .lsr @U                         ; LSR U             ; Shift (U T) to the right
       .ror @T                         ; ROR T             

       b    @LL57                      ; JMP LL57          ; Jump back to LL57 to see if we can shift the result
                                                           ; any more

* ******************************************************************************
* 
* Name: LL9 (Part 8 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Calculate the screen coordinates of visible vertices
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This section projects the coordinate of the vertex into screen coordinates and
* stores them on the XX3 heap. By the end of this part, the XX3 heap contains
* four bytes containing the 16-bit screen coordinates of the current vertex, in
* the order: x_lo, x_hi, y_lo, y_hi.
* 
* When we reach here, we are looping through the vertices, and we've just worked
* out the coordinates of the vertex in our normal coordinate system, as follows
* 
* XX15(2 0)           (x_sign x_lo) = x-coordinate of the current vertex
* 
* XX15(5 3)           (y_sign y_lo) = y-coordinate of the current vertex
* 
* (U T)               (z_sign z_lo) = z-coordinate of the current vertex
* 
* Note that U is always zero when we get to this point, as the vertex is always
* in front of us (so it has a positive z-coordinate, into the screen).
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL70+1              Contains an RTS (as the first byte of an LDA
* instruction)
* 
* LL66                A re-entry point into the ship-drawing routine, used by
* the LL62 routine to store 128 - (U R) on the XX3 heap
* 
* ******************************************************************************

LL60:
       movb @T,ra                      ; LDA T             ; Set Q = z_lo
       movb ra,@Q                      ; STA Q             

       movb @XX15,ra                   ; LDA XX15          ; Set A = x_lo

       cb   @Q,ra                      ; CMP Q             ; If x_lo < z_lo jump to LL69
       jnc  LL69                       ; BCC LL69          

       .jsr @LL61                      ; JSR LL61          ; Call LL61 to calculate:
                                                           ; 
                                                           ; (U R) = 256 * A / Q
                                                           ; = 256 * x / z
                                                           ; 
                                                           ; which we can do as x >= z

       b    @LL65                      ; JMP LL65          ; Jump to LL65 to skip the division for x_lo < z_lo

LL69:
       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; = 256 * x / z
                                                           ; 
                                                           ; Because x < z, the result fits into one byte, and we
                                                           ; also know that U = 0, so (U R) also contains the
                                                           ; result

LL65:
                                                           ; At this point we have:
                                                           ; 
                                                           ; (U R) = x / z
                                                           ; 
                                                           ; so (U R) contains the vertex's x-coordinate projected
                                                           ; on screen
                                                           ; 
                                                           ; The next task is to convert (U R) to a pixel screen
                                                           ; coordinate and stick it on the XX3 heap.
                                                           ; 
                                                           ; We start with the x-coordinate. To convert the
                                                           ; x-coordinate to a screen pixel we add 128, the
                                                           ; x-coordinate of the centre of the screen, because the
                                                           ; projected value is relative to an origin at the centre
                                                           ; of the screen, but the origin of the screen pixels is
                                                           ; at the top-left of the screen
       movb @CNT,rx                    ; LDX CNT           ; Fetch the pointer to the end of the XX3 heap from CNT
                                                           ; into X

       movb @XX15+2,ra                 ; LDA XX15+2        ; If x_sign is negative, jump up to LL62, which will
       jlt  LL62                       ; BMI LL62          ; store 128 - (U R) on the XX3 heap and return by
                                                           ; jumping down to LL66 below

       movb @R,ra                      ; LDA R             ; Calculate 128 + (U R), starting with the low bytes
       .clc                            ; CLC               
       .adi (>80*256)                  ; ADC #128          

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
                                                           ; the heap at XX3

       ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
                                                           ; byte

       movb @U,ra                      ; LDA U             ; And then add the high bytes
       .adi (>00*256)                  ; ADC #0            

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
                                                           ; the heap at XX3

LL66:
                                                           ; We've just stored the screen x-coordinate of the
                                                           ; vertex on the XX3 heap, so now for the y-coordinate
       movb rx,ra                      ; TXA               ; Store the heap pointer in X on the stack (at this
       .pha                            ; PHA               ; it points to the last entry on the heap, not the first
                                                           ; free byte)

       li   ra,>00*256                 ; LDA #0            ; Set U = 0
       movb ra,@U                      ; STA U             

       movb @T,ra                      ; LDA T             ; Set Q = z_lo
       movb ra,@Q                      ; STA Q             

       movb @XX15+3,ra                 ; LDA XX15+3        ; Set A = y_lo

       cb   @Q,ra                      ; CMP Q             ; If y_lo < z_lo jump to LL67
       jnc  LL67                       ; BCC LL67          

       .jsr @LL61                      ; JSR LL61          ; Call LL61 to calculate:
                                                           ; 
                                                           ; (U R) = 256 * A / Q
                                                           ; = 256 * y / z
                                                           ; 
                                                           ; which we can do as y >= z

       b    @LL68                      ; JMP LL68          ; Jump to LL68 to skip the division for y_lo < z_lo

LL70:
                                                           ; This gets called from below when y_sign is negative
       li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y + (U R), starting with the low bytes
       .clc                            ; CLC               
       .adc @R,ra                      ; ADC R             

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
                                                           ; the heap at XX3

       ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
                                                           ; byte

       li   ra,>00*256                 ; LDA #0            ; And then add the high bytes
       .adc @U,ra                      ; ADC U             

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
                                                           ; the heap at XX3

       b    @LL50                      ; JMP LL50          ; Jump to LL50 to move on to the next vertex

LL67:
       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; = 256 * y / z
                                                           ; 
                                                           ; Because y < z, the result fits into one byte, and we
                                                           ; also know that U = 0, so (U R) also contains the
                                                           ; result

LL68:
                                                           ; At this point we have:
                                                           ; 
                                                           ; (U R) = y / z
                                                           ; 
                                                           ; so (U R) contains the vertex's y-coordinate projected
                                                           ; on screen
                                                           ; 
                                                           ; We now want to convert this to a screen y-coordinate
                                                           ; and stick it on the XX3 heap, much like we did with
                                                           ; the x-coordinate above. Again, we convert the
                                                           ; coordinate by adding or subtracting the y-coordinate
                                                           ; of the centre of the screen, which is in the constant
                                                           ; #Y, but this time we do the opposite, as a positive
                                                           ; projected y-coordinate, i.e. up the space y-axis and
                                                           ; up the screen, converts to a low y-coordinate, which
                                                           ; is the opposite way round to the x-coordinates
       .pla                            ; PLA               ; Restore the heap pointer from the stack into X
       movb ra,rx                      ; TAX               

       ab   rone,rx                    ; INX               ; When we stored the heap pointer, it pointed to the
                                                           ; last entry on the heap, not the first free byte, so we
                                                           ; increment it so it does point to the next free byte

       movb @XX15+5,ra                 ; LDA XX15+5        ; If y_sign is negative, jump up to LL70, which will
       jlt  LL70                       ; BMI LL70          ; store #Y + (U R) on the XX3 heap and return by jumping
                                                           ; down to LL50 below

       li   ra,(Y)*256                 ; LDA #Y            ; Calculate #Y - (U R), starting with the low bytes
       .sec                            ; SEC               
       .sbc @R,ra                      ; SBC R             

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the low byte of the result in the X-th byte of
                                                           ; the heap at XX3

       ab   rone,rx                    ; INX               ; Increment the heap pointer in X to point to the next
                                                           ; byte

       li   ra,>00*256                 ; LDA #0            ; And then subtract the high bytes
       .sbc @U,ra                      ; SBC U             

       movb ra,@XX3(rx)                ; STA XX3,X         ; Store the high byte of the result in the X-th byte of
                                                           ; the heap at XX3

LL50:
                                                           ; By the time we get here, the XX3 heap contains four
                                                           ; bytes containing the screen coordinates of the current
                                                           ; vertex, in the order: x_lo, x_hi, y_lo, y_hi
       .clc                            ; CLC               ; Set CNT = CNT + 4, so the heap pointer points to the
       movb @CNT,ra                    ; LDA CNT           ; next free byte on the heap
       .adi (>04*256)                  ; ADC #4            
       movb ra,@CNT                    ; STA CNT           

       movb @XX17,ra                   ; LDA XX17          ; Set A to the offset of the current vertex's data,
                                                           ; which we set in part 6

       .adi (>06*256)                  ; ADC #6            ; Set Y = A + 6, so Y now points to the data for the
       movb ra,ry                      ; TAY               ; next vertex

       joc  LL72                       ; BCS LL72          ; If the addition just overflowed, meaning we just tried
                                                           ; to access vertex #43, jump to LL72, as the maximum
                                                           ; number of vertices allowed is 42

       cb   @XX20,ra                   ; CMP XX20          ; If Y >= number of vertices * 6 (which we stored in
       joc  LL72                       ; BCS LL72          ; XX20 in part 6), jump to LL72, as we have processed
                                                           ; all the vertices for this ship

       b    @LL48                      ; JMP LL48          ; Loop back to LL48 in part 6 to calculate visibility
                                                           ; and screen coordinates for the next vertex

* ******************************************************************************
* 
* Name: LL9 (Part 9 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Draw laser beams if the ship is firing its laser at us
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part sets things up so we can loop through the edges in the next part. It
* also adds a line to the ship line heap, if the ship is firing at us.
* 
* When we get here, the heap at XX3 contains all the visible vertex screen
* coordinates.
* 
* ******************************************************************************

LL72:
       movb @XX1+31,ra                 ; LDA XX1+31        ; If bit 5 of the ship's byte #31 is clear, then the
       andi ra,>20*256                 ; AND #%00100000    ; ship is not currently exploding, so jump down to EE31
       jeq  EE31                       ; BEQ EE31          

       movb @XX1+31,ra                 ; LDA XX1+31        ; The ship is exploding, so set bit 3 of the ship's byte
       ori  ra,>08*256                 ; ORA #%00001000    ; #31 to denote that we are drawing something on-screen
       movb ra,@XX1+31                 ; STA XX1+31        ; for this ship

       b    @DOEXP                     ; JMP DOEXP         ; Jump to DOEXP to display the explosion cloud,
                                                           ; returning from the subroutine using a tail call

EE31:
       li   ra,>08*256                 ; LDA #%00001000    ; If bit 3 of the ship's byte #31 is clear, then there
       .bit @XX1+31                    ; BIT XX1+31        ; is nothing already being shown for this ship, so skip
       jeq  LL74                       ; BEQ LL74          ; to LL74 as we don't need to erase anything from the
                                                           ; screen

       .jsr @LL155                     ; JSR LL155         ; Otherwise call LL155 to draw the existing ship, which
                                                           ; removes it from the screen

       li   ra,>08*256                 ; LDA #%00001000    ; Set bit 3 of A so the next instruction sets bit 3 of
                                                           ; the ship's byte #31 to denote that we are drawing
                                                           ; something on-screen for this ship

LL74:
       socb @XX1+31,ra                 ; ORA XX1+31        ; Apply bit 3 of A to the ship's byte #31, so if there
       movb ra,@XX1+31                 ; STA XX1+31        ; was no ship already on screen, the bit is clear,
                                                           ; otherwise it is set

       li   ry,>09*256                 ; LDY #9            ; Fetch byte #9 of the ship's blueprint, which is the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number of edges, and store it in XX20
       movb ra,@XX20                   ; STA XX20          

       li   ry,>00*256                 ; LDY #0            ; We are about to step through all the edges, using Y
                                                           ; as a counter

       movb ry,@U                      ; STY U             ; Set U = 0 (though we increment it to 1 below)

       movb ry,@XX17                   ; STY XX17          ; Set XX17 = 0, which we are going to use as a counter
                                                           ; for stepping through the ship's edges

       ab   rone,ra                    ; INC U             ; We are going to start calculating the lines we need to
                                                           ; draw for this ship, and will store them in the ship
                                                           ; line heap, using U to point to the end of the heap, so
                                                           ; we start by setting U = 1

       .bit @XX1+31                    ; BIT XX1+31        ; If bit 6 of the ship's byte #31 is clear, then the
       jno  LL170                      ; BVC LL170         ; ship is not firing its lasers, so jump to LL170 to
                                                           ; skip the drawing of laser lines

                                                           ; The ship is firing its laser at us, so we need to draw
                                                           ; the laser lines

       movb @XX1+31,ra                 ; LDA XX1+31        ; Clear bit 6 of the ship's byte #31 so the ship doesn't
       andi ra,>bf*256                 ; AND #%10111111    ; keep firing endlessly
       movb ra,@XX1+31                 ; STA XX1+31        

       li   ry,>06*256                 ; LDY #6            ; Fetch byte #6 of the ship's blueprint, which is the
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; number * 4 of the vertex where the ship has its lasers

       movb ra,ry                      ; TAY               ; Put the vertex number into Y, where it can act as an
                                                           ; index into list of vertex screen coordinates we added
                                                           ; to the XX3 heap

       movb @XX3(ry),rx                ; LDX XX3,Y         ; Fetch the x_lo coordinate of the laser vertex from the
       movb rx,@XX15                   ; STX XX15          ; XX3 heap into XX15

       ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
       jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
                                                           ; the vertex calculation in part 6 and 7, so jump to
                                                           ; LL170 to skip drawing the laser lines

                                                           ; We now build a laser beam from the ship's laser vertex
                                                           ; towards our ship, as follows:
                                                           ; 
                                                           ; XX15(1 0) = laser vertex x-coordinate
                                                           ; 
                                                           ; XX15(3 2) = laser vertex y-coordinate
                                                           ; 
                                                           ; XX15(5 4) = x-coordinate of the end of the beam
                                                           ; 
                                                           ; XX12(1 0) = y-coordinate of the end of the beam
                                                           ; 
                                                           ; The end of the laser beam will be positioned to look
                                                           ; good, rather than being directly aimed at us, as
                                                           ; otherwise we would only see a flashing point of light
                                                           ; as they unleashed their attack

       movb @XX3+1(ry),rx              ; LDX XX3+1,Y       ; Fetch the x_hi coordinate of the laser vertex from the
       movb rx,@XX15+1                 ; STX XX15+1        ; XX3 heap into XX15+1

       ab   rone,rx                    ; INX               ; If X = 255 then the laser vertex is not visible, as
       jeq  LL170                      ; BEQ LL170         ; the value we stored in part 2 wasn't overwritten by
                                                           ; a vertex calculation in part 6 and 7, so jump to LL170
                                                           ; to skip drawing the laser beam

       movb @XX3+2(ry),rx              ; LDX XX3+2,Y       ; Fetch the y_lo coordinate of the laser vertex from the
       movb rx,@XX15+2                 ; STX XX15+2        ; XX3 heap into XX15+2

       movb @XX3+3(ry),rx              ; LDX XX3+3,Y       ; Fetch the y_hi coordinate of the laser vertex from the
       movb rx,@XX15+3                 ; STX XX15+3        ; XX3 heap into XX15+3

       li   ra,>00*256                 ; LDA #0            ; Set XX15(5 4) = 0, so their laser beam fires to the
       movb ra,@XX15+4                 ; STA XX15+4        ; left edge of the screen
       movb ra,@XX15+5                 ; STA XX15+5        

       movb ra,@XX12+1                 ; STA XX12+1        ; Set XX12(1 0) = the ship's z_lo coordinate, which will
       movb @XX1+6,ra                  ; LDA XX1+6         ; effectively make the vertical position of the end of
       movb ra,@XX12                   ; STA XX12          ; the laser beam move around as the ship moves in space

       movb @XX1+2,ra                  ; LDA XX1+2         ; If the ship's x_sign is positive, skip the next
       jgt  B114                       ; BPL B114          ; instruction

       sb   rone,ra                    ; DEC XX15+4        ; The ship's x_sign is negative (i.e. it's on the left
                                                           ; side of the screen), so switch the laser beam so it
                                                           ; goes to the right edge of the screen by decrementing
                                                           ; XX15(5 4) to 255

B114:
       .jsr @LL145                     ; JSR LL145         ; Call LL145 to see if the laser beam needs to be
                                                           ; clipped to fit on-screen, returning the clipped line's
                                                           ; end-points in (X1, Y1) and (X2, Y2)

       joc  LL170                      ; BCS LL170         ; If the C flag is set then the line is not visible on
                                                           ; screen, so jump to LL170 so we don't store this line
                                                           ; in the ship line heap

       movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
                                                           ; next free byte on the heap, into Y

       movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U

* ******************************************************************************
* 
* Name: LL9 (Part 10 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Calculate the visibility of each of the ship's edges
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part calculates which edges are visible - in other words, which lines we
* should draw - and clips them to fit on the screen.
* 
* When we get here, the heap at XX3 contains all the visible vertex screen
* coordinates.
* 
* ******************************************************************************

LL170:
       li   ry,>03*256                 ; LDY #3            ; Fetch byte #3 of the ship's blueprint, which contains
       .clc                            ; CLC               ; the low byte of the offset to the edges data
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       

       .adc @XX0,ra                    ; ADC XX0           ; Set V = low byte edges offset + XX0
       movb ra,@V                      ; STA V             

       li   ry,>10*256                 ; LDY #16           ; Fetch byte #16 of the ship's blueprint, which contains
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the high byte of the offset to the edges data

       .adc @XX0+1,ra                  ; ADC XX0+1         ; Set V+1 = high byte edges offset + XX0+1
       movb ra,@V+1                    ; STA V+1           ; 
                                                           ; So V(1 0) now points to the start of the edges data
                                                           ; for this ship

       li   ry,>05*256                 ; LDY #5            ; Fetch byte #5 of the ship's blueprint, which contains
       .ld_ind_y_idx @XX0,ra           ; LDA (XX0),Y       ; the maximum heap size for plotting the ship (which is
       movb ra,@T1                     ; STA T1            ; 1 + 4 * the maximum number of visible edges) and store
                                                           ; it in T1

       movb @XX17,ry                   ; LDY XX17          ; Set Y to the edge counter in XX17

LL75:
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #0 for this edge, which contains the
                                                           ; visibility distance for this edge, beyond which the
                                                           ; edge is not shown

       cb   @XX4,ra                    ; CMP XX4           ; If XX4 > the visibility distance, where XX4 contains
       jnc  LL78                       ; BCC LL78          ; the ship's z-distance reduced to 0-31 (which we set in
                                                           ; part 2), then this edge is too far away to be visible,
                                                           ; so jump down to LL78 to move on to the next edge

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #1

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #1 for this edge into A, so:
                                                           ; 
                                                           ; A = %ffff ffff, where:
                                                           ; 
                                                           ; * Bits 0-3 = the number of face 1
                                                           ; 
                                                           ; * Bits 4-7 = the number of face 2

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #2

       movb ra,@P                      ; STA P             ; Store byte #1 into P

       andi ra,>0f*256                 ; AND #%00001111    ; Extract the number of face 1 into X
       movb ra,rx                      ; TAX               

       movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is non-zero then we decided in part 5 that
       jne  LL79                       ; BNE LL79          ; face 1 is visible, so jump to LL79

       movb @P,ra                      ; LDA P             ; Fetch byte #1 for this edge into A

       srl  ra,1                       ; LSR A             ; Shift right four times to extract the number of face 2
       srl  ra,1                       ; LSR A             ; from bits 4-7 into X
       srl  ra,1                       ; LSR A             
       srl  ra,1                       ; LSR A             
       movb ra,rx                      ; TAX               

       movb @XX2(rx),ra                ; LDA XX2,X         ; If XX2+X is zero then we decided in part 5 that
       jeq  LL78                       ; BEQ LL78          ; face 2 is hidden, so jump to LL78

LL79:
                                                           ; We now build the screen line for this edge, as
                                                           ; follows:
                                                           ; 
                                                           ; XX15(1 0) = start x-coordinate
                                                           ; 
                                                           ; XX15(3 2) = start y-coordinate
                                                           ; 
                                                           ; XX15(5 4) = end x-coordinate
                                                           ; 
                                                           ; XX12(1 0) = end y-coordinate
                                                           ; 
                                                           ; We can then pass this to the line clipping routine
                                                           ; before storing the resulting line in the ship line
                                                           ; heap
       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #2 for this edge into X, which contains
       movb ra,rx                      ; TAX               ; the number of the vertex at the start of the edge

       ab   rone,ry                    ; INY               ; Increment Y to point to byte #3

       .ld_ind_y_idx @V,ra             ; LDA (V),Y         ; Fetch byte #3 for this edge into Q, which contains
       movb ra,@Q                      ; STA Q             ; the number of the vertex at the end of the edge

       movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's start vertex
       movb ra,@XX15+1                 ; STA XX15+1        ; from the XX3 heap into XX15+1

       movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's start vertex
       movb ra,@XX15                   ; STA XX15          ; from the XX3 heap into XX15

       movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's start vertex
       movb ra,@XX15+2                 ; STA XX15+2        ; from the XX3 heap into XX15+2

       movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's start vertex
       movb ra,@XX15+3                 ; STA XX15+3        ; from the XX3 heap into XX15+3

       movb @Q,rx                      ; LDX Q             ; Set X to the number of the vertex at the end of the
                                                           ; edge, which we stored in Q

       movb @XX3(rx),ra                ; LDA XX3,X         ; Fetch the x_lo coordinate of the edge's end vertex
       movb ra,@XX15+4                 ; STA XX15+4        ; from the XX3 heap into XX15+4

       movb @XX3+3(rx),ra              ; LDA XX3+3,X       ; Fetch the y_hi coordinate of the edge's end vertex
       movb ra,@XX12+1                 ; STA XX12+1        ; from the XX3 heap into XX12+1

       movb @XX3+2(rx),ra              ; LDA XX3+2,X       ; Fetch the y_lo coordinate of the edge's end vertex
       movb ra,@XX12                   ; STA XX12          ; from the XX3 heap into XX12

       movb @XX3+1(rx),ra              ; LDA XX3+1,X       ; Fetch the x_hi coordinate of the edge's end vertex
       movb ra,@XX15+5                 ; STA XX15+5        ; from the XX3 heap into XX15+5

       .jsr @LL147                     ; JSR LL147         ; Call LL147 to see if the new line segment needs to be
                                                           ; clipped to fit on-screen, returning the clipped line's
                                                           ; end-points in (X1, Y1) and (X2, Y2)

       joc  LL78                       ; BCS LL78          ; If the C flag is set then the line is not visible on
                                                           ; screen, so jump to LL78 so we don't store this line
                                                           ; in the ship line heap

* ******************************************************************************
* 
* Name: LL9 (Part 11 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Add all visible edges to the ship line heap
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part adds all the visible edges to the ship line heap, so we can draw
* them in part 12.
* 
* Other entry points:
* 
* LL81+2              Draw the contents of the ship line heap, used to draw
* the ship as a dot from SHPPT
* 
* ******************************************************************************

LL80:
       movb @U,ry                      ; LDY U             ; Fetch the ship line heap pointer, which points to the
                                                           ; next free byte on the heap, into Y

       movb @XX15,ra                   ; LDA XX15          ; Add X1 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb @XX15+1,ra                 ; LDA XX15+1        ; Add Y1 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb @XX15+2,ra                 ; LDA XX15+2        ; Add X2 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb @XX15+3,ra                 ; LDA XX15+3        ; Add Y2 to the end of the heap
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       movb ry,@U                      ; STY U             ; Store the updated ship line heap pointer in U

       cb   @T1,ry                     ; CPY T1            ; If Y >= T1 then we have reached the maximum number of
       joc  LL81                       ; BCS LL81          ; edge lines that we can store in the ship line heap, so
                                                           ; skip to LL81 so we don't loop back for the next edge

LL78:
       ab   rone,ra                    ; INC XX17          ; Increment the edge counter to point to the next edge

       movb @XX17,ry                   ; LDY XX17          ; If Y >= XX20, which contains the number of edges in
       cb   @XX20,ry                   ; CPY XX20          ; the blueprint, jump to LL81 as we have processed all
       joc  LL81                       ; BCS LL81          ; the edges and don't need to loop back for the next one

       li   ry,>00*256                 ; LDY #0            ; Set Y to point to byte #0 again, ready for the next
                                                           ; edge

       movb @V,ra                      ; LDA V             ; Increment V by 4 so V(1 0) points to the data for the
       .adi (>04*256)                  ; ADC #4            ; next edge
       movb ra,@V                      ; STA V             

       jnc  ll81_                      ; BCC ll81          ; If the above addition didn't overflow, jump to ll81 to
                                                           ; skip the following instruction

       ab   rone,ra                    ; INC V+1           ; Otherwise increment the high byte of V(1 0), as we
                                                           ; just moved the V(1 0) pointer past a page boundary

ll81_:
       b    @LL75                      ; JMP LL75          ; Loop back to LL75 to process the next edge

LL81:
                                                           ; We have finished adding lines to the ship line heap,
                                                           ; so now we need to set the first byte of the heap to
                                                           ; the number of bytes stored there
       movb @U,ra                      ; LDA U             ; Fetch the ship line heap pointer from U into A, which
                                                           ; points to the end of the heap, and therefore contains
                                                           ; the heap size

       li   ry,>00*256                 ; LDY #0            ; Store A as the first byte of the ship line heap, so
       .st_ind_y_idx @XX19,ra          ; STA (XX19),Y      ; the heap is now correctly set up

* ******************************************************************************
* 
* Name: LL9 (Part 12 of 12)
* Type: Subroutine
* Category: Drawing ships
* Summary: Draw ship: Draw all the visible edges from the ship line heap
* Deep dive: Drawing ships
* 
* ------------------------------------------------------------------------------
* 
* This part draws the lines in the ship line heap, which is used both to draw
* the ship, and to remove it from the screen.
* 
* ******************************************************************************

LL155:
       li   ry,>00*256                 ; LDY #0            ; Fetch the first byte from the ship line heap into A,
       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; which contains the number of bytes in the heap

       movb ra,@XX20                   ; STA XX20          ; Store the heap size in XX20

       ci   ra,>04*256                 ; CMP #4            ; If the heap size is less than 4, there is nothing to
       jnc  LL118-1                    ; BCC LL118-1       ; draw, so return from the subroutine (as LL118-1
                                                           ; contains an RTS)

       ab   rone,ry                    ; INY               ; Set Y = 1, which we will use as an index into the ship
                                                           ; line heap, starting at byte #1 (as byte #0 contains
                                                           ; the heap size)

LL27:
       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X1 line coordinate from the heap and store
       movb ra,@XX15                   ; STA XX15          ; it in XX15

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y1 line coordinate from the heap and store
       movb ra,@XX15+1                 ; STA XX15+1        ; it in XX15+1

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the X2 line coordinate from the heap and store
       movb ra,@XX15+2                 ; STA XX15+2        ; it in XX15+2

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       .ld_ind_y_idx @XX19,ra          ; LDA (XX19),Y      ; Fetch the Y2 line coordinate from the heap and store
       movb ra,@XX15+3                 ; STA XX15+3        ; it in XX15+3

       .jsr @LL30                      ; JSR LL30          ; Draw a line from (X1, Y1) to (X2, Y2)

       ab   rone,ry                    ; INY               ; Increment the heap pointer

       cb   @XX20,ry                   ; CPY XX20          ; If the heap counter is less than the size of the heap,
       jnc  LL27                       ; BCC LL27          ; loop back to LL27 to draw the next line from the heap

* .LL82                  \ This label is commented out in the original source

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL118
* Type: Subroutine
* Category: Drawing lines
* Summary: Move a point along a line until it is on-screen
* Deep dive: Line-clipping
* 
* ------------------------------------------------------------------------------
* 
* Given a point (x1, y1), a gradient and a direction of slope, move the point
* along the line until it is on-screen, so this effectively clips the (x1, y1)
* end of a line to be on the screen.
* 
* See the deep dive on "Line-clipping" for more details.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
* 
* XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
* 
* XX12+2              The line's gradient * 256 (so 1.0 = 256)
* 
* XX12+3              The direction of slope:
* 
* * Positive (bit 7 clear) = top left to bottom right
* 
* * Negative (bit 7 set) = top right to bottom left
* 
* T                   The gradient of slope:
* 
* * 0 if it's a shallow slope
* 
* * &FF if it's a steep slope
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* XX15                x1 as an 8-bit coordinate
* 
* XX15+2              y1 as an 8-bit coordinate
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL118-1             Contains an RTS
* 
* ******************************************************************************

LL118:
       movb @XX15+1,ra                 ; LDA XX15+1        ; If x1_hi is positive, jump down to LL119 to skip the
       jgt  LL119                      ; BPL LL119         ; following

       movb ra,@S                      ; STA S             ; Otherwise x1_hi is negative, i.e. off the left of the
                                                           ; screen, so set S = x1_hi

       .jsr @LL120                     ; JSR LL120         ; Call LL120 to calculate:
                                                           ; 
                                                           ; (Y X) = (S x1_lo) * XX12+2      if T = 0
                                                           ; = x1 * gradient
                                                           ; 
                                                           ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
                                                           ; = x1 / gradient
                                                           ; 
                                                           ; with the sign of (Y X) set to the opposite of the
                                                           ; line's direction of slope

       movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
       .clc                            ; CLC               ; 
       .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
       movb ra,@XX15+2                 ; STA XX15+2        

       movb ry,ra                      ; TYA               ; And then adding the high bytes
       .adc @XX15+3,ra                 ; ADC XX15+3        
       movb ra,@XX15+3                 ; STA XX15+3        

       li   ra,>00*256                 ; LDA #0            ; Set x1 = 0
       movb ra,@XX15                   ; STA XX15          
       movb ra,@XX15+1                 ; STA XX15+1        

       movb ra,rx                      ; TAX               ; Set X = 0 so the next instruction becomes a JMP

LL119:
       jeq  LL134                      ; BEQ LL134         ; If x1_hi = 0 then jump down to LL134 to skip the
                                                           ; following, as the x-coordinate is already on-screen
                                                           ; (as 0 <= (x_hi x_lo) <= 255)

       movb ra,@S                      ; STA S             ; Otherwise x1_hi is positive, i.e. x1 >= 256 and off
       sb   rone,ra                    ; DEC S             ; the right side of the screen, so set S = x1_hi - 1

       .jsr @LL120                     ; JSR LL120         ; Call LL120 to calculate:
                                                           ; 
                                                           ; (Y X) = (S x1_lo) * XX12+2      if T = 0
                                                           ; = (x1 - 256) * gradient
                                                           ; 
                                                           ; (Y X) = (S x1_lo) / XX12+2      if T <> 0
                                                           ; = (x1 - 256) / gradient
                                                           ; 
                                                           ; with the sign of (Y X) set to the opposite of the
                                                           ; line's direction of slope

       movb rx,ra                      ; TXA               ; Set y1 = y1 + (Y X)
       .clc                            ; CLC               ; 
       .adc @XX15+2,ra                 ; ADC XX15+2        ; starting with the low bytes
       movb ra,@XX15+2                 ; STA XX15+2        

       movb ry,ra                      ; TYA               ; And then adding the high bytes
       .adc @XX15+3,ra                 ; ADC XX15+3        
       movb ra,@XX15+3                 ; STA XX15+3        

       li   rx,>ff*256                 ; LDX #255          ; Set x1 = 255
       movb rx,@XX15                   ; STX XX15          
       ab   rone,rx                    ; INX               
       movb rx,@XX15+1                 ; STX XX15+1        

LL134:
                                                           ; We have moved the point so the x-coordinate is on
                                                           ; screen (i.e. in the range 0-255), so now for the
                                                           ; y-coordinate
       movb @XX15+3,ra                 ; LDA XX15+3        ; If y1_hi is positive, jump down to LL119 to skip
       jgt  LL135                      ; BPL LL135         ; the following

       movb ra,@S                      ; STA S             ; Otherwise y1_hi is negative, i.e. off the top of the
                                                           ; screen, so set S = y1_hi

       movb @XX15+2,ra                 ; LDA XX15+2        ; Set R = y1_lo
       movb ra,@R                      ; STA R             

       .jsr @LL123                     ; JSR LL123         ; Call LL123 to calculate:
                                                           ; 
                                                           ; (Y X) = (S R) / XX12+2      if T = 0
                                                           ; = y1 / gradient
                                                           ; 
                                                           ; (Y X) = (S R) * XX12+2      if T <> 0
                                                           ; = y1 * gradient
                                                           ; 
                                                           ; with the sign of (Y X) set to the opposite of the
                                                           ; line's direction of slope

       movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
       .clc                            ; CLC               ; 
       .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
       movb ra,@XX15                   ; STA XX15          

       movb ry,ra                      ; TYA               ; And then adding the high bytes
       .adc @XX15+1,ra                 ; ADC XX15+1        
       movb ra,@XX15+1                 ; STA XX15+1        

       li   ra,>00*256                 ; LDA #0            ; Set y1 = 0
       movb ra,@XX15+2                 ; STA XX15+2        
       movb ra,@XX15+3                 ; STA XX15+3        

LL135:
* BNE LL139              \ This instruction is commented out in the original
                                                           ; source
       movb @XX15+2,ra                 ; LDA XX15+2        ; Set (S R) = (y1_hi y1_lo) - screen height
       .sec                            ; SEC               ; 
       .sbi ((Y*2)*256)                ; SBC #Y*2          ; starting with the low bytes
       movb ra,@R                      ; STA R             

       movb @XX15+3,ra                 ; LDA XX15+3        ; And then subtracting the high bytes
       .sbi (>00*256)                  ; SBC #0            
       movb ra,@S                      ; STA S             

       jnc  LL136                      ; BCC LL136         ; If the subtraction underflowed, i.e. if y1 < screen
                                                           ; height, then y1 is already on-screen, so jump to LL136
                                                           ; to return from the subroutine, as we are done

LL139:
                                                           ; If we get here then y1 >= screen height, i.e. off the
                                                           ; bottom of the screen
       .jsr @LL123                     ; JSR LL123         ; Call LL123 to calculate:
                                                           ; 
                                                           ; (Y X) = (S R) / XX12+2      if T = 0
                                                           ; = (y1 - screen height) / gradient
                                                           ; 
                                                           ; (Y X) = (S R) * XX12+2      if T <> 0
                                                           ; = (y1 - screen height) * gradient
                                                           ; 
                                                           ; with the sign of (Y X) set to the opposite of the
                                                           ; line's direction of slope

       movb rx,ra                      ; TXA               ; Set x1 = x1 + (Y X)
       .clc                            ; CLC               ; 
       .adc @XX15,ra                   ; ADC XX15          ; starting with the low bytes
       movb ra,@XX15                   ; STA XX15          

       movb ry,ra                      ; TYA               ; And then adding the high bytes
       .adc @XX15+1,ra                 ; ADC XX15+1        
       movb ra,@XX15+1                 ; STA XX15+1        

       li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; Set y1 = 2 * #Y - 1. The constant #Y is 96, the
       movb ra,@XX15+2                 ; STA XX15+2        ; y-coordinate of the mid-point of the space view, so
       li   ra,>00*256                 ; LDA #0            ; this sets Y2 to 191, the y-coordinate of the bottom
       movb ra,@XX15+3                 ; STA XX15+3        ; pixel row of the space view

LL136:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL120
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (Y X) = (S x1_lo) * XX12+2 or (S x1_lo) / XX12+2
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
* 
* * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
* 
* giving (Y X) the opposite sign to the slope direction in XX12+3.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* T                   The gradient of slope:
* 
* * 0 if it's a shallow slope
* 
* * &FF if it's a steep slope
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL122               Calculate (Y X) = (S R) * Q and set the sign to the
* opposite of the top byte on the stack
* 
* ******************************************************************************

LL120:
       movb @XX15,ra                   ; LDA XX15          ; Set R = x1_lo
       movb ra,@R                      ; STA R             

* .LL120                 \ This label is commented out in the original source

       .jsr @LL129                     ; JSR LL129         ; Call LL129 to do the following:
                                                           ; 
                                                           ; Q = XX12+2
                                                           ; = line gradient
                                                           ; 
                                                           ; A = S EOR XX12+3
                                                           ; = S EOR slope direction
                                                           ; 
                                                           ; (S R) = |S R|
                                                           ; 
                                                           ; So A contains the sign of S * slope direction

       .pha                            ; PHA               ; Store A on the stack so we can use it later

       movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump
       jne  LL121                      ; BNE LL121         ; down to LL121 to calculate this instead:
                                                           ; 
                                                           ; (Y X) = (S R) / Q

LL122:
                                                           ; The following calculates:
                                                           ; 
                                                           ; (Y X) = (S R) * Q
                                                           ; 
                                                           ; using the same shift-and-add algorithm that's
                                                           ; documented in MULT1
       li   ra,>00*256                 ; LDA #0            ; Set A = 0

       movb ra,rx                      ; TAX               ; Set (Y X) = 0 so we can start building the answer here
       movb ra,ry                      ; TAY               

       .lsr @S                         ; LSR S             ; Shift (S R) to the right, so we extract bit 0 of (S R)
       .ror @R                         ; ROR R             ; into the C flag

       .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag

       jnc  LL126                      ; BCC LL126         ; If C (i.e. the next bit from Q) is clear, do not do
                                                           ; the addition for this bit of Q, and instead skip to
                                                           ; LL126 to just do the shifts

LL125:
       movb rx,ra                      ; TXA               ; Set (Y X) = (Y X) + (S R)
       .clc                            ; CLC               ; 
       .adc @R,ra                      ; ADC R             ; starting with the low bytes
       movb ra,rx                      ; TAX               

       movb ry,ra                      ; TYA               ; And then doing the high bytes
       .adc @S,ra                      ; ADC S             
       movb ra,ry                      ; TAY               

LL126:
       .lsr @S                         ; LSR S             ; Shift (S R) to the right
       .ror @R                         ; ROR R             

       .asl @Q                         ; ASL Q             ; Shift Q to the left, catching bit 7 in the C flag

       joc  LL125                      ; BCS LL125         ; If C (i.e. the next bit from Q) is set, loop back to
                                                           ; LL125 to do the addition for this bit of Q

       jne  LL126                      ; BNE LL126         ; If Q has not yet run out of set bits, loop back to
                                                           ; LL126 to do the "shift" part of shift-and-add until
                                                           ; we have done additions for all the set bits in Q, to
                                                           ; give us our multiplication result

       .pla                            ; PLA               ; Restore A, which we calculated above, from the stack

       jgt  LL133                      ; BPL LL133         ; If A is positive jump to LL133 to negate (Y X) and
                                                           ; return from the subroutine using a tail call

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL123
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate (Y X) = (S R) / XX12+2 or (S R) * XX12+2
* 
* ------------------------------------------------------------------------------
* 
* Calculate the following:
* 
* * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
* 
* * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
* 
* giving (Y X) the opposite sign to the slope direction in XX12+3.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX12+2              The line's gradient * 256 (so 1.0 = 256)
* 
* XX12+3              The direction of slope:
* 
* * Bit 7 clear means top left to bottom right
* 
* * Bit 7 set means top right to bottom left
* 
* T                   The gradient of slope:
* 
* * 0 if it's a shallow slope
* 
* * &FF if it's a steep slope
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL121               Calculate (Y X) = (S R) / Q and set the sign to the
* opposite of the top byte on the stack
* 
* LL133               Negate (Y X) and return from the subroutine
* 
* LL128               Contains an RTS
* 
* ******************************************************************************

LL123:
       .jsr @LL129                     ; JSR LL129         ; Call LL129 to do the following:
                                                           ; 
                                                           ; Q = XX12+2
                                                           ; = line gradient
                                                           ; 
                                                           ; A = S EOR XX12+3
                                                           ; = S EOR slope direction
                                                           ; 
                                                           ; (S R) = |S R|
                                                           ; 
                                                           ; So A contains the sign of S * slope direction

       .pha                            ; PHA               ; Store A on the stack so we can use it later

       movb @T,rx                      ; LDX T             ; If T is non-zero, then it's a steep slope, so jump up
       jne  LL122                      ; BNE LL122         ; to LL122 to calculate this instead:
                                                           ; 
                                                           ; (Y X) = (S R) * Q

LL121:
                                                           ; The following calculates:
                                                           ; 
                                                           ; (Y X) = (S R) / Q
                                                           ; 
                                                           ; using the same shift-and-subtract algorithm that's
                                                           ; documented in TIS2
       li   ra,>ff*256                 ; LDA #%11111111    ; Set Y = %11111111
       movb ra,ry                      ; TAY               

       .asla                           ; ASL A             ; Set X = %11111110
       movb ra,rx                      ; TAX               

                                                           ; This sets (Y X) = %1111111111111110, so we can rotate
                                                           ; through 15 loop iterations, getting a 1 each time, and
                                                           ; then getting a 0 on the 16th iteration... and we can
                                                           ; also use it to catch our result bits into bit 0 each
                                                           ; time

LL130:
       .asl @R                         ; ASL R             ; Shift (S R) to the left
       .rol @S                         ; ROL S             

       movb @S,ra                      ; LDA S             ; Set A = S

       joc  LL131                      ; BCS LL131         ; If bit 7 of S was set, then jump straight to the
                                                           ; subtraction

       cb   @Q,ra                      ; CMP Q             ; If A < Q (i.e. S < Q), skip the following subtractions
       jnc  LL132                      ; BCC LL132         

LL131:
       .sbc @Q,ra                      ; SBC Q             ; A >= Q (i.e. S >= Q) so set:
       movb ra,@S                      ; STA S             ; 
                                                           ; S = (A R) - Q
                                                           ; = (S R) - Q
                                                           ; 
                                                           ; starting with the low bytes (we know the C flag is
                                                           ; set so the subtraction will be correct)

       movb @R,ra                      ; LDA R             ; And then doing the high bytes
       .sbi (>00*256)                  ; SBC #0            
       movb ra,@R                      ; STA R             

       .sec                            ; SEC               ; Set the C flag to rotate into the result in (Y X)

LL132:
       movb rx,ra                      ; TXA               ; Rotate the counter in (Y X) to the left, and catch the
       .rola                           ; ROL A             ; result bit into bit 0 (which will be a 0 if we didn't
       movb ra,rx                      ; TAX               ; do the subtraction, or 1 if we did)
       movb ry,ra                      ; TYA               
       .rola                           ; ROL A             
       movb ra,ry                      ; TAY               

       joc  LL130                      ; BCS LL130         ; If we still have set bits in (Y X), loop back to LL130
                                                           ; to do the next iteration of 15, until we have done the
                                                           ; whole division

       .pla                            ; PLA               ; Restore A, which we calculated above, from the stack

       jlt  LL128                      ; BMI LL128         ; If A is negative jump to LL128 to return from the
                                                           ; subroutine with (Y X) as is

LL133:
       movb rx,ra                      ; TXA               ; Otherwise negate (Y X) using two's complement by first
       .eoi (>ff*256)                  ; EOR #%11111111    ; setting the low byte to ~X + 1
* CLC                    \
       .adi (>01*256)                  ; ADC #1            ; The CLC instruction is commented out in the original
       movb ra,rx                      ; TAX               ; source. It would have no effect as we know the C flag
                                                           ; is clear from when we passed through the BCS above

       movb ry,ra                      ; TYA               ; Then set the high byte to ~Y + C
       .eoi (>ff*256)                  ; EOR #%11111111    
       .adi (>00*256)                  ; ADC #0            
       movb ra,ry                      ; TAY               

LL128:
       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL129
* Type: Subroutine
* Category: Maths (Arithmetic)
* Summary: Calculate Q = XX12+2, A = S EOR XX12+3 and (S R) = |S R|
* 
* ------------------------------------------------------------------------------
* 
* Do the following, in this order:
* 
* Q = XX12+2
* 
* A = S EOR XX12+3
* 
* (S R) = |S R|
* 
* This sets up the variables required above to calculate (S R) / XX12+2 and give
* the result the opposite sign to XX13+3.
* 
* ******************************************************************************

LL129:
       movb @XX12+2,rx                 ; LDX XX12+2        ; Set Q = XX12+2
       movb rx,@Q                      ; STX Q             

       movb @S,ra                      ; LDA S             ; If S is positive, jump to LL127
       jgt  LL127                      ; BPL LL127         

       li   ra,>00*256                 ; LDA #0            ; Otherwise set R = -R
       .sec                            ; SEC               
       .sbc @R,ra                      ; SBC R             
       movb ra,@R                      ; STA R             

       movb @S,ra                      ; LDA S             ; Push S onto the stack
       .pha                            ; PHA               

       .eoi (>ff*256)                  ; EOR #%11111111    ; Set S = ~S + 1 + C
       .adi (>00*256)                  ; ADC #0            
       movb ra,@S                      ; STA S             

       .pla                            ; PLA               ; Pull the original, negative S from the stack into A

LL127:
       .eor @XX12+3                    ; EOR XX12+3        ; Set A = original argument S EOR'd with XX12+3

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Name: LL145 (Part 1 of 4)
* Type: Subroutine
* Category: Drawing lines
* Summary: Clip line: Work out which end-points are on-screen, if any
* Deep dive: Line-clipping
* Extended screen coordinates
* 
* ------------------------------------------------------------------------------
* 
* This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or
* returns an error if it can't be clipped to fit. The arguments are 16-bit
* coordinates, and the clipped line is returned using 8-bit screen coordinates.
* 
* This part sets XX13 to reflect which of the two points are on-screen and
* off-screen.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* XX15(1 0)           x1 as a 16-bit coordinate (x1_hi x1_lo)
* 
* XX15(3 2)           y1 as a 16-bit coordinate (y1_hi y1_lo)
* 
* XX15(5 4)           x2 as a 16-bit coordinate (x2_hi x2_lo)
* 
* XX12(1 0)           y2 as a 16-bit coordinate (y2_hi y2_lo)
* 
* ------------------------------------------------------------------------------
* 
* Returns:
* 
* (X1, Y1)            Screen coordinate of the start of the clipped line
* 
* (X2, Y2)            Screen coordinate of the end of the clipped line
* 
* C flag              Clear if the clipped line fits on-screen, set if it
* doesn't
* 
* XX13                The state of the original coordinates on-screen:
* 
* * 0   = (x2, y2) on-screen
* 
* * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
* 
* * 191 = (x1, y1) off-screen, (x2, y2) off-screen
* 
* So XX13 is non-zero if the end of the line was clipped,
* meaning the next line sent to BLINE can't join onto the
* end but has to start a new segment
* 
* SWAP                The swap status of the returned coordinates:
* 
* * &FF if we swapped the values of (x1, y1) and
* (x2, y2) as part of the clipping process
* 
* * 0 if the coordinates are still in the same order
* 
* Y                   Y is preserved
* 
* ------------------------------------------------------------------------------
* 
* Other entry points:
* 
* LL147               Don't initialise the values in SWAP or A
* 
* ******************************************************************************

LL145:
       li   ra,>00*256                 ; LDA #0            ; Set SWAP = 0
       movb ra,@SWAP                   ; STA SWAP          

       movb @XX15+5,ra                 ; LDA XX15+5        ; Set A = x2_hi

LL147:
       li   rx,(Y*2-1)*256             ; LDX #Y*2-1        ; Set X = #Y * 2 - 1. The constant #Y is 96, the
                                                           ; y-coordinate of the mid-point of the space view, so
                                                           ; this sets Y2 to 191, the y-coordinate of the bottom
                                                           ; pixel row of the space view

       socb @XX12+1,ra                 ; ORA XX12+1        ; If one or both of x2_hi and y2_hi are non-zero, jump
       jne  LL107                      ; BNE LL107         ; to LL107 to skip the following, leaving X at 191

       cb   @XX12,rx                   ; CPX XX12          ; If y2_lo > the y-coordinate of the bottom of screen
       jnc  LL107                      ; BCC LL107         ; then (x2, y2) is off the bottom of the screen, so skip
                                                           ; the following instruction, leaving X at 191

       li   rx,>00*256                 ; LDX #0            ; Set X = 0

LL107:
       movb rx,@XX13                   ; STX XX13          ; Set XX13 = X, so we have:
                                                           ; 
                                                           ; * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen
                                                           ; 
                                                           ; * XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo
                                                           ; is off the bottom of the screen
                                                           ; 
                                                           ; In other words, XX13 is 191 if (x2, y2) is off-screen,
                                                           ; otherwise it is 0

       movb @XX15+1,ra                 ; LDA XX15+1        ; If one or both of x1_hi and y1_hi are non-zero, jump
       socb @XX15+3,ra                 ; ORA XX15+3        ; to LL83
       jne  LL83                       ; BNE LL83          

       li   ra,(Y*2-1)*256             ; LDA #Y*2-1        ; If y1_lo > the y-coordinate of the bottom of screen
       cb   @XX15+2,ra                 ; CMP XX15+2        ; then (x1, y1) is off the bottom of the screen, so jump
       jnc  LL83                       ; BCC LL83          ; to LL83

                                                           ; If we get here, (x1, y1) is on-screen

       movb @XX13,ra                   ; LDA XX13          ; If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
       jne  LL108                      ; BNE LL108         ; to LL108 to halve it before continuing at LL83

                                                           ; If we get here, the high bytes are all zero, which
                                                           ; means the x-coordinates are < 256 and therefore fit on
                                                           ; screen, and neither coordinate is off the bottom of
                                                           ; the screen. That means both coordinates are already on
                                                           ; screen, so we don't need to do any clipping, all we
                                                           ; need to do is move the low bytes into (X1, Y1) and
                                                           ; X2, Y2) and return

LL146:
                                                           ; If we get here then we have clipped our line to the
                                                           ; screen edge (if we had to clip it at all), so we move
                                                           ; the low bytes from (x1, y1) and (x2, y2) into (X1, Y1)
                                                           ; and (X2, Y2), remembering that they share locations
                                                           ; with XX15:
                                                           ; 
                                                           ; X1 = XX15
                                                           ; Y1 = XX15+1
                                                           ; X2 = XX15+2
                                                           ; Y2 = XX15+3
                                                           ; 
                                                           ; X1 already contains x1_lo, so now we do the rest
       movb @XX15+2,ra                 ; LDA XX15+2        ; Set Y1 (aka XX15+1) = y1_lo
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX15+4,ra                 ; LDA XX15+4        ; Set X2 (aka XX15+2) = x2_lo
       movb ra,@XX15+2                 ; STA XX15+2        

       movb @XX12,ra                   ; LDA XX12          ; Set Y2 (aka XX15+3) = y2_lo
       movb ra,@XX15+3                 ; STA XX15+3        

       .clc                            ; CLC               ; Clear the C flag as the clipped line fits on-screen

       .rts                            ; RTS               ; Return from the subroutine

LL109:
       .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
                                                           ; fit on-screen

       .rts                            ; RTS               ; Return from the subroutine

LL108:
       .lsr @XX13                      ; LSR XX13          ; If we get here then (x2, y2) is off-screen and XX13 is
                                                           ; 191, so shift XX13 right to halve it to 95

* ******************************************************************************
* 
* Name: LL145 (Part 2 of 4)
* Type: Subroutine
* Category: Drawing lines
* Summary: Clip line: Work out if any part of the line is on-screen
* Deep dive: Line-clipping
* Extended screen coordinates
* 
* ------------------------------------------------------------------------------
* 
* This part does a number of tests to see if the line is on or off the screen.
* 
* If we get here then at least one of (x1, y1) and (x2, y2) is off-screen, with
* XX13 set as follows:
* 
* * 0   = (x1, y1) off-screen, (x2, y2) on-screen
* 
* * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
* 
* * 191 = (x1, y1) off-screen, (x2, y2) off-screen
* 
* where "off-screen" is defined as having a non-zero high byte in one of the
* coordinates, or in the case of y-coordinates, having a low byte > 191, the
* y-coordinate of the bottom of the space view.
* 
* ******************************************************************************

LL83:
       movb @XX13,ra                   ; LDA XX13          ; If XX13 < 128 then only one of the points is on-screen
       jgt  LL115                      ; BPL LL115         ; so jump down to LL115 to skip the checks of whether
                                                           ; both points are in the strips to the right or bottom
                                                           ; of the screen

                                                           ; If we get here, both points are off-screen

       movb @XX15+1,ra                 ; LDA XX15+1        ; If both x1_hi and x2_hi have bit 7 set, jump to LL109
       .and @XX15+5                    ; AND XX15+5        ; to return from the subroutine with the C flag set, as
       jlt  LL109                      ; BMI LL109         ; the entire line is above the top of the screen

       movb @XX15+3,ra                 ; LDA XX15+3        ; If both y1_hi and y2_hi have bit 7 set, jump to LL109
       .and @XX12+1                    ; AND XX12+1        ; to return from the subroutine with the C flag set, as
       jlt  LL109                      ; BMI LL109         ; the entire line is to the left of the screen

       movb @XX15+1,rx                 ; LDX XX15+1        ; Set A = X = x1_hi - 1
       sb   rone,rx                    ; DEX               
       movb rx,ra                      ; TXA               

       movb @XX15+5,rx                 ; LDX XX15+5        ; Set XX12+2 = x2_hi - 1
       sb   rone,rx                    ; DEX               
       movb rx,@XX12+2                 ; STX XX12+2        

       socb @XX12+2,ra                 ; ORA XX12+2        ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
       jgt  LL109                      ; BPL LL109         ; jump to LL109 to return from the subroutine with the C
                                                           ; flag set, as the line doesn't fit on-screen

       movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo < y-coordinate of screen bottom, clear the C
       ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it

       movb @XX15+3,ra                 ; LDA XX15+3        ; Set XX12+2 = y1_hi - (1 - C), so:
       .sbi (>00*256)                  ; SBC #0            ; 
       movb ra,@XX12+2                 ; STA XX12+2        ; * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen
                                                           ; * Set XX12+2 = y1_hi     otherwise
                                                           ; 
                                                           ; We do this subtraction because we are only interested
                                                           ; in trying to move the points up by a screen if that
                                                           ; might move the point into the space view portion of
                                                           ; the screen, i.e. if y1_lo is on-screen

       movb @XX12,ra                   ; LDA XX12          ; If y2_lo < y-coordinate of screen bottom, clear the C
       ci   ra,(Y*2)*256               ; CMP #Y*2          ; flag, otherwise set it

       movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+2 = y2_hi - (1 - C), so:
       .sbi (>00*256)                  ; SBC #0            ; 
                                                           ; * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen
                                                           ; * Set XX12+1 = y2_hi     otherwise
                                                           ; 
                                                           ; We do this subtraction because we are only interested
                                                           ; in trying to move the points up by a screen if that
                                                           ; might move the point into the space view portion of
                                                           ; the screen, i.e. if y1_lo is on-screen

       socb @XX12+2,ra                 ; ORA XX12+2        ; If neither XX12+1 or XX12+2 have bit 7 set, jump to
       jgt  LL109                      ; BPL LL109         ; LL109 to return from the subroutine with the C flag
                                                           ; set, as the line doesn't fit on-screen

* ******************************************************************************
* 
* Name: LL145 (Part 3 of 4)
* Type: Subroutine
* Category: Drawing lines
* Summary: Clip line: Calculate the line's gradient
* Deep dive: Line-clipping
* Extended screen coordinates
* 
* ******************************************************************************

LL115:
       movb ry,ra                      ; TYA               ; Store Y on the stack so we can preserve it through the
       .pha                            ; PHA               ; call to this subroutine

       movb @XX15+4,ra                 ; LDA XX15+4        ; Set XX12+2 = x2_lo - x1_lo
       .sec                            ; SEC               
       .sbc @XX15,ra                   ; SBC XX15          
       movb ra,@XX12+2                 ; STA XX12+2        

       movb @XX15+5,ra                 ; LDA XX15+5        ; Set XX12+3 = x2_hi - x1_hi
       .sbc @XX15+1,ra                 ; SBC XX15+1        
       movb ra,@XX12+3                 ; STA XX12+3        

       movb @XX12,ra                   ; LDA XX12          ; Set XX12+4 = y2_lo - y1_lo
       .sec                            ; SEC               
       .sbc @XX15+2,ra                 ; SBC XX15+2        
       movb ra,@XX12+4                 ; STA XX12+4        

       movb @XX12+1,ra                 ; LDA XX12+1        ; Set XX12+5 = y2_hi - y1_hi
       .sbc @XX15+3,ra                 ; SBC XX15+3        
       movb ra,@XX12+5                 ; STA XX12+5        

                                                           ; So we now have:
                                                           ; 
                                                           ; delta_x in XX12(3 2)
                                                           ; delta_y in XX12(5 4)
                                                           ; 
                                                           ; where the delta is (x1, y1) - (x2, y2))

       .eor @XX12+3                    ; EOR XX12+3        ; Set S = the sign of delta_x * the sign of delta_y, so
       movb ra,@S                      ; STA S             ; if bit 7 of S is set, the deltas have different signs

       movb @XX12+5,ra                 ; LDA XX12+5        ; If delta_y_hi is positive, jump down to LL110 to skip
       jgt  LL110                      ; BPL LL110         ; the following

       li   ra,>00*256                 ; LDA #0            ; Otherwise flip the sign of delta_y to make it
       .sec                            ; SEC               ; positive, starting with the low bytes
       .sbc @XX12+4,ra                 ; SBC XX12+4        
       movb ra,@XX12+4                 ; STA XX12+4        

       li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
       .sbc @XX12+5,ra                 ; SBC XX12+5        ; 
       movb ra,@XX12+5                 ; STA XX12+5        ; XX12(5 4) = |delta_y|

LL110:
       movb @XX12+3,ra                 ; LDA XX12+3        ; If delta_x_hi is positive, jump down to LL111 to skip
       jgt  LL111                      ; BPL LL111         ; the following

       .sec                            ; SEC               ; Otherwise flip the sign of delta_x to make it
       li   ra,>00*256                 ; LDA #0            ; positive, starting with the low bytes
       .sbc @XX12+2,ra                 ; SBC XX12+2        
       movb ra,@XX12+2                 ; STA XX12+2        

       li   ra,>00*256                 ; LDA #0            ; And then doing the high bytes, so now:
       .sbc @XX12+3,ra                 ; SBC XX12+3        ; 
                                                           ; (A XX12+2) = |delta_x|

LL111:
                                                           ; We now keep halving |delta_x| and |delta_y| until
                                                           ; both of them have zero in their high bytes
       movb ra,rx                      ; TAX               ; If |delta_x_hi| is non-zero, skip the following
       jne  LL112                      ; BNE LL112         

       movb @XX12+5,rx                 ; LDX XX12+5        ; If |delta_y_hi| = 0, jump down to LL113 (as both
       jeq  LL113                      ; BEQ LL113         ; |delta_x_hi| and |delta_y_hi| are 0)

LL112:
       srl  ra,1                       ; LSR A             ; Halve the value of delta_x in (A XX12+2)
       .ror @XX12+2                    ; ROR XX12+2        

       .lsr @XX12+5                    ; LSR XX12+5        ; Halve the value of delta_y XX12(5 4)
       .ror @XX12+4                    ; ROR XX12+4        

       b    @LL111                     ; JMP LL111         ; Loop back to LL111

LL113:
                                                           ; By now, the high bytes of both |delta_x| and |delta_y|
                                                           ; are zero
       movb rx,@T                      ; STX T             ; We know that X = 0 as that's what we tested with a BEQ
                                                           ; above, so this sets T = 0

       movb @XX12+2,ra                 ; LDA XX12+2        ; If delta_x_lo < delta_y_lo, so our line is more
       cb   @XX12+4,ra                 ; CMP XX12+4        ; vertical than horizontal, jump to LL114
       jnc  LL114                      ; BCC LL114         

                                                           ; If we get here then our line is more horizontal than
                                                           ; vertical, so it is a shallow slope

       movb ra,@Q                      ; STA Q             ; Set Q = delta_x_lo

       movb @XX12+4,ra                 ; LDA XX12+4        ; Set A = delta_y_lo

       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; = 256 * delta_y_lo / delta_x_lo

       b    @LL116                     ; JMP LL116         ; Jump to LL116, as we now have the line's gradient in R

LL114:
                                                           ; If we get here then our line is more vertical than
                                                           ; horizontal, so it is a steep slope
       movb @XX12+4,ra                 ; LDA XX12+4        ; Set Q = delta_y_lo
       movb ra,@Q                      ; STA Q             
       movb @XX12+2,ra                 ; LDA XX12+2        ; Set A = delta_x_lo

       .jsr @LL28                      ; JSR LL28          ; Call LL28 to calculate:
                                                           ; 
                                                           ; R = 256 * A / Q
                                                           ; = 256 * delta_x_lo / delta_y_lo

       sb   rone,ra                    ; DEC T             ; T was set to 0 above, so this sets T = &FF when our
                                                           ; line is steep

* ******************************************************************************
* 
* Name: LL145 (Part 4 of 4)
* Type: Subroutine
* Category: Drawing lines
* Summary: Clip line: Call the routine in LL188 to do the actual clipping
* Deep dive: Line-clipping
* Extended screen coordinates
* 
* ------------------------------------------------------------------------------
* 
* This part sets things up to call the routine in LL188, which does the actual
* clipping.
* 
* If we get here, then R has been set to the gradient of the line (x1, y1) to
* (x2, y2), with T indicating the gradient of slope:
* 
* * 0   = shallow slope (more horizontal than vertical)
* 
* * &FF = steep slope (more vertical than horizontal)
* 
* and XX13 has been set as follows:
* 
* * 0   = (x1, y1) off-screen, (x2, y2) on-screen
* 
* * 95  = (x1, y1) on-screen,  (x2, y2) off-screen
* 
* * 191 = (x1, y1) off-screen, (x2, y2) off-screen
* 
* ******************************************************************************

LL116:
       movb @R,ra                      ; LDA R             ; Store the gradient in XX12+2
       movb ra,@XX12+2                 ; STA XX12+2        

       movb @S,ra                      ; LDA S             ; Store the type of slope in XX12+3, bit 7 clear means
       movb ra,@XX12+3                 ; STA XX12+3        ; top left to bottom right, bit 7 set means top right to
                                                           ; bottom left

       movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, skip the following instruction
       jeq  LL138                      ; BEQ LL138         

       jgt  LLX117                     ; BPL LLX117        ; If XX13 is positive, it must be 95. This means
                                                           ; (x1, y1) is on-screen but (x2, y2) isn't, so we jump
                                                           ; to LLX117 to swap the (x1, y1) and (x2, y2)
                                                           ; coordinates around before doing the actual clipping,
                                                           ; because we need to clip (x2, y2) but the clipping
                                                           ; routine at LL118 only clips (x1, y1)

LL138:
                                                           ; If we get here, XX13 = 0 or 191, so (x1, y1) is
                                                           ; off-screen and needs clipping
       .jsr @LL118                     ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
                                                           ; screen, i.e. clip the line at the (x1, y1) end

       movb @XX13,ra                   ; LDA XX13          ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
       jgt  LL124                      ; BPL LL124         ; LL124 to return with a successfully clipped line

LL117:
                                                           ; If we get here, XX13 = 191 (both coordinates are
                                                           ; off-screen)
       movb @XX15+1,ra                 ; LDA XX15+1        ; If either of x1_hi or y1_hi are non-zero, jump to
       socb @XX15+3,ra                 ; ORA XX15+3        ; LL137 to return from the subroutine with the C flag
       jne  LL137                      ; BNE LL137         ; set, as the line doesn't fit on-screen

       movb @XX15+2,ra                 ; LDA XX15+2        ; If y1_lo > y-coordinate of the bottom of the screen
       ci   ra,(Y*2)*256               ; CMP #Y*2          ; jump to LL137 to return from the subroutine with the
       joc  LL137                      ; BCS LL137         ; C flag set, as the line doesn't fit on-screen

LLX117:
                                                           ; If we get here, XX13 = 95 or 191, and in both cases
                                                           ; (x2, y2) is off-screen, so we now need to swap the
                                                           ; (x1, y1) and (x2, y2) coordinates around before doing
                                                           ; the actual clipping, because we need to clip (x2, y2)
                                                           ; but the clipping routine at LL118 only clips (x1, y1)
       movb @XX15,rx                   ; LDX XX15          ; Swap x1_lo = x2_lo
       movb @XX15+4,ra                 ; LDA XX15+4        
       movb ra,@XX15                   ; STA XX15          
       movb rx,@XX15+4                 ; STX XX15+4        

       movb @XX15+5,ra                 ; LDA XX15+5        ; Swap x2_lo = x1_lo
       movb @XX15+1,rx                 ; LDX XX15+1        
       movb rx,@XX15+5                 ; STX XX15+5        
       movb ra,@XX15+1                 ; STA XX15+1        

       movb @XX15+2,rx                 ; LDX XX15+2        ; Swap y1_lo = y2_lo
       movb @XX12,ra                   ; LDA XX12          
       movb ra,@XX15+2                 ; STA XX15+2        
       movb rx,@XX12                   ; STX XX12          

       movb @XX12+1,ra                 ; LDA XX12+1        ; Swap y2_lo = y1_lo
       movb @XX15+3,rx                 ; LDX XX15+3        
       movb rx,@XX12+1                 ; STX XX12+1        
       movb ra,@XX15+3                 ; STA XX15+3        

       .jsr @LL118                     ; JSR LL118         ; Call LL118 to move (x1, y1) along the line onto the
                                                           ; screen, i.e. clip the line at the (x1, y1) end

       sb   rone,ra                    ; DEC SWAP          ; Set SWAP = &FF to indicate that we just clipped the
                                                           ; line at the (x2, y2) end by swapping the coordinates
                                                           ; (the DEC does this as we set SWAP to 0 at the start of
                                                           ; this subroutine)

LL124:
       .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
       movb ra,ry                      ; TAY               ; the call to this subroutine

       b    @LL146                     ; JMP LL146         ; Jump up to LL146 to move the low bytes of (x1, y1) and
                                                           ; (x2, y2) into (X1, Y1) and (X2, Y2), and return from
                                                           ; the subroutine with a successfully clipped line

LL137:
       .pla                            ; PLA               ; Restore Y from the stack so it gets preserved through
       movb ra,ry                      ; TAY               ; the call to this subroutine

       .sec                            ; SEC               ; Set the C flag to indicate the clipped line does not
                                                           ; fit on-screen

       .rts                            ; RTS               ; Return from the subroutine

* ******************************************************************************
* 
* Save ELTG.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* Name: checksum0
* Type: Variable
* Category: Copy protection
* Summary: Checksum for the entire main game code
* 
* ------------------------------------------------------------------------------
* 
* This byte contains a checksum for the entire main game code. It is populated
* by elite-checksum.py and is used by the encryption checks in elite-loader.asm
* (see the CHK routine in the loader for more details).
* 
* ******************************************************************************

checksum0_:
       bss 1                                               ; This value is checked against the calculated checksum
                                                           ; in part 6 of the loader in elite-loader.asm

* ******************************************************************************
* 
* ELITE SHIP BLUEPRINTS FILE
* 
* Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

CODE_SHIPS.:
       equ $

LOAD_SHIPS.:
       equ LOAD. + $ - CODE.

* ******************************************************************************
* 
* Name: XX21
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprints lookup table
* Deep dive: Ship blueprints
* 
* ******************************************************************************

XX21:
       data >0000                                                    ; 1 = Sidewinder
       data >0000                                                    ; COPS =  2 = Viper
       data >0000                                                    ; 3 = Mamba
       data >0000                                                    ; 4 = Python
       data >0000                                                    ; 5 = Cobra Mk III (bounty hunter)
       data >0000                                                    ; THG  =  6 = Thargoid
       data >0000                                                    ; CYL  =  7 = Cobra Mk III (trader)
       data >0000                                                    ; SST  =  8 = Coriolis space station
       data >0000                                                    ; MSL  =  9 = Missile
       data >0000                                                    ; AST  = 10 = Asteroid
       data >0000                                                    ; OIL  = 11 = Cargo canister
       data >0000                                                    ; TGL  = 12 = Thargon
       data >0000                                                    ; ESC  = 13 = Escape pod

* ******************************************************************************
* 
* Name: VERTEX
* Type: Macro
* Category: Drawing ships
* Summary: Macro definition for adding vertices to ship blueprints
* Deep dive: Ship blueprints
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used to build the ship blueprints:
* 
* VERTEX x, y, z, face1, face2, face3, face4, visibility
* 
* See the deep dive on "Ship blueprints" for details of how vertices are stored
* in the ship blueprints, and the deep dive on "Drawing ships" for information
* on how vertices are used to draw 3D wireframe ships.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* x                   The vertex's x-coordinate
* 
* y                   The vertex's y-coordinate
* 
* z                   The vertex's z-coordinate
* 
* face1               The number of face 1 associated with this vertex
* 
* face2               The number of face 2 associated with this vertex
* 
* face3               The number of face 3 associated with this vertex
* 
* face4               The number of face 4 associated with this vertex
* 
* visibility          The visibility distance, beyond which the vertex is not
* shown
* 
* ******************************************************************************

       ; VERTEX x, y, z, face1, face2, face3, face4, visibility

       ; IF x < 0                      ;                   
       ; s_x = 1 << 7                  ;                   
       ; ELSE                          ;                   
       ; s_x = 0                       ;                   
       ; ENDIF                         ;                   

       ; IF y < 0                      ;                   
       ; s_y = 1 << 6                  ;                   
       ; ELSE                          ;                   
       ; s_y = 0                       ;                   
       ; ENDIF                         ;                   

       ; IF z < 0                      ;                   
       ; s_z = 1 << 5                  ;                   
       ; ELSE                          ;                   
       ; s_z = 0                       ;                   
       ; ENDIF                         ;                   

       ; s = s_x + s_y + s_z + visibility ;                   
       ; f1 = face1 + (face2 << 4)     ;                   
       ; f2 = face3 + (face4 << 4)     ;                   
       ; ax = ABS(x)                   ;                   
       ; ay = ABS(y)                   ;                   
       ; az = ABS(z)                   ;                   

       ; EQUB ax, ay, az, s, f1, f2    ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: EDGE
* Type: Macro
* Category: Drawing ships
* Summary: Macro definition for adding edges to ship blueprints
* Deep dive: Ship blueprints
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used to build the ship blueprints:
* 
* EDGE vertex1, vertex2, face1, face2, visibility
* 
* See the deep dive on "Ship blueprints" for details of how edges are stored
* in the ship blueprints, and the deep dive on "Drawing ships" for information
* on how edges are used to draw 3D wireframe ships.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* vertex1             The number of the vertex at the start of the edge
* 
* vertex1             The number of the vertex at the end of the edge
* 
* face1               The number of face 1 associated with this edge
* 
* face2               The number of face 2 associated with this edge
* 
* visibility          The visibility distance, beyond which the edge is not
* shown
* 
* ******************************************************************************

       ; EDGE vertex1, vertex2, face1, face2, visibility

       ; f = face1 + (face2 << 4)      ;                   
       ; EQUB visibility, f, vertex1 << 2, vertex2 << 2 ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: FACE
* Type: Macro
* Category: Drawing ships
* Summary: Macro definition for adding faces to ship blueprints
* Deep dive: Ship blueprints
* 
* ------------------------------------------------------------------------------
* 
* The following macro is used to build the ship blueprints:
* 
* FACE normal_x, normal_y, normal_z, visibility
* 
* See the deep dive on "Ship blueprints" for details of how faces are stored
* in the ship blueprints, and the deep dive on "Drawing ships" for information
* on how faces are used to draw 3D wireframe ships.
* 
* ------------------------------------------------------------------------------
* 
* Arguments:
* 
* normal_x            The face normal's x-coordinate
* 
* normal_y            The face normal's y-coordinate
* 
* normal_z            The face normal's z-coordinate
* 
* visibility          The visibility distance, beyond which the edge is always
* shown
* 
* ******************************************************************************

       ; FACE normal_x, normal_y, normal_z, visibility

       ; IF normal_x < 0               ;                   
       ; s_x = 1 << 7                  ;                   
       ; ELSE                          ;                   
       ; s_x = 0                       ;                   
       ; ENDIF                         ;                   

       ; IF normal_y < 0               ;                   
       ; s_y = 1 << 6                  ;                   
       ; ELSE                          ;                   
       ; s_y = 0                       ;                   
       ; ENDIF                         ;                   

       ; IF normal_z < 0               ;                   
       ; s_z = 1 << 5                  ;                   
       ; ELSE                          ;                   
       ; s_z = 0                       ;                   
       ; ENDIF                         ;                   

       ; s = s_x + s_y + s_z + visibility ;                   
       ; ax = ABS(normal_x)            ;                   
       ; ay = ABS(normal_y)            ;                   
       ; az = ABS(normal_z)            ;                   

       ; EQUB s, ax, ay, az            ;                   

       ; ENDMACRO

* ******************************************************************************
* 
* Name: SHIP_SIDEWINDER
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Sidewinder
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_SIDEWINDER:
       byte >00                                                      ; Max. canisters on demise = 0
       data >4100                                                    ; Targetable area          = 65 * 65

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >3d                                                      ; Max. edge count          = (61 - 1) / 4 = 15
       byte >00                                                      ; Gun vertex               = 0
       byte >1e                                                      ; Explosion count          = 6, as (4 * n) + 6 = 30
       byte >3c                                                      ; Number of vertices       = 60 / 6 = 10
       byte >0f                                                      ; Number of edges          = 15
       data >3200                                                    ; Bounty                   = 50
       byte >1c                                                      ; Number of faces          = 28 / 4 = 7
       byte >14                                                      ; Visibility distance      = 20
       byte >46                                                      ; Max. energy              = 70
       byte >25                                                      ; Max. speed               = 37

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >02                                                      ; Normals are scaled by    = 2^2 = 4
       byte >10                                                      ; Laser power              = 2
                                                                     ; Missiles                 = 0

SHIP_SIDEWINDER_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX  -32,    0,   36,     0,      1,    4,     5,         31 ; VERTEX  -32,    0 ; Vertex 0
       ; VERTEX   32,    0,   36,     0,      2,    5,     6,         31 ; VERTEX   32,    0 ; Vertex 1
       ; VERTEX   64,    0,  -28,     2,      3,    6,     6,         31 ; VERTEX   64,    0 ; Vertex 2
       ; VERTEX  -64,    0,  -28,     1,      3,    4,     4,         31 ; VERTEX  -64,    0 ; Vertex 3
       ; VERTEX    0,   16,  -28,     0,      1,    2,     3,         31 ; VERTEX    0,   16 ; Vertex 4
       ; VERTEX    0,  -16,  -28,     3,      4,    5,     6,         31 ; VERTEX    0,  -16 ; Vertex 5
       ; VERTEX  -12,    6,  -28,     3,      3,    3,     3,         15 ; VERTEX  -12,    6 ; Vertex 6
       ; VERTEX   12,    6,  -28,     3,      3,    3,     3,         15 ; VERTEX   12,    6 ; Vertex 7
       ; VERTEX   12,   -6,  -28,     3,      3,    3,     3,         12 ; VERTEX   12,   -6 ; Vertex 8
       ; VERTEX  -12,   -6,  -28,     3,      3,    3,     3,         12 ; VERTEX  -12,   -6 ; Vertex 9

SHIP_SIDEWINDER_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     0,     5,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       1,       2,     2,     6,         31 ; EDGE       1,     ; Edge 1
       ; EDGE       1,       4,     0,     2,         31 ; EDGE       1,     ; Edge 2
       ; EDGE       0,       4,     0,     1,         31 ; EDGE       0,     ; Edge 3
       ; EDGE       0,       3,     1,     4,         31 ; EDGE       0,     ; Edge 4
       ; EDGE       3,       4,     1,     3,         31 ; EDGE       3,     ; Edge 5
       ; EDGE       2,       4,     2,     3,         31 ; EDGE       2,     ; Edge 6
       ; EDGE       3,       5,     3,     4,         31 ; EDGE       3,     ; Edge 7
       ; EDGE       2,       5,     3,     6,         31 ; EDGE       2,     ; Edge 8
       ; EDGE       1,       5,     5,     6,         31 ; EDGE       1,     ; Edge 9
       ; EDGE       0,       5,     4,     5,         31 ; EDGE       0,     ; Edge 10
       ; EDGE       6,       7,     3,     3,         15 ; EDGE       6,     ; Edge 11
       ; EDGE       7,       8,     3,     3,         12 ; EDGE       7,     ; Edge 12
       ; EDGE       6,       9,     3,     3,         12 ; EDGE       6,     ; Edge 13
       ; EDGE       8,       9,     3,     3,         12 ; EDGE       8,     ; Edge 14

SHIP_SIDEWINDER_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE        0,       32,        8,         31 ; FACE        0,    ; Face 0
       ; FACE      -12,       47,        6,         31 ; FACE      -12,    ; Face 1
       ; FACE       12,       47,        6,         31 ; FACE       12,    ; Face 2
       ; FACE        0,        0,     -112,         31 ; FACE        0,    ; Face 3
       ; FACE      -12,      -47,        6,         31 ; FACE      -12,    ; Face 4
       ; FACE        0,      -32,        8,         31 ; FACE        0,    ; Face 5
       ; FACE       12,      -47,        6,         31 ; FACE       12,    ; Face 6

* ******************************************************************************
* 
* Name: SHIP_VIPER
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Viper
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_VIPER:
       byte >00                                                      ; Max. canisters on demise = 0
       data >4b00                                                    ; Targetable area          = 75 * 75

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >4d                                                      ; Max. edge count          = (77 - 1) / 4 = 19
       byte >00                                                      ; Gun vertex               = 0
       byte >2a                                                      ; Explosion count          = 9, as (4 * n) + 6 = 42
       byte >5a                                                      ; Number of vertices       = 90 / 6 = 15
       byte >14                                                      ; Number of edges          = 20
       data >0000                                                    ; Bounty                   = 0
       byte >1c                                                      ; Number of faces          = 28 / 4 = 7
       byte >17                                                      ; Visibility distance      = 23
       byte >78                                                      ; Max. energy              = 120
       byte >20                                                      ; Max. speed               = 32

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >01                                                      ; Normals are scaled by    = 2^1 = 2
       byte >11                                                      ; Laser power              = 2
                                                                     ; Missiles                 = 1

SHIP_VIPER_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX    0,    0,   72,     1,      2,    3,     4,         31 ; VERTEX    0,    0 ; Vertex 0
       ; VERTEX    0,   16,   24,     0,      1,    2,     2,         30 ; VERTEX    0,   16 ; Vertex 1
       ; VERTEX    0,  -16,   24,     3,      4,    5,     5,         30 ; VERTEX    0,  -16 ; Vertex 2
       ; VERTEX   48,    0,  -24,     2,      4,    6,     6,         31 ; VERTEX   48,    0 ; Vertex 3
       ; VERTEX  -48,    0,  -24,     1,      3,    6,     6,         31 ; VERTEX  -48,    0 ; Vertex 4
       ; VERTEX   24,  -16,  -24,     4,      5,    6,     6,         30 ; VERTEX   24,  -16 ; Vertex 5
       ; VERTEX  -24,  -16,  -24,     5,      3,    6,     6,         30 ; VERTEX  -24,  -16 ; Vertex 6
       ; VERTEX   24,   16,  -24,     0,      2,    6,     6,         31 ; VERTEX   24,   16 ; Vertex 7
       ; VERTEX  -24,   16,  -24,     0,      1,    6,     6,         31 ; VERTEX  -24,   16 ; Vertex 8
       ; VERTEX  -32,    0,  -24,     6,      6,    6,     6,         19 ; VERTEX  -32,    0 ; Vertex 9
       ; VERTEX   32,    0,  -24,     6,      6,    6,     6,         19 ; VERTEX   32,    0 ; Vertex 10
       ; VERTEX    8,    8,  -24,     6,      6,    6,     6,         19 ; VERTEX    8,    8 ; Vertex 11
       ; VERTEX   -8,    8,  -24,     6,      6,    6,     6,         19 ; VERTEX   -8,    8 ; Vertex 12
       ; VERTEX   -8,   -8,  -24,     6,      6,    6,     6,         18 ; VERTEX   -8,   -8 ; Vertex 13
       ; VERTEX    8,   -8,  -24,     6,      6,    6,     6,         18 ; VERTEX    8,   -8 ; Vertex 14

SHIP_VIPER_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       3,     2,     4,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       1,     1,     2,         30 ; EDGE       0,     ; Edge 1
       ; EDGE       0,       2,     3,     4,         30 ; EDGE       0,     ; Edge 2
       ; EDGE       0,       4,     1,     3,         31 ; EDGE       0,     ; Edge 3
       ; EDGE       1,       7,     0,     2,         30 ; EDGE       1,     ; Edge 4
       ; EDGE       1,       8,     0,     1,         30 ; EDGE       1,     ; Edge 5
       ; EDGE       2,       5,     4,     5,         30 ; EDGE       2,     ; Edge 6
       ; EDGE       2,       6,     3,     5,         30 ; EDGE       2,     ; Edge 7
       ; EDGE       7,       8,     0,     6,         31 ; EDGE       7,     ; Edge 8
       ; EDGE       5,       6,     5,     6,         30 ; EDGE       5,     ; Edge 9
       ; EDGE       4,       8,     1,     6,         31 ; EDGE       4,     ; Edge 10
       ; EDGE       4,       6,     3,     6,         30 ; EDGE       4,     ; Edge 11
       ; EDGE       3,       7,     2,     6,         31 ; EDGE       3,     ; Edge 12
       ; EDGE       3,       5,     6,     4,         30 ; EDGE       3,     ; Edge 13
       ; EDGE       9,      12,     6,     6,         19 ; EDGE       9,     ; Edge 14
       ; EDGE       9,      13,     6,     6,         18 ; EDGE       9,     ; Edge 15
       ; EDGE      10,      11,     6,     6,         19 ; EDGE      10,     ; Edge 16
       ; EDGE      10,      14,     6,     6,         18 ; EDGE      10,     ; Edge 17
       ; EDGE      11,      14,     6,     6,         16 ; EDGE      11,     ; Edge 18
       ; EDGE      12,      13,     6,     6,         16 ; EDGE      12,     ; Edge 19

SHIP_VIPER_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE        0,       32,        0,         31 ; FACE        0,    ; Face 0
       ; FACE      -22,       33,       11,         31 ; FACE      -22,    ; Face 1
       ; FACE       22,       33,       11,         31 ; FACE       22,    ; Face 2
       ; FACE      -22,      -33,       11,         31 ; FACE      -22,    ; Face 3
       ; FACE       22,      -33,       11,         31 ; FACE       22,    ; Face 4
       ; FACE        0,      -32,        0,         31 ; FACE        0,    ; Face 5
       ; FACE        0,        0,      -48,         31 ; FACE        0,    ; Face 6

* ******************************************************************************
* 
* Name: SHIP_MAMBA
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Mamba
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_MAMBA:
       byte >01                                                      ; Max. canisters on demise = 1
       data >4600                                                    ; Targetable area          = 70 * 70

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >5d                                                      ; Max. edge count          = (93 - 1) / 4 = 23
       byte >00                                                      ; Gun vertex               = 0
       byte >22                                                      ; Explosion count          = 7, as (4 * n) + 6 = 34
       byte >96                                                      ; Number of vertices       = 150 / 6 = 25
       byte >1c                                                      ; Number of edges          = 28
       data >9600                                                    ; Bounty                   = 150
       byte >14                                                      ; Number of faces          = 20 / 4 = 5
       byte >19                                                      ; Visibility distance      = 25
       byte >5a                                                      ; Max. energy              = 90
       byte >1e                                                      ; Max. speed               = 30

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >02                                                      ; Normals are scaled by    = 2^2 = 4
       byte >12                                                      ; Laser power              = 2
                                                                     ; Missiles                 = 2

SHIP_MAMBA_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX    0,    0,   64,     0,      1,    2,     3,         31 ; VERTEX    0,    0 ; Vertex 0
       ; VERTEX  -64,   -8,  -32,     0,      2,    4,     4,         31 ; VERTEX  -64,   -8 ; Vertex 1
       ; VERTEX  -32,    8,  -32,     1,      2,    4,     4,         30 ; VERTEX  -32,    8 ; Vertex 2
       ; VERTEX   32,    8,  -32,     1,      3,    4,     4,         30 ; VERTEX   32,    8 ; Vertex 3
       ; VERTEX   64,   -8,  -32,     0,      3,    4,     4,         31 ; VERTEX   64,   -8 ; Vertex 4
       ; VERTEX   -4,    4,   16,     1,      1,    1,     1,         14 ; VERTEX   -4,    4 ; Vertex 5
       ; VERTEX    4,    4,   16,     1,      1,    1,     1,         14 ; VERTEX    4,    4 ; Vertex 6
       ; VERTEX    8,    3,   28,     1,      1,    1,     1,         13 ; VERTEX    8,    3 ; Vertex 7
       ; VERTEX   -8,    3,   28,     1,      1,    1,     1,         13 ; VERTEX   -8,    3 ; Vertex 8
       ; VERTEX  -20,   -4,   16,     0,      0,    0,     0,         20 ; VERTEX  -20,   -4 ; Vertex 9
       ; VERTEX   20,   -4,   16,     0,      0,    0,     0,         20 ; VERTEX   20,   -4 ; Vertex 10
       ; VERTEX  -24,   -7,  -20,     0,      0,    0,     0,         20 ; VERTEX  -24,   -7 ; Vertex 11
       ; VERTEX  -16,   -7,  -20,     0,      0,    0,     0,         16 ; VERTEX  -16,   -7 ; Vertex 12
       ; VERTEX   16,   -7,  -20,     0,      0,    0,     0,         16 ; VERTEX   16,   -7 ; Vertex 13
       ; VERTEX   24,   -7,  -20,     0,      0,    0,     0,         20 ; VERTEX   24,   -7 ; Vertex 14
       ; VERTEX   -8,    4,  -32,     4,      4,    4,     4,         13 ; VERTEX   -8,    4 ; Vertex 15
       ; VERTEX    8,    4,  -32,     4,      4,    4,     4,         13 ; VERTEX    8,    4 ; Vertex 16
       ; VERTEX    8,   -4,  -32,     4,      4,    4,     4,         14 ; VERTEX    8,   -4 ; Vertex 17
       ; VERTEX   -8,   -4,  -32,     4,      4,    4,     4,         14 ; VERTEX   -8,   -4 ; Vertex 18
       ; VERTEX  -32,    4,  -32,     4,      4,    4,     4,          7 ; VERTEX  -32,    4 ; Vertex 19
       ; VERTEX   32,    4,  -32,     4,      4,    4,     4,          7 ; VERTEX   32,    4 ; Vertex 20
       ; VERTEX   36,   -4,  -32,     4,      4,    4,     4,          7 ; VERTEX   36,   -4 ; Vertex 21
       ; VERTEX  -36,   -4,  -32,     4,      4,    4,     4,          7 ; VERTEX  -36,   -4 ; Vertex 22
       ; VERTEX  -38,    0,  -32,     4,      4,    4,     4,          5 ; VERTEX  -38,    0 ; Vertex 23
       ; VERTEX   38,    0,  -32,     4,      4,    4,     4,          5 ; VERTEX   38,    0 ; Vertex 24

SHIP_MAMBA_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     0,     2,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       4,     0,     3,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       1,       4,     0,     4,         31 ; EDGE       1,     ; Edge 2
       ; EDGE       1,       2,     2,     4,         30 ; EDGE       1,     ; Edge 3
       ; EDGE       2,       3,     1,     4,         30 ; EDGE       2,     ; Edge 4
       ; EDGE       3,       4,     3,     4,         30 ; EDGE       3,     ; Edge 5
       ; EDGE       5,       6,     1,     1,         14 ; EDGE       5,     ; Edge 6
       ; EDGE       6,       7,     1,     1,         12 ; EDGE       6,     ; Edge 7
       ; EDGE       7,       8,     1,     1,         13 ; EDGE       7,     ; Edge 8
       ; EDGE       5,       8,     1,     1,         12 ; EDGE       5,     ; Edge 9
       ; EDGE       9,      11,     0,     0,         20 ; EDGE       9,     ; Edge 10
       ; EDGE       9,      12,     0,     0,         16 ; EDGE       9,     ; Edge 11
       ; EDGE      10,      13,     0,     0,         16 ; EDGE      10,     ; Edge 12
       ; EDGE      10,      14,     0,     0,         20 ; EDGE      10,     ; Edge 13
       ; EDGE      13,      14,     0,     0,         14 ; EDGE      13,     ; Edge 14
       ; EDGE      11,      12,     0,     0,         14 ; EDGE      11,     ; Edge 15
       ; EDGE      15,      16,     4,     4,         13 ; EDGE      15,     ; Edge 16
       ; EDGE      17,      18,     4,     4,         14 ; EDGE      17,     ; Edge 17
       ; EDGE      15,      18,     4,     4,         12 ; EDGE      15,     ; Edge 18
       ; EDGE      16,      17,     4,     4,         12 ; EDGE      16,     ; Edge 19
       ; EDGE      20,      21,     4,     4,          7 ; EDGE      20,     ; Edge 20
       ; EDGE      20,      24,     4,     4,          5 ; EDGE      20,     ; Edge 21
       ; EDGE      21,      24,     4,     4,          5 ; EDGE      21,     ; Edge 22
       ; EDGE      19,      22,     4,     4,          7 ; EDGE      19,     ; Edge 23
       ; EDGE      19,      23,     4,     4,          5 ; EDGE      19,     ; Edge 24
       ; EDGE      22,      23,     4,     4,          5 ; EDGE      22,     ; Edge 25
       ; EDGE       0,       2,     1,     2,         30 ; EDGE       0,     ; Edge 26
       ; EDGE       0,       3,     1,     3,         30 ; EDGE       0,     ; Edge 27

SHIP_MAMBA_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE        0,      -24,        2,         30 ; FACE        0,    ; Face 0
       ; FACE        0,       24,        2,         30 ; FACE        0,    ; Face 1
       ; FACE      -32,       64,       16,         30 ; FACE      -32,    ; Face 2
       ; FACE       32,       64,       16,         30 ; FACE       32,    ; Face 3
       ; FACE        0,        0,     -127,         30 ; FACE        0,    ; Face 4

* ******************************************************************************
* 
* Name: SHIP_COBRA_MK_3
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Cobra Mk III
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_COBRA_MK_3:
       byte >03                                                      ; Max. canisters on demise = 3
       data >5f00                                                    ; Targetable area          = 95 * 95

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >99                                                      ; Max. edge count          = (153 - 1) / 4 = 38
       byte >54                                                      ; Gun vertex               = 84 / 4 = 21
       byte >2a                                                      ; Explosion count          = 9, as (4 * n) + 6 = 42
       byte >a8                                                      ; Number of vertices       = 168 / 6 = 28
       byte >26                                                      ; Number of edges          = 38
       data >0000                                                    ; Bounty                   = 0
       byte >34                                                      ; Number of faces          = 52 / 4 = 13
       byte >32                                                      ; Visibility distance      = 50
       byte >96                                                      ; Max. energy              = 150
       byte >1c                                                      ; Max. speed               = 28

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >01                                                      ; Normals are scaled by    = 2^1 = 2
       byte >13                                                      ; Laser power              = 2
                                                                     ; Missiles                 = 3

SHIP_COBRA_MK_3_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX   32,    0,   76,    15,     15,   15,    15,         31 ; VERTEX   32,    0 ; Vertex 0
       ; VERTEX  -32,    0,   76,    15,     15,   15,    15,         31 ; VERTEX  -32,    0 ; Vertex 1
       ; VERTEX    0,   26,   24,    15,     15,   15,    15,         31 ; VERTEX    0,   26 ; Vertex 2
       ; VERTEX -120,   -3,   -8,     3,      7,   10,    10,         31 ; VERTEX -120,   -3 ; Vertex 3
       ; VERTEX  120,   -3,   -8,     4,      8,   12,    12,         31 ; VERTEX  120,   -3 ; Vertex 4
       ; VERTEX  -88,   16,  -40,    15,     15,   15,    15,         31 ; VERTEX  -88,   16 ; Vertex 5
       ; VERTEX   88,   16,  -40,    15,     15,   15,    15,         31 ; VERTEX   88,   16 ; Vertex 6
       ; VERTEX  128,   -8,  -40,     8,      9,   12,    12,         31 ; VERTEX  128,   -8 ; Vertex 7
       ; VERTEX -128,   -8,  -40,     7,      9,   10,    10,         31 ; VERTEX -128,   -8 ; Vertex 8
       ; VERTEX    0,   26,  -40,     5,      6,    9,     9,         31 ; VERTEX    0,   26 ; Vertex 9
       ; VERTEX  -32,  -24,  -40,     9,     10,   11,    11,         31 ; VERTEX  -32,  -24 ; Vertex 10
       ; VERTEX   32,  -24,  -40,     9,     11,   12,    12,         31 ; VERTEX   32,  -24 ; Vertex 11
       ; VERTEX  -36,    8,  -40,     9,      9,    9,     9,         20 ; VERTEX  -36,    8 ; Vertex 12
       ; VERTEX   -8,   12,  -40,     9,      9,    9,     9,         20 ; VERTEX   -8,   12 ; Vertex 13
       ; VERTEX    8,   12,  -40,     9,      9,    9,     9,         20 ; VERTEX    8,   12 ; Vertex 14
       ; VERTEX   36,    8,  -40,     9,      9,    9,     9,         20 ; VERTEX   36,    8 ; Vertex 15
       ; VERTEX   36,  -12,  -40,     9,      9,    9,     9,         20 ; VERTEX   36,  -12 ; Vertex 16
       ; VERTEX    8,  -16,  -40,     9,      9,    9,     9,         20 ; VERTEX    8,  -16 ; Vertex 17
       ; VERTEX   -8,  -16,  -40,     9,      9,    9,     9,         20 ; VERTEX   -8,  -16 ; Vertex 18
       ; VERTEX  -36,  -12,  -40,     9,      9,    9,     9,         20 ; VERTEX  -36,  -12 ; Vertex 19
       ; VERTEX    0,    0,   76,     0,     11,   11,    11,          6 ; VERTEX    0,    0 ; Vertex 20
       ; VERTEX    0,    0,   90,     0,     11,   11,    11,         31 ; VERTEX    0,    0 ; Vertex 21
       ; VERTEX  -80,   -6,  -40,     9,      9,    9,     9,          8 ; VERTEX  -80,   -6 ; Vertex 22
       ; VERTEX  -80,    6,  -40,     9,      9,    9,     9,          8 ; VERTEX  -80,    6 ; Vertex 23
       ; VERTEX  -88,    0,  -40,     9,      9,    9,     9,          6 ; VERTEX  -88,    0 ; Vertex 24
       ; VERTEX   80,    6,  -40,     9,      9,    9,     9,          8 ; VERTEX   80,    6 ; Vertex 25
       ; VERTEX   88,    0,  -40,     9,      9,    9,     9,          6 ; VERTEX   88,    0 ; Vertex 26
       ; VERTEX   80,   -6,  -40,     9,      9,    9,     9,          8 ; VERTEX   80,   -6 ; Vertex 27

SHIP_COBRA_MK_3_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     0,    11,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       4,     4,    12,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       1,       3,     3,    10,         31 ; EDGE       1,     ; Edge 2
       ; EDGE       3,       8,     7,    10,         31 ; EDGE       3,     ; Edge 3
       ; EDGE       4,       7,     8,    12,         31 ; EDGE       4,     ; Edge 4
       ; EDGE       6,       7,     8,     9,         31 ; EDGE       6,     ; Edge 5
       ; EDGE       6,       9,     6,     9,         31 ; EDGE       6,     ; Edge 6
       ; EDGE       5,       9,     5,     9,         31 ; EDGE       5,     ; Edge 7
       ; EDGE       5,       8,     7,     9,         31 ; EDGE       5,     ; Edge 8
       ; EDGE       2,       5,     1,     5,         31 ; EDGE       2,     ; Edge 9
       ; EDGE       2,       6,     2,     6,         31 ; EDGE       2,     ; Edge 10
       ; EDGE       3,       5,     3,     7,         31 ; EDGE       3,     ; Edge 11
       ; EDGE       4,       6,     4,     8,         31 ; EDGE       4,     ; Edge 12
       ; EDGE       1,       2,     0,     1,         31 ; EDGE       1,     ; Edge 13
       ; EDGE       0,       2,     0,     2,         31 ; EDGE       0,     ; Edge 14
       ; EDGE       8,      10,     9,    10,         31 ; EDGE       8,     ; Edge 15
       ; EDGE      10,      11,     9,    11,         31 ; EDGE      10,     ; Edge 16
       ; EDGE       7,      11,     9,    12,         31 ; EDGE       7,     ; Edge 17
       ; EDGE       1,      10,    10,    11,         31 ; EDGE       1,     ; Edge 18
       ; EDGE       0,      11,    11,    12,         31 ; EDGE       0,     ; Edge 19
       ; EDGE       1,       5,     1,     3,         29 ; EDGE       1,     ; Edge 20
       ; EDGE       0,       6,     2,     4,         29 ; EDGE       0,     ; Edge 21
       ; EDGE      20,      21,     0,    11,          6 ; EDGE      20,     ; Edge 22
       ; EDGE      12,      13,     9,     9,         20 ; EDGE      12,     ; Edge 23
       ; EDGE      18,      19,     9,     9,         20 ; EDGE      18,     ; Edge 24
       ; EDGE      14,      15,     9,     9,         20 ; EDGE      14,     ; Edge 25
       ; EDGE      16,      17,     9,     9,         20 ; EDGE      16,     ; Edge 26
       ; EDGE      15,      16,     9,     9,         19 ; EDGE      15,     ; Edge 27
       ; EDGE      14,      17,     9,     9,         17 ; EDGE      14,     ; Edge 28
       ; EDGE      13,      18,     9,     9,         19 ; EDGE      13,     ; Edge 29
       ; EDGE      12,      19,     9,     9,         19 ; EDGE      12,     ; Edge 30
       ; EDGE       2,       9,     5,     6,         30 ; EDGE       2,     ; Edge 31
       ; EDGE      22,      24,     9,     9,          6 ; EDGE      22,     ; Edge 32
       ; EDGE      23,      24,     9,     9,          6 ; EDGE      23,     ; Edge 33
       ; EDGE      22,      23,     9,     9,          8 ; EDGE      22,     ; Edge 34
       ; EDGE      25,      26,     9,     9,          6 ; EDGE      25,     ; Edge 35
       ; EDGE      26,      27,     9,     9,          6 ; EDGE      26,     ; Edge 36
       ; EDGE      25,      27,     9,     9,          8 ; EDGE      25,     ; Edge 37

SHIP_COBRA_MK_3_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE        0,       62,       31,         31 ; FACE        0,    ; Face 0
       ; FACE      -18,       55,       16,         31 ; FACE      -18,    ; Face 1
       ; FACE       18,       55,       16,         31 ; FACE       18,    ; Face 2
       ; FACE      -16,       52,       14,         31 ; FACE      -16,    ; Face 3
       ; FACE       16,       52,       14,         31 ; FACE       16,    ; Face 4
       ; FACE      -14,       47,        0,         31 ; FACE      -14,    ; Face 5
       ; FACE       14,       47,        0,         31 ; FACE       14,    ; Face 6
       ; FACE      -61,      102,        0,         31 ; FACE      -61,    ; Face 7
       ; FACE       61,      102,        0,         31 ; FACE       61,    ; Face 8
       ; FACE        0,        0,      -80,         31 ; FACE        0,    ; Face 9
       ; FACE       -7,      -42,        9,         31 ; FACE       -7,    ; Face 10
       ; FACE        0,      -30,        6,         31 ; FACE        0,    ; Face 11
       ; FACE        7,      -42,        9,         31 ; FACE        7,    ; Face 12

* ******************************************************************************
* 
* Name: SHIP_THARGOID
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Thargoid mothership
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_THARGOID:
       byte >00                                                      ; Max. canisters on demise = 0
       data >6300                                                    ; Targetable area          = 99 * 99

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >65                                                      ; Max. edge count          = (101 - 1) / 4 = 25
       byte >3c                                                      ; Gun vertex               = 60 / 4 = 15
       byte >26                                                      ; Explosion count          = 8, as (4 * n) + 6 = 38
       byte >78                                                      ; Number of vertices       = 120 / 6 = 20
       byte >1a                                                      ; Number of edges          = 26
       data >f401                                                    ; Bounty                   = 500
       byte >28                                                      ; Number of faces          = 40 / 4 = 10
       byte >37                                                      ; Visibility distance      = 55
       byte >f0                                                      ; Max. energy              = 240
       byte >27                                                      ; Max. speed               = 39

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >02                                                      ; Normals are scaled by    = 2^2 = 4
       byte >16                                                      ; Laser power              = 2
                                                                     ; Missiles                 = 6

SHIP_THARGOID_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX   32,  -48,   48,     0,      4,    8,     8,         31 ; VERTEX   32,  -48 ; Vertex 0
       ; VERTEX   32,  -68,    0,     0,      1,    4,     4,         31 ; VERTEX   32,  -68 ; Vertex 1
       ; VERTEX   32,  -48,  -48,     1,      2,    4,     4,         31 ; VERTEX   32,  -48 ; Vertex 2
       ; VERTEX   32,    0,  -68,     2,      3,    4,     4,         31 ; VERTEX   32,    0 ; Vertex 3
       ; VERTEX   32,   48,  -48,     3,      4,    5,     5,         31 ; VERTEX   32,   48 ; Vertex 4
       ; VERTEX   32,   68,    0,     4,      5,    6,     6,         31 ; VERTEX   32,   68 ; Vertex 5
       ; VERTEX   32,   48,   48,     4,      6,    7,     7,         31 ; VERTEX   32,   48 ; Vertex 6
       ; VERTEX   32,    0,   68,     4,      7,    8,     8,         31 ; VERTEX   32,    0 ; Vertex 7
       ; VERTEX  -24, -116,  116,     0,      8,    9,     9,         31 ; VERTEX  -24, -116 ; Vertex 8
       ; VERTEX  -24, -164,    0,     0,      1,    9,     9,         31 ; VERTEX  -24, -164 ; Vertex 9
       ; VERTEX  -24, -116, -116,     1,      2,    9,     9,         31 ; VERTEX  -24, -116 ; Vertex 10
       ; VERTEX  -24,    0, -164,     2,      3,    9,     9,         31 ; VERTEX  -24,    0 ; Vertex 11
       ; VERTEX  -24,  116, -116,     3,      5,    9,     9,         31 ; VERTEX  -24,  116 ; Vertex 12
       ; VERTEX  -24,  164,    0,     5,      6,    9,     9,         31 ; VERTEX  -24,  164 ; Vertex 13
       ; VERTEX  -24,  116,  116,     6,      7,    9,     9,         31 ; VERTEX  -24,  116 ; Vertex 14
       ; VERTEX  -24,    0,  164,     7,      8,    9,     9,         31 ; VERTEX  -24,    0 ; Vertex 15
       ; VERTEX  -24,   64,   80,     9,      9,    9,     9,         30 ; VERTEX  -24,   64 ; Vertex 16
       ; VERTEX  -24,   64,  -80,     9,      9,    9,     9,         30 ; VERTEX  -24,   64 ; Vertex 17
       ; VERTEX  -24,  -64,  -80,     9,      9,    9,     9,         30 ; VERTEX  -24,  -64 ; Vertex 18
       ; VERTEX  -24,  -64,   80,     9,      9,    9,     9,         30 ; VERTEX  -24,  -64 ; Vertex 19

SHIP_THARGOID_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       7,     4,     8,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       1,     0,     4,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       1,       2,     1,     4,         31 ; EDGE       1,     ; Edge 2
       ; EDGE       2,       3,     2,     4,         31 ; EDGE       2,     ; Edge 3
       ; EDGE       3,       4,     3,     4,         31 ; EDGE       3,     ; Edge 4
       ; EDGE       4,       5,     4,     5,         31 ; EDGE       4,     ; Edge 5
       ; EDGE       5,       6,     4,     6,         31 ; EDGE       5,     ; Edge 6
       ; EDGE       6,       7,     4,     7,         31 ; EDGE       6,     ; Edge 7
       ; EDGE       0,       8,     0,     8,         31 ; EDGE       0,     ; Edge 8
       ; EDGE       1,       9,     0,     1,         31 ; EDGE       1,     ; Edge 9
       ; EDGE       2,      10,     1,     2,         31 ; EDGE       2,     ; Edge 10
       ; EDGE       3,      11,     2,     3,         31 ; EDGE       3,     ; Edge 11
       ; EDGE       4,      12,     3,     5,         31 ; EDGE       4,     ; Edge 12
       ; EDGE       5,      13,     5,     6,         31 ; EDGE       5,     ; Edge 13
       ; EDGE       6,      14,     6,     7,         31 ; EDGE       6,     ; Edge 14
       ; EDGE       7,      15,     7,     8,         31 ; EDGE       7,     ; Edge 15
       ; EDGE       8,      15,     8,     9,         31 ; EDGE       8,     ; Edge 16
       ; EDGE       8,       9,     0,     9,         31 ; EDGE       8,     ; Edge 17
       ; EDGE       9,      10,     1,     9,         31 ; EDGE       9,     ; Edge 18
       ; EDGE      10,      11,     2,     9,         31 ; EDGE      10,     ; Edge 19
       ; EDGE      11,      12,     3,     9,         31 ; EDGE      11,     ; Edge 20
       ; EDGE      12,      13,     5,     9,         31 ; EDGE      12,     ; Edge 21
       ; EDGE      13,      14,     6,     9,         31 ; EDGE      13,     ; Edge 22
       ; EDGE      14,      15,     7,     9,         31 ; EDGE      14,     ; Edge 23
       ; EDGE      16,      17,     9,     9,         30 ; EDGE      16,     ; Edge 24
       ; EDGE      18,      19,     9,     9,         30 ; EDGE      18,     ; Edge 25

SHIP_THARGOID_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE      103,      -60,       25,         31 ; FACE      103,    ; Face 0
       ; FACE      103,      -60,      -25,         31 ; FACE      103,    ; Face 1
       ; FACE      103,      -25,      -60,         31 ; FACE      103,    ; Face 2
       ; FACE      103,       25,      -60,         31 ; FACE      103,    ; Face 3
       ; FACE       64,        0,        0,         31 ; FACE       64,    ; Face 4
       ; FACE      103,       60,      -25,         31 ; FACE      103,    ; Face 5
       ; FACE      103,       60,       25,         31 ; FACE      103,    ; Face 6
       ; FACE      103,       25,       60,         31 ; FACE      103,    ; Face 7
       ; FACE      103,      -25,       60,         31 ; FACE      103,    ; Face 8
       ; FACE      -48,        0,        0,         31 ; FACE      -48,    ; Face 9

* ******************************************************************************
* 
* Name: SHIP_CORIOLIS
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Coriolis space station
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_CORIOLIS:
       byte >00                                                      ; Max. canisters on demise = 0
       data >a000                                                    ; Targetable area          = 160 * 160

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >55                                                      ; Max. edge count          = (85 - 1) / 4 = 21
       byte >00                                                      ; Gun vertex               = 0
       byte >36                                                      ; Explosion count          = 12, as (4 * n) + 6 = 54
       byte >60                                                      ; Number of vertices       = 96 / 6 = 16
       byte >1c                                                      ; Number of edges          = 28
       data >0000                                                    ; Bounty                   = 0
       byte >38                                                      ; Number of faces          = 56 / 4 = 14
       byte >78                                                      ; Visibility distance      = 120
       byte >f0                                                      ; Max. energy              = 240
       byte >00                                                      ; Max. speed               = 0

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >00                                                      ; Normals are scaled by    = 2^0 = 1
       byte >06                                                      ; Laser power              = 0
                                                                     ; Missiles                 = 6

SHIP_CORIOLIS_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX  160,    0,  160,     0,      1,    2,     6,         31 ; VERTEX  160,    0 ; Vertex 0
       ; VERTEX    0,  160,  160,     0,      2,    3,     8,         31 ; VERTEX    0,  160 ; Vertex 1
       ; VERTEX -160,    0,  160,     0,      3,    4,     7,         31 ; VERTEX -160,    0 ; Vertex 2
       ; VERTEX    0, -160,  160,     0,      1,    4,     5,         31 ; VERTEX    0, -160 ; Vertex 3
       ; VERTEX  160, -160,    0,     1,      5,    6,    10,         31 ; VERTEX  160, -160 ; Vertex 4
       ; VERTEX  160,  160,    0,     2,      6,    8,    11,         31 ; VERTEX  160,  160 ; Vertex 5
       ; VERTEX -160,  160,    0,     3,      7,    8,    12,         31 ; VERTEX -160,  160 ; Vertex 6
       ; VERTEX -160, -160,    0,     4,      5,    7,     9,         31 ; VERTEX -160, -160 ; Vertex 7
       ; VERTEX  160,    0, -160,     6,     10,   11,    13,         31 ; VERTEX  160,    0 ; Vertex 8
       ; VERTEX    0,  160, -160,     8,     11,   12,    13,         31 ; VERTEX    0,  160 ; Vertex 9
       ; VERTEX -160,    0, -160,     7,      9,   12,    13,         31 ; VERTEX -160,    0 ; Vertex 10
       ; VERTEX    0, -160, -160,     5,      9,   10,    13,         31 ; VERTEX    0, -160 ; Vertex 11
       ; VERTEX   10,  -30,  160,     0,      0,    0,     0,         30 ; VERTEX   10,  -30 ; Vertex 12
       ; VERTEX   10,   30,  160,     0,      0,    0,     0,         30 ; VERTEX   10,   30 ; Vertex 13
       ; VERTEX  -10,   30,  160,     0,      0,    0,     0,         30 ; VERTEX  -10,   30 ; Vertex 14
       ; VERTEX  -10,  -30,  160,     0,      0,    0,     0,         30 ; VERTEX  -10,  -30 ; Vertex 15

SHIP_CORIOLIS_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       3,     0,     1,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       1,     0,     2,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       1,       2,     0,     3,         31 ; EDGE       1,     ; Edge 2
       ; EDGE       2,       3,     0,     4,         31 ; EDGE       2,     ; Edge 3
       ; EDGE       3,       4,     1,     5,         31 ; EDGE       3,     ; Edge 4
       ; EDGE       0,       4,     1,     6,         31 ; EDGE       0,     ; Edge 5
       ; EDGE       0,       5,     2,     6,         31 ; EDGE       0,     ; Edge 6
       ; EDGE       5,       1,     2,     8,         31 ; EDGE       5,     ; Edge 7
       ; EDGE       1,       6,     3,     8,         31 ; EDGE       1,     ; Edge 8
       ; EDGE       2,       6,     3,     7,         31 ; EDGE       2,     ; Edge 9
       ; EDGE       2,       7,     4,     7,         31 ; EDGE       2,     ; Edge 10
       ; EDGE       3,       7,     4,     5,         31 ; EDGE       3,     ; Edge 11
       ; EDGE       8,      11,    10,    13,         31 ; EDGE       8,     ; Edge 12
       ; EDGE       8,       9,    11,    13,         31 ; EDGE       8,     ; Edge 13
       ; EDGE       9,      10,    12,    13,         31 ; EDGE       9,     ; Edge 14
       ; EDGE      10,      11,     9,    13,         31 ; EDGE      10,     ; Edge 15
       ; EDGE       4,      11,     5,    10,         31 ; EDGE       4,     ; Edge 16
       ; EDGE       4,       8,     6,    10,         31 ; EDGE       4,     ; Edge 17
       ; EDGE       5,       8,     6,    11,         31 ; EDGE       5,     ; Edge 18
       ; EDGE       5,       9,     8,    11,         31 ; EDGE       5,     ; Edge 19
       ; EDGE       6,       9,     8,    12,         31 ; EDGE       6,     ; Edge 20
       ; EDGE       6,      10,     7,    12,         31 ; EDGE       6,     ; Edge 21
       ; EDGE       7,      10,     7,     9,         31 ; EDGE       7,     ; Edge 22
       ; EDGE       7,      11,     5,     9,         31 ; EDGE       7,     ; Edge 23
       ; EDGE      12,      13,     0,     0,         30 ; EDGE      12,     ; Edge 24
       ; EDGE      13,      14,     0,     0,         30 ; EDGE      13,     ; Edge 25
       ; EDGE      14,      15,     0,     0,         30 ; EDGE      14,     ; Edge 26
       ; EDGE      15,      12,     0,     0,         30 ; EDGE      15,     ; Edge 27

SHIP_CORIOLIS_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE        0,        0,      160,         31 ; FACE        0,    ; Face 0
       ; FACE      107,     -107,      107,         31 ; FACE      107,    ; Face 1
       ; FACE      107,      107,      107,         31 ; FACE      107,    ; Face 2
       ; FACE     -107,      107,      107,         31 ; FACE     -107,    ; Face 3
       ; FACE     -107,     -107,      107,         31 ; FACE     -107,    ; Face 4
       ; FACE        0,     -160,        0,         31 ; FACE        0,    ; Face 5
       ; FACE      160,        0,        0,         31 ; FACE      160,    ; Face 6
       ; FACE     -160,        0,        0,         31 ; FACE     -160,    ; Face 7
       ; FACE        0,      160,        0,         31 ; FACE        0,    ; Face 8
       ; FACE     -107,     -107,     -107,         31 ; FACE     -107,    ; Face 9
       ; FACE      107,     -107,     -107,         31 ; FACE      107,    ; Face 10
       ; FACE      107,      107,     -107,         31 ; FACE      107,    ; Face 11
       ; FACE     -107,      107,     -107,         31 ; FACE     -107,    ; Face 12
       ; FACE        0,        0,     -160,         31 ; FACE        0,    ; Face 13

* ******************************************************************************
* 
* Name: SHIP_MISSILE
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a missile
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_MISSILE:
       byte >00                                                      ; Max. canisters on demise = 0
       data >2800                                                    ; Targetable area          = 40 * 40

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >51                                                      ; Max. edge count          = (81 - 1) / 4 = 20
       byte >00                                                      ; Gun vertex               = 0
       byte >0a                                                      ; Explosion count          = 1, as (4 * n) + 6 = 10
       byte >66                                                      ; Number of vertices       = 102 / 6 = 17
       byte >18                                                      ; Number of edges          = 24
       data >0000                                                    ; Bounty                   = 0
       byte >24                                                      ; Number of faces          = 36 / 4 = 9
       byte >0e                                                      ; Visibility distance      = 14
       byte >02                                                      ; Max. energy              = 2
       byte >2c                                                      ; Max. speed               = 44

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >02                                                      ; Normals are scaled by    = 2^2 = 4
       byte >00                                                      ; Laser power              = 0
                                                                     ; Missiles                 = 0

SHIP_MISSILE_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX    0,    0,   68,     0,      1,    2,     3,         31 ; VERTEX    0,    0 ; Vertex 0
       ; VERTEX    8,   -8,   36,     1,      2,    4,     5,         31 ; VERTEX    8,   -8 ; Vertex 1
       ; VERTEX    8,    8,   36,     2,      3,    4,     7,         31 ; VERTEX    8,    8 ; Vertex 2
       ; VERTEX   -8,    8,   36,     0,      3,    6,     7,         31 ; VERTEX   -8,    8 ; Vertex 3
       ; VERTEX   -8,   -8,   36,     0,      1,    5,     6,         31 ; VERTEX   -8,   -8 ; Vertex 4
       ; VERTEX    8,    8,  -44,     4,      7,    8,     8,         31 ; VERTEX    8,    8 ; Vertex 5
       ; VERTEX    8,   -8,  -44,     4,      5,    8,     8,         31 ; VERTEX    8,   -8 ; Vertex 6
       ; VERTEX   -8,   -8,  -44,     5,      6,    8,     8,         31 ; VERTEX   -8,   -8 ; Vertex 7
       ; VERTEX   -8,    8,  -44,     6,      7,    8,     8,         31 ; VERTEX   -8,    8 ; Vertex 8
       ; VERTEX   12,   12,  -44,     4,      7,    8,     8,          8 ; VERTEX   12,   12 ; Vertex 9
       ; VERTEX   12,  -12,  -44,     4,      5,    8,     8,          8 ; VERTEX   12,  -12 ; Vertex 10
       ; VERTEX  -12,  -12,  -44,     5,      6,    8,     8,          8 ; VERTEX  -12,  -12 ; Vertex 11
       ; VERTEX  -12,   12,  -44,     6,      7,    8,     8,          8 ; VERTEX  -12,   12 ; Vertex 12
       ; VERTEX   -8,    8,  -12,     6,      7,    7,     7,          8 ; VERTEX   -8,    8 ; Vertex 13
       ; VERTEX   -8,   -8,  -12,     5,      6,    6,     6,          8 ; VERTEX   -8,   -8 ; Vertex 14
       ; VERTEX    8,    8,  -12,     4,      7,    7,     7,          8 ; VERTEX    8,    8 ; Vertex 15
       ; VERTEX    8,   -8,  -12,     4,      5,    5,     5,          8 ; VERTEX    8,   -8 ; Vertex 16

SHIP_MISSILE_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     1,     2,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       2,     2,     3,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       0,       3,     0,     3,         31 ; EDGE       0,     ; Edge 2
       ; EDGE       0,       4,     0,     1,         31 ; EDGE       0,     ; Edge 3
       ; EDGE       1,       2,     4,     2,         31 ; EDGE       1,     ; Edge 4
       ; EDGE       1,       4,     1,     5,         31 ; EDGE       1,     ; Edge 5
       ; EDGE       3,       4,     0,     6,         31 ; EDGE       3,     ; Edge 6
       ; EDGE       2,       3,     3,     7,         31 ; EDGE       2,     ; Edge 7
       ; EDGE       2,       5,     4,     7,         31 ; EDGE       2,     ; Edge 8
       ; EDGE       1,       6,     4,     5,         31 ; EDGE       1,     ; Edge 9
       ; EDGE       4,       7,     5,     6,         31 ; EDGE       4,     ; Edge 10
       ; EDGE       3,       8,     6,     7,         31 ; EDGE       3,     ; Edge 11
       ; EDGE       7,       8,     6,     8,         31 ; EDGE       7,     ; Edge 12
       ; EDGE       5,       8,     7,     8,         31 ; EDGE       5,     ; Edge 13
       ; EDGE       5,       6,     4,     8,         31 ; EDGE       5,     ; Edge 14
       ; EDGE       6,       7,     5,     8,         31 ; EDGE       6,     ; Edge 15
       ; EDGE       6,      10,     5,     8,          8 ; EDGE       6,     ; Edge 16
       ; EDGE       5,       9,     7,     8,          8 ; EDGE       5,     ; Edge 17
       ; EDGE       8,      12,     7,     8,          8 ; EDGE       8,     ; Edge 18
       ; EDGE       7,      11,     5,     8,          8 ; EDGE       7,     ; Edge 19
       ; EDGE       9,      15,     4,     7,          8 ; EDGE       9,     ; Edge 20
       ; EDGE      10,      16,     4,     5,          8 ; EDGE      10,     ; Edge 21
       ; EDGE      12,      13,     6,     7,          8 ; EDGE      12,     ; Edge 22
       ; EDGE      11,      14,     5,     6,          8 ; EDGE      11,     ; Edge 23

SHIP_MISSILE_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE      -64,        0,       16,         31 ; FACE      -64,    ; Face 0
       ; FACE        0,      -64,       16,         31 ; FACE        0,    ; Face 1
       ; FACE       64,        0,       16,         31 ; FACE       64,    ; Face 2
       ; FACE        0,       64,       16,         31 ; FACE        0,    ; Face 3
       ; FACE       32,        0,        0,         31 ; FACE       32,    ; Face 4
       ; FACE        0,      -32,        0,         31 ; FACE        0,    ; Face 5
       ; FACE      -32,        0,        0,         31 ; FACE      -32,    ; Face 6
       ; FACE        0,       32,        0,         31 ; FACE        0,    ; Face 7
       ; FACE        0,        0,     -176,         31 ; FACE        0,    ; Face 8

* ******************************************************************************
* 
* Name: SHIP_ASTEROID
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for an asteroid
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_ASTEROID:
       byte >00                                                      ; Max. canisters on demise = 0
       data >5000                                                    ; Targetable area          = 80 * 80

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >41                                                      ; Max. edge count          = (65 - 1) / 4 = 16
       byte >00                                                      ; Gun vertex               = 0
       byte >22                                                      ; Explosion count          = 7, as (4 * n) + 6 = 34
       byte >36                                                      ; Number of vertices       = 54 / 6 = 9
       byte >15                                                      ; Number of edges          = 21
       data >0500                                                    ; Bounty                   = 5
       byte >38                                                      ; Number of faces          = 56 / 4 = 14
       byte >32                                                      ; Visibility distance      = 50
       byte >3c                                                      ; Max. energy              = 60
       byte >1e                                                      ; Max. speed               = 30

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >01                                                      ; Normals are scaled by    = 2^1 = 2
       byte >00                                                      ; Laser power              = 0
                                                                     ; Missiles                 = 0

SHIP_ASTEROID_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX    0,   80,    0,    15,     15,   15,    15,         31 ; VERTEX    0,   80 ; Vertex 0
       ; VERTEX  -80,  -10,    0,    15,     15,   15,    15,         31 ; VERTEX  -80,  -10 ; Vertex 1
       ; VERTEX    0,  -80,    0,    15,     15,   15,    15,         31 ; VERTEX    0,  -80 ; Vertex 2
       ; VERTEX   70,  -40,    0,    15,     15,   15,    15,         31 ; VERTEX   70,  -40 ; Vertex 3
       ; VERTEX   60,   50,    0,     5,      6,   12,    13,         31 ; VERTEX   60,   50 ; Vertex 4
       ; VERTEX   50,    0,   60,    15,     15,   15,    15,         31 ; VERTEX   50,    0 ; Vertex 5
       ; VERTEX  -40,    0,   70,     0,      1,    2,     3,         31 ; VERTEX  -40,    0 ; Vertex 6
       ; VERTEX    0,   30,  -75,    15,     15,   15,    15,         31 ; VERTEX    0,   30 ; Vertex 7
       ; VERTEX    0,  -50,  -60,     8,      9,   10,    11,         31 ; VERTEX    0,  -50 ; Vertex 8

SHIP_ASTEROID_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     2,     7,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       4,     6,    13,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       3,       4,     5,    12,         31 ; EDGE       3,     ; Edge 2
       ; EDGE       2,       3,     4,    11,         31 ; EDGE       2,     ; Edge 3
       ; EDGE       1,       2,     3,    10,         31 ; EDGE       1,     ; Edge 4
       ; EDGE       1,       6,     2,     3,         31 ; EDGE       1,     ; Edge 5
       ; EDGE       2,       6,     1,     3,         31 ; EDGE       2,     ; Edge 6
       ; EDGE       2,       5,     1,     4,         31 ; EDGE       2,     ; Edge 7
       ; EDGE       5,       6,     0,     1,         31 ; EDGE       5,     ; Edge 8
       ; EDGE       0,       5,     0,     6,         31 ; EDGE       0,     ; Edge 9
       ; EDGE       3,       5,     4,     5,         31 ; EDGE       3,     ; Edge 10
       ; EDGE       0,       6,     0,     2,         31 ; EDGE       0,     ; Edge 11
       ; EDGE       4,       5,     5,     6,         31 ; EDGE       4,     ; Edge 12
       ; EDGE       1,       8,     8,    10,         31 ; EDGE       1,     ; Edge 13
       ; EDGE       1,       7,     7,     8,         31 ; EDGE       1,     ; Edge 14
       ; EDGE       0,       7,     7,    13,         31 ; EDGE       0,     ; Edge 15
       ; EDGE       4,       7,    12,    13,         31 ; EDGE       4,     ; Edge 16
       ; EDGE       3,       7,     9,    12,         31 ; EDGE       3,     ; Edge 17
       ; EDGE       3,       8,     9,    11,         31 ; EDGE       3,     ; Edge 18
       ; EDGE       2,       8,    10,    11,         31 ; EDGE       2,     ; Edge 19
       ; EDGE       7,       8,     8,     9,         31 ; EDGE       7,     ; Edge 20

SHIP_ASTEROID_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE        9,       66,       81,         31 ; FACE        9,    ; Face 0
       ; FACE        9,      -66,       81,         31 ; FACE        9,    ; Face 1
       ; FACE      -72,       64,       31,         31 ; FACE      -72,    ; Face 2
       ; FACE      -64,      -73,       47,         31 ; FACE      -64,    ; Face 3
       ; FACE       45,      -79,       65,         31 ; FACE       45,    ; Face 4
       ; FACE      135,       15,       35,         31 ; FACE      135,    ; Face 5
       ; FACE       38,       76,       70,         31 ; FACE       38,    ; Face 6
       ; FACE      -66,       59,      -39,         31 ; FACE      -66,    ; Face 7
       ; FACE      -67,      -15,      -80,         31 ; FACE      -67,    ; Face 8
       ; FACE       66,      -14,      -75,         31 ; FACE       66,    ; Face 9
       ; FACE      -70,      -80,      -40,         31 ; FACE      -70,    ; Face 10
       ; FACE       58,     -102,      -51,         31 ; FACE       58,    ; Face 11
       ; FACE       81,        9,      -67,         31 ; FACE       81,    ; Face 12
       ; FACE       47,       94,      -63,         31 ; FACE       47,    ; Face 13

* ******************************************************************************
* 
* Name: SHIP_CANISTER
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a cargo canister
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_CANISTER:
       byte >00                                                      ; Max. canisters on demise = 0
       data >1400                                                    ; Targetable area          = 20 * 20

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >31                                                      ; Max. edge count          = (49 - 1) / 4 = 12
       byte >00                                                      ; Gun vertex               = 0
       byte >12                                                      ; Explosion count          = 3, as (4 * n) + 6 = 18
       byte >3c                                                      ; Number of vertices       = 60 / 6 = 10
       byte >0f                                                      ; Number of edges          = 15
       data >0000                                                    ; Bounty                   = 0
       byte >1c                                                      ; Number of faces          = 28 / 4 = 7
       byte >0c                                                      ; Visibility distance      = 12
       byte >11                                                      ; Max. energy              = 17
       byte >0f                                                      ; Max. speed               = 15

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >02                                                      ; Normals are scaled by    = 2^2 = 4
       byte >00                                                      ; Laser power              = 0
                                                                     ; Missiles                 = 0

SHIP_CANISTER_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX   24,   16,    0,     0,      1,    5,     5,         31 ; VERTEX   24,   16 ; Vertex 0
       ; VERTEX   24,    5,   15,     0,      1,    2,     2,         31 ; VERTEX   24,    5 ; Vertex 1
       ; VERTEX   24,  -13,    9,     0,      2,    3,     3,         31 ; VERTEX   24,  -13 ; Vertex 2
       ; VERTEX   24,  -13,   -9,     0,      3,    4,     4,         31 ; VERTEX   24,  -13 ; Vertex 3
       ; VERTEX   24,    5,  -15,     0,      4,    5,     5,         31 ; VERTEX   24,    5 ; Vertex 4
       ; VERTEX  -24,   16,    0,     1,      5,    6,     6,         31 ; VERTEX  -24,   16 ; Vertex 5
       ; VERTEX  -24,    5,   15,     1,      2,    6,     6,         31 ; VERTEX  -24,    5 ; Vertex 6
       ; VERTEX  -24,  -13,    9,     2,      3,    6,     6,         31 ; VERTEX  -24,  -13 ; Vertex 7
       ; VERTEX  -24,  -13,   -9,     3,      4,    6,     6,         31 ; VERTEX  -24,  -13 ; Vertex 8
       ; VERTEX  -24,    5,  -15,     4,      5,    6,     6,         31 ; VERTEX  -24,    5 ; Vertex 9

SHIP_CANISTER_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     0,     1,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       1,       2,     0,     2,         31 ; EDGE       1,     ; Edge 1
       ; EDGE       2,       3,     0,     3,         31 ; EDGE       2,     ; Edge 2
       ; EDGE       3,       4,     0,     4,         31 ; EDGE       3,     ; Edge 3
       ; EDGE       0,       4,     0,     5,         31 ; EDGE       0,     ; Edge 4
       ; EDGE       0,       5,     1,     5,         31 ; EDGE       0,     ; Edge 5
       ; EDGE       1,       6,     1,     2,         31 ; EDGE       1,     ; Edge 6
       ; EDGE       2,       7,     2,     3,         31 ; EDGE       2,     ; Edge 7
       ; EDGE       3,       8,     3,     4,         31 ; EDGE       3,     ; Edge 8
       ; EDGE       4,       9,     4,     5,         31 ; EDGE       4,     ; Edge 9
       ; EDGE       5,       6,     1,     6,         31 ; EDGE       5,     ; Edge 10
       ; EDGE       6,       7,     2,     6,         31 ; EDGE       6,     ; Edge 11
       ; EDGE       7,       8,     3,     6,         31 ; EDGE       7,     ; Edge 12
       ; EDGE       8,       9,     4,     6,         31 ; EDGE       8,     ; Edge 13
       ; EDGE       9,       5,     5,     6,         31 ; EDGE       9,     ; Edge 14

SHIP_CANISTER_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE       96,        0,        0,         31 ; FACE       96,    ; Face 0
       ; FACE        0,       41,       30,         31 ; FACE        0,    ; Face 1
       ; FACE        0,      -18,       48,         31 ; FACE        0,    ; Face 2
       ; FACE        0,      -51,        0,         31 ; FACE        0,    ; Face 3
       ; FACE        0,      -18,      -48,         31 ; FACE        0,    ; Face 4
       ; FACE        0,       41,      -30,         31 ; FACE        0,    ; Face 5
       ; FACE      -96,        0,        0,         31 ; FACE      -96,    ; Face 6

* ******************************************************************************
* 
* Name: SHIP_THARGON
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Thargon
* Deep dive: Ship blueprints
* 
* ------------------------------------------------------------------------------
* 
* The ship blueprint for the Thargon reuses the edges data from the cargo
* canister, so the edges data offset is negative.
* 
* ******************************************************************************

SHIP_THARGON:
       byte >00                                                      ; Max. canisters on demise = 0
       data >2800                                                    ; Targetable area          = 40 * 40

       byte >00                                                      ; Edges from canister
       byte >00                                                      ; Faces data offset (low)

       byte >41                                                      ; Max. edge count          = (65 - 1) / 4 = 16
       byte >00                                                      ; Gun vertex               = 0
       byte >12                                                      ; Explosion count          = 3, as (4 * n) + 6 = 18
       byte >3c                                                      ; Number of vertices       = 60 / 6 = 10
       byte >0f                                                      ; Number of edges          = 15
       data >3200                                                    ; Bounty                   = 50
       byte >1c                                                      ; Number of faces          = 28 / 4 = 7
       byte >14                                                      ; Visibility distance      = 20
       byte >14                                                      ; Max. energy              = 20
       byte >1e                                                      ; Max. speed               = 30

       byte >00                                                      ; Edges from canister
       byte >00                                                      ; Faces data offset (high)

       byte >02                                                      ; Normals are scaled by    = 2^2 = 4
       byte >10                                                      ; Laser power              = 2
                                                                     ; Missiles                 = 0

SHIP_THARGON_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX   -9,    0,   40,     1,      0,    5,     5,         31 ; VERTEX   -9,    0 ; Vertex 0
       ; VERTEX   -9,  -38,   12,     1,      0,    2,     2,         31 ; VERTEX   -9,  -38 ; Vertex 1
       ; VERTEX   -9,  -24,  -32,     2,      0,    3,     3,         31 ; VERTEX   -9,  -24 ; Vertex 2
       ; VERTEX   -9,   24,  -32,     3,      0,    4,     4,         31 ; VERTEX   -9,   24 ; Vertex 3
       ; VERTEX   -9,   38,   12,     4,      0,    5,     5,         31 ; VERTEX   -9,   38 ; Vertex 4
       ; VERTEX    9,    0,   -8,     5,      1,    6,     6,         31 ; VERTEX    9,    0 ; Vertex 5
       ; VERTEX    9,  -10,  -15,     2,      1,    6,     6,         31 ; VERTEX    9,  -10 ; Vertex 6
       ; VERTEX    9,   -6,  -26,     3,      2,    6,     6,         31 ; VERTEX    9,   -6 ; Vertex 7
       ; VERTEX    9,    6,  -26,     4,      3,    6,     6,         31 ; VERTEX    9,    6 ; Vertex 8
       ; VERTEX    9,   10,  -15,     5,      4,    6,     6,         31 ; VERTEX    9,   10 ; Vertex 9

SHIP_THARGON_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE      -36,        0,        0,         31 ; FACE      -36,    ; Face 0
       ; FACE       20,       -5,        7,         31 ; FACE       20,    ; Face 1
       ; FACE       46,      -42,      -14,         31 ; FACE       46,    ; Face 2
       ; FACE       36,        0,     -104,         31 ; FACE       36,    ; Face 3
       ; FACE       46,       42,      -14,         31 ; FACE       46,    ; Face 4
       ; FACE       20,        5,        7,         31 ; FACE       20,    ; Face 5
       ; FACE       36,        0,        0,         31 ; FACE       36,    ; Face 6

* ******************************************************************************
* 
* Name: SHIP_ESCAPE_POD
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for an escape pod
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_ESCAPE_POD:
       byte >00                                                      ; Max. canisters on demise = 0
       data >1000                                                    ; Targetable area          = 16 * 16

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >19                                                      ; Max. edge count          = (25 - 1) / 4 = 6
       byte >00                                                      ; Gun vertex               = 0
       byte >16                                                      ; Explosion count          = 4, as (4 * n) + 6 = 22
       byte >18                                                      ; Number of vertices       = 24 / 6 = 4
       byte >06                                                      ; Number of edges          = 6
       data >0000                                                    ; Bounty                   = 0
       byte >10                                                      ; Number of faces          = 16 / 4 = 4
       byte >08                                                      ; Visibility distance      = 8
       byte >11                                                      ; Max. energy              = 17
       byte >08                                                      ; Max. speed               = 8

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >03                                                      ; Normals are scaled by    =  2^3 = 8
       byte >00                                                      ; Laser power              = 0
                                                                     ; Missiles                 = 0

SHIP_ESCAPE_POD_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX   -7,    0,   36,     2,      1,    3,     3,         31 ; VERTEX   -7,    0 ; Vertex 0
       ; VERTEX   -7,  -14,  -12,     2,      0,    3,     3,         31 ; VERTEX   -7,  -14 ; Vertex 1
       ; VERTEX   -7,   14,  -12,     1,      0,    3,     3,         31 ; VERTEX   -7,   14 ; Vertex 2
       ; VERTEX   21,    0,    0,     1,      0,    2,     2,         31 ; VERTEX   21,    0 ; Vertex 3

SHIP_ESCAPE_POD_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       1,     3,     2,         31 ; EDGE       0,     ; Edge 0
       ; EDGE       1,       2,     3,     0,         31 ; EDGE       1,     ; Edge 1
       ; EDGE       2,       3,     1,     0,         31 ; EDGE       2,     ; Edge 2
       ; EDGE       3,       0,     2,     1,         31 ; EDGE       3,     ; Edge 3
       ; EDGE       0,       2,     3,     1,         31 ; EDGE       0,     ; Edge 4
       ; EDGE       3,       1,     2,     0,         31 ; EDGE       3,     ; Edge 5

SHIP_ESCAPE_POD_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE       26,        0,      -61,         31 ; FACE       26,    ; Face 0
       ; FACE       19,       51,       15,         31 ; FACE       19,    ; Face 1
       ; FACE       19,      -51,       15,         31 ; FACE       19,    ; Face 2
       ; FACE      -56,        0,        0,         31 ; FACE      -56,    ; Face 3

* ******************************************************************************
* 
* Save SHIPS.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* ELITE PYTHON SHIP BLUEPRINT FILE
* 
* Produces the binary file PYTHON.bin that gets loaded by elite-bcfs.asm.
* 
* ******************************************************************************

       ; CLEAR 0, &7F00                ; CLEAR 0, &7F00    

CODE_PYTHON.:
       equ >7F00
LOAD_PYTHON.:
       equ >1B00

       aorg CODE_PYTHON.

* ******************************************************************************
* 
* Name: SHIP_PYTHON
* Type: Variable
* Category: Drawing ships
* Summary: Ship blueprint for a Python
* Deep dive: Ship blueprints
* 
* ******************************************************************************

SHIP_PYTHON:
       byte >03                                                      ; Max. canisters on demise = 3
       data >7800                                                    ; Targetable area          = 120 * 120

       byte >00                                                      ; Edges data offset (low)
       byte >00                                                      ; Faces data offset (low)

       byte >55                                                      ; Max. edge count          = (85 - 1) / 4 = 21
       byte >00                                                      ; Gun vertex               = 0
       byte >2e                                                      ; Explosion count          = 10, as (4 * n) + 6 = 46
       byte >42                                                      ; Number of vertices       = 66 / 6 = 11
       byte >1a                                                      ; Number of edges          = 26
       data >c800                                                    ; Bounty                   = 200
       byte >34                                                      ; Number of faces          = 52 / 4 = 13
       byte >28                                                      ; Visibility distance      = 40
       byte >fa                                                      ; Max. energy              = 250
       byte >14                                                      ; Max. speed               = 20

       byte >00                                                      ; Edges data offset (high)
       byte >00                                                      ; Faces data offset (high)

       byte >00                                                      ; Normals are scaled by    = 2^0 = 1
       byte >1b                                                      ; Laser power              = 3
                                                                     ; Missiles                 = 3

SHIP_PYTHON_VERTICES:
                                                           ; x,    y,    z, face1, face2, face3, face4, visibility
       ; VERTEX    0,    0,  224,     0,      1,    2,     3,         31 ; VERTEX    0,    0 ; Vertex 0
       ; VERTEX    0,   48,   48,     0,      1,    4,     5,         30 ; VERTEX    0,   48 ; Vertex 1
       ; VERTEX   96,    0,  -16,    15,     15,   15,    15,         31 ; VERTEX   96,    0 ; Vertex 2
       ; VERTEX  -96,    0,  -16,    15,     15,   15,    15,         31 ; VERTEX  -96,    0 ; Vertex 3
       ; VERTEX    0,   48,  -32,     4,      5,    8,     9,         30 ; VERTEX    0,   48 ; Vertex 4
       ; VERTEX    0,   24, -112,     9,      8,   12,    12,         31 ; VERTEX    0,   24 ; Vertex 5
       ; VERTEX  -48,    0, -112,     8,     11,   12,    12,         31 ; VERTEX  -48,    0 ; Vertex 6
       ; VERTEX   48,    0, -112,     9,     10,   12,    12,         31 ; VERTEX   48,    0 ; Vertex 7
       ; VERTEX    0,  -48,   48,     2,      3,    6,     7,         30 ; VERTEX    0,  -48 ; Vertex 8
       ; VERTEX    0,  -48,  -32,     6,      7,   10,    11,         30 ; VERTEX    0,  -48 ; Vertex 9
       ; VERTEX    0,  -24, -112,    10,     11,   12,    12,         30 ; VERTEX    0,  -24 ; Vertex 10

SHIP_PYTHON_EDGES:
                                                           ; vertex1, vertex2, face1, face2, visibility
       ; EDGE       0,       8,     2,     3,         30 ; EDGE       0,     ; Edge 0
       ; EDGE       0,       3,     0,     2,         31 ; EDGE       0,     ; Edge 1
       ; EDGE       0,       2,     1,     3,         31 ; EDGE       0,     ; Edge 2
       ; EDGE       0,       1,     0,     1,         30 ; EDGE       0,     ; Edge 3
       ; EDGE       2,       4,     9,     5,         29 ; EDGE       2,     ; Edge 4
       ; EDGE       1,       2,     1,     5,         29 ; EDGE       1,     ; Edge 5
       ; EDGE       2,       8,     7,     3,         29 ; EDGE       2,     ; Edge 6
       ; EDGE       1,       3,     0,     4,         29 ; EDGE       1,     ; Edge 7
       ; EDGE       3,       8,     2,     6,         29 ; EDGE       3,     ; Edge 8
       ; EDGE       2,       9,     7,    10,         29 ; EDGE       2,     ; Edge 9
       ; EDGE       3,       4,     4,     8,         29 ; EDGE       3,     ; Edge 10
       ; EDGE       3,       9,     6,    11,         29 ; EDGE       3,     ; Edge 11
       ; EDGE       3,       5,     8,     8,          5 ; EDGE       3,     ; Edge 12
       ; EDGE       3,      10,    11,    11,          5 ; EDGE       3,     ; Edge 13
       ; EDGE       2,       5,     9,     9,          5 ; EDGE       2,     ; Edge 14
       ; EDGE       2,      10,    10,    10,          5 ; EDGE       2,     ; Edge 15
       ; EDGE       2,       7,     9,    10,         31 ; EDGE       2,     ; Edge 16
       ; EDGE       3,       6,     8,    11,         31 ; EDGE       3,     ; Edge 17
       ; EDGE       5,       6,     8,    12,         31 ; EDGE       5,     ; Edge 18
       ; EDGE       5,       7,     9,    12,         31 ; EDGE       5,     ; Edge 19
       ; EDGE       7,      10,    12,    10,         29 ; EDGE       7,     ; Edge 20
       ; EDGE       6,      10,    11,    12,         29 ; EDGE       6,     ; Edge 21
       ; EDGE       4,       5,     8,     9,         29 ; EDGE       4,     ; Edge 22
       ; EDGE       9,      10,    10,    11,         29 ; EDGE       9,     ; Edge 23
       ; EDGE       1,       4,     4,     5,         29 ; EDGE       1,     ; Edge 24
       ; EDGE       8,       9,     6,     7,         29 ; EDGE       8,     ; Edge 25

SHIP_PYTHON_FACES:
                                                           ; normal_x, normal_y, normal_z, visibility
       ; FACE      -27,       40,       11,         30 ; FACE      -27,    ; Face 0
       ; FACE       27,       40,       11,         30 ; FACE       27,    ; Face 1
       ; FACE      -27,      -40,       11,         30 ; FACE      -27,    ; Face 2
       ; FACE       27,      -40,       11,         30 ; FACE       27,    ; Face 3
       ; FACE      -19,       38,        0,         30 ; FACE      -19,    ; Face 4
       ; FACE       19,       38,        0,         30 ; FACE       19,    ; Face 5
       ; FACE      -19,      -38,        0,         30 ; FACE      -19,    ; Face 6
       ; FACE       19,      -38,        0,         30 ; FACE       19,    ; Face 7
       ; FACE      -25,       37,      -11,         30 ; FACE      -25,    ; Face 8
       ; FACE       25,       37,      -11,         30 ; FACE       25,    ; Face 9
       ; FACE       25,      -37,      -11,         30 ; FACE       25,    ; Face 10
       ; FACE      -25,      -37,      -11,         30 ; FACE      -25,    ; Face 11
       ; FACE        0,        0,     -112,         30 ; FACE        0,    ; Face 12

       bss 11                                              ; This space appears to be unused

* ******************************************************************************
* 
* Name: SVN
* Type: Variable
* Category: Save and load
* Summary: The "saving in progress" flag
* 
* ******************************************************************************

SVN:
       bss 1                                               ; "Saving in progress" flag
                                                           ; 
                                                           ; * Non-zero while we are saving a commander
                                                           ; 
                                                           ; * 0 otherwise

* ******************************************************************************
* 
* Name: VEC
* Type: Variable
* Category: Drawing the screen
* Summary: The original value of the IRQ1 vector
* 
* ******************************************************************************

VEC:
       bss 2                                               ; VEC = &7FFE
                                                           ; 
                                                           ; This gets set to the value of the original IRQ1 vector
                                                           ; by the loading process

* ******************************************************************************
* 
* Save PYTHON.bin
* 
* ******************************************************************************



* ******************************************************************************
* 
* Show free space
* 
* ******************************************************************************

